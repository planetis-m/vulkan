# Written by Leonardo Mariscal <leo@ldmd.mx>, 2019

## Vulkan Bindings
## ====
## WARNING: This is a generated file. Do not edit
## Any edits will be overwritten by the generator.

var vkGetProc: proc (procName: cstring): pointer {.cdecl.}
var currInst: pointer = nil

when not defined(vkCustomLoader):
  import dynlib

  when defined(windows):
    const vkDLL = "vulkan-1.dll"
  elif defined(macosx):
    const vkDLL = "libMoltenVK.dylib"
  else:
    const vkDLL = "libvulkan.so.1"

  let vkHandleDLL = loadLib(vkDLL)
  if isNil(vkHandleDLL):
    raise newException(LibraryError, "could not load: " & vkDLL)

  let vkGetProcAddress = cast[proc (inst: pointer, s: cstring): pointer {.stdcall.}](checkedSymAddr(vkHandleDLL, "vkGetInstanceProcAddr"))

  vkGetProc = proc (procName: cstring): pointer {.cdecl.} =
    result = vkGetProcAddress(currInst, procName)
    if result == nil:
      raiseInvalidLibrary(procName)

proc setVKGetProc*(getProc: proc (procName: cstring): pointer {.cdecl.}) =
  vkGetProc = getProc

type
  VkHandle* = uint
  VkNonDispatchableHandle* = uint
  ANativeWindow* = object
  AHardwareBuffer* = object
  CAMetalLayer* = object
  MTLDevice_id* = object
  MTLCommandQueue_id* = object
  MTLBuffer_id* = object
  MTLTexture_id* = object
  MTLSharedEvent_id* = object
  IOSurfaceRef* = object

# Enums
const
  VkMaxPhysicalDeviceNameSize* = 256
  VkUuidSize* = 16
  VkLuidSize* = 8
  VkMaxExtensionNameSize* = 256
  VkMaxDescriptionSize* = 256
  VkMaxMemoryTypes* = 32
  VkMaxMemoryHeaps* = 16
  VkLodClampNone* = 1000.0f
  VkRemainingMipLevels* = (not 0'u32)
  VkRemainingArrayLayers* = (not 0'u32)
  VkRemaining3dSlicesExt* = (not 0'u32)
  VkWholeSize* = (not 0'u64)
  VkAttachmentUnused* = (not 0'u32)
  VkTrue* = 1
  VkFalse* = 0
  VkQueueFamilyIgnored* = (not 0'u32)
  VkQueueFamilyExternal* = (not 1'u32)
  VkQueueFamilyForeignExt* = (not 2'u32)
  VkSubpassExternal* = (not 0'u32)
  VkMaxDeviceGroupSize* = 32
  VkMaxDriverNameSize* = 256
  VkMaxDriverInfoSize* = 256
  VkShaderUnusedKhr* = (not 0'u32)
  VkMaxGlobalPrioritySize* = 16
  VkMaxShaderModuleIdentifierSizeExt* = 32
  VkMaxPipelineBinaryKeySizeKhr* = 32
  VkMaxVideoAv1ReferencesPerFrameKhr* = 7
  VkMaxVideoVp9ReferencesPerFrameKhr* = 3
  VkShaderIndexUnusedAmdx* = (not 0'u32)
  VkPartitionedAccelerationStructurePartitionIndexGlobalNv* = (not 0'u32)
  VkCompressedTriangleFormatDgf1ByteAlignmentAmdx* = 128
  VkCompressedTriangleFormatDgf1ByteStrideAmdx* = 128
  VkMaxPhysicalDeviceDataGraphOperationSetNameSizeArm* = 128
  VkDataGraphModelToolchainVersionLengthQcom* = 3
  VkComputeOccupancyPriorityLowNv* = 0.25f
  VkComputeOccupancyPriorityNormalNv* = 0.50f
  VkComputeOccupancyPriorityHighNv* = 0.75f
  # Extension: VK_KHR_surface
  VkKhrSurfaceSpecVersion* = 25
  VkKhrSurfaceExtensionName* = "VK_KHR_surface"
  # Extension: VK_KHR_swapchain
  VkKhrSwapchainSpecVersion* = 70
  VkKhrSwapchainExtensionName* = "VK_KHR_swapchain"
  # Extension: VK_KHR_display
  VkKhrDisplaySpecVersion* = 23
  VkKhrDisplayExtensionName* = "VK_KHR_display"
  # Extension: VK_KHR_display_swapchain
  VkKhrDisplaySwapchainSpecVersion* = 10
  VkKhrDisplaySwapchainExtensionName* = "VK_KHR_display_swapchain"
  # Extension: VK_KHR_xlib_surface
  VkKhrXlibSurfaceSpecVersion* = 6
  VkKhrXlibSurfaceExtensionName* = "VK_KHR_xlib_surface"
  # Extension: VK_KHR_xcb_surface
  VkKhrXcbSurfaceSpecVersion* = 6
  VkKhrXcbSurfaceExtensionName* = "VK_KHR_xcb_surface"
  # Extension: VK_KHR_wayland_surface
  VkKhrWaylandSurfaceSpecVersion* = 6
  VkKhrWaylandSurfaceExtensionName* = "VK_KHR_wayland_surface"
  # Extension: VK_KHR_android_surface
  VkKhrAndroidSurfaceSpecVersion* = 6
  VkKhrAndroidSurfaceExtensionName* = "VK_KHR_android_surface"
  # Extension: VK_KHR_win32_surface
  VkKhrWin32SurfaceSpecVersion* = 6
  VkKhrWin32SurfaceExtensionName* = "VK_KHR_win32_surface"
  # Extension: VK_EXT_debug_report
  VkExtDebugReportSpecVersion* = 10
  VkExtDebugReportExtensionName* = "VK_EXT_debug_report"
  # Extension: VK_NV_glsl_shader
  VkNvGlslShaderSpecVersion* = 1
  VkNvGlslShaderExtensionName* = "VK_NV_glsl_shader"
  # Extension: VK_EXT_depth_range_unrestricted
  VkExtDepthRangeUnrestrictedSpecVersion* = 1
  VkExtDepthRangeUnrestrictedExtensionName* = "VK_EXT_depth_range_unrestricted"
  # Extension: VK_KHR_sampler_mirror_clamp_to_edge
  VkKhrSamplerMirrorClampToEdgeSpecVersion* = 3
  VkKhrSamplerMirrorClampToEdgeExtensionName* = "VK_KHR_sampler_mirror_clamp_to_edge"
  # Extension: VK_IMG_filter_cubic
  VkImgFilterCubicSpecVersion* = 1
  VkImgFilterCubicExtensionName* = "VK_IMG_filter_cubic"
  # Extension: VK_AMD_rasterization_order
  VkAmdRasterizationOrderSpecVersion* = 1
  VkAmdRasterizationOrderExtensionName* = "VK_AMD_rasterization_order"
  # Extension: VK_AMD_shader_trinary_minmax
  VkAmdShaderTrinaryMinmaxSpecVersion* = 1
  VkAmdShaderTrinaryMinmaxExtensionName* = "VK_AMD_shader_trinary_minmax"
  # Extension: VK_AMD_shader_explicit_vertex_parameter
  VkAmdShaderExplicitVertexParameterSpecVersion* = 1
  VkAmdShaderExplicitVertexParameterExtensionName* = "VK_AMD_shader_explicit_vertex_parameter"
  # Extension: VK_EXT_debug_marker
  VkExtDebugMarkerSpecVersion* = 4
  VkExtDebugMarkerExtensionName* = "VK_EXT_debug_marker"
  # Extension: VK_KHR_video_queue
  VkKhrVideoQueueSpecVersion* = 8
  VkKhrVideoQueueExtensionName* = "VK_KHR_video_queue"
  # Extension: VK_KHR_video_decode_queue
  VkKhrVideoDecodeQueueSpecVersion* = 8
  VkKhrVideoDecodeQueueExtensionName* = "VK_KHR_video_decode_queue"
  # Extension: VK_AMD_gcn_shader
  VkAmdGcnShaderSpecVersion* = 1
  VkAmdGcnShaderExtensionName* = "VK_AMD_gcn_shader"
  # Extension: VK_NV_dedicated_allocation
  VkNvDedicatedAllocationSpecVersion* = 1
  VkNvDedicatedAllocationExtensionName* = "VK_NV_dedicated_allocation"
  # Extension: VK_EXT_transform_feedback
  VkExtTransformFeedbackSpecVersion* = 1
  VkExtTransformFeedbackExtensionName* = "VK_EXT_transform_feedback"
  # Extension: VK_NVX_binary_import
  VkNvxBinaryImportSpecVersion* = 2
  VkNvxBinaryImportExtensionName* = "VK_NVX_binary_import"
  # Extension: VK_NVX_image_view_handle
  VkNvxImageViewHandleSpecVersion* = 4
  VkNvxImageViewHandleExtensionName* = "VK_NVX_image_view_handle"
  # Extension: VK_AMD_draw_indirect_count
  VkAmdDrawIndirectCountSpecVersion* = 2
  VkAmdDrawIndirectCountExtensionName* = "VK_AMD_draw_indirect_count"
  # Extension: VK_AMD_negative_viewport_height
  VkAmdNegativeViewportHeightSpecVersion* = 1
  VkAmdNegativeViewportHeightExtensionName* = "VK_AMD_negative_viewport_height"
  # Extension: VK_AMD_gpu_shader_half_float
  VkAmdGpuShaderHalfFloatSpecVersion* = 2
  VkAmdGpuShaderHalfFloatExtensionName* = "VK_AMD_gpu_shader_half_float"
  # Extension: VK_AMD_shader_ballot
  VkAmdShaderBallotSpecVersion* = 1
  VkAmdShaderBallotExtensionName* = "VK_AMD_shader_ballot"
  # Extension: VK_KHR_video_encode_h264
  VkKhrVideoEncodeH264SpecVersion* = 14
  VkKhrVideoEncodeH264ExtensionName* = "VK_KHR_video_encode_h264"
  # Extension: VK_KHR_video_encode_h265
  VkKhrVideoEncodeH265SpecVersion* = 14
  VkKhrVideoEncodeH265ExtensionName* = "VK_KHR_video_encode_h265"
  # Extension: VK_KHR_video_decode_h264
  VkKhrVideoDecodeH264SpecVersion* = 9
  VkKhrVideoDecodeH264ExtensionName* = "VK_KHR_video_decode_h264"
  # Extension: VK_AMD_texture_gather_bias_lod
  VkAmdTextureGatherBiasLodSpecVersion* = 1
  VkAmdTextureGatherBiasLodExtensionName* = "VK_AMD_texture_gather_bias_lod"
  # Extension: VK_AMD_shader_info
  VkAmdShaderInfoSpecVersion* = 1
  VkAmdShaderInfoExtensionName* = "VK_AMD_shader_info"
  # Extension: VK_KHR_dynamic_rendering
  VkKhrDynamicRenderingSpecVersion* = 1
  VkKhrDynamicRenderingExtensionName* = "VK_KHR_dynamic_rendering"
  # Extension: VK_AMD_shader_image_load_store_lod
  VkAmdShaderImageLoadStoreLodSpecVersion* = 1
  VkAmdShaderImageLoadStoreLodExtensionName* = "VK_AMD_shader_image_load_store_lod"
  # Extension: VK_GGP_stream_descriptor_surface
  VkGgpStreamDescriptorSurfaceSpecVersion* = 1
  VkGgpStreamDescriptorSurfaceExtensionName* = "VK_GGP_stream_descriptor_surface"
  # Extension: VK_NV_corner_sampled_image
  VkNvCornerSampledImageSpecVersion* = 2
  VkNvCornerSampledImageExtensionName* = "VK_NV_corner_sampled_image"
  # Extension: VK_NV_private_vendor_info
  VkNvPrivateVendorInfoSpecVersion* = 2
  VkNvPrivateVendorInfoExtensionName* = "VK_NV_private_vendor_info"
  # Extension: VK_KHR_multiview
  VkKhrMultiviewSpecVersion* = 1
  VkKhrMultiviewExtensionName* = "VK_KHR_multiview"
  # Extension: VK_IMG_format_pvrtc
  VkImgFormatPvrtcSpecVersion* = 1
  VkImgFormatPvrtcExtensionName* = "VK_IMG_format_pvrtc"
  # Extension: VK_NV_external_memory_capabilities
  VkNvExternalMemoryCapabilitiesSpecVersion* = 1
  VkNvExternalMemoryCapabilitiesExtensionName* = "VK_NV_external_memory_capabilities"
  # Extension: VK_NV_external_memory
  VkNvExternalMemorySpecVersion* = 1
  VkNvExternalMemoryExtensionName* = "VK_NV_external_memory"
  # Extension: VK_NV_external_memory_win32
  VkNvExternalMemoryWin32SpecVersion* = 1
  VkNvExternalMemoryWin32ExtensionName* = "VK_NV_external_memory_win32"
  # Extension: VK_NV_win32_keyed_mutex
  VkNvWin32KeyedMutexSpecVersion* = 2
  VkNvWin32KeyedMutexExtensionName* = "VK_NV_win32_keyed_mutex"
  # Extension: VK_KHR_get_physical_device_properties2
  VkKhrGetPhysicalDeviceProperties2SpecVersion* = 2
  VkKhrGetPhysicalDeviceProperties2ExtensionName* = "VK_KHR_get_physical_device_properties2"
  # Extension: VK_KHR_device_group
  VkKhrDeviceGroupSpecVersion* = 4
  VkKhrDeviceGroupExtensionName* = "VK_KHR_device_group"
  # Extension: VK_EXT_validation_flags
  VkExtValidationFlagsSpecVersion* = 3
  VkExtValidationFlagsExtensionName* = "VK_EXT_validation_flags"
  # Extension: VK_NN_vi_surface
  VkNnViSurfaceSpecVersion* = 1
  VkNnViSurfaceExtensionName* = "VK_NN_vi_surface"
  # Extension: VK_KHR_shader_draw_parameters
  VkKhrShaderDrawParametersSpecVersion* = 1
  VkKhrShaderDrawParametersExtensionName* = "VK_KHR_shader_draw_parameters"
  # Extension: VK_EXT_shader_subgroup_ballot
  VkExtShaderSubgroupBallotSpecVersion* = 1
  VkExtShaderSubgroupBallotExtensionName* = "VK_EXT_shader_subgroup_ballot"
  # Extension: VK_EXT_shader_subgroup_vote
  VkExtShaderSubgroupVoteSpecVersion* = 1
  VkExtShaderSubgroupVoteExtensionName* = "VK_EXT_shader_subgroup_vote"
  # Extension: VK_EXT_texture_compression_astc_hdr
  VkExtTextureCompressionAstcHdrSpecVersion* = 1
  VkExtTextureCompressionAstcHdrExtensionName* = "VK_EXT_texture_compression_astc_hdr"
  # Extension: VK_EXT_astc_decode_mode
  VkExtAstcDecodeModeSpecVersion* = 1
  VkExtAstcDecodeModeExtensionName* = "VK_EXT_astc_decode_mode"
  # Extension: VK_EXT_pipeline_robustness
  VkExtPipelineRobustnessSpecVersion* = 1
  VkExtPipelineRobustnessExtensionName* = "VK_EXT_pipeline_robustness"
  # Extension: VK_KHR_maintenance1
  VkKhrMaintenance1SpecVersion* = 2
  VkKhrMaintenance1ExtensionName* = "VK_KHR_maintenance1"
  # Extension: VK_KHR_device_group_creation
  VkKhrDeviceGroupCreationSpecVersion* = 1
  VkKhrDeviceGroupCreationExtensionName* = "VK_KHR_device_group_creation"
  # Extension: VK_KHR_external_memory_capabilities
  VkKhrExternalMemoryCapabilitiesSpecVersion* = 1
  VkKhrExternalMemoryCapabilitiesExtensionName* = "VK_KHR_external_memory_capabilities"
  # Extension: VK_KHR_external_memory
  VkKhrExternalMemorySpecVersion* = 1
  VkKhrExternalMemoryExtensionName* = "VK_KHR_external_memory"
  # Extension: VK_KHR_external_memory_win32
  VkKhrExternalMemoryWin32SpecVersion* = 1
  VkKhrExternalMemoryWin32ExtensionName* = "VK_KHR_external_memory_win32"
  # Extension: VK_KHR_external_memory_fd
  VkKhrExternalMemoryFdSpecVersion* = 1
  VkKhrExternalMemoryFdExtensionName* = "VK_KHR_external_memory_fd"
  # Extension: VK_KHR_win32_keyed_mutex
  VkKhrWin32KeyedMutexSpecVersion* = 1
  VkKhrWin32KeyedMutexExtensionName* = "VK_KHR_win32_keyed_mutex"
  # Extension: VK_KHR_external_semaphore_capabilities
  VkKhrExternalSemaphoreCapabilitiesSpecVersion* = 1
  VkKhrExternalSemaphoreCapabilitiesExtensionName* = "VK_KHR_external_semaphore_capabilities"
  # Extension: VK_KHR_external_semaphore
  VkKhrExternalSemaphoreSpecVersion* = 1
  VkKhrExternalSemaphoreExtensionName* = "VK_KHR_external_semaphore"
  # Extension: VK_KHR_external_semaphore_win32
  VkKhrExternalSemaphoreWin32SpecVersion* = 1
  VkKhrExternalSemaphoreWin32ExtensionName* = "VK_KHR_external_semaphore_win32"
  # Extension: VK_KHR_external_semaphore_fd
  VkKhrExternalSemaphoreFdSpecVersion* = 1
  VkKhrExternalSemaphoreFdExtensionName* = "VK_KHR_external_semaphore_fd"
  # Extension: VK_KHR_push_descriptor
  VkKhrPushDescriptorSpecVersion* = 2
  VkKhrPushDescriptorExtensionName* = "VK_KHR_push_descriptor"
  # Extension: VK_EXT_conditional_rendering
  VkExtConditionalRenderingSpecVersion* = 2
  VkExtConditionalRenderingExtensionName* = "VK_EXT_conditional_rendering"
  # Extension: VK_KHR_shader_float16_int8
  VkKhrShaderFloat16Int8SpecVersion* = 1
  VkKhrShaderFloat16Int8ExtensionName* = "VK_KHR_shader_float16_int8"
  # Extension: VK_KHR_16bit_storage
  VkKhr16bitStorageSpecVersion* = 1
  VkKhr16bitStorageExtensionName* = "VK_KHR_16bit_storage"
  # Extension: VK_KHR_incremental_present
  VkKhrIncrementalPresentSpecVersion* = 2
  VkKhrIncrementalPresentExtensionName* = "VK_KHR_incremental_present"
  # Extension: VK_KHR_descriptor_update_template
  VkKhrDescriptorUpdateTemplateSpecVersion* = 1
  VkKhrDescriptorUpdateTemplateExtensionName* = "VK_KHR_descriptor_update_template"
  # Extension: VK_NV_clip_space_w_scaling
  VkNvClipSpaceWScalingSpecVersion* = 1
  VkNvClipSpaceWScalingExtensionName* = "VK_NV_clip_space_w_scaling"
  # Extension: VK_EXT_direct_mode_display
  VkExtDirectModeDisplaySpecVersion* = 1
  VkExtDirectModeDisplayExtensionName* = "VK_EXT_direct_mode_display"
  # Extension: VK_EXT_acquire_xlib_display
  VkExtAcquireXlibDisplaySpecVersion* = 1
  VkExtAcquireXlibDisplayExtensionName* = "VK_EXT_acquire_xlib_display"
  # Extension: VK_EXT_display_surface_counter
  VkExtDisplaySurfaceCounterSpecVersion* = 1
  VkExtDisplaySurfaceCounterExtensionName* = "VK_EXT_display_surface_counter"
  # Extension: VK_EXT_display_control
  VkExtDisplayControlSpecVersion* = 1
  VkExtDisplayControlExtensionName* = "VK_EXT_display_control"
  # Extension: VK_GOOGLE_display_timing
  VkGoogleDisplayTimingSpecVersion* = 1
  VkGoogleDisplayTimingExtensionName* = "VK_GOOGLE_display_timing"
  # Extension: VK_NV_sample_mask_override_coverage
  VkNvSampleMaskOverrideCoverageSpecVersion* = 1
  VkNvSampleMaskOverrideCoverageExtensionName* = "VK_NV_sample_mask_override_coverage"
  # Extension: VK_NV_geometry_shader_passthrough
  VkNvGeometryShaderPassthroughSpecVersion* = 1
  VkNvGeometryShaderPassthroughExtensionName* = "VK_NV_geometry_shader_passthrough"
  # Extension: VK_NV_viewport_array2
  VkNvViewportArray2SpecVersion* = 1
  VkNvViewportArray2ExtensionName* = "VK_NV_viewport_array2"
  # Extension: VK_NVX_multiview_per_view_attributes
  VkNvxMultiviewPerViewAttributesSpecVersion* = 1
  VkNvxMultiviewPerViewAttributesExtensionName* = "VK_NVX_multiview_per_view_attributes"
  # Extension: VK_NV_viewport_swizzle
  VkNvViewportSwizzleSpecVersion* = 1
  VkNvViewportSwizzleExtensionName* = "VK_NV_viewport_swizzle"
  # Extension: VK_EXT_discard_rectangles
  VkExtDiscardRectanglesSpecVersion* = 2
  VkExtDiscardRectanglesExtensionName* = "VK_EXT_discard_rectangles"
  # Extension: VK_EXT_conservative_rasterization
  VkExtConservativeRasterizationSpecVersion* = 1
  VkExtConservativeRasterizationExtensionName* = "VK_EXT_conservative_rasterization"
  # Extension: VK_EXT_depth_clip_enable
  VkExtDepthClipEnableSpecVersion* = 1
  VkExtDepthClipEnableExtensionName* = "VK_EXT_depth_clip_enable"
  # Extension: VK_EXT_swapchain_colorspace
  VkExtSwapchainColorSpaceSpecVersion* = 5
  VkExtSwapchainColorSpaceExtensionName* = "VK_EXT_swapchain_colorspace"
  # Extension: VK_EXT_hdr_metadata
  VkExtHdrMetadataSpecVersion* = 3
  VkExtHdrMetadataExtensionName* = "VK_EXT_hdr_metadata"
  # Extension: VK_KHR_imageless_framebuffer
  VkKhrImagelessFramebufferSpecVersion* = 1
  VkKhrImagelessFramebufferExtensionName* = "VK_KHR_imageless_framebuffer"
  # Extension: VK_KHR_create_renderpass2
  VkKhrCreateRenderpass2SpecVersion* = 1
  VkKhrCreateRenderpass2ExtensionName* = "VK_KHR_create_renderpass2"
  # Extension: VK_IMG_relaxed_line_rasterization
  VkImgRelaxedLineRasterizationSpecVersion* = 1
  VkImgRelaxedLineRasterizationExtensionName* = "VK_IMG_relaxed_line_rasterization"
  # Extension: VK_KHR_shared_presentable_image
  VkKhrSharedPresentableImageSpecVersion* = 1
  VkKhrSharedPresentableImageExtensionName* = "VK_KHR_shared_presentable_image"
  # Extension: VK_KHR_external_fence_capabilities
  VkKhrExternalFenceCapabilitiesSpecVersion* = 1
  VkKhrExternalFenceCapabilitiesExtensionName* = "VK_KHR_external_fence_capabilities"
  # Extension: VK_KHR_external_fence
  VkKhrExternalFenceSpecVersion* = 1
  VkKhrExternalFenceExtensionName* = "VK_KHR_external_fence"
  # Extension: VK_KHR_external_fence_win32
  VkKhrExternalFenceWin32SpecVersion* = 1
  VkKhrExternalFenceWin32ExtensionName* = "VK_KHR_external_fence_win32"
  # Extension: VK_KHR_external_fence_fd
  VkKhrExternalFenceFdSpecVersion* = 1
  VkKhrExternalFenceFdExtensionName* = "VK_KHR_external_fence_fd"
  # Extension: VK_KHR_performance_query
  VkKhrPerformanceQuerySpecVersion* = 1
  VkKhrPerformanceQueryExtensionName* = "VK_KHR_performance_query"
  # Extension: VK_KHR_maintenance2
  VkKhrMaintenance2SpecVersion* = 1
  VkKhrMaintenance2ExtensionName* = "VK_KHR_maintenance2"
  # Extension: VK_KHR_get_surface_capabilities2
  VkKhrGetSurfaceCapabilities2SpecVersion* = 1
  VkKhrGetSurfaceCapabilities2ExtensionName* = "VK_KHR_get_surface_capabilities2"
  # Extension: VK_KHR_variable_pointers
  VkKhrVariablePointersSpecVersion* = 1
  VkKhrVariablePointersExtensionName* = "VK_KHR_variable_pointers"
  # Extension: VK_KHR_get_display_properties2
  VkKhrGetDisplayProperties2SpecVersion* = 1
  VkKhrGetDisplayProperties2ExtensionName* = "VK_KHR_get_display_properties2"
  # Extension: VK_MVK_ios_surface
  VkMvkIosSurfaceSpecVersion* = 3
  VkMvkIosSurfaceExtensionName* = "VK_MVK_ios_surface"
  # Extension: VK_MVK_macos_surface
  VkMvkMacosSurfaceSpecVersion* = 3
  VkMvkMacosSurfaceExtensionName* = "VK_MVK_macos_surface"
  # Extension: VK_EXT_external_memory_dma_buf
  VkExtExternalMemoryDmaBufSpecVersion* = 1
  VkExtExternalMemoryDmaBufExtensionName* = "VK_EXT_external_memory_dma_buf"
  # Extension: VK_EXT_queue_family_foreign
  VkExtQueueFamilyForeignSpecVersion* = 1
  VkExtQueueFamilyForeignExtensionName* = "VK_EXT_queue_family_foreign"
  # Extension: VK_KHR_dedicated_allocation
  VkKhrDedicatedAllocationSpecVersion* = 3
  VkKhrDedicatedAllocationExtensionName* = "VK_KHR_dedicated_allocation"
  # Extension: VK_EXT_debug_utils
  VkExtDebugUtilsSpecVersion* = 2
  VkExtDebugUtilsExtensionName* = "VK_EXT_debug_utils"
  # Extension: VK_ANDROID_external_memory_android_hardware_buffer
  VkAndroidExternalMemoryAndroidHardwareBufferSpecVersion* = 5
  VkAndroidExternalMemoryAndroidHardwareBufferExtensionName* = "VK_ANDROID_external_memory_android_hardware_buffer"
  # Extension: VK_EXT_sampler_filter_minmax
  VkExtSamplerFilterMinmaxSpecVersion* = 2
  VkExtSamplerFilterMinmaxExtensionName* = "VK_EXT_sampler_filter_minmax"
  # Extension: VK_KHR_storage_buffer_storage_class
  VkKhrStorageBufferStorageClassSpecVersion* = 1
  VkKhrStorageBufferStorageClassExtensionName* = "VK_KHR_storage_buffer_storage_class"
  # Extension: VK_AMD_gpu_shader_int16
  VkAmdGpuShaderInt16SpecVersion* = 2
  VkAmdGpuShaderInt16ExtensionName* = "VK_AMD_gpu_shader_int16"
  # Extension: VK_AMDX_shader_enqueue
  VkAmdxShaderEnqueueSpecVersion* = 2
  VkAmdxShaderEnqueueExtensionName* = "VK_AMDX_shader_enqueue"
  # Extension: VK_EXT_descriptor_heap
  VkExtDescriptorHeapSpecVersion* = 1
  VkExtDescriptorHeapExtensionName* = "VK_EXT_descriptor_heap"
  # Extension: VK_AMD_mixed_attachment_samples
  VkAmdMixedAttachmentSamplesSpecVersion* = 1
  VkAmdMixedAttachmentSamplesExtensionName* = "VK_AMD_mixed_attachment_samples"
  # Extension: VK_AMD_shader_fragment_mask
  VkAmdShaderFragmentMaskSpecVersion* = 1
  VkAmdShaderFragmentMaskExtensionName* = "VK_AMD_shader_fragment_mask"
  # Extension: VK_EXT_inline_uniform_block
  VkExtInlineUniformBlockSpecVersion* = 1
  VkExtInlineUniformBlockExtensionName* = "VK_EXT_inline_uniform_block"
  # Extension: VK_EXT_shader_stencil_export
  VkExtShaderStencilExportSpecVersion* = 1
  VkExtShaderStencilExportExtensionName* = "VK_EXT_shader_stencil_export"
  # Extension: VK_KHR_shader_bfloat16
  VkKhrShaderBfloat16SpecVersion* = 1
  VkKhrShaderBfloat16ExtensionName* = "VK_KHR_shader_bfloat16"
  # Extension: VK_EXT_sample_locations
  VkExtSampleLocationsSpecVersion* = 1
  VkExtSampleLocationsExtensionName* = "VK_EXT_sample_locations"
  # Extension: VK_KHR_relaxed_block_layout
  VkKhrRelaxedBlockLayoutSpecVersion* = 1
  VkKhrRelaxedBlockLayoutExtensionName* = "VK_KHR_relaxed_block_layout"
  # Extension: VK_KHR_get_memory_requirements2
  VkKhrGetMemoryRequirements2SpecVersion* = 1
  VkKhrGetMemoryRequirements2ExtensionName* = "VK_KHR_get_memory_requirements2"
  # Extension: VK_KHR_image_format_list
  VkKhrImageFormatListSpecVersion* = 1
  VkKhrImageFormatListExtensionName* = "VK_KHR_image_format_list"
  # Extension: VK_EXT_blend_operation_advanced
  VkExtBlendOperationAdvancedSpecVersion* = 2
  VkExtBlendOperationAdvancedExtensionName* = "VK_EXT_blend_operation_advanced"
  # Extension: VK_NV_fragment_coverage_to_color
  VkNvFragmentCoverageToColorSpecVersion* = 1
  VkNvFragmentCoverageToColorExtensionName* = "VK_NV_fragment_coverage_to_color"
  # Extension: VK_KHR_acceleration_structure
  VkKhrAccelerationStructureSpecVersion* = 13
  VkKhrAccelerationStructureExtensionName* = "VK_KHR_acceleration_structure"
  # Extension: VK_KHR_ray_tracing_pipeline
  VkKhrRayTracingPipelineSpecVersion* = 1
  VkKhrRayTracingPipelineExtensionName* = "VK_KHR_ray_tracing_pipeline"
  # Extension: VK_KHR_ray_query
  VkKhrRayQuerySpecVersion* = 1
  VkKhrRayQueryExtensionName* = "VK_KHR_ray_query"
  # Extension: VK_NV_framebuffer_mixed_samples
  VkNvFramebufferMixedSamplesSpecVersion* = 1
  VkNvFramebufferMixedSamplesExtensionName* = "VK_NV_framebuffer_mixed_samples"
  # Extension: VK_NV_fill_rectangle
  VkNvFillRectangleSpecVersion* = 1
  VkNvFillRectangleExtensionName* = "VK_NV_fill_rectangle"
  # Extension: VK_NV_shader_sm_builtins
  VkNvShaderSmBuiltinsSpecVersion* = 1
  VkNvShaderSmBuiltinsExtensionName* = "VK_NV_shader_sm_builtins"
  # Extension: VK_EXT_post_depth_coverage
  VkExtPostDepthCoverageSpecVersion* = 1
  VkExtPostDepthCoverageExtensionName* = "VK_EXT_post_depth_coverage"
  # Extension: VK_KHR_sampler_ycbcr_conversion
  VkKhrSamplerYcbcrConversionSpecVersion* = 14
  VkKhrSamplerYcbcrConversionExtensionName* = "VK_KHR_sampler_ycbcr_conversion"
  # Extension: VK_KHR_bind_memory2
  VkKhrBindMemory2SpecVersion* = 1
  VkKhrBindMemory2ExtensionName* = "VK_KHR_bind_memory2"
  # Extension: VK_EXT_image_drm_format_modifier
  VkExtImageDrmFormatModifierSpecVersion* = 2
  VkExtImageDrmFormatModifierExtensionName* = "VK_EXT_image_drm_format_modifier"
  # Extension: VK_EXT_validation_cache
  VkExtValidationCacheSpecVersion* = 1
  VkExtValidationCacheExtensionName* = "VK_EXT_validation_cache"
  # Extension: VK_EXT_descriptor_indexing
  VkExtDescriptorIndexingSpecVersion* = 2
  VkExtDescriptorIndexingExtensionName* = "VK_EXT_descriptor_indexing"
  # Extension: VK_EXT_shader_viewport_index_layer
  VkExtShaderViewportIndexLayerSpecVersion* = 1
  VkExtShaderViewportIndexLayerExtensionName* = "VK_EXT_shader_viewport_index_layer"
  # Extension: VK_KHR_portability_subset
  VkKhrPortabilitySubsetSpecVersion* = 1
  VkKhrPortabilitySubsetExtensionName* = "VK_KHR_portability_subset"
  # Extension: VK_NV_shading_rate_image
  VkNvShadingRateImageSpecVersion* = 3
  VkNvShadingRateImageExtensionName* = "VK_NV_shading_rate_image"
  # Extension: VK_NV_ray_tracing
  VkNvRayTracingSpecVersion* = 3
  VkNvRayTracingExtensionName* = "VK_NV_ray_tracing"
  # Extension: VK_NV_representative_fragment_test
  VkNvRepresentativeFragmentTestSpecVersion* = 2
  VkNvRepresentativeFragmentTestExtensionName* = "VK_NV_representative_fragment_test"
  # Extension: VK_KHR_maintenance3
  VkKhrMaintenance3SpecVersion* = 1
  VkKhrMaintenance3ExtensionName* = "VK_KHR_maintenance3"
  # Extension: VK_KHR_draw_indirect_count
  VkKhrDrawIndirectCountSpecVersion* = 1
  VkKhrDrawIndirectCountExtensionName* = "VK_KHR_draw_indirect_count"
  # Extension: VK_EXT_filter_cubic
  VkExtFilterCubicSpecVersion* = 3
  VkExtFilterCubicExtensionName* = "VK_EXT_filter_cubic"
  # Extension: VK_QCOM_render_pass_shader_resolve
  VkQcomRenderPassShaderResolveSpecVersion* = 4
  VkQcomRenderPassShaderResolveExtensionName* = "VK_QCOM_render_pass_shader_resolve"
  # Extension: VK_QCOM_cooperative_matrix_conversion
  VkQcomCooperativeMatrixConversionSpecVersion* = 1
  VkQcomCooperativeMatrixConversionExtensionName* = "VK_QCOM_cooperative_matrix_conversion"
  # Extension: VK_EXT_global_priority
  VkExtGlobalPrioritySpecVersion* = 2
  VkExtGlobalPriorityExtensionName* = "VK_EXT_global_priority"
  # Extension: VK_KHR_shader_subgroup_extended_types
  VkKhrShaderSubgroupExtendedTypesSpecVersion* = 1
  VkKhrShaderSubgroupExtendedTypesExtensionName* = "VK_KHR_shader_subgroup_extended_types"
  # Extension: VK_KHR_8bit_storage
  VkKhr8bitStorageSpecVersion* = 1
  VkKhr8bitStorageExtensionName* = "VK_KHR_8bit_storage"
  # Extension: VK_EXT_external_memory_host
  VkExtExternalMemoryHostSpecVersion* = 1
  VkExtExternalMemoryHostExtensionName* = "VK_EXT_external_memory_host"
  # Extension: VK_AMD_buffer_marker
  VkAmdBufferMarkerSpecVersion* = 1
  VkAmdBufferMarkerExtensionName* = "VK_AMD_buffer_marker"
  # Extension: VK_KHR_shader_atomic_int64
  VkKhrShaderAtomicInt64SpecVersion* = 1
  VkKhrShaderAtomicInt64ExtensionName* = "VK_KHR_shader_atomic_int64"
  # Extension: VK_KHR_shader_clock
  VkKhrShaderClockSpecVersion* = 1
  VkKhrShaderClockExtensionName* = "VK_KHR_shader_clock"
  # Extension: VK_AMD_pipeline_compiler_control
  VkAmdPipelineCompilerControlSpecVersion* = 1
  VkAmdPipelineCompilerControlExtensionName* = "VK_AMD_pipeline_compiler_control"
  # Extension: VK_EXT_calibrated_timestamps
  VkExtCalibratedTimestampsSpecVersion* = 2
  VkExtCalibratedTimestampsExtensionName* = "VK_EXT_calibrated_timestamps"
  # Extension: VK_AMD_shader_core_properties
  VkAmdShaderCorePropertiesSpecVersion* = 2
  VkAmdShaderCorePropertiesExtensionName* = "VK_AMD_shader_core_properties"
  # Extension: VK_KHR_video_decode_h265
  VkKhrVideoDecodeH265SpecVersion* = 8
  VkKhrVideoDecodeH265ExtensionName* = "VK_KHR_video_decode_h265"
  # Extension: VK_KHR_global_priority
  VkKhrGlobalPrioritySpecVersion* = 1
  VkKhrGlobalPriorityExtensionName* = "VK_KHR_global_priority"
  # Extension: VK_AMD_memory_overallocation_behavior
  VkAmdMemoryOverallocationBehaviorSpecVersion* = 1
  VkAmdMemoryOverallocationBehaviorExtensionName* = "VK_AMD_memory_overallocation_behavior"
  # Extension: VK_EXT_vertex_attribute_divisor
  VkExtVertexAttributeDivisorSpecVersion* = 3
  VkExtVertexAttributeDivisorExtensionName* = "VK_EXT_vertex_attribute_divisor"
  # Extension: VK_GGP_frame_token
  VkGgpFrameTokenSpecVersion* = 1
  VkGgpFrameTokenExtensionName* = "VK_GGP_frame_token"
  # Extension: VK_EXT_pipeline_creation_feedback
  VkExtPipelineCreationFeedbackSpecVersion* = 1
  VkExtPipelineCreationFeedbackExtensionName* = "VK_EXT_pipeline_creation_feedback"
  # Extension: VK_KHR_driver_properties
  VkKhrDriverPropertiesSpecVersion* = 1
  VkKhrDriverPropertiesExtensionName* = "VK_KHR_driver_properties"
  # Extension: VK_KHR_shader_float_controls
  VkKhrShaderFloatControlsSpecVersion* = 4
  VkKhrShaderFloatControlsExtensionName* = "VK_KHR_shader_float_controls"
  # Extension: VK_NV_shader_subgroup_partitioned
  VkNvShaderSubgroupPartitionedSpecVersion* = 1
  VkNvShaderSubgroupPartitionedExtensionName* = "VK_NV_shader_subgroup_partitioned"
  # Extension: VK_KHR_depth_stencil_resolve
  VkKhrDepthStencilResolveSpecVersion* = 1
  VkKhrDepthStencilResolveExtensionName* = "VK_KHR_depth_stencil_resolve"
  # Extension: VK_KHR_swapchain_mutable_format
  VkKhrSwapchainMutableFormatSpecVersion* = 1
  VkKhrSwapchainMutableFormatExtensionName* = "VK_KHR_swapchain_mutable_format"
  # Extension: VK_NV_compute_shader_derivatives
  VkNvComputeShaderDerivativesSpecVersion* = 1
  VkNvComputeShaderDerivativesExtensionName* = "VK_NV_compute_shader_derivatives"
  # Extension: VK_NV_mesh_shader
  VkNvMeshShaderSpecVersion* = 1
  VkNvMeshShaderExtensionName* = "VK_NV_mesh_shader"
  # Extension: VK_NV_fragment_shader_barycentric
  VkNvFragmentShaderBarycentricSpecVersion* = 1
  VkNvFragmentShaderBarycentricExtensionName* = "VK_NV_fragment_shader_barycentric"
  # Extension: VK_NV_shader_image_footprint
  VkNvShaderImageFootprintSpecVersion* = 2
  VkNvShaderImageFootprintExtensionName* = "VK_NV_shader_image_footprint"
  # Extension: VK_NV_scissor_exclusive
  VkNvScissorExclusiveSpecVersion* = 2
  VkNvScissorExclusiveExtensionName* = "VK_NV_scissor_exclusive"
  # Extension: VK_NV_device_diagnostic_checkpoints
  VkNvDeviceDiagnosticCheckpointsSpecVersion* = 2
  VkNvDeviceDiagnosticCheckpointsExtensionName* = "VK_NV_device_diagnostic_checkpoints"
  # Extension: VK_KHR_timeline_semaphore
  VkKhrTimelineSemaphoreSpecVersion* = 2
  VkKhrTimelineSemaphoreExtensionName* = "VK_KHR_timeline_semaphore"
  # Extension: VK_EXT_present_timing
  VkExtPresentTimingSpecVersion* = 3
  VkExtPresentTimingExtensionName* = "VK_EXT_present_timing"
  # Extension: VK_INTEL_shader_integer_functions2
  VkIntelShaderIntegerFunctions2SpecVersion* = 1
  VkIntelShaderIntegerFunctions2ExtensionName* = "VK_INTEL_shader_integer_functions2"
  # Extension: VK_INTEL_performance_query
  VkIntelPerformanceQuerySpecVersion* = 2
  VkIntelPerformanceQueryExtensionName* = "VK_INTEL_performance_query"
  # Extension: VK_KHR_vulkan_memory_model
  VkKhrVulkanMemoryModelSpecVersion* = 3
  VkKhrVulkanMemoryModelExtensionName* = "VK_KHR_vulkan_memory_model"
  # Extension: VK_EXT_pci_bus_info
  VkExtPciBusInfoSpecVersion* = 2
  VkExtPciBusInfoExtensionName* = "VK_EXT_pci_bus_info"
  # Extension: VK_AMD_display_native_hdr
  VkAmdDisplayNativeHdrSpecVersion* = 1
  VkAmdDisplayNativeHdrExtensionName* = "VK_AMD_display_native_hdr"
  # Extension: VK_FUCHSIA_imagepipe_surface
  VkFuchsiaImagepipeSurfaceSpecVersion* = 1
  VkFuchsiaImagepipeSurfaceExtensionName* = "VK_FUCHSIA_imagepipe_surface"
  # Extension: VK_KHR_shader_terminate_invocation
  VkKhrShaderTerminateInvocationSpecVersion* = 1
  VkKhrShaderTerminateInvocationExtensionName* = "VK_KHR_shader_terminate_invocation"
  # Extension: VK_EXT_metal_surface
  VkExtMetalSurfaceSpecVersion* = 1
  VkExtMetalSurfaceExtensionName* = "VK_EXT_metal_surface"
  # Extension: VK_EXT_fragment_density_map
  VkExtFragmentDensityMapSpecVersion* = 3
  VkExtFragmentDensityMapExtensionName* = "VK_EXT_fragment_density_map"
  # Extension: VK_EXT_scalar_block_layout
  VkExtScalarBlockLayoutSpecVersion* = 1
  VkExtScalarBlockLayoutExtensionName* = "VK_EXT_scalar_block_layout"
  # Extension: VK_GOOGLE_hlsl_functionality1
  VkGoogleHlslFunctionality1SpecVersion* = 1
  VkGoogleHlslFunctionality1ExtensionName* = "VK_GOOGLE_hlsl_functionality1"
  # Extension: VK_GOOGLE_decorate_string
  VkGoogleDecorateStringSpecVersion* = 1
  VkGoogleDecorateStringExtensionName* = "VK_GOOGLE_decorate_string"
  # Extension: VK_EXT_subgroup_size_control
  VkExtSubgroupSizeControlSpecVersion* = 2
  VkExtSubgroupSizeControlExtensionName* = "VK_EXT_subgroup_size_control"
  # Extension: VK_KHR_fragment_shading_rate
  VkKhrFragmentShadingRateSpecVersion* = 2
  VkKhrFragmentShadingRateExtensionName* = "VK_KHR_fragment_shading_rate"
  # Extension: VK_AMD_shader_core_properties2
  VkAmdShaderCoreProperties2SpecVersion* = 1
  VkAmdShaderCoreProperties2ExtensionName* = "VK_AMD_shader_core_properties2"
  # Extension: VK_AMD_device_coherent_memory
  VkAmdDeviceCoherentMemorySpecVersion* = 1
  VkAmdDeviceCoherentMemoryExtensionName* = "VK_AMD_device_coherent_memory"
  # Extension: VK_KHR_dynamic_rendering_local_read
  VkKhrDynamicRenderingLocalReadSpecVersion* = 1
  VkKhrDynamicRenderingLocalReadExtensionName* = "VK_KHR_dynamic_rendering_local_read"
  # Extension: VK_EXT_shader_image_atomic_int64
  VkExtShaderImageAtomicInt64SpecVersion* = 1
  VkExtShaderImageAtomicInt64ExtensionName* = "VK_EXT_shader_image_atomic_int64"
  # Extension: VK_KHR_shader_quad_control
  VkKhrShaderQuadControlSpecVersion* = 1
  VkKhrShaderQuadControlExtensionName* = "VK_KHR_shader_quad_control"
  # Extension: VK_KHR_spirv_1_4
  VkKhrSpirv14SpecVersion* = 1
  VkKhrSpirv14ExtensionName* = "VK_KHR_spirv_1_4"
  # Extension: VK_EXT_memory_budget
  VkExtMemoryBudgetSpecVersion* = 1
  VkExtMemoryBudgetExtensionName* = "VK_EXT_memory_budget"
  # Extension: VK_EXT_memory_priority
  VkExtMemoryPrioritySpecVersion* = 1
  VkExtMemoryPriorityExtensionName* = "VK_EXT_memory_priority"
  # Extension: VK_KHR_surface_protected_capabilities
  VkKhrSurfaceProtectedCapabilitiesSpecVersion* = 1
  VkKhrSurfaceProtectedCapabilitiesExtensionName* = "VK_KHR_surface_protected_capabilities"
  # Extension: VK_NV_dedicated_allocation_image_aliasing
  VkNvDedicatedAllocationImageAliasingSpecVersion* = 1
  VkNvDedicatedAllocationImageAliasingExtensionName* = "VK_NV_dedicated_allocation_image_aliasing"
  # Extension: VK_KHR_separate_depth_stencil_layouts
  VkKhrSeparateDepthStencilLayoutsSpecVersion* = 1
  VkKhrSeparateDepthStencilLayoutsExtensionName* = "VK_KHR_separate_depth_stencil_layouts"
  # Extension: VK_EXT_buffer_device_address
  VkExtBufferDeviceAddressSpecVersion* = 2
  VkExtBufferDeviceAddressExtensionName* = "VK_EXT_buffer_device_address"
  # Extension: VK_EXT_tooling_info
  VkExtToolingInfoSpecVersion* = 1
  VkExtToolingInfoExtensionName* = "VK_EXT_tooling_info"
  # Extension: VK_EXT_separate_stencil_usage
  VkExtSeparateStencilUsageSpecVersion* = 1
  VkExtSeparateStencilUsageExtensionName* = "VK_EXT_separate_stencil_usage"
  # Extension: VK_EXT_validation_features
  VkExtValidationFeaturesSpecVersion* = 6
  VkExtValidationFeaturesExtensionName* = "VK_EXT_validation_features"
  # Extension: VK_KHR_present_wait
  VkKhrPresentWaitSpecVersion* = 1
  VkKhrPresentWaitExtensionName* = "VK_KHR_present_wait"
  # Extension: VK_NV_cooperative_matrix
  VkNvCooperativeMatrixSpecVersion* = 1
  VkNvCooperativeMatrixExtensionName* = "VK_NV_cooperative_matrix"
  # Extension: VK_NV_coverage_reduction_mode
  VkNvCoverageReductionModeSpecVersion* = 1
  VkNvCoverageReductionModeExtensionName* = "VK_NV_coverage_reduction_mode"
  # Extension: VK_EXT_fragment_shader_interlock
  VkExtFragmentShaderInterlockSpecVersion* = 1
  VkExtFragmentShaderInterlockExtensionName* = "VK_EXT_fragment_shader_interlock"
  # Extension: VK_EXT_ycbcr_image_arrays
  VkExtYcbcrImageArraysSpecVersion* = 1
  VkExtYcbcrImageArraysExtensionName* = "VK_EXT_ycbcr_image_arrays"
  # Extension: VK_KHR_uniform_buffer_standard_layout
  VkKhrUniformBufferStandardLayoutSpecVersion* = 1
  VkKhrUniformBufferStandardLayoutExtensionName* = "VK_KHR_uniform_buffer_standard_layout"
  # Extension: VK_EXT_provoking_vertex
  VkExtProvokingVertexSpecVersion* = 1
  VkExtProvokingVertexExtensionName* = "VK_EXT_provoking_vertex"
  # Extension: VK_EXT_full_screen_exclusive
  VkExtFullScreenExclusiveSpecVersion* = 4
  VkExtFullScreenExclusiveExtensionName* = "VK_EXT_full_screen_exclusive"
  # Extension: VK_EXT_headless_surface
  VkExtHeadlessSurfaceSpecVersion* = 1
  VkExtHeadlessSurfaceExtensionName* = "VK_EXT_headless_surface"
  # Extension: VK_KHR_buffer_device_address
  VkKhrBufferDeviceAddressSpecVersion* = 1
  VkKhrBufferDeviceAddressExtensionName* = "VK_KHR_buffer_device_address"
  # Extension: VK_EXT_line_rasterization
  VkExtLineRasterizationSpecVersion* = 1
  VkExtLineRasterizationExtensionName* = "VK_EXT_line_rasterization"
  # Extension: VK_EXT_shader_atomic_float
  VkExtShaderAtomicFloatSpecVersion* = 1
  VkExtShaderAtomicFloatExtensionName* = "VK_EXT_shader_atomic_float"
  # Extension: VK_EXT_host_query_reset
  VkExtHostQueryResetSpecVersion* = 1
  VkExtHostQueryResetExtensionName* = "VK_EXT_host_query_reset"
  # Extension: VK_EXT_index_type_uint8
  VkExtIndexTypeUint8SpecVersion* = 1
  VkExtIndexTypeUint8ExtensionName* = "VK_EXT_index_type_uint8"
  # Extension: VK_EXT_extended_dynamic_state
  VkExtExtendedDynamicStateSpecVersion* = 1
  VkExtExtendedDynamicStateExtensionName* = "VK_EXT_extended_dynamic_state"
  # Extension: VK_KHR_deferred_host_operations
  VkKhrDeferredHostOperationsSpecVersion* = 4
  VkKhrDeferredHostOperationsExtensionName* = "VK_KHR_deferred_host_operations"
  # Extension: VK_KHR_pipeline_executable_properties
  VkKhrPipelineExecutablePropertiesSpecVersion* = 1
  VkKhrPipelineExecutablePropertiesExtensionName* = "VK_KHR_pipeline_executable_properties"
  # Extension: VK_EXT_host_image_copy
  VkExtHostImageCopySpecVersion* = 1
  VkExtHostImageCopyExtensionName* = "VK_EXT_host_image_copy"
  # Extension: VK_KHR_map_memory2
  VkKhrMapMemory2SpecVersion* = 1
  VkKhrMapMemory2ExtensionName* = "VK_KHR_map_memory2"
  # Extension: VK_EXT_map_memory_placed
  VkExtMapMemoryPlacedSpecVersion* = 1
  VkExtMapMemoryPlacedExtensionName* = "VK_EXT_map_memory_placed"
  # Extension: VK_EXT_shader_atomic_float2
  VkExtShaderAtomicFloat2SpecVersion* = 1
  VkExtShaderAtomicFloat2ExtensionName* = "VK_EXT_shader_atomic_float2"
  # Extension: VK_EXT_surface_maintenance1
  VkExtSurfaceMaintenance1SpecVersion* = 1
  VkExtSurfaceMaintenance1ExtensionName* = "VK_EXT_surface_maintenance1"
  # Extension: VK_EXT_swapchain_maintenance1
  VkExtSwapchainMaintenance1SpecVersion* = 1
  VkExtSwapchainMaintenance1ExtensionName* = "VK_EXT_swapchain_maintenance1"
  # Extension: VK_EXT_shader_demote_to_helper_invocation
  VkExtShaderDemoteToHelperInvocationSpecVersion* = 1
  VkExtShaderDemoteToHelperInvocationExtensionName* = "VK_EXT_shader_demote_to_helper_invocation"
  # Extension: VK_NV_device_generated_commands
  VkNvDeviceGeneratedCommandsSpecVersion* = 3
  VkNvDeviceGeneratedCommandsExtensionName* = "VK_NV_device_generated_commands"
  # Extension: VK_NV_inherited_viewport_scissor
  VkNvInheritedViewportScissorSpecVersion* = 1
  VkNvInheritedViewportScissorExtensionName* = "VK_NV_inherited_viewport_scissor"
  # Extension: VK_KHR_shader_integer_dot_product
  VkKhrShaderIntegerDotProductSpecVersion* = 1
  VkKhrShaderIntegerDotProductExtensionName* = "VK_KHR_shader_integer_dot_product"
  # Extension: VK_EXT_texel_buffer_alignment
  VkExtTexelBufferAlignmentSpecVersion* = 1
  VkExtTexelBufferAlignmentExtensionName* = "VK_EXT_texel_buffer_alignment"
  # Extension: VK_QCOM_render_pass_transform
  VkQcomRenderPassTransformSpecVersion* = 5
  VkQcomRenderPassTransformExtensionName* = "VK_QCOM_render_pass_transform"
  # Extension: VK_EXT_depth_bias_control
  VkExtDepthBiasControlSpecVersion* = 1
  VkExtDepthBiasControlExtensionName* = "VK_EXT_depth_bias_control"
  # Extension: VK_EXT_device_memory_report
  VkExtDeviceMemoryReportSpecVersion* = 2
  VkExtDeviceMemoryReportExtensionName* = "VK_EXT_device_memory_report"
  # Extension: VK_EXT_acquire_drm_display
  VkExtAcquireDrmDisplaySpecVersion* = 1
  VkExtAcquireDrmDisplayExtensionName* = "VK_EXT_acquire_drm_display"
  # Extension: VK_EXT_robustness2
  VkExtRobustness2SpecVersion* = 1
  VkExtRobustness2ExtensionName* = "VK_EXT_robustness2"
  # Extension: VK_EXT_custom_border_color
  VkExtCustomBorderColorSpecVersion* = 12
  VkExtCustomBorderColorExtensionName* = "VK_EXT_custom_border_color"
  # Extension: VK_EXT_texture_compression_astc_3d
  VkExtTextureCompressionAstc3dSpecVersion* = 1
  VkExtTextureCompressionAstc3dExtensionName* = "VK_EXT_texture_compression_astc_3d"
  # Extension: VK_GOOGLE_user_type
  VkGoogleUserTypeSpecVersion* = 1
  VkGoogleUserTypeExtensionName* = "VK_GOOGLE_user_type"
  # Extension: VK_KHR_pipeline_library
  VkKhrPipelineLibrarySpecVersion* = 1
  VkKhrPipelineLibraryExtensionName* = "VK_KHR_pipeline_library"
  # Extension: VK_NV_present_barrier
  VkNvPresentBarrierSpecVersion* = 1
  VkNvPresentBarrierExtensionName* = "VK_NV_present_barrier"
  # Extension: VK_KHR_shader_non_semantic_info
  VkKhrShaderNonSemanticInfoSpecVersion* = 1
  VkKhrShaderNonSemanticInfoExtensionName* = "VK_KHR_shader_non_semantic_info"
  # Extension: VK_KHR_present_id
  VkKhrPresentIdSpecVersion* = 1
  VkKhrPresentIdExtensionName* = "VK_KHR_present_id"
  # Extension: VK_EXT_private_data
  VkExtPrivateDataSpecVersion* = 1
  VkExtPrivateDataExtensionName* = "VK_EXT_private_data"
  # Extension: VK_EXT_pipeline_creation_cache_control
  VkExtPipelineCreationCacheControlSpecVersion* = 3
  VkExtPipelineCreationCacheControlExtensionName* = "VK_EXT_pipeline_creation_cache_control"
  # Extension: VK_KHR_video_encode_queue
  VkKhrVideoEncodeQueueSpecVersion* = 12
  VkKhrVideoEncodeQueueExtensionName* = "VK_KHR_video_encode_queue"
  # Extension: VK_NV_device_diagnostics_config
  VkNvDeviceDiagnosticsConfigSpecVersion* = 2
  VkNvDeviceDiagnosticsConfigExtensionName* = "VK_NV_device_diagnostics_config"
  # Extension: VK_QCOM_render_pass_store_ops
  VkQcomRenderPassStoreOpsSpecVersion* = 2
  VkQcomRenderPassStoreOpsExtensionName* = "VK_QCOM_render_pass_store_ops"
  # Extension: VK_NV_cuda_kernel_launch
  VkNvCudaKernelLaunchSpecVersion* = 2
  VkNvCudaKernelLaunchExtensionName* = "VK_NV_cuda_kernel_launch"
  # Extension: VK_KHR_object_refresh
  VkKhrObjectRefreshSpecVersion* = 1
  VkKhrObjectRefreshExtensionName* = "VK_KHR_object_refresh"
  # Extension: VK_QCOM_tile_shading
  VkQcomTileShadingSpecVersion* = 2
  VkQcomTileShadingExtensionName* = "VK_QCOM_tile_shading"
  # Extension: VK_NV_low_latency
  VkNvLowLatencySpecVersion* = 1
  VkNvLowLatencyExtensionName* = "VK_NV_low_latency"
  # Extension: VK_EXT_metal_objects
  VkExtMetalObjectsSpecVersion* = 2
  VkExtMetalObjectsExtensionName* = "VK_EXT_metal_objects"
  # Extension: VK_KHR_synchronization2
  VkKhrSynchronization2SpecVersion* = 1
  VkKhrSynchronization2ExtensionName* = "VK_KHR_synchronization2"
  # Extension: VK_EXT_descriptor_buffer
  VkExtDescriptorBufferSpecVersion* = 1
  VkExtDescriptorBufferExtensionName* = "VK_EXT_descriptor_buffer"
  # Extension: VK_EXT_graphics_pipeline_library
  VkExtGraphicsPipelineLibrarySpecVersion* = 1
  VkExtGraphicsPipelineLibraryExtensionName* = "VK_EXT_graphics_pipeline_library"
  # Extension: VK_AMD_shader_early_and_late_fragment_tests
  VkAmdShaderEarlyAndLateFragmentTestsSpecVersion* = 1
  VkAmdShaderEarlyAndLateFragmentTestsExtensionName* = "VK_AMD_shader_early_and_late_fragment_tests"
  # Extension: VK_KHR_fragment_shader_barycentric
  VkKhrFragmentShaderBarycentricSpecVersion* = 1
  VkKhrFragmentShaderBarycentricExtensionName* = "VK_KHR_fragment_shader_barycentric"
  # Extension: VK_KHR_shader_subgroup_uniform_control_flow
  VkKhrShaderSubgroupUniformControlFlowSpecVersion* = 1
  VkKhrShaderSubgroupUniformControlFlowExtensionName* = "VK_KHR_shader_subgroup_uniform_control_flow"
  # Extension: VK_KHR_zero_initialize_workgroup_memory
  VkKhrZeroInitializeWorkgroupMemorySpecVersion* = 1
  VkKhrZeroInitializeWorkgroupMemoryExtensionName* = "VK_KHR_zero_initialize_workgroup_memory"
  # Extension: VK_NV_fragment_shading_rate_enums
  VkNvFragmentShadingRateEnumsSpecVersion* = 1
  VkNvFragmentShadingRateEnumsExtensionName* = "VK_NV_fragment_shading_rate_enums"
  # Extension: VK_NV_ray_tracing_motion_blur
  VkNvRayTracingMotionBlurSpecVersion* = 1
  VkNvRayTracingMotionBlurExtensionName* = "VK_NV_ray_tracing_motion_blur"
  # Extension: VK_EXT_mesh_shader
  VkExtMeshShaderSpecVersion* = 1
  VkExtMeshShaderExtensionName* = "VK_EXT_mesh_shader"
  # Extension: VK_EXT_ycbcr_2plane_444_formats
  VkExtYcbcr2plane444FormatsSpecVersion* = 1
  VkExtYcbcr2plane444FormatsExtensionName* = "VK_EXT_ycbcr_2plane_444_formats"
  # Extension: VK_EXT_fragment_density_map2
  VkExtFragmentDensityMap2SpecVersion* = 1
  VkExtFragmentDensityMap2ExtensionName* = "VK_EXT_fragment_density_map2"
  # Extension: VK_QCOM_rotated_copy_commands
  VkQcomRotatedCopyCommandsSpecVersion* = 2
  VkQcomRotatedCopyCommandsExtensionName* = "VK_QCOM_rotated_copy_commands"
  # Extension: VK_EXT_image_robustness
  VkExtImageRobustnessSpecVersion* = 1
  VkExtImageRobustnessExtensionName* = "VK_EXT_image_robustness"
  # Extension: VK_KHR_workgroup_memory_explicit_layout
  VkKhrWorkgroupMemoryExplicitLayoutSpecVersion* = 1
  VkKhrWorkgroupMemoryExplicitLayoutExtensionName* = "VK_KHR_workgroup_memory_explicit_layout"
  # Extension: VK_KHR_copy_commands2
  VkKhrCopyCommands2SpecVersion* = 1
  VkKhrCopyCommands2ExtensionName* = "VK_KHR_copy_commands2"
  # Extension: VK_EXT_image_compression_control
  VkExtImageCompressionControlSpecVersion* = 1
  VkExtImageCompressionControlExtensionName* = "VK_EXT_image_compression_control"
  # Extension: VK_EXT_attachment_feedback_loop_layout
  VkExtAttachmentFeedbackLoopLayoutSpecVersion* = 2
  VkExtAttachmentFeedbackLoopLayoutExtensionName* = "VK_EXT_attachment_feedback_loop_layout"
  # Extension: VK_EXT_4444_formats
  VkExt4444FormatsSpecVersion* = 1
  VkExt4444FormatsExtensionName* = "VK_EXT_4444_formats"
  # Extension: VK_EXT_device_fault
  VkExtDeviceFaultSpecVersion* = 2
  VkExtDeviceFaultExtensionName* = "VK_EXT_device_fault"
  # Extension: VK_ARM_rasterization_order_attachment_access
  VkArmRasterizationOrderAttachmentAccessSpecVersion* = 1
  VkArmRasterizationOrderAttachmentAccessExtensionName* = "VK_ARM_rasterization_order_attachment_access"
  # Extension: VK_EXT_rgba10x6_formats
  VkExtRgba10x6FormatsSpecVersion* = 1
  VkExtRgba10x6FormatsExtensionName* = "VK_EXT_rgba10x6_formats"
  # Extension: VK_NV_acquire_winrt_display
  VkNvAcquireWinrtDisplaySpecVersion* = 1
  VkNvAcquireWinrtDisplayExtensionName* = "VK_NV_acquire_winrt_display"
  # Extension: VK_EXT_directfb_surface
  VkExtDirectfbSurfaceSpecVersion* = 1
  VkExtDirectfbSurfaceExtensionName* = "VK_EXT_directfb_surface"
  # Extension: VK_VALVE_mutable_descriptor_type
  VkValveMutableDescriptorTypeSpecVersion* = 1
  VkValveMutableDescriptorTypeExtensionName* = "VK_VALVE_mutable_descriptor_type"
  # Extension: VK_EXT_vertex_input_dynamic_state
  VkExtVertexInputDynamicStateSpecVersion* = 2
  VkExtVertexInputDynamicStateExtensionName* = "VK_EXT_vertex_input_dynamic_state"
  # Extension: VK_EXT_physical_device_drm
  VkExtPhysicalDeviceDrmSpecVersion* = 1
  VkExtPhysicalDeviceDrmExtensionName* = "VK_EXT_physical_device_drm"
  # Extension: VK_EXT_device_address_binding_report
  VkExtDeviceAddressBindingReportSpecVersion* = 1
  VkExtDeviceAddressBindingReportExtensionName* = "VK_EXT_device_address_binding_report"
  # Extension: VK_EXT_depth_clip_control
  VkExtDepthClipControlSpecVersion* = 1
  VkExtDepthClipControlExtensionName* = "VK_EXT_depth_clip_control"
  # Extension: VK_EXT_primitive_topology_list_restart
  VkExtPrimitiveTopologyListRestartSpecVersion* = 1
  VkExtPrimitiveTopologyListRestartExtensionName* = "VK_EXT_primitive_topology_list_restart"
  # Extension: VK_KHR_format_feature_flags2
  VkKhrFormatFeatureFlags2SpecVersion* = 2
  VkKhrFormatFeatureFlags2ExtensionName* = "VK_KHR_format_feature_flags2"
  # Extension: VK_EXT_present_mode_fifo_latest_ready
  VkExtPresentModeFifoLatestReadySpecVersion* = 1
  VkExtPresentModeFifoLatestReadyExtensionName* = "VK_EXT_present_mode_fifo_latest_ready"
  # Extension: VK_FUCHSIA_external_memory
  VkFuchsiaExternalMemorySpecVersion* = 1
  VkFuchsiaExternalMemoryExtensionName* = "VK_FUCHSIA_external_memory"
  # Extension: VK_FUCHSIA_external_semaphore
  VkFuchsiaExternalSemaphoreSpecVersion* = 1
  VkFuchsiaExternalSemaphoreExtensionName* = "VK_FUCHSIA_external_semaphore"
  # Extension: VK_FUCHSIA_buffer_collection
  VkFuchsiaBufferCollectionSpecVersion* = 2
  VkFuchsiaBufferCollectionExtensionName* = "VK_FUCHSIA_buffer_collection"
  # Extension: VK_HUAWEI_subpass_shading
  VkHuaweiSubpassShadingSpecVersion* = 3
  VkHuaweiSubpassShadingExtensionName* = "VK_HUAWEI_subpass_shading"
  # Extension: VK_HUAWEI_invocation_mask
  VkHuaweiInvocationMaskSpecVersion* = 1
  VkHuaweiInvocationMaskExtensionName* = "VK_HUAWEI_invocation_mask"
  # Extension: VK_NV_external_memory_rdma
  VkNvExternalMemoryRdmaSpecVersion* = 1
  VkNvExternalMemoryRdmaExtensionName* = "VK_NV_external_memory_rdma"
  # Extension: VK_EXT_pipeline_properties
  VkExtPipelinePropertiesSpecVersion* = 1
  VkExtPipelinePropertiesExtensionName* = "VK_EXT_pipeline_properties"
  # Extension: VK_NV_external_sci_sync
  VkNvExternalSciSyncSpecVersion* = 2
  VkNvExternalSciSyncExtensionName* = "VK_NV_external_sci_sync"
  # Extension: VK_NV_external_memory_sci_buf
  VkNvExternalMemorySciBufSpecVersion* = 2
  VkNvExternalMemorySciBufExtensionName* = "VK_NV_external_memory_sci_buf"
  # Extension: VK_EXT_frame_boundary
  VkExtFrameBoundarySpecVersion* = 1
  VkExtFrameBoundaryExtensionName* = "VK_EXT_frame_boundary"
  # Extension: VK_EXT_multisampled_render_to_single_sampled
  VkExtMultisampledRenderToSingleSampledSpecVersion* = 1
  VkExtMultisampledRenderToSingleSampledExtensionName* = "VK_EXT_multisampled_render_to_single_sampled"
  # Extension: VK_EXT_extended_dynamic_state2
  VkExtExtendedDynamicState2SpecVersion* = 1
  VkExtExtendedDynamicState2ExtensionName* = "VK_EXT_extended_dynamic_state2"
  # Extension: VK_QNX_screen_surface
  VkQnxScreenSurfaceSpecVersion* = 1
  VkQnxScreenSurfaceExtensionName* = "VK_QNX_screen_surface"
  # Extension: VK_EXT_color_write_enable
  VkExtColorWriteEnableSpecVersion* = 1
  VkExtColorWriteEnableExtensionName* = "VK_EXT_color_write_enable"
  # Extension: VK_EXT_primitives_generated_query
  VkExtPrimitivesGeneratedQuerySpecVersion* = 1
  VkExtPrimitivesGeneratedQueryExtensionName* = "VK_EXT_primitives_generated_query"
  # Extension: VK_KHR_ray_tracing_maintenance1
  VkKhrRayTracingMaintenance1SpecVersion* = 1
  VkKhrRayTracingMaintenance1ExtensionName* = "VK_KHR_ray_tracing_maintenance1"
  # Extension: VK_KHR_shader_untyped_pointers
  VkKhrShaderUntypedPointersSpecVersion* = 1
  VkKhrShaderUntypedPointersExtensionName* = "VK_KHR_shader_untyped_pointers"
  # Extension: VK_EXT_global_priority_query
  VkExtGlobalPriorityQuerySpecVersion* = 1
  VkExtGlobalPriorityQueryExtensionName* = "VK_EXT_global_priority_query"
  # Extension: VK_VALVE_video_encode_rgb_conversion
  VkValveVideoEncodeRgbConversionSpecVersion* = 1
  VkValveVideoEncodeRgbConversionExtensionName* = "VK_VALVE_video_encode_rgb_conversion"
  # Extension: VK_EXT_image_view_min_lod
  VkExtImageViewMinLodSpecVersion* = 1
  VkExtImageViewMinLodExtensionName* = "VK_EXT_image_view_min_lod"
  # Extension: VK_EXT_multi_draw
  VkExtMultiDrawSpecVersion* = 1
  VkExtMultiDrawExtensionName* = "VK_EXT_multi_draw"
  # Extension: VK_EXT_image_2d_view_of_3d
  VkExtImage2dViewOf3dSpecVersion* = 1
  VkExtImage2dViewOf3dExtensionName* = "VK_EXT_image_2d_view_of_3d"
  # Extension: VK_KHR_portability_enumeration
  VkKhrPortabilityEnumerationSpecVersion* = 1
  VkKhrPortabilityEnumerationExtensionName* = "VK_KHR_portability_enumeration"
  # Extension: VK_EXT_shader_tile_image
  VkExtShaderTileImageSpecVersion* = 1
  VkExtShaderTileImageExtensionName* = "VK_EXT_shader_tile_image"
  # Extension: VK_EXT_opacity_micromap
  VkExtOpacityMicromapSpecVersion* = 2
  VkExtOpacityMicromapExtensionName* = "VK_EXT_opacity_micromap"
  # Extension: VK_NV_displacement_micromap
  VkNvDisplacementMicromapSpecVersion* = 2
  VkNvDisplacementMicromapExtensionName* = "VK_NV_displacement_micromap"
  # Extension: VK_EXT_load_store_op_none
  VkExtLoadStoreOpNoneSpecVersion* = 1
  VkExtLoadStoreOpNoneExtensionName* = "VK_EXT_load_store_op_none"
  # Extension: VK_HUAWEI_cluster_culling_shader
  VkHuaweiClusterCullingShaderSpecVersion* = 3
  VkHuaweiClusterCullingShaderExtensionName* = "VK_HUAWEI_cluster_culling_shader"
  # Extension: VK_EXT_border_color_swizzle
  VkExtBorderColorSwizzleSpecVersion* = 1
  VkExtBorderColorSwizzleExtensionName* = "VK_EXT_border_color_swizzle"
  # Extension: VK_EXT_pageable_device_local_memory
  VkExtPageableDeviceLocalMemorySpecVersion* = 1
  VkExtPageableDeviceLocalMemoryExtensionName* = "VK_EXT_pageable_device_local_memory"
  # Extension: VK_KHR_maintenance4
  VkKhrMaintenance4SpecVersion* = 2
  VkKhrMaintenance4ExtensionName* = "VK_KHR_maintenance4"
  # Extension: VK_ARM_shader_core_properties
  VkArmShaderCorePropertiesSpecVersion* = 1
  VkArmShaderCorePropertiesExtensionName* = "VK_ARM_shader_core_properties"
  # Extension: VK_KHR_shader_subgroup_rotate
  VkKhrShaderSubgroupRotateSpecVersion* = 2
  VkKhrShaderSubgroupRotateExtensionName* = "VK_KHR_shader_subgroup_rotate"
  # Extension: VK_ARM_scheduling_controls
  VkArmSchedulingControlsSpecVersion* = 1
  VkArmSchedulingControlsExtensionName* = "VK_ARM_scheduling_controls"
  # Extension: VK_EXT_image_sliced_view_of_3d
  VkExtImageSlicedViewOf3dSpecVersion* = 1
  VkExtImageSlicedViewOf3dExtensionName* = "VK_EXT_image_sliced_view_of_3d"
  # Extension: VK_VALVE_descriptor_set_host_mapping
  VkValveDescriptorSetHostMappingSpecVersion* = 1
  VkValveDescriptorSetHostMappingExtensionName* = "VK_VALVE_descriptor_set_host_mapping"
  # Extension: VK_EXT_depth_clamp_zero_one
  VkExtDepthClampZeroOneSpecVersion* = 1
  VkExtDepthClampZeroOneExtensionName* = "VK_EXT_depth_clamp_zero_one"
  # Extension: VK_EXT_non_seamless_cube_map
  VkExtNonSeamlessCubeMapSpecVersion* = 1
  VkExtNonSeamlessCubeMapExtensionName* = "VK_EXT_non_seamless_cube_map"
  # Extension: VK_ARM_render_pass_striped
  VkArmRenderPassStripedSpecVersion* = 1
  VkArmRenderPassStripedExtensionName* = "VK_ARM_render_pass_striped"
  # Extension: VK_QCOM_fragment_density_map_offset
  VkQcomFragmentDensityMapOffsetSpecVersion* = 3
  VkQcomFragmentDensityMapOffsetExtensionName* = "VK_QCOM_fragment_density_map_offset"
  # Extension: VK_NV_copy_memory_indirect
  VkNvCopyMemoryIndirectSpecVersion* = 1
  VkNvCopyMemoryIndirectExtensionName* = "VK_NV_copy_memory_indirect"
  # Extension: VK_NV_memory_decompression
  VkNvMemoryDecompressionSpecVersion* = 1
  VkNvMemoryDecompressionExtensionName* = "VK_NV_memory_decompression"
  # Extension: VK_NV_device_generated_commands_compute
  VkNvDeviceGeneratedCommandsComputeSpecVersion* = 2
  VkNvDeviceGeneratedCommandsComputeExtensionName* = "VK_NV_device_generated_commands_compute"
  # Extension: VK_NV_ray_tracing_linear_swept_spheres
  VkNvRayTracingLinearSweptSpheresSpecVersion* = 1
  VkNvRayTracingLinearSweptSpheresExtensionName* = "VK_NV_ray_tracing_linear_swept_spheres"
  # Extension: VK_NV_linear_color_attachment
  VkNvLinearColorAttachmentSpecVersion* = 1
  VkNvLinearColorAttachmentExtensionName* = "VK_NV_linear_color_attachment"
  # Extension: VK_GOOGLE_surfaceless_query
  VkGoogleSurfacelessQuerySpecVersion* = 2
  VkGoogleSurfacelessQueryExtensionName* = "VK_GOOGLE_surfaceless_query"
  # Extension: VK_KHR_shader_maximal_reconvergence
  VkKhrShaderMaximalReconvergenceSpecVersion* = 1
  VkKhrShaderMaximalReconvergenceExtensionName* = "VK_KHR_shader_maximal_reconvergence"
  # Extension: VK_EXT_application_parameters
  VkExtApplicationParametersSpecVersion* = 1
  VkExtApplicationParametersExtensionName* = "VK_EXT_application_parameters"
  # Extension: VK_EXT_image_compression_control_swapchain
  VkExtImageCompressionControlSwapchainSpecVersion* = 1
  VkExtImageCompressionControlSwapchainExtensionName* = "VK_EXT_image_compression_control_swapchain"
  # Extension: VK_QCOM_image_processing
  VkQcomImageProcessingSpecVersion* = 1
  VkQcomImageProcessingExtensionName* = "VK_QCOM_image_processing"
  # Extension: VK_EXT_nested_command_buffer
  VkExtNestedCommandBufferSpecVersion* = 1
  VkExtNestedCommandBufferExtensionName* = "VK_EXT_nested_command_buffer"
  # Extension: VK_OHOS_external_memory
  VkOhosExternalMemorySpecVersion* = 1
  VkOhosExternalMemoryExtensionName* = "VK_OHOS_external_memory"
  # Extension: VK_EXT_external_memory_acquire_unmodified
  VkExtExternalMemoryAcquireUnmodifiedSpecVersion* = 1
  VkExtExternalMemoryAcquireUnmodifiedExtensionName* = "VK_EXT_external_memory_acquire_unmodified"
  # Extension: VK_EXT_extended_dynamic_state3
  VkExtExtendedDynamicState3SpecVersion* = 2
  VkExtExtendedDynamicState3ExtensionName* = "VK_EXT_extended_dynamic_state3"
  # Extension: VK_EXT_subpass_merge_feedback
  VkExtSubpassMergeFeedbackSpecVersion* = 2
  VkExtSubpassMergeFeedbackExtensionName* = "VK_EXT_subpass_merge_feedback"
  # Extension: VK_LUNARG_direct_driver_loading
  VkLunargDirectDriverLoadingSpecVersion* = 1
  VkLunargDirectDriverLoadingExtensionName* = "VK_LUNARG_direct_driver_loading"
  # Extension: VK_ARM_tensors
  VkArmTensorsSpecVersion* = 2
  VkArmTensorsExtensionName* = "VK_ARM_tensors"
  # Extension: VK_EXT_shader_module_identifier
  VkExtShaderModuleIdentifierSpecVersion* = 1
  VkExtShaderModuleIdentifierExtensionName* = "VK_EXT_shader_module_identifier"
  # Extension: VK_EXT_rasterization_order_attachment_access
  VkExtRasterizationOrderAttachmentAccessSpecVersion* = 1
  VkExtRasterizationOrderAttachmentAccessExtensionName* = "VK_EXT_rasterization_order_attachment_access"
  # Extension: VK_NV_optical_flow
  VkNvOpticalFlowSpecVersion* = 1
  VkNvOpticalFlowExtensionName* = "VK_NV_optical_flow"
  # Extension: VK_EXT_legacy_dithering
  VkExtLegacyDitheringSpecVersion* = 2
  VkExtLegacyDitheringExtensionName* = "VK_EXT_legacy_dithering"
  # Extension: VK_EXT_pipeline_protected_access
  VkExtPipelineProtectedAccessSpecVersion* = 1
  VkExtPipelineProtectedAccessExtensionName* = "VK_EXT_pipeline_protected_access"
  # Extension: VK_ANDROID_external_format_resolve
  VkAndroidExternalFormatResolveSpecVersion* = 1
  VkAndroidExternalFormatResolveExtensionName* = "VK_ANDROID_external_format_resolve"
  # Extension: VK_KHR_maintenance5
  VkKhrMaintenance5SpecVersion* = 1
  VkKhrMaintenance5ExtensionName* = "VK_KHR_maintenance5"
  # Extension: VK_AMD_anti_lag
  VkAmdAntiLagSpecVersion* = 1
  VkAmdAntiLagExtensionName* = "VK_AMD_anti_lag"
  # Extension: VK_AMDX_dense_geometry_format
  VkAmdxDenseGeometryFormatSpecVersion* = 1
  VkAmdxDenseGeometryFormatExtensionName* = "VK_AMDX_dense_geometry_format"
  # Extension: VK_KHR_present_id2
  VkKhrPresentId2SpecVersion* = 1
  VkKhrPresentId2ExtensionName* = "VK_KHR_present_id2"
  # Extension: VK_KHR_present_wait2
  VkKhrPresentWait2SpecVersion* = 1
  VkKhrPresentWait2ExtensionName* = "VK_KHR_present_wait2"
  # Extension: VK_KHR_ray_tracing_position_fetch
  VkKhrRayTracingPositionFetchSpecVersion* = 1
  VkKhrRayTracingPositionFetchExtensionName* = "VK_KHR_ray_tracing_position_fetch"
  # Extension: VK_EXT_shader_object
  VkExtShaderObjectSpecVersion* = 1
  VkExtShaderObjectExtensionName* = "VK_EXT_shader_object"
  # Extension: VK_KHR_pipeline_binary
  VkKhrPipelineBinarySpecVersion* = 1
  VkKhrPipelineBinaryExtensionName* = "VK_KHR_pipeline_binary"
  # Extension: VK_QCOM_tile_properties
  VkQcomTilePropertiesSpecVersion* = 1
  VkQcomTilePropertiesExtensionName* = "VK_QCOM_tile_properties"
  # Extension: VK_SEC_amigo_profiling
  VkSecAmigoProfilingSpecVersion* = 1
  VkSecAmigoProfilingExtensionName* = "VK_SEC_amigo_profiling"
  # Extension: VK_KHR_surface_maintenance1
  VkKhrSurfaceMaintenance1SpecVersion* = 1
  VkKhrSurfaceMaintenance1ExtensionName* = "VK_KHR_surface_maintenance1"
  # Extension: VK_KHR_swapchain_maintenance1
  VkKhrSwapchainMaintenance1SpecVersion* = 1
  VkKhrSwapchainMaintenance1ExtensionName* = "VK_KHR_swapchain_maintenance1"
  # Extension: VK_QCOM_multiview_per_view_viewports
  VkQcomMultiviewPerViewViewportsSpecVersion* = 1
  VkQcomMultiviewPerViewViewportsExtensionName* = "VK_QCOM_multiview_per_view_viewports"
  # Extension: VK_NV_external_sci_sync2
  VkNvExternalSciSync2SpecVersion* = 1
  VkNvExternalSciSync2ExtensionName* = "VK_NV_external_sci_sync2"
  # Extension: VK_NV_ray_tracing_invocation_reorder
  VkNvRayTracingInvocationReorderSpecVersion* = 1
  VkNvRayTracingInvocationReorderExtensionName* = "VK_NV_ray_tracing_invocation_reorder"
  # Extension: VK_NV_cooperative_vector
  VkNvCooperativeVectorSpecVersion* = 4
  VkNvCooperativeVectorExtensionName* = "VK_NV_cooperative_vector"
  # Extension: VK_NV_extended_sparse_address_space
  VkNvExtendedSparseAddressSpaceSpecVersion* = 1
  VkNvExtendedSparseAddressSpaceExtensionName* = "VK_NV_extended_sparse_address_space"
  # Extension: VK_EXT_mutable_descriptor_type
  VkExtMutableDescriptorTypeSpecVersion* = 1
  VkExtMutableDescriptorTypeExtensionName* = "VK_EXT_mutable_descriptor_type"
  # Extension: VK_EXT_legacy_vertex_attributes
  VkExtLegacyVertexAttributesSpecVersion* = 1
  VkExtLegacyVertexAttributesExtensionName* = "VK_EXT_legacy_vertex_attributes"
  # Extension: VK_EXT_layer_settings
  VkExtLayerSettingsSpecVersion* = 2
  VkExtLayerSettingsExtensionName* = "VK_EXT_layer_settings"
  # Extension: VK_ARM_shader_core_builtins
  VkArmShaderCoreBuiltinsSpecVersion* = 2
  VkArmShaderCoreBuiltinsExtensionName* = "VK_ARM_shader_core_builtins"
  # Extension: VK_EXT_pipeline_library_group_handles
  VkExtPipelineLibraryGroupHandlesSpecVersion* = 1
  VkExtPipelineLibraryGroupHandlesExtensionName* = "VK_EXT_pipeline_library_group_handles"
  # Extension: VK_EXT_dynamic_rendering_unused_attachments
  VkExtDynamicRenderingUnusedAttachmentsSpecVersion* = 1
  VkExtDynamicRenderingUnusedAttachmentsExtensionName* = "VK_EXT_dynamic_rendering_unused_attachments"
  # Extension: VK_KHR_internally_synchronized_queues
  VkKhrInternallySynchronizedQueuesSpecVersion* = 1
  VkKhrInternallySynchronizedQueuesExtensionName* = "VK_KHR_internally_synchronized_queues"
  # Extension: VK_NV_low_latency2
  VkNvLowLatency2SpecVersion* = 2
  VkNvLowLatency2ExtensionName* = "VK_NV_low_latency2"
  # Extension: VK_KHR_cooperative_matrix
  VkKhrCooperativeMatrixSpecVersion* = 2
  VkKhrCooperativeMatrixExtensionName* = "VK_KHR_cooperative_matrix"
  # Extension: VK_ARM_data_graph
  VkArmDataGraphSpecVersion* = 1
  VkArmDataGraphExtensionName* = "VK_ARM_data_graph"
  # Extension: VK_QCOM_multiview_per_view_render_areas
  VkQcomMultiviewPerViewRenderAreasSpecVersion* = 1
  VkQcomMultiviewPerViewRenderAreasExtensionName* = "VK_QCOM_multiview_per_view_render_areas"
  # Extension: VK_KHR_compute_shader_derivatives
  VkKhrComputeShaderDerivativesSpecVersion* = 1
  VkKhrComputeShaderDerivativesExtensionName* = "VK_KHR_compute_shader_derivatives"
  # Extension: VK_KHR_video_decode_av1
  VkKhrVideoDecodeAv1SpecVersion* = 1
  VkKhrVideoDecodeAv1ExtensionName* = "VK_KHR_video_decode_av1"
  # Extension: VK_KHR_video_encode_av1
  VkKhrVideoEncodeAv1SpecVersion* = 1
  VkKhrVideoEncodeAv1ExtensionName* = "VK_KHR_video_encode_av1"
  # Extension: VK_KHR_video_decode_vp9
  VkKhrVideoDecodeVp9SpecVersion* = 1
  VkKhrVideoDecodeVp9ExtensionName* = "VK_KHR_video_decode_vp9"
  # Extension: VK_KHR_video_maintenance1
  VkKhrVideoMaintenance1SpecVersion* = 1
  VkKhrVideoMaintenance1ExtensionName* = "VK_KHR_video_maintenance1"
  # Extension: VK_NV_per_stage_descriptor_set
  VkNvPerStageDescriptorSetSpecVersion* = 1
  VkNvPerStageDescriptorSetExtensionName* = "VK_NV_per_stage_descriptor_set"
  # Extension: VK_QCOM_image_processing2
  VkQcomImageProcessing2SpecVersion* = 1
  VkQcomImageProcessing2ExtensionName* = "VK_QCOM_image_processing2"
  # Extension: VK_QCOM_filter_cubic_weights
  VkQcomFilterCubicWeightsSpecVersion* = 1
  VkQcomFilterCubicWeightsExtensionName* = "VK_QCOM_filter_cubic_weights"
  # Extension: VK_QCOM_ycbcr_degamma
  VkQcomYcbcrDegammaSpecVersion* = 1
  VkQcomYcbcrDegammaExtensionName* = "VK_QCOM_ycbcr_degamma"
  # Extension: VK_QCOM_filter_cubic_clamp
  VkQcomFilterCubicClampSpecVersion* = 1
  VkQcomFilterCubicClampExtensionName* = "VK_QCOM_filter_cubic_clamp"
  # Extension: VK_EXT_attachment_feedback_loop_dynamic_state
  VkExtAttachmentFeedbackLoopDynamicStateSpecVersion* = 1
  VkExtAttachmentFeedbackLoopDynamicStateExtensionName* = "VK_EXT_attachment_feedback_loop_dynamic_state"
  # Extension: VK_KHR_vertex_attribute_divisor
  VkKhrVertexAttributeDivisorSpecVersion* = 1
  VkKhrVertexAttributeDivisorExtensionName* = "VK_KHR_vertex_attribute_divisor"
  # Extension: VK_KHR_load_store_op_none
  VkKhrLoadStoreOpNoneSpecVersion* = 1
  VkKhrLoadStoreOpNoneExtensionName* = "VK_KHR_load_store_op_none"
  # Extension: VK_KHR_unified_image_layouts
  VkKhrUnifiedImageLayoutsSpecVersion* = 1
  VkKhrUnifiedImageLayoutsExtensionName* = "VK_KHR_unified_image_layouts"
  # Extension: VK_KHR_shader_float_controls2
  VkKhrShaderFloatControls2SpecVersion* = 1
  VkKhrShaderFloatControls2ExtensionName* = "VK_KHR_shader_float_controls2"
  # Extension: VK_QNX_external_memory_screen_buffer
  VkQnxExternalMemoryScreenBufferSpecVersion* = 1
  VkQnxExternalMemoryScreenBufferExtensionName* = "VK_QNX_external_memory_screen_buffer"
  # Extension: VK_MSFT_layered_driver
  VkMsftLayeredDriverSpecVersion* = 1
  VkMsftLayeredDriverExtensionName* = "VK_MSFT_layered_driver"
  # Extension: VK_KHR_index_type_uint8
  VkKhrIndexTypeUint8SpecVersion* = 1
  VkKhrIndexTypeUint8ExtensionName* = "VK_KHR_index_type_uint8"
  # Extension: VK_KHR_line_rasterization
  VkKhrLineRasterizationSpecVersion* = 1
  VkKhrLineRasterizationExtensionName* = "VK_KHR_line_rasterization"
  # Extension: VK_KHR_calibrated_timestamps
  VkKhrCalibratedTimestampsSpecVersion* = 1
  VkKhrCalibratedTimestampsExtensionName* = "VK_KHR_calibrated_timestamps"
  # Extension: VK_KHR_shader_expect_assume
  VkKhrShaderExpectAssumeSpecVersion* = 1
  VkKhrShaderExpectAssumeExtensionName* = "VK_KHR_shader_expect_assume"
  # Extension: VK_KHR_maintenance6
  VkKhrMaintenance6SpecVersion* = 1
  VkKhrMaintenance6ExtensionName* = "VK_KHR_maintenance6"
  # Extension: VK_NV_descriptor_pool_overallocation
  VkNvDescriptorPoolOverallocationSpecVersion* = 1
  VkNvDescriptorPoolOverallocationExtensionName* = "VK_NV_descriptor_pool_overallocation"
  # Extension: VK_QCOM_tile_memory_heap
  VkQcomTileMemoryHeapSpecVersion* = 1
  VkQcomTileMemoryHeapExtensionName* = "VK_QCOM_tile_memory_heap"
  # Extension: VK_KHR_copy_memory_indirect
  VkKhrCopyMemoryIndirectSpecVersion* = 1
  VkKhrCopyMemoryIndirectExtensionName* = "VK_KHR_copy_memory_indirect"
  # Extension: VK_EXT_memory_decompression
  VkExtMemoryDecompressionSpecVersion* = 1
  VkExtMemoryDecompressionExtensionName* = "VK_EXT_memory_decompression"
  # Extension: VK_NV_display_stereo
  VkNvDisplayStereoSpecVersion* = 1
  VkNvDisplayStereoExtensionName* = "VK_NV_display_stereo"
  # Extension: VK_KHR_video_encode_intra_refresh
  VkKhrVideoEncodeIntraRefreshSpecVersion* = 1
  VkKhrVideoEncodeIntraRefreshExtensionName* = "VK_KHR_video_encode_intra_refresh"
  # Extension: VK_KHR_video_encode_quantization_map
  VkKhrVideoEncodeQuantizationMapSpecVersion* = 2
  VkKhrVideoEncodeQuantizationMapExtensionName* = "VK_KHR_video_encode_quantization_map"
  # Extension: VK_NV_raw_access_chains
  VkNvRawAccessChainsSpecVersion* = 1
  VkNvRawAccessChainsExtensionName* = "VK_NV_raw_access_chains"
  # Extension: VK_NV_external_compute_queue
  VkNvExternalComputeQueueSpecVersion* = 1
  VkNvExternalComputeQueueExtensionName* = "VK_NV_external_compute_queue"
  # Extension: VK_KHR_shader_relaxed_extended_instruction
  VkKhrShaderRelaxedExtendedInstructionSpecVersion* = 1
  VkKhrShaderRelaxedExtendedInstructionExtensionName* = "VK_KHR_shader_relaxed_extended_instruction"
  # Extension: VK_NV_command_buffer_inheritance
  VkNvCommandBufferInheritanceSpecVersion* = 1
  VkNvCommandBufferInheritanceExtensionName* = "VK_NV_command_buffer_inheritance"
  # Extension: VK_KHR_maintenance7
  VkKhrMaintenance7SpecVersion* = 1
  VkKhrMaintenance7ExtensionName* = "VK_KHR_maintenance7"
  # Extension: VK_NV_shader_atomic_float16_vector
  VkNvShaderAtomicFloat16VectorSpecVersion* = 1
  VkNvShaderAtomicFloat16VectorExtensionName* = "VK_NV_shader_atomic_float16_vector"
  # Extension: VK_EXT_shader_replicated_composites
  VkExtShaderReplicatedCompositesSpecVersion* = 1
  VkExtShaderReplicatedCompositesExtensionName* = "VK_EXT_shader_replicated_composites"
  # Extension: VK_EXT_shader_float8
  VkExtShaderFloat8SpecVersion* = 1
  VkExtShaderFloat8ExtensionName* = "VK_EXT_shader_float8"
  # Extension: VK_NV_ray_tracing_validation
  VkNvRayTracingValidationSpecVersion* = 1
  VkNvRayTracingValidationExtensionName* = "VK_NV_ray_tracing_validation"
  # Extension: VK_NV_cluster_acceleration_structure
  VkNvClusterAccelerationStructureSpecVersion* = 4
  VkNvClusterAccelerationStructureExtensionName* = "VK_NV_cluster_acceleration_structure"
  # Extension: VK_NV_partitioned_acceleration_structure
  VkNvPartitionedAccelerationStructureSpecVersion* = 1
  VkNvPartitionedAccelerationStructureExtensionName* = "VK_NV_partitioned_acceleration_structure"
  # Extension: VK_EXT_device_generated_commands
  VkExtDeviceGeneratedCommandsSpecVersion* = 1
  VkExtDeviceGeneratedCommandsExtensionName* = "VK_EXT_device_generated_commands"
  # Extension: VK_KHR_maintenance8
  VkKhrMaintenance8SpecVersion* = 1
  VkKhrMaintenance8ExtensionName* = "VK_KHR_maintenance8"
  # Extension: VK_MESA_image_alignment_control
  VkMesaImageAlignmentControlSpecVersion* = 1
  VkMesaImageAlignmentControlExtensionName* = "VK_MESA_image_alignment_control"
  # Extension: VK_KHR_shader_fma
  VkKhrShaderFmaSpecVersion* = 1
  VkKhrShaderFmaExtensionName* = "VK_KHR_shader_fma"
  # Extension: VK_NV_push_constant_bank
  VkNvPushConstantBankSpecVersion* = 1
  VkNvPushConstantBankExtensionName* = "VK_NV_push_constant_bank"
  # Extension: VK_EXT_ray_tracing_invocation_reorder
  VkExtRayTracingInvocationReorderSpecVersion* = 1
  VkExtRayTracingInvocationReorderExtensionName* = "VK_EXT_ray_tracing_invocation_reorder"
  # Extension: VK_EXT_depth_clamp_control
  VkExtDepthClampControlSpecVersion* = 1
  VkExtDepthClampControlExtensionName* = "VK_EXT_depth_clamp_control"
  # Extension: VK_KHR_maintenance9
  VkKhrMaintenance9SpecVersion* = 1
  VkKhrMaintenance9ExtensionName* = "VK_KHR_maintenance9"
  # Extension: VK_KHR_video_maintenance2
  VkKhrVideoMaintenance2SpecVersion* = 1
  VkKhrVideoMaintenance2ExtensionName* = "VK_KHR_video_maintenance2"
  # Extension: VK_OHOS_surface
  VkOhosSurfaceSpecVersion* = 1
  VkOhosSurfaceExtensionName* = "VK_OHOS_surface"
  # Extension: VK_HUAWEI_hdr_vivid
  VkHuaweiHdrVividSpecVersion* = 1
  VkHuaweiHdrVividExtensionName* = "VK_HUAWEI_hdr_vivid"
  # Extension: VK_NV_cooperative_matrix2
  VkNvCooperativeMatrix2SpecVersion* = 1
  VkNvCooperativeMatrix2ExtensionName* = "VK_NV_cooperative_matrix2"
  # Extension: VK_ARM_pipeline_opacity_micromap
  VkArmPipelineOpacityMicromapSpecVersion* = 1
  VkArmPipelineOpacityMicromapExtensionName* = "VK_ARM_pipeline_opacity_micromap"
  # Extension: VK_EXT_external_memory_metal
  VkExtExternalMemoryMetalSpecVersion* = 1
  VkExtExternalMemoryMetalExtensionName* = "VK_EXT_external_memory_metal"
  # Extension: VK_KHR_depth_clamp_zero_one
  VkKhrDepthClampZeroOneSpecVersion* = 1
  VkKhrDepthClampZeroOneExtensionName* = "VK_KHR_depth_clamp_zero_one"
  # Extension: VK_ARM_performance_counters_by_region
  VkArmPerformanceCountersByRegionSpecVersion* = 1
  VkArmPerformanceCountersByRegionExtensionName* = "VK_ARM_performance_counters_by_region"
  # Extension: VK_EXT_vertex_attribute_robustness
  VkExtVertexAttributeRobustnessSpecVersion* = 1
  VkExtVertexAttributeRobustnessExtensionName* = "VK_EXT_vertex_attribute_robustness"
  # Extension: VK_ARM_format_pack
  VkArmFormatPackSpecVersion* = 1
  VkArmFormatPackExtensionName* = "VK_ARM_format_pack"
  # Extension: VK_VALVE_fragment_density_map_layered
  VkValveFragmentDensityMapLayeredSpecVersion* = 1
  VkValveFragmentDensityMapLayeredExtensionName* = "VK_VALVE_fragment_density_map_layered"
  # Extension: VK_KHR_robustness2
  VkKhrRobustness2SpecVersion* = 1
  VkKhrRobustness2ExtensionName* = "VK_KHR_robustness2"
  # Extension: VK_NV_present_metering
  VkNvPresentMeteringSpecVersion* = 1
  VkNvPresentMeteringExtensionName* = "VK_NV_present_metering"
  # Extension: VK_EXT_fragment_density_map_offset
  VkExtFragmentDensityMapOffsetSpecVersion* = 1
  VkExtFragmentDensityMapOffsetExtensionName* = "VK_EXT_fragment_density_map_offset"
  # Extension: VK_EXT_zero_initialize_device_memory
  VkExtZeroInitializeDeviceMemorySpecVersion* = 1
  VkExtZeroInitializeDeviceMemoryExtensionName* = "VK_EXT_zero_initialize_device_memory"
  # Extension: VK_KHR_present_mode_fifo_latest_ready
  VkKhrPresentModeFifoLatestReadySpecVersion* = 1
  VkKhrPresentModeFifoLatestReadyExtensionName* = "VK_KHR_present_mode_fifo_latest_ready"
  # Extension: VK_EXT_shader_64bit_indexing
  VkExtShader64bitIndexingSpecVersion* = 1
  VkExtShader64bitIndexingExtensionName* = "VK_EXT_shader_64bit_indexing"
  # Extension: VK_EXT_custom_resolve
  VkExtCustomResolveSpecVersion* = 1
  VkExtCustomResolveExtensionName* = "VK_EXT_custom_resolve"
  # Extension: VK_QCOM_data_graph_model
  VkQcomDataGraphModelSpecVersion* = 1
  VkQcomDataGraphModelExtensionName* = "VK_QCOM_data_graph_model"
  # Extension: VK_KHR_maintenance10
  VkKhrMaintenance10SpecVersion* = 1
  VkKhrMaintenance10ExtensionName* = "VK_KHR_maintenance10"
  # Extension: VK_EXT_shader_long_vector
  VkExtShaderLongVectorSpecVersion* = 1
  VkExtShaderLongVectorExtensionName* = "VK_EXT_shader_long_vector"
  # Extension: VK_SEC_pipeline_cache_incremental_mode
  VkSecPipelineCacheIncrementalModeSpecVersion* = 1
  VkSecPipelineCacheIncrementalModeExtensionName* = "VK_SEC_pipeline_cache_incremental_mode"
  # Extension: VK_EXT_shader_uniform_buffer_unsized_array
  VkExtShaderUniformBufferUnsizedArraySpecVersion* = 1
  VkExtShaderUniformBufferUnsizedArrayExtensionName* = "VK_EXT_shader_uniform_buffer_unsized_array"
  # Extension: VK_NV_compute_occupancy_priority
  VkNvComputeOccupancyPrioritySpecVersion* = 1
  VkNvComputeOccupancyPriorityExtensionName* = "VK_NV_compute_occupancy_priority"
  # Extension: VK_EXT_shader_subgroup_partitioned
  VkExtShaderSubgroupPartitionedSpecVersion* = 1
  VkExtShaderSubgroupPartitionedExtensionName* = "VK_EXT_shader_subgroup_partitioned"
  # Extension: VK_SEC_ubm_surface
  VkSecUbmSurfaceSpecVersion* = 1
  VkSecUbmSurfaceExtensionName* = "VK_SEC_ubm_surface"
  # Extension: VK_VALVE_shader_mixed_float_dot_product
  VkValveShaderMixedFloatDotProductSpecVersion* = 1
  VkValveShaderMixedFloatDotProductExtensionName* = "VK_VALVE_shader_mixed_float_dot_product"

type
  VkImageLayout* {.size: sizeof(int32).} = enum
    Undefined
    General
    ColorAttachmentOptimal
    DepthStencilAttachmentOptimal
    DepthStencilReadOnlyOptimal
    ShaderReadOnlyOptimal
    TransferSrcOptimal
    TransferDstOptimal
    Preinitialized
    PresentSrcKhr = 1000001002
    VideoDecodeDstKhr = 1000024000
    VideoDecodeSrcKhr
    VideoDecodeDpbKhr
    SharedPresentKhr = 1000111000
    DepthReadOnlyStencilAttachmentOptimal = 1000117000
    DepthAttachmentStencilReadOnlyOptimal
    FragmentShadingRateAttachmentOptimalKhr = 1000164003
    FragmentDensityMapOptimalExt = 1000218000
    RenderingLocalRead = 1000232000
    DepthAttachmentOptimal = 1000241000
    DepthReadOnlyOptimal
    StencilAttachmentOptimal
    StencilReadOnlyOptimal
    VideoEncodeDstKhr = 1000299000
    VideoEncodeSrcKhr
    VideoEncodeDpbKhr
    ReadOnlyOptimal = 1000314000
    AttachmentOptimal
    AttachmentFeedbackLoopOptimalExt = 1000339000
    TensorAliasingArm = 1000460000
    VideoEncodeQuantizationMapKhr = 1000553000
    ZeroInitializedExt = 1000620000

  VkAttachmentLoadOp* {.size: sizeof(int32).} = enum
    Load
    Clear
    DontCare
    None = 1000400000

  VkAttachmentStoreOp* {.size: sizeof(int32).} = enum
    Store
    DontCare
    None = 1000301000

  VkImageType* {.size: sizeof(int32).} = enum
    N1d
    N2d
    N3d

  VkImageTiling* {.size: sizeof(int32).} = enum
    Optimal
    Linear
    DrmFormatModifierExt = 1000158000

  VkImageViewType* {.size: sizeof(int32).} = enum
    N1d
    N2d
    N3d
    Cube
    N1dArray
    N2dArray
    CubeArray

  VkCommandBufferLevel* {.size: sizeof(int32).} = enum
    Primary
    Secondary

  VkComponentSwizzle* {.size: sizeof(int32).} = enum
    Identity
    Zero
    One
    R
    G
    B
    A

  VkDescriptorType* {.size: sizeof(int32).} = enum
    Sampler
    CombinedImageSampler
    SampledImage
    StorageImage
    UniformTexelBuffer
    StorageTexelBuffer
    UniformBuffer
    StorageBuffer
    UniformBufferDynamic
    StorageBufferDynamic
    InputAttachment
    InlineUniformBlock = 1000138000
    AccelerationStructureKhr = 1000150000
    AccelerationStructureNv = 1000165000
    MutableExt = 1000351000
    SampleWeightImageQcom = 1000440000
    BlockMatchImageQcom
    TensorArm = 1000460000
    PartitionedAccelerationStructureNv = 1000570000

  VkQueryType* {.size: sizeof(int32).} = enum
    Occlusion
    PipelineStatistics
    Timestamp
    ResultStatusOnlyKhr = 1000023000
    TransformFeedbackStreamExt = 1000028004
    PerformanceQueryKhr = 1000116000
    AccelerationStructureCompactedSizeKhr = 1000150000
    AccelerationStructureSerializationSizeKhr
    AccelerationStructureCompactedSizeNv = 1000165000
    PerformanceQueryIntel = 1000210000
    VideoEncodeFeedbackKhr = 1000299000
    MeshPrimitivesGeneratedExt = 1000328000
    PrimitivesGeneratedExt = 1000382000
    AccelerationStructureSerializationBottomLevelPointersKhr = 1000386000
    AccelerationStructureSizeKhr
    MicromapSerializationSizeExt = 1000396000
    MicromapCompactedSizeExt

  VkBorderColor* {.size: sizeof(int32).} = enum
    FloatTransparentBlack
    IntTransparentBlack
    FloatOpaqueBlack
    IntOpaqueBlack
    FloatOpaqueWhite
    IntOpaqueWhite
    FloatCustomExt = 1000287003
    IntCustomExt

  VkPipelineBindPoint* {.size: sizeof(int32).} = enum
    Graphics
    Compute
    ExecutionGraphAmdx = 1000134000
    RayTracingKhr = 1000165000
    SubpassShadingHuawei = 1000369003
    DataGraphArm = 1000507000

  VkPipelineCacheHeaderVersion* {.size: sizeof(int32).} = enum
    One = 1
    SafetyCriticalOne = 1000298001
    DataGraphQcom = 1000629000

  VkPipelineCacheCreateFlagBits* {.size: sizeof(int32).} = enum
    ExternallySynchronizedBit = 1
    ReadOnlyBit
    UseApplicationStorageBit = 4
    InternallySynchronizedMergeBitKhr = 8

  VkPrimitiveTopology* {.size: sizeof(int32).} = enum
    PointList
    LineList
    LineStrip
    TriangleList
    TriangleStrip
    TriangleFan
    LineListWithAdjacency
    LineStripWithAdjacency
    TriangleListWithAdjacency
    TriangleStripWithAdjacency
    PatchList

  VkSharingMode* {.size: sizeof(int32).} = enum
    Exclusive
    Concurrent

  VkIndexType* {.size: sizeof(int32).} = enum
    Uint16
    Uint32
    NoneKhr = 1000165000
    Uint8 = 1000265000

  VkFilter* {.size: sizeof(int32).} = enum
    Nearest
    Linear
    CubicExt = 1000015000

  VkSamplerMipmapMode* {.size: sizeof(int32).} = enum
    Nearest
    Linear

  VkSamplerAddressMode* {.size: sizeof(int32).} = enum
    Repeat
    MirroredRepeat
    ClampToEdge
    ClampToBorder
    MirrorClampToEdge

  VkCompareOp* {.size: sizeof(int32).} = enum
    Never
    Less
    Equal
    LessOrEqual
    Greater
    NotEqual
    GreaterOrEqual
    Always

  VkPolygonMode* {.size: sizeof(int32).} = enum
    Fill
    Line
    Point
    FillRectangleNv = 1000153000

  VkFrontFace* {.size: sizeof(int32).} = enum
    CounterClockwise
    Clockwise

  VkBlendFactor* {.size: sizeof(int32).} = enum
    Zero
    One
    SrcColor
    OneMinusSrcColor
    DstColor
    OneMinusDstColor
    SrcAlpha
    OneMinusSrcAlpha
    DstAlpha
    OneMinusDstAlpha
    ConstantColor
    OneMinusConstantColor
    ConstantAlpha
    OneMinusConstantAlpha
    SrcAlphaSaturate
    Src1Color
    OneMinusSrc1Color
    Src1Alpha
    OneMinusSrc1Alpha

  VkBlendOp* {.size: sizeof(int32).} = enum
    Add
    Subtract
    ReverseSubtract
    Min
    Max
    ZeroExt = 1000148000
    SrcExt
    DstExt
    SrcOverExt
    DstOverExt
    SrcInExt
    DstInExt
    SrcOutExt
    DstOutExt
    SrcAtopExt
    DstAtopExt
    XorExt
    MultiplyExt
    ScreenExt
    OverlayExt
    DarkenExt
    LightenExt
    ColordodgeExt
    ColorburnExt
    HardlightExt
    SoftlightExt
    DifferenceExt
    ExclusionExt
    InvertExt
    InvertRgbExt
    LineardodgeExt
    LinearburnExt
    VividlightExt
    LinearlightExt
    PinlightExt
    HardmixExt
    HslHueExt
    HslSaturationExt
    HslColorExt
    HslLuminosityExt
    PlusExt
    PlusClampedExt
    PlusClampedAlphaExt
    PlusDarkerExt
    MinusExt
    MinusClampedExt
    ContrastExt
    InvertOvgExt
    RedExt
    GreenExt
    BlueExt

  VkStencilOp* {.size: sizeof(int32).} = enum
    Keep
    Zero
    Replace
    IncrementAndClamp
    DecrementAndClamp
    Invert
    IncrementAndWrap
    DecrementAndWrap

  VkLogicOp* {.size: sizeof(int32).} = enum
    Clear
    And
    AndReverse
    Copy
    AndInverted
    NoOp
    Xor
    Or
    Nor
    Equivalent
    Invert
    OrReverse
    CopyInverted
    OrInverted
    Nand
    Set

  VkInternalAllocationType* {.size: sizeof(int32).} = enum
    Executable

  VkSystemAllocationScope* {.size: sizeof(int32).} = enum
    Command
    Object
    Cache
    Device
    Instance

  VkPhysicalDeviceType* {.size: sizeof(int32).} = enum
    Other
    IntegratedGpu
    DiscreteGpu
    VirtualGpu
    Cpu

  VkVertexInputRate* {.size: sizeof(int32).} = enum
    Vertex
    Instance

  VkFormat* {.size: sizeof(int32).} = enum
    Undefined
    R4g4UnormPack8
    R4g4b4a4UnormPack16
    B4g4r4a4UnormPack16
    R5g6b5UnormPack16
    B5g6r5UnormPack16
    R5g5b5a1UnormPack16
    B5g5r5a1UnormPack16
    A1r5g5b5UnormPack16
    R8Unorm
    R8Snorm
    R8Uscaled
    R8Sscaled
    R8Uint
    R8Sint
    R8Srgb
    R8g8Unorm
    R8g8Snorm
    R8g8Uscaled
    R8g8Sscaled
    R8g8Uint
    R8g8Sint
    R8g8Srgb
    R8g8b8Unorm
    R8g8b8Snorm
    R8g8b8Uscaled
    R8g8b8Sscaled
    R8g8b8Uint
    R8g8b8Sint
    R8g8b8Srgb
    B8g8r8Unorm
    B8g8r8Snorm
    B8g8r8Uscaled
    B8g8r8Sscaled
    B8g8r8Uint
    B8g8r8Sint
    B8g8r8Srgb
    R8g8b8a8Unorm
    R8g8b8a8Snorm
    R8g8b8a8Uscaled
    R8g8b8a8Sscaled
    R8g8b8a8Uint
    R8g8b8a8Sint
    R8g8b8a8Srgb
    B8g8r8a8Unorm
    B8g8r8a8Snorm
    B8g8r8a8Uscaled
    B8g8r8a8Sscaled
    B8g8r8a8Uint
    B8g8r8a8Sint
    B8g8r8a8Srgb
    A8b8g8r8UnormPack32
    A8b8g8r8SnormPack32
    A8b8g8r8UscaledPack32
    A8b8g8r8SscaledPack32
    A8b8g8r8UintPack32
    A8b8g8r8SintPack32
    A8b8g8r8SrgbPack32
    A2r10g10b10UnormPack32
    A2r10g10b10SnormPack32
    A2r10g10b10UscaledPack32
    A2r10g10b10SscaledPack32
    A2r10g10b10UintPack32
    A2r10g10b10SintPack32
    A2b10g10r10UnormPack32
    A2b10g10r10SnormPack32
    A2b10g10r10UscaledPack32
    A2b10g10r10SscaledPack32
    A2b10g10r10UintPack32
    A2b10g10r10SintPack32
    R16Unorm
    R16Snorm
    R16Uscaled
    R16Sscaled
    R16Uint
    R16Sint
    R16Sfloat
    R16g16Unorm
    R16g16Snorm
    R16g16Uscaled
    R16g16Sscaled
    R16g16Uint
    R16g16Sint
    R16g16Sfloat
    R16g16b16Unorm
    R16g16b16Snorm
    R16g16b16Uscaled
    R16g16b16Sscaled
    R16g16b16Uint
    R16g16b16Sint
    R16g16b16Sfloat
    R16g16b16a16Unorm
    R16g16b16a16Snorm
    R16g16b16a16Uscaled
    R16g16b16a16Sscaled
    R16g16b16a16Uint
    R16g16b16a16Sint
    R16g16b16a16Sfloat
    R32Uint
    R32Sint
    R32Sfloat
    R32g32Uint
    R32g32Sint
    R32g32Sfloat
    R32g32b32Uint
    R32g32b32Sint
    R32g32b32Sfloat
    R32g32b32a32Uint
    R32g32b32a32Sint
    R32g32b32a32Sfloat
    R64Uint
    R64Sint
    R64Sfloat
    R64g64Uint
    R64g64Sint
    R64g64Sfloat
    R64g64b64Uint
    R64g64b64Sint
    R64g64b64Sfloat
    R64g64b64a64Uint
    R64g64b64a64Sint
    R64g64b64a64Sfloat
    B10g11r11UfloatPack32
    E5b9g9r9UfloatPack32
    D16Unorm
    X8D24UnormPack32
    D32Sfloat
    S8Uint
    D16UnormS8Uint
    D24UnormS8Uint
    D32SfloatS8Uint
    Bc1RgbUnormBlock
    Bc1RgbSrgbBlock
    Bc1RgbaUnormBlock
    Bc1RgbaSrgbBlock
    Bc2UnormBlock
    Bc2SrgbBlock
    Bc3UnormBlock
    Bc3SrgbBlock
    Bc4UnormBlock
    Bc4SnormBlock
    Bc5UnormBlock
    Bc5SnormBlock
    Bc6hUfloatBlock
    Bc6hSfloatBlock
    Bc7UnormBlock
    Bc7SrgbBlock
    Etc2R8g8b8UnormBlock
    Etc2R8g8b8SrgbBlock
    Etc2R8g8b8a1UnormBlock
    Etc2R8g8b8a1SrgbBlock
    Etc2R8g8b8a8UnormBlock
    Etc2R8g8b8a8SrgbBlock
    EacR11UnormBlock
    EacR11SnormBlock
    EacR11g11UnormBlock
    EacR11g11SnormBlock
    Astc4x4UnormBlock
    Astc4x4SrgbBlock
    Astc5x4UnormBlock
    Astc5x4SrgbBlock
    Astc5x5UnormBlock
    Astc5x5SrgbBlock
    Astc6x5UnormBlock
    Astc6x5SrgbBlock
    Astc6x6UnormBlock
    Astc6x6SrgbBlock
    Astc8x5UnormBlock
    Astc8x5SrgbBlock
    Astc8x6UnormBlock
    Astc8x6SrgbBlock
    Astc8x8UnormBlock
    Astc8x8SrgbBlock
    Astc10x5UnormBlock
    Astc10x5SrgbBlock
    Astc10x6UnormBlock
    Astc10x6SrgbBlock
    Astc10x8UnormBlock
    Astc10x8SrgbBlock
    Astc10x10UnormBlock
    Astc10x10SrgbBlock
    Astc12x10UnormBlock
    Astc12x10SrgbBlock
    Astc12x12UnormBlock
    Astc12x12SrgbBlock
    Pvrtc12bppUnormBlockImg = 1000054000
    Pvrtc14bppUnormBlockImg
    Pvrtc22bppUnormBlockImg
    Pvrtc24bppUnormBlockImg
    Pvrtc12bppSrgbBlockImg
    Pvrtc14bppSrgbBlockImg
    Pvrtc22bppSrgbBlockImg
    Pvrtc24bppSrgbBlockImg
    Astc4x4SfloatBlock = 1000066000
    Astc5x4SfloatBlock
    Astc5x5SfloatBlock
    Astc6x5SfloatBlock
    Astc6x6SfloatBlock
    Astc8x5SfloatBlock
    Astc8x6SfloatBlock
    Astc8x8SfloatBlock
    Astc10x5SfloatBlock
    Astc10x6SfloatBlock
    Astc10x8SfloatBlock
    Astc10x10SfloatBlock
    Astc12x10SfloatBlock
    Astc12x12SfloatBlock
    G8b8g8r8422Unorm = 1000156000
    B8g8r8g8422Unorm
    G8B8R83plane420Unorm
    G8B8r82plane420Unorm
    G8B8R83plane422Unorm
    G8B8r82plane422Unorm
    G8B8R83plane444Unorm
    R10x6UnormPack16
    R10x6g10x6Unorm2pack16
    R10x6g10x6b10x6a10x6Unorm4pack16
    G10x6b10x6g10x6r10x6422Unorm4pack16
    B10x6g10x6r10x6g10x6422Unorm4pack16
    G10x6B10x6R10x63plane420Unorm3pack16
    G10x6B10x6r10x62plane420Unorm3pack16
    G10x6B10x6R10x63plane422Unorm3pack16
    G10x6B10x6r10x62plane422Unorm3pack16
    G10x6B10x6R10x63plane444Unorm3pack16
    R12x4UnormPack16
    R12x4g12x4Unorm2pack16
    R12x4g12x4b12x4a12x4Unorm4pack16
    G12x4b12x4g12x4r12x4422Unorm4pack16
    B12x4g12x4r12x4g12x4422Unorm4pack16
    G12x4B12x4R12x43plane420Unorm3pack16
    G12x4B12x4r12x42plane420Unorm3pack16
    G12x4B12x4R12x43plane422Unorm3pack16
    G12x4B12x4r12x42plane422Unorm3pack16
    G12x4B12x4R12x43plane444Unorm3pack16
    G16b16g16r16422Unorm
    B16g16r16g16422Unorm
    G16B16R163plane420Unorm
    G16B16r162plane420Unorm
    G16B16R163plane422Unorm
    G16B16r162plane422Unorm
    G16B16R163plane444Unorm
    Astc3x3x3UnormBlockExt = 1000288000
    Astc3x3x3SrgbBlockExt
    Astc3x3x3SfloatBlockExt
    Astc4x3x3UnormBlockExt
    Astc4x3x3SrgbBlockExt
    Astc4x3x3SfloatBlockExt
    Astc4x4x3UnormBlockExt
    Astc4x4x3SrgbBlockExt
    Astc4x4x3SfloatBlockExt
    Astc4x4x4UnormBlockExt
    Astc4x4x4SrgbBlockExt
    Astc4x4x4SfloatBlockExt
    Astc5x4x4UnormBlockExt
    Astc5x4x4SrgbBlockExt
    Astc5x4x4SfloatBlockExt
    Astc5x5x4UnormBlockExt
    Astc5x5x4SrgbBlockExt
    Astc5x5x4SfloatBlockExt
    Astc5x5x5UnormBlockExt
    Astc5x5x5SrgbBlockExt
    Astc5x5x5SfloatBlockExt
    Astc6x5x5UnormBlockExt
    Astc6x5x5SrgbBlockExt
    Astc6x5x5SfloatBlockExt
    Astc6x6x5UnormBlockExt
    Astc6x6x5SrgbBlockExt
    Astc6x6x5SfloatBlockExt
    Astc6x6x6UnormBlockExt
    Astc6x6x6SrgbBlockExt
    Astc6x6x6SfloatBlockExt
    G8B8r82plane444Unorm = 1000330000
    G10x6B10x6r10x62plane444Unorm3pack16
    G12x4B12x4r12x42plane444Unorm3pack16
    G16B16r162plane444Unorm
    A4r4g4b4UnormPack16 = 1000340000
    A4b4g4r4UnormPack16
    R8BoolArm = 1000460000
    R16SfloatFpencodingBfloat16Arm
    R8SfloatFpencodingFloat8e4m3Arm
    R8SfloatFpencodingFloat8e5m2Arm
    R16g16Sfixed5Nv = 1000464000
    A1b5g5r5UnormPack16 = 1000470000
    A8Unorm
    R10x6UintPack16Arm = 1000609000
    R10x6g10x6Uint2pack16Arm
    R10x6g10x6b10x6a10x6Uint4pack16Arm
    R12x4UintPack16Arm
    R12x4g12x4Uint2pack16Arm
    R12x4g12x4b12x4a12x4Uint4pack16Arm
    R14x2UintPack16Arm
    R14x2g14x2Uint2pack16Arm
    R14x2g14x2b14x2a14x2Uint4pack16Arm
    R14x2UnormPack16Arm
    R14x2g14x2Unorm2pack16Arm
    R14x2g14x2b14x2a14x2Unorm4pack16Arm
    G14x2B14x2r14x22plane420Unorm3pack16Arm
    G14x2B14x2r14x22plane422Unorm3pack16Arm

  VkStructureType* {.size: sizeof(int32).} = enum
    ApplicationInfo
    InstanceCreateInfo
    DeviceQueueCreateInfo
    DeviceCreateInfo
    SubmitInfo
    MemoryAllocateInfo
    MappedMemoryRange
    BindSparseInfo
    FenceCreateInfo
    SemaphoreCreateInfo
    EventCreateInfo
    QueryPoolCreateInfo
    BufferCreateInfo
    BufferViewCreateInfo
    ImageCreateInfo
    ImageViewCreateInfo
    ShaderModuleCreateInfo
    PipelineCacheCreateInfo
    PipelineShaderStageCreateInfo
    PipelineVertexInputStateCreateInfo
    PipelineInputAssemblyStateCreateInfo
    PipelineTessellationStateCreateInfo
    PipelineViewportStateCreateInfo
    PipelineRasterizationStateCreateInfo
    PipelineMultisampleStateCreateInfo
    PipelineDepthStencilStateCreateInfo
    PipelineColorBlendStateCreateInfo
    PipelineDynamicStateCreateInfo
    GraphicsPipelineCreateInfo
    ComputePipelineCreateInfo
    PipelineLayoutCreateInfo
    SamplerCreateInfo
    DescriptorSetLayoutCreateInfo
    DescriptorPoolCreateInfo
    DescriptorSetAllocateInfo
    WriteDescriptorSet
    CopyDescriptorSet
    FramebufferCreateInfo
    RenderPassCreateInfo
    CommandPoolCreateInfo
    CommandBufferAllocateInfo
    CommandBufferInheritanceInfo
    CommandBufferBeginInfo
    RenderPassBeginInfo
    BufferMemoryBarrier
    ImageMemoryBarrier
    MemoryBarrier
    LoaderInstanceCreateInfo
    LoaderDeviceCreateInfo
    PhysicalDeviceVulkan11Features
    PhysicalDeviceVulkan11Properties
    PhysicalDeviceVulkan12Features
    PhysicalDeviceVulkan12Properties
    PhysicalDeviceVulkan13Features
    PhysicalDeviceVulkan13Properties
    PhysicalDeviceVulkan14Features
    PhysicalDeviceVulkan14Properties
    SwapchainCreateInfoKhr = 1000001000
    PresentInfoKhr
    DisplayModeCreateInfoKhr = 1000002000
    DisplaySurfaceCreateInfoKhr
    DisplayPresentInfoKhr = 1000003000
    XlibSurfaceCreateInfoKhr = 1000004000
    XcbSurfaceCreateInfoKhr = 1000005000
    WaylandSurfaceCreateInfoKhr = 1000006000
    AndroidSurfaceCreateInfoKhr = 1000008000
    Win32SurfaceCreateInfoKhr = 1000009000
    DebugReportCallbackCreateInfoExt = 1000011000
    PipelineRasterizationStateRasterizationOrderAmd = 1000018000
    DebugMarkerObjectNameInfoExt = 1000022000
    DebugMarkerObjectTagInfoExt
    DebugMarkerMarkerInfoExt
    VideoProfileInfoKhr = 1000023000
    VideoCapabilitiesKhr
    VideoPictureResourceInfoKhr
    VideoSessionMemoryRequirementsKhr
    BindVideoSessionMemoryInfoKhr
    VideoSessionCreateInfoKhr
    VideoSessionParametersCreateInfoKhr
    VideoSessionParametersUpdateInfoKhr
    VideoBeginCodingInfoKhr
    VideoEndCodingInfoKhr
    VideoCodingControlInfoKhr
    VideoReferenceSlotInfoKhr
    QueueFamilyVideoPropertiesKhr
    VideoProfileListInfoKhr
    PhysicalDeviceVideoFormatInfoKhr
    VideoFormatPropertiesKhr
    QueueFamilyQueryResultStatusPropertiesKhr
    VideoDecodeInfoKhr = 1000024000
    VideoDecodeCapabilitiesKhr
    VideoDecodeUsageInfoKhr
    DedicatedAllocationImageCreateInfoNv = 1000026000
    DedicatedAllocationBufferCreateInfoNv
    DedicatedAllocationMemoryAllocateInfoNv
    PhysicalDeviceTransformFeedbackFeaturesExt = 1000028000
    PhysicalDeviceTransformFeedbackPropertiesExt
    PipelineRasterizationStateStreamCreateInfoExt
    CuModuleCreateInfoNvx = 1000029000
    CuFunctionCreateInfoNvx
    CuLaunchInfoNvx
    CuModuleTexturingModeCreateInfoNvx = 1000029004
    ImageViewHandleInfoNvx = 1000030000
    ImageViewAddressPropertiesNvx
    VideoEncodeH264CapabilitiesKhr = 1000038000
    VideoEncodeH264SessionParametersCreateInfoKhr
    VideoEncodeH264SessionParametersAddInfoKhr
    VideoEncodeH264PictureInfoKhr
    VideoEncodeH264DpbSlotInfoKhr
    VideoEncodeH264NaluSliceInfoKhr
    VideoEncodeH264GopRemainingFrameInfoKhr
    VideoEncodeH264ProfileInfoKhr
    VideoEncodeH264RateControlInfoKhr
    VideoEncodeH264RateControlLayerInfoKhr
    VideoEncodeH264SessionCreateInfoKhr
    VideoEncodeH264QualityLevelPropertiesKhr
    VideoEncodeH264SessionParametersGetInfoKhr
    VideoEncodeH264SessionParametersFeedbackInfoKhr
    VideoEncodeH265CapabilitiesKhr = 1000039000
    VideoEncodeH265SessionParametersCreateInfoKhr
    VideoEncodeH265SessionParametersAddInfoKhr
    VideoEncodeH265PictureInfoKhr
    VideoEncodeH265DpbSlotInfoKhr
    VideoEncodeH265NaluSliceSegmentInfoKhr
    VideoEncodeH265GopRemainingFrameInfoKhr
    VideoEncodeH265ProfileInfoKhr
    VideoEncodeH265RateControlInfoKhr = 1000039009
    VideoEncodeH265RateControlLayerInfoKhr
    VideoEncodeH265SessionCreateInfoKhr
    VideoEncodeH265QualityLevelPropertiesKhr
    VideoEncodeH265SessionParametersGetInfoKhr
    VideoEncodeH265SessionParametersFeedbackInfoKhr
    VideoDecodeH264CapabilitiesKhr = 1000040000
    VideoDecodeH264PictureInfoKhr
    VideoDecodeH264ProfileInfoKhr = 1000040003
    VideoDecodeH264SessionParametersCreateInfoKhr
    VideoDecodeH264SessionParametersAddInfoKhr
    VideoDecodeH264DpbSlotInfoKhr
    TextureLodGatherFormatPropertiesAmd = 1000041000
    RenderingInfo = 1000044000
    RenderingAttachmentInfo
    PipelineRenderingCreateInfo
    PhysicalDeviceDynamicRenderingFeatures
    CommandBufferInheritanceRenderingInfo
    RenderingFragmentShadingRateAttachmentInfoKhr = 1000044006
    RenderingFragmentDensityMapAttachmentInfoExt
    AttachmentSampleCountInfoAmd
    MultiviewPerViewAttributesInfoNvx
    StreamDescriptorSurfaceCreateInfoGgp = 1000049000
    PhysicalDeviceCornerSampledImageFeaturesNv = 1000050000
    PrivateVendorInfoPlaceholderOffset0Nv = 1000051000
    RenderPassMultiviewCreateInfo = 1000053000
    PhysicalDeviceMultiviewFeatures
    PhysicalDeviceMultiviewProperties
    ExternalMemoryImageCreateInfoNv = 1000056000
    ExportMemoryAllocateInfoNv
    ImportMemoryWin32HandleInfoNv = 1000057000
    ExportMemoryWin32HandleInfoNv
    Win32KeyedMutexAcquireReleaseInfoNv = 1000058000
    PhysicalDeviceFeatures2 = 1000059000
    PhysicalDeviceProperties2
    FormatProperties2
    ImageFormatProperties2
    PhysicalDeviceImageFormatInfo2
    QueueFamilyProperties2
    PhysicalDeviceMemoryProperties2
    SparseImageFormatProperties2
    PhysicalDeviceSparseImageFormatInfo2
    MemoryAllocateFlagsInfo = 1000060000
    DeviceGroupRenderPassBeginInfo = 1000060003
    DeviceGroupCommandBufferBeginInfo
    DeviceGroupSubmitInfo
    DeviceGroupBindSparseInfo
    DeviceGroupPresentCapabilitiesKhr
    ImageSwapchainCreateInfoKhr
    BindImageMemorySwapchainInfoKhr
    AcquireNextImageInfoKhr
    DeviceGroupPresentInfoKhr
    DeviceGroupSwapchainCreateInfoKhr
    BindBufferMemoryDeviceGroupInfo
    BindImageMemoryDeviceGroupInfo
    ValidationFlagsExt = 1000061000
    ViSurfaceCreateInfoNn = 1000062000
    PhysicalDeviceShaderDrawParametersFeatures = 1000063000
    PhysicalDeviceTextureCompressionAstcHdrFeatures = 1000066000
    ImageViewAstcDecodeModeExt = 1000067000
    PhysicalDeviceAstcDecodeFeaturesExt
    PipelineRobustnessCreateInfo = 1000068000
    PhysicalDevicePipelineRobustnessFeatures
    PhysicalDevicePipelineRobustnessProperties
    PhysicalDeviceGroupProperties = 1000070000
    DeviceGroupDeviceCreateInfo
    PhysicalDeviceExternalImageFormatInfo = 1000071000
    ExternalImageFormatProperties
    PhysicalDeviceExternalBufferInfo
    ExternalBufferProperties
    PhysicalDeviceIdProperties
    ExternalMemoryBufferCreateInfo = 1000072000
    ExternalMemoryImageCreateInfo
    ExportMemoryAllocateInfo
    ImportMemoryWin32HandleInfoKhr = 1000073000
    ExportMemoryWin32HandleInfoKhr
    MemoryWin32HandlePropertiesKhr
    MemoryGetWin32HandleInfoKhr
    ImportMemoryFdInfoKhr = 1000074000
    MemoryFdPropertiesKhr
    MemoryGetFdInfoKhr
    Win32KeyedMutexAcquireReleaseInfoKhr = 1000075000
    PhysicalDeviceExternalSemaphoreInfo = 1000076000
    ExternalSemaphoreProperties
    ExportSemaphoreCreateInfo = 1000077000
    ImportSemaphoreWin32HandleInfoKhr = 1000078000
    ExportSemaphoreWin32HandleInfoKhr
    D3d12FenceSubmitInfoKhr
    SemaphoreGetWin32HandleInfoKhr
    ImportSemaphoreFdInfoKhr = 1000079000
    SemaphoreGetFdInfoKhr
    PhysicalDevicePushDescriptorProperties = 1000080000
    CommandBufferInheritanceConditionalRenderingInfoExt = 1000081000
    PhysicalDeviceConditionalRenderingFeaturesExt
    ConditionalRenderingBeginInfoExt
    PhysicalDeviceShaderFloat16Int8Features = 1000082000
    PhysicalDevice16bitStorageFeatures = 1000083000
    PresentRegionsKhr = 1000084000
    DescriptorUpdateTemplateCreateInfo = 1000085000
    PipelineViewportWScalingStateCreateInfoNv = 1000087000
    SurfaceCapabilities2Ext = 1000090000
    DisplayPowerInfoExt = 1000091000
    DeviceEventInfoExt
    DisplayEventInfoExt
    SwapchainCounterCreateInfoExt
    PresentTimesInfoGoogle = 1000092000
    PhysicalDeviceSubgroupProperties = 1000094000
    PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx = 1000097000
    PipelineViewportSwizzleStateCreateInfoNv = 1000098000
    PhysicalDeviceDiscardRectanglePropertiesExt = 1000099000
    PipelineDiscardRectangleStateCreateInfoExt
    PhysicalDeviceConservativeRasterizationPropertiesExt = 1000101000
    PipelineRasterizationConservativeStateCreateInfoExt
    PhysicalDeviceDepthClipEnableFeaturesExt = 1000102000
    PipelineRasterizationDepthClipStateCreateInfoExt
    HdrMetadataExt = 1000105000
    PhysicalDeviceImagelessFramebufferFeatures = 1000108000
    FramebufferAttachmentsCreateInfo
    FramebufferAttachmentImageInfo
    RenderPassAttachmentBeginInfo
    AttachmentDescription2 = 1000109000
    AttachmentReference2
    SubpassDescription2
    SubpassDependency2
    RenderPassCreateInfo2
    SubpassBeginInfo
    SubpassEndInfo
    PhysicalDeviceRelaxedLineRasterizationFeaturesImg = 1000110000
    SharedPresentSurfaceCapabilitiesKhr = 1000111000
    PhysicalDeviceExternalFenceInfo = 1000112000
    ExternalFenceProperties
    ExportFenceCreateInfo = 1000113000
    ImportFenceWin32HandleInfoKhr = 1000114000
    ExportFenceWin32HandleInfoKhr
    FenceGetWin32HandleInfoKhr
    ImportFenceFdInfoKhr = 1000115000
    FenceGetFdInfoKhr
    PhysicalDevicePerformanceQueryFeaturesKhr = 1000116000
    PhysicalDevicePerformanceQueryPropertiesKhr
    QueryPoolPerformanceCreateInfoKhr
    PerformanceQuerySubmitInfoKhr
    AcquireProfilingLockInfoKhr
    PerformanceCounterKhr
    PerformanceCounterDescriptionKhr
    PerformanceQueryReservationInfoKhr
    PhysicalDevicePointClippingProperties = 1000117000
    RenderPassInputAttachmentAspectCreateInfo
    ImageViewUsageCreateInfo
    PipelineTessellationDomainOriginStateCreateInfo
    PhysicalDeviceSurfaceInfo2Khr = 1000119000
    SurfaceCapabilities2Khr
    SurfaceFormat2Khr
    PhysicalDeviceVariablePointersFeatures = 1000120000
    DisplayProperties2Khr = 1000121000
    DisplayPlaneProperties2Khr
    DisplayModeProperties2Khr
    DisplayPlaneInfo2Khr
    DisplayPlaneCapabilities2Khr
    IosSurfaceCreateInfoMvk = 1000122000
    MacosSurfaceCreateInfoMvk = 1000123000
    MemoryDedicatedRequirements = 1000127000
    MemoryDedicatedAllocateInfo
    DebugUtilsObjectNameInfoExt = 1000128000
    DebugUtilsObjectTagInfoExt
    DebugUtilsLabelExt
    DebugUtilsMessengerCallbackDataExt
    DebugUtilsMessengerCreateInfoExt
    AndroidHardwareBufferUsageAndroid = 1000129000
    AndroidHardwareBufferPropertiesAndroid
    AndroidHardwareBufferFormatPropertiesAndroid
    ImportAndroidHardwareBufferInfoAndroid
    MemoryGetAndroidHardwareBufferInfoAndroid
    ExternalFormatAndroid
    AndroidHardwareBufferFormatProperties2Android
    PhysicalDeviceSamplerFilterMinmaxProperties = 1000130000
    SamplerReductionModeCreateInfo
    PhysicalDeviceShaderEnqueueFeaturesAmdx = 1000134000
    PhysicalDeviceShaderEnqueuePropertiesAmdx
    ExecutionGraphPipelineScratchSizeAmdx
    ExecutionGraphPipelineCreateInfoAmdx
    PipelineShaderStageNodeCreateInfoAmdx
    TexelBufferDescriptorInfoExt = 1000135000
    ImageDescriptorInfoExt
    ResourceDescriptorInfoExt
    BindHeapInfoExt
    PushDataInfoExt
    DescriptorSetAndBindingMappingExt
    ShaderDescriptorSetAndBindingMappingInfoExt
    OpaqueCaptureDataCreateInfoExt
    PhysicalDeviceDescriptorHeapPropertiesExt
    PhysicalDeviceDescriptorHeapFeaturesExt
    CommandBufferInheritanceDescriptorHeapInfoExt
    SamplerCustomBorderColorIndexCreateInfoExt
    IndirectCommandsLayoutPushDataTokenNv
    SubsampledImageFormatPropertiesExt
    PhysicalDeviceDescriptorHeapTensorPropertiesArm
    PhysicalDeviceInlineUniformBlockFeatures = 1000138000
    PhysicalDeviceInlineUniformBlockProperties
    WriteDescriptorSetInlineUniformBlock
    DescriptorPoolInlineUniformBlockCreateInfo
    PhysicalDeviceShaderBfloat16FeaturesKhr = 1000141000
    SampleLocationsInfoExt = 1000143000
    RenderPassSampleLocationsBeginInfoExt
    PipelineSampleLocationsStateCreateInfoExt
    PhysicalDeviceSampleLocationsPropertiesExt
    MultisamplePropertiesExt
    ProtectedSubmitInfo = 1000145000
    PhysicalDeviceProtectedMemoryFeatures
    PhysicalDeviceProtectedMemoryProperties
    DeviceQueueInfo2
    BufferMemoryRequirementsInfo2 = 1000146000
    ImageMemoryRequirementsInfo2
    ImageSparseMemoryRequirementsInfo2
    MemoryRequirements2
    SparseImageMemoryRequirements2
    ImageFormatListCreateInfo = 1000147000
    PhysicalDeviceBlendOperationAdvancedFeaturesExt = 1000148000
    PhysicalDeviceBlendOperationAdvancedPropertiesExt
    PipelineColorBlendAdvancedStateCreateInfoExt
    PipelineCoverageToColorStateCreateInfoNv = 1000149000
    AccelerationStructureBuildGeometryInfoKhr = 1000150000
    AccelerationStructureDeviceAddressInfoKhr = 1000150002
    AccelerationStructureGeometryAabbsDataKhr
    AccelerationStructureGeometryInstancesDataKhr
    AccelerationStructureGeometryTrianglesDataKhr
    AccelerationStructureGeometryKhr
    WriteDescriptorSetAccelerationStructureKhr
    AccelerationStructureVersionInfoKhr = 1000150009
    CopyAccelerationStructureInfoKhr
    CopyAccelerationStructureToMemoryInfoKhr
    CopyMemoryToAccelerationStructureInfoKhr
    PhysicalDeviceAccelerationStructureFeaturesKhr
    PhysicalDeviceAccelerationStructurePropertiesKhr
    RayTracingPipelineCreateInfoKhr
    RayTracingShaderGroupCreateInfoKhr
    AccelerationStructureCreateInfoKhr
    RayTracingPipelineInterfaceCreateInfoKhr
    AccelerationStructureBuildSizesInfoKhr = 1000150020
    PipelineCoverageModulationStateCreateInfoNv = 1000152000
    PhysicalDeviceShaderSmBuiltinsFeaturesNv = 1000154000
    PhysicalDeviceShaderSmBuiltinsPropertiesNv
    SamplerYcbcrConversionCreateInfo = 1000156000
    SamplerYcbcrConversionInfo
    BindImagePlaneMemoryInfo
    ImagePlaneMemoryRequirementsInfo
    PhysicalDeviceSamplerYcbcrConversionFeatures
    SamplerYcbcrConversionImageFormatProperties
    BindBufferMemoryInfo = 1000157000
    BindImageMemoryInfo
    DrmFormatModifierPropertiesListExt = 1000158000
    PhysicalDeviceImageDrmFormatModifierInfoExt = 1000158002
    ImageDrmFormatModifierListCreateInfoExt
    ImageDrmFormatModifierExplicitCreateInfoExt
    ImageDrmFormatModifierPropertiesExt
    DrmFormatModifierPropertiesList2Ext
    ValidationCacheCreateInfoExt = 1000160000
    ShaderModuleValidationCacheCreateInfoExt
    DescriptorSetLayoutBindingFlagsCreateInfo = 1000161000
    PhysicalDeviceDescriptorIndexingFeatures
    PhysicalDeviceDescriptorIndexingProperties
    DescriptorSetVariableDescriptorCountAllocateInfo
    DescriptorSetVariableDescriptorCountLayoutSupport
    PhysicalDevicePortabilitySubsetFeaturesKhr = 1000163000
    PhysicalDevicePortabilitySubsetPropertiesKhr
    PipelineViewportShadingRateImageStateCreateInfoNv = 1000164000
    PhysicalDeviceShadingRateImageFeaturesNv
    PhysicalDeviceShadingRateImagePropertiesNv
    PipelineViewportCoarseSampleOrderStateCreateInfoNv = 1000164005
    RayTracingPipelineCreateInfoNv = 1000165000
    AccelerationStructureCreateInfoNv
    GeometryNv = 1000165003
    GeometryTrianglesNv
    GeometryAabbNv
    BindAccelerationStructureMemoryInfoNv
    WriteDescriptorSetAccelerationStructureNv
    AccelerationStructureMemoryRequirementsInfoNv
    PhysicalDeviceRayTracingPropertiesNv
    RayTracingShaderGroupCreateInfoNv = 1000165011
    AccelerationStructureInfoNv
    PhysicalDeviceRepresentativeFragmentTestFeaturesNv = 1000166000
    PipelineRepresentativeFragmentTestStateCreateInfoNv
    PhysicalDeviceMaintenance3Properties = 1000168000
    DescriptorSetLayoutSupport
    PhysicalDeviceImageViewImageFormatInfoExt = 1000170000
    FilterCubicImageViewImageFormatPropertiesExt
    PhysicalDeviceCooperativeMatrixConversionFeaturesQcom = 1000172000
    DeviceQueueGlobalPriorityCreateInfo = 1000174000
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures = 1000175000
    PhysicalDevice8bitStorageFeatures = 1000177000
    ImportMemoryHostPointerInfoExt = 1000178000
    MemoryHostPointerPropertiesExt
    PhysicalDeviceExternalMemoryHostPropertiesExt
    PhysicalDeviceShaderAtomicInt64Features = 1000180000
    PhysicalDeviceShaderClockFeaturesKhr = 1000181000
    PipelineCompilerControlCreateInfoAmd = 1000183000
    CalibratedTimestampInfoKhr = 1000184000
    PhysicalDeviceShaderCorePropertiesAmd = 1000185000
    VideoDecodeH265CapabilitiesKhr = 1000187000
    VideoDecodeH265SessionParametersCreateInfoKhr
    VideoDecodeH265SessionParametersAddInfoKhr
    VideoDecodeH265ProfileInfoKhr
    VideoDecodeH265PictureInfoKhr
    VideoDecodeH265DpbSlotInfoKhr
    DeviceMemoryOverallocationCreateInfoAmd = 1000189000
    PhysicalDeviceVertexAttributeDivisorPropertiesExt = 1000190000
    PipelineVertexInputDivisorStateCreateInfo
    PhysicalDeviceVertexAttributeDivisorFeatures
    PresentFrameTokenGgp = 1000191000
    PipelineCreationFeedbackCreateInfo = 1000192000
    PhysicalDeviceDriverProperties = 1000196000
    PhysicalDeviceFloatControlsProperties = 1000197000
    PhysicalDeviceDepthStencilResolveProperties = 1000199000
    SubpassDescriptionDepthStencilResolve
    PhysicalDeviceComputeShaderDerivativesFeaturesKhr = 1000201000
    PhysicalDeviceMeshShaderFeaturesNv = 1000202000
    PhysicalDeviceMeshShaderPropertiesNv
    PhysicalDeviceFragmentShaderBarycentricFeaturesKhr = 1000203000
    PhysicalDeviceShaderImageFootprintFeaturesNv = 1000204000
    PipelineViewportExclusiveScissorStateCreateInfoNv = 1000205000
    PhysicalDeviceExclusiveScissorFeaturesNv = 1000205002
    CheckpointDataNv = 1000206000
    QueueFamilyCheckpointPropertiesNv
    PhysicalDeviceTimelineSemaphoreFeatures = 1000207000
    PhysicalDeviceTimelineSemaphoreProperties
    SemaphoreTypeCreateInfo
    TimelineSemaphoreSubmitInfo
    SemaphoreWaitInfo
    SemaphoreSignalInfo
    PhysicalDevicePresentTimingFeaturesExt = 1000208000
    SwapchainTimingPropertiesExt
    SwapchainTimeDomainPropertiesExt
    PresentTimingsInfoExt
    PresentTimingInfoExt
    PastPresentationTimingInfoExt
    PastPresentationTimingPropertiesExt
    PastPresentationTimingExt
    PresentTimingSurfaceCapabilitiesExt
    SwapchainCalibratedTimestampInfoExt
    PhysicalDeviceShaderIntegerFunctions2FeaturesIntel = 1000209000
    QueryPoolPerformanceQueryCreateInfoIntel = 1000210000
    InitializePerformanceApiInfoIntel
    PerformanceMarkerInfoIntel
    PerformanceStreamMarkerInfoIntel
    PerformanceOverrideInfoIntel
    PerformanceConfigurationAcquireInfoIntel
    PhysicalDeviceVulkanMemoryModelFeatures = 1000211000
    PhysicalDevicePciBusInfoPropertiesExt = 1000212000
    DisplayNativeHdrSurfaceCapabilitiesAmd = 1000213000
    SwapchainDisplayNativeHdrCreateInfoAmd
    ImagepipeSurfaceCreateInfoFuchsia = 1000214000
    PhysicalDeviceShaderTerminateInvocationFeatures = 1000215000
    MetalSurfaceCreateInfoExt = 1000217000
    PhysicalDeviceFragmentDensityMapFeaturesExt = 1000218000
    PhysicalDeviceFragmentDensityMapPropertiesExt
    RenderPassFragmentDensityMapCreateInfoExt
    PhysicalDeviceScalarBlockLayoutFeatures = 1000221000
    PhysicalDeviceSubgroupSizeControlProperties = 1000225000
    PipelineShaderStageRequiredSubgroupSizeCreateInfo
    PhysicalDeviceSubgroupSizeControlFeatures
    FragmentShadingRateAttachmentInfoKhr = 1000226000
    PipelineFragmentShadingRateStateCreateInfoKhr
    PhysicalDeviceFragmentShadingRatePropertiesKhr
    PhysicalDeviceFragmentShadingRateFeaturesKhr
    PhysicalDeviceFragmentShadingRateKhr
    PhysicalDeviceShaderCoreProperties2Amd = 1000227000
    PhysicalDeviceCoherentMemoryFeaturesAmd = 1000229000
    PhysicalDeviceDynamicRenderingLocalReadFeatures = 1000232000
    RenderingAttachmentLocationInfo
    RenderingInputAttachmentIndexInfo
    PhysicalDeviceShaderImageAtomicInt64FeaturesExt = 1000234000
    PhysicalDeviceShaderQuadControlFeaturesKhr = 1000235000
    PhysicalDeviceMemoryBudgetPropertiesExt = 1000237000
    PhysicalDeviceMemoryPriorityFeaturesExt = 1000238000
    MemoryPriorityAllocateInfoExt
    SurfaceProtectedCapabilitiesKhr = 1000239000
    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNv = 1000240000
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures = 1000241000
    AttachmentReferenceStencilLayout
    AttachmentDescriptionStencilLayout
    PhysicalDeviceBufferDeviceAddressFeaturesExt = 1000244000
    BufferDeviceAddressInfo
    BufferDeviceAddressCreateInfoExt
    PhysicalDeviceToolProperties = 1000245000
    ImageStencilUsageCreateInfo = 1000246000
    ValidationFeaturesExt = 1000247000
    PhysicalDevicePresentWaitFeaturesKhr = 1000248000
    PhysicalDeviceCooperativeMatrixFeaturesNv = 1000249000
    CooperativeMatrixPropertiesNv
    PhysicalDeviceCooperativeMatrixPropertiesNv
    PhysicalDeviceCoverageReductionModeFeaturesNv = 1000250000
    PipelineCoverageReductionStateCreateInfoNv
    FramebufferMixedSamplesCombinationNv
    PhysicalDeviceFragmentShaderInterlockFeaturesExt = 1000251000
    PhysicalDeviceYcbcrImageArraysFeaturesExt = 1000252000
    PhysicalDeviceUniformBufferStandardLayoutFeatures = 1000253000
    PhysicalDeviceProvokingVertexFeaturesExt = 1000254000
    PipelineRasterizationProvokingVertexStateCreateInfoExt
    PhysicalDeviceProvokingVertexPropertiesExt
    SurfaceFullScreenExclusiveInfoExt = 1000255000
    SurfaceFullScreenExclusiveWin32InfoExt
    SurfaceCapabilitiesFullScreenExclusiveExt
    HeadlessSurfaceCreateInfoExt = 1000256000
    PhysicalDeviceBufferDeviceAddressFeatures = 1000257000
    BufferOpaqueCaptureAddressCreateInfo = 1000257002
    MemoryOpaqueCaptureAddressAllocateInfo
    DeviceMemoryOpaqueCaptureAddressInfo
    PhysicalDeviceLineRasterizationFeatures = 1000259000
    PipelineRasterizationLineStateCreateInfo
    PhysicalDeviceLineRasterizationProperties
    PhysicalDeviceShaderAtomicFloatFeaturesExt = 1000260000
    PhysicalDeviceHostQueryResetFeatures = 1000261000
    PhysicalDeviceIndexTypeUint8Features = 1000265000
    PhysicalDeviceExtendedDynamicStateFeaturesExt = 1000267000
    PhysicalDevicePipelineExecutablePropertiesFeaturesKhr = 1000269000
    PipelineInfoKhr
    PipelineExecutablePropertiesKhr
    PipelineExecutableInfoKhr
    PipelineExecutableStatisticKhr
    PipelineExecutableInternalRepresentationKhr
    PhysicalDeviceHostImageCopyFeatures = 1000270000
    PhysicalDeviceHostImageCopyProperties
    MemoryToImageCopy
    ImageToMemoryCopy
    CopyImageToMemoryInfo
    CopyMemoryToImageInfo
    HostImageLayoutTransitionInfo
    CopyImageToImageInfo
    SubresourceHostMemcpySize
    HostImageCopyDevicePerformanceQuery
    MemoryMapInfo = 1000271000
    MemoryUnmapInfo
    PhysicalDeviceMapMemoryPlacedFeaturesExt = 1000272000
    PhysicalDeviceMapMemoryPlacedPropertiesExt
    MemoryMapPlacedInfoExt
    PhysicalDeviceShaderAtomicFloat2FeaturesExt = 1000273000
    SurfacePresentModeKhr = 1000274000
    SurfacePresentScalingCapabilitiesKhr
    SurfacePresentModeCompatibilityKhr
    PhysicalDeviceSwapchainMaintenance1FeaturesKhr = 1000275000
    SwapchainPresentFenceInfoKhr
    SwapchainPresentModesCreateInfoKhr
    SwapchainPresentModeInfoKhr
    SwapchainPresentScalingCreateInfoKhr
    ReleaseSwapchainImagesInfoKhr
    PhysicalDeviceShaderDemoteToHelperInvocationFeatures = 1000276000
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNv = 1000277000
    GraphicsShaderGroupCreateInfoNv
    GraphicsPipelineShaderGroupsCreateInfoNv
    IndirectCommandsLayoutTokenNv
    IndirectCommandsLayoutCreateInfoNv
    GeneratedCommandsInfoNv
    GeneratedCommandsMemoryRequirementsInfoNv
    PhysicalDeviceDeviceGeneratedCommandsFeaturesNv
    PhysicalDeviceInheritedViewportScissorFeaturesNv = 1000278000
    CommandBufferInheritanceViewportScissorInfoNv
    PhysicalDeviceShaderIntegerDotProductFeatures = 1000280000
    PhysicalDeviceShaderIntegerDotProductProperties
    PhysicalDeviceTexelBufferAlignmentFeaturesExt = 1000281000
    PhysicalDeviceTexelBufferAlignmentProperties
    CommandBufferInheritanceRenderPassTransformInfoQcom = 1000282000
    RenderPassTransformBeginInfoQcom
    PhysicalDeviceDepthBiasControlFeaturesExt = 1000283000
    DepthBiasInfoExt
    DepthBiasRepresentationInfoExt
    PhysicalDeviceDeviceMemoryReportFeaturesExt = 1000284000
    DeviceDeviceMemoryReportCreateInfoExt
    DeviceMemoryReportCallbackDataExt
    PhysicalDeviceRobustness2FeaturesKhr = 1000286000
    PhysicalDeviceRobustness2PropertiesKhr
    SamplerCustomBorderColorCreateInfoExt = 1000287000
    PhysicalDeviceCustomBorderColorPropertiesExt
    PhysicalDeviceCustomBorderColorFeaturesExt
    PhysicalDeviceTextureCompressionAstc3dFeaturesExt = 1000288000
    PipelineLibraryCreateInfoKhr = 1000290000
    PhysicalDevicePresentBarrierFeaturesNv = 1000292000
    SurfaceCapabilitiesPresentBarrierNv
    SwapchainPresentBarrierCreateInfoNv
    PresentIdKhr = 1000294000
    PhysicalDevicePresentIdFeaturesKhr
    PhysicalDevicePrivateDataFeatures = 1000295000
    DevicePrivateDataCreateInfo
    PrivateDataSlotCreateInfo
    PhysicalDevicePipelineCreationCacheControlFeatures = 1000297000
    PhysicalDeviceVulkanSc10Features = 1000298000
    PhysicalDeviceVulkanSc10Properties
    DeviceObjectReservationCreateInfo
    CommandPoolMemoryReservationCreateInfo
    CommandPoolMemoryConsumption
    PipelinePoolSize
    FaultData = 1000298007
    FaultCallbackInfo
    PipelineOfflineCreateInfo = 1000298010
    VideoEncodeInfoKhr = 1000299000
    VideoEncodeRateControlInfoKhr
    VideoEncodeRateControlLayerInfoKhr
    VideoEncodeCapabilitiesKhr
    VideoEncodeUsageInfoKhr
    QueryPoolVideoEncodeFeedbackCreateInfoKhr
    PhysicalDeviceVideoEncodeQualityLevelInfoKhr
    VideoEncodeQualityLevelPropertiesKhr
    VideoEncodeQualityLevelInfoKhr
    VideoEncodeSessionParametersGetInfoKhr
    VideoEncodeSessionParametersFeedbackInfoKhr
    PhysicalDeviceDiagnosticsConfigFeaturesNv = 1000300000
    DeviceDiagnosticsConfigCreateInfoNv
    CudaModuleCreateInfoNv = 1000307000
    CudaFunctionCreateInfoNv
    CudaLaunchInfoNv
    PhysicalDeviceCudaKernelLaunchFeaturesNv
    PhysicalDeviceCudaKernelLaunchPropertiesNv
    RefreshObjectListKhr = 1000308000
    PhysicalDeviceTileShadingFeaturesQcom = 1000309000
    PhysicalDeviceTileShadingPropertiesQcom
    RenderPassTileShadingCreateInfoQcom
    PerTileBeginInfoQcom
    PerTileEndInfoQcom
    DispatchTileInfoQcom
    QueryLowLatencySupportNv = 1000310000
    ExportMetalObjectCreateInfoExt = 1000311000
    ExportMetalObjectsInfoExt
    ExportMetalDeviceInfoExt
    ExportMetalCommandQueueInfoExt
    ExportMetalBufferInfoExt
    ImportMetalBufferInfoExt
    ExportMetalTextureInfoExt
    ImportMetalTextureInfoExt
    ExportMetalIoSurfaceInfoExt
    ImportMetalIoSurfaceInfoExt
    ExportMetalSharedEventInfoExt
    ImportMetalSharedEventInfoExt
    MemoryBarrier2 = 1000314000
    BufferMemoryBarrier2
    ImageMemoryBarrier2
    DependencyInfo
    SubmitInfo2
    SemaphoreSubmitInfo
    CommandBufferSubmitInfo
    PhysicalDeviceSynchronization2Features
    QueueFamilyCheckpointProperties2Nv
    CheckpointData2Nv
    PhysicalDeviceDescriptorBufferPropertiesExt = 1000316000
    PhysicalDeviceDescriptorBufferDensityMapPropertiesExt
    PhysicalDeviceDescriptorBufferFeaturesExt
    DescriptorAddressInfoExt
    DescriptorGetInfoExt
    BufferCaptureDescriptorDataInfoExt
    ImageCaptureDescriptorDataInfoExt
    ImageViewCaptureDescriptorDataInfoExt
    SamplerCaptureDescriptorDataInfoExt
    AccelerationStructureCaptureDescriptorDataInfoExt
    OpaqueCaptureDescriptorDataCreateInfoExt
    DescriptorBufferBindingInfoExt
    DescriptorBufferBindingPushDescriptorBufferHandleExt
    PhysicalDeviceGraphicsPipelineLibraryFeaturesExt = 1000320000
    PhysicalDeviceGraphicsPipelineLibraryPropertiesExt
    GraphicsPipelineLibraryCreateInfoExt
    PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAmd = 1000321000
    PhysicalDeviceFragmentShaderBarycentricPropertiesKhr = 1000322000
    PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKhr = 1000323000
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = 1000325000
    PhysicalDeviceFragmentShadingRateEnumsPropertiesNv = 1000326000
    PhysicalDeviceFragmentShadingRateEnumsFeaturesNv
    PipelineFragmentShadingRateEnumStateCreateInfoNv
    AccelerationStructureGeometryMotionTrianglesDataNv = 1000327000
    PhysicalDeviceRayTracingMotionBlurFeaturesNv
    AccelerationStructureMotionInfoNv
    PhysicalDeviceMeshShaderFeaturesExt = 1000328000
    PhysicalDeviceMeshShaderPropertiesExt
    PhysicalDeviceYcbcr2Plane444FormatsFeaturesExt = 1000330000
    PhysicalDeviceFragmentDensityMap2FeaturesExt = 1000332000
    PhysicalDeviceFragmentDensityMap2PropertiesExt
    CopyCommandTransformInfoQcom = 1000333000
    PhysicalDeviceImageRobustnessFeatures = 1000335000
    PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKhr = 1000336000
    CopyBufferInfo2 = 1000337000
    CopyImageInfo2
    CopyBufferToImageInfo2
    CopyImageToBufferInfo2
    BlitImageInfo2
    ResolveImageInfo2
    BufferCopy2
    ImageCopy2
    ImageBlit2
    BufferImageCopy2
    ImageResolve2
    PhysicalDeviceImageCompressionControlFeaturesExt = 1000338000
    ImageCompressionControlExt
    SubresourceLayout2
    ImageSubresource2
    ImageCompressionPropertiesExt
    PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesExt = 1000339000
    PhysicalDevice4444FormatsFeaturesExt = 1000340000
    PhysicalDeviceFaultFeaturesExt = 1000341000
    DeviceFaultCountsExt
    DeviceFaultInfoExt
    PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesExt = 1000342000
    PhysicalDeviceRgba10x6FormatsFeaturesExt = 1000344000
    DirectfbSurfaceCreateInfoExt = 1000346000
    PhysicalDeviceRayTracingPipelineFeaturesKhr = 1000347000
    PhysicalDeviceRayTracingPipelinePropertiesKhr
    PhysicalDeviceRayQueryFeaturesKhr = 1000348013
    PhysicalDeviceMutableDescriptorTypeFeaturesExt = 1000351000
    MutableDescriptorTypeCreateInfoExt = 1000351002
    PhysicalDeviceVertexInputDynamicStateFeaturesExt = 1000352000
    VertexInputBindingDescription2Ext
    VertexInputAttributeDescription2Ext
    PhysicalDeviceDrmPropertiesExt = 1000353000
    PhysicalDeviceAddressBindingReportFeaturesExt = 1000354000
    DeviceAddressBindingCallbackDataExt
    PhysicalDeviceDepthClipControlFeaturesExt = 1000355000
    PipelineViewportDepthClipControlCreateInfoExt
    PhysicalDevicePrimitiveTopologyListRestartFeaturesExt = 1000356000
    FormatProperties3 = 1000360000
    PhysicalDevicePresentModeFifoLatestReadyFeaturesKhr = 1000361000
    ImportMemoryZirconHandleInfoFuchsia = 1000364000
    MemoryZirconHandlePropertiesFuchsia
    MemoryGetZirconHandleInfoFuchsia
    ImportSemaphoreZirconHandleInfoFuchsia = 1000365000
    SemaphoreGetZirconHandleInfoFuchsia
    BufferCollectionCreateInfoFuchsia = 1000366000
    ImportMemoryBufferCollectionFuchsia
    BufferCollectionImageCreateInfoFuchsia
    BufferCollectionPropertiesFuchsia
    BufferConstraintsInfoFuchsia
    BufferCollectionBufferCreateInfoFuchsia
    ImageConstraintsInfoFuchsia
    ImageFormatConstraintsInfoFuchsia
    SysmemColorSpaceFuchsia
    BufferCollectionConstraintsInfoFuchsia
    SubpassShadingPipelineCreateInfoHuawei = 1000369000
    PhysicalDeviceSubpassShadingFeaturesHuawei
    PhysicalDeviceSubpassShadingPropertiesHuawei
    PhysicalDeviceInvocationMaskFeaturesHuawei = 1000370000
    MemoryGetRemoteAddressInfoNv = 1000371000
    PhysicalDeviceExternalMemoryRdmaFeaturesNv
    PipelinePropertiesIdentifierExt = 1000372000
    PhysicalDevicePipelinePropertiesFeaturesExt
    ImportFenceSciSyncInfoNv = 1000373000
    ExportFenceSciSyncInfoNv
    FenceGetSciSyncInfoNv
    SciSyncAttributesInfoNv
    ImportSemaphoreSciSyncInfoNv
    ExportSemaphoreSciSyncInfoNv
    SemaphoreGetSciSyncInfoNv
    PhysicalDeviceExternalSciSyncFeaturesNv
    ImportMemorySciBufInfoNv = 1000374000
    ExportMemorySciBufInfoNv
    MemoryGetSciBufInfoNv
    MemorySciBufPropertiesNv
    PhysicalDeviceExternalMemorySciBufFeaturesNv
    PhysicalDeviceFrameBoundaryFeaturesExt = 1000375000
    FrameBoundaryExt
    PhysicalDeviceMultisampledRenderToSingleSampledFeaturesExt = 1000376000
    SubpassResolvePerformanceQueryExt
    MultisampledRenderToSingleSampledInfoExt
    PhysicalDeviceExtendedDynamicState2FeaturesExt = 1000377000
    ScreenSurfaceCreateInfoQnx = 1000378000
    PhysicalDeviceColorWriteEnableFeaturesExt = 1000381000
    PipelineColorWriteCreateInfoExt
    PhysicalDevicePrimitivesGeneratedQueryFeaturesExt = 1000382000
    PhysicalDeviceRayTracingMaintenance1FeaturesKhr = 1000386000
    PhysicalDeviceShaderUntypedPointersFeaturesKhr = 1000387000
    PhysicalDeviceGlobalPriorityQueryFeatures = 1000388000
    QueueFamilyGlobalPriorityProperties
    PhysicalDeviceVideoEncodeRgbConversionFeaturesValve = 1000390000
    VideoEncodeRgbConversionCapabilitiesValve
    VideoEncodeProfileRgbConversionInfoValve
    VideoEncodeSessionRgbConversionCreateInfoValve
    PhysicalDeviceImageViewMinLodFeaturesExt = 1000391000
    ImageViewMinLodCreateInfoExt
    PhysicalDeviceMultiDrawFeaturesExt = 1000392000
    PhysicalDeviceMultiDrawPropertiesExt
    PhysicalDeviceImage2dViewOf3dFeaturesExt = 1000393000
    PhysicalDeviceShaderTileImageFeaturesExt = 1000395000
    PhysicalDeviceShaderTileImagePropertiesExt
    MicromapBuildInfoExt = 1000396000
    MicromapVersionInfoExt
    CopyMicromapInfoExt
    CopyMicromapToMemoryInfoExt
    CopyMemoryToMicromapInfoExt
    PhysicalDeviceOpacityMicromapFeaturesExt
    PhysicalDeviceOpacityMicromapPropertiesExt
    MicromapCreateInfoExt
    MicromapBuildSizesInfoExt
    AccelerationStructureTrianglesOpacityMicromapExt
    PhysicalDeviceDisplacementMicromapFeaturesNv = 1000397000
    PhysicalDeviceDisplacementMicromapPropertiesNv
    AccelerationStructureTrianglesDisplacementMicromapNv
    PhysicalDeviceClusterCullingShaderFeaturesHuawei = 1000404000
    PhysicalDeviceClusterCullingShaderPropertiesHuawei
    PhysicalDeviceClusterCullingShaderVrsFeaturesHuawei
    PhysicalDeviceBorderColorSwizzleFeaturesExt = 1000411000
    SamplerBorderColorComponentMappingCreateInfoExt
    PhysicalDevicePageableDeviceLocalMemoryFeaturesExt = 1000412000
    PhysicalDeviceMaintenance4Features = 1000413000
    PhysicalDeviceMaintenance4Properties
    DeviceBufferMemoryRequirements
    DeviceImageMemoryRequirements
    PhysicalDeviceShaderCorePropertiesArm = 1000415000
    PhysicalDeviceShaderSubgroupRotateFeatures = 1000416000
    DeviceQueueShaderCoreControlCreateInfoArm = 1000417000
    PhysicalDeviceSchedulingControlsFeaturesArm
    PhysicalDeviceSchedulingControlsPropertiesArm
    PhysicalDeviceImageSlicedViewOf3dFeaturesExt = 1000418000
    ImageViewSlicedCreateInfoExt
    PhysicalDeviceDescriptorSetHostMappingFeaturesValve = 1000420000
    DescriptorSetBindingReferenceValve
    DescriptorSetLayoutHostMappingInfoValve
    PhysicalDeviceDepthClampZeroOneFeaturesKhr = 1000421000
    PhysicalDeviceNonSeamlessCubeMapFeaturesExt = 1000422000
    PhysicalDeviceRenderPassStripedFeaturesArm = 1000424000
    PhysicalDeviceRenderPassStripedPropertiesArm
    RenderPassStripeBeginInfoArm
    RenderPassStripeInfoArm
    RenderPassStripeSubmitInfoArm
    PhysicalDeviceFragmentDensityMapOffsetFeaturesExt = 1000425000
    PhysicalDeviceFragmentDensityMapOffsetPropertiesExt
    RenderPassFragmentDensityMapOffsetEndInfoExt
    PhysicalDeviceCopyMemoryIndirectFeaturesNv = 1000426000
    PhysicalDeviceCopyMemoryIndirectPropertiesKhr
    PhysicalDeviceMemoryDecompressionFeaturesExt = 1000427000
    PhysicalDeviceMemoryDecompressionPropertiesExt
    PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNv = 1000428000
    ComputePipelineIndirectBufferInfoNv
    PipelineIndirectDeviceAddressInfoNv
    PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNv = 1000429008
    AccelerationStructureGeometryLinearSweptSpheresDataNv
    AccelerationStructureGeometrySpheresDataNv
    PhysicalDeviceLinearColorAttachmentFeaturesNv = 1000430000
    PhysicalDeviceShaderMaximalReconvergenceFeaturesKhr = 1000434000
    ApplicationParametersExt = 1000435000
    PhysicalDeviceImageCompressionControlSwapchainFeaturesExt = 1000437000
    PhysicalDeviceImageProcessingFeaturesQcom = 1000440000
    PhysicalDeviceImageProcessingPropertiesQcom
    ImageViewSampleWeightCreateInfoQcom
    PhysicalDeviceNestedCommandBufferFeaturesExt = 1000451000
    PhysicalDeviceNestedCommandBufferPropertiesExt
    NativeBufferUsageOhos = 1000452000
    NativeBufferPropertiesOhos
    NativeBufferFormatPropertiesOhos
    ImportNativeBufferInfoOhos
    MemoryGetNativeBufferInfoOhos
    ExternalFormatOhos
    ExternalMemoryAcquireUnmodifiedExt = 1000453000
    PhysicalDeviceExtendedDynamicState3FeaturesExt = 1000455000
    PhysicalDeviceExtendedDynamicState3PropertiesExt
    PhysicalDeviceSubpassMergeFeedbackFeaturesExt = 1000458000
    RenderPassCreationControlExt
    RenderPassCreationFeedbackCreateInfoExt
    RenderPassSubpassFeedbackCreateInfoExt
    DirectDriverLoadingInfoLunarg = 1000459000
    DirectDriverLoadingListLunarg
    TensorCreateInfoArm = 1000460000
    TensorViewCreateInfoArm
    BindTensorMemoryInfoArm
    WriteDescriptorSetTensorArm
    PhysicalDeviceTensorPropertiesArm
    TensorFormatPropertiesArm
    TensorDescriptionArm
    TensorMemoryRequirementsInfoArm
    TensorMemoryBarrierArm
    PhysicalDeviceTensorFeaturesArm
    DeviceTensorMemoryRequirementsArm
    CopyTensorInfoArm
    TensorCopyArm
    TensorDependencyInfoArm
    MemoryDedicatedAllocateInfoTensorArm
    PhysicalDeviceExternalTensorInfoArm
    ExternalTensorPropertiesArm
    ExternalMemoryTensorCreateInfoArm
    PhysicalDeviceDescriptorBufferTensorFeaturesArm
    PhysicalDeviceDescriptorBufferTensorPropertiesArm
    DescriptorGetTensorInfoArm
    TensorCaptureDescriptorDataInfoArm
    TensorViewCaptureDescriptorDataInfoArm
    FrameBoundaryTensorsArm
    PhysicalDeviceShaderModuleIdentifierFeaturesExt = 1000462000
    PhysicalDeviceShaderModuleIdentifierPropertiesExt
    PipelineShaderStageModuleIdentifierCreateInfoExt
    ShaderModuleIdentifierExt
    PhysicalDeviceOpticalFlowFeaturesNv = 1000464000
    PhysicalDeviceOpticalFlowPropertiesNv
    OpticalFlowImageFormatInfoNv
    OpticalFlowImageFormatPropertiesNv
    OpticalFlowSessionCreateInfoNv
    OpticalFlowExecuteInfoNv
    OpticalFlowSessionCreatePrivateDataInfoNv = 1000464010
    PhysicalDeviceLegacyDitheringFeaturesExt = 1000465000
    PhysicalDevicePipelineProtectedAccessFeatures = 1000466000
    PhysicalDeviceExternalFormatResolveFeaturesAndroid = 1000468000
    PhysicalDeviceExternalFormatResolvePropertiesAndroid
    AndroidHardwareBufferFormatResolvePropertiesAndroid
    PhysicalDeviceMaintenance5Features = 1000470000
    PhysicalDeviceMaintenance5Properties
    RenderingAreaInfo = 1000470003
    DeviceImageSubresourceInfo
    PipelineCreateFlags2CreateInfo
    BufferUsageFlags2CreateInfo
    PhysicalDeviceAntiLagFeaturesAmd = 1000476000
    AntiLagDataAmd
    AntiLagPresentationInfoAmd
    PhysicalDeviceDenseGeometryFormatFeaturesAmdx = 1000478000
    AccelerationStructureDenseGeometryFormatTrianglesDataAmdx
    SurfaceCapabilitiesPresentId2Khr = 1000479000
    PresentId2Khr
    PhysicalDevicePresentId2FeaturesKhr
    SurfaceCapabilitiesPresentWait2Khr = 1000480000
    PhysicalDevicePresentWait2FeaturesKhr
    PresentWait2InfoKhr
    PhysicalDeviceRayTracingPositionFetchFeaturesKhr = 1000481000
    PhysicalDeviceShaderObjectFeaturesExt = 1000482000
    PhysicalDeviceShaderObjectPropertiesExt
    ShaderCreateInfoExt
    PhysicalDevicePipelineBinaryFeaturesKhr = 1000483000
    PipelineBinaryCreateInfoKhr
    PipelineBinaryInfoKhr
    PipelineBinaryKeyKhr
    PhysicalDevicePipelineBinaryPropertiesKhr
    ReleaseCapturedPipelineDataInfoKhr
    PipelineBinaryDataInfoKhr
    PipelineCreateInfoKhr
    DevicePipelineBinaryInternalCacheControlKhr
    PipelineBinaryHandlesInfoKhr
    PhysicalDeviceTilePropertiesFeaturesQcom = 1000484000
    TilePropertiesQcom
    PhysicalDeviceAmigoProfilingFeaturesSec = 1000485000
    AmigoProfilingSubmitInfoSec
    PhysicalDeviceMultiviewPerViewViewportsFeaturesQcom = 1000488000
    SemaphoreSciSyncPoolCreateInfoNv = 1000489000
    SemaphoreSciSyncCreateInfoNv
    PhysicalDeviceExternalSciSync2FeaturesNv
    DeviceSemaphoreSciSyncPoolReservationCreateInfoNv
    PhysicalDeviceRayTracingInvocationReorderFeaturesNv = 1000490000
    PhysicalDeviceRayTracingInvocationReorderPropertiesNv
    PhysicalDeviceCooperativeVectorFeaturesNv = 1000491000
    PhysicalDeviceCooperativeVectorPropertiesNv
    CooperativeVectorPropertiesNv
    ConvertCooperativeVectorMatrixInfoNv = 1000491004
    PhysicalDeviceExtendedSparseAddressSpaceFeaturesNv = 1000492000
    PhysicalDeviceExtendedSparseAddressSpacePropertiesNv
    PhysicalDeviceLegacyVertexAttributesFeaturesExt = 1000495000
    PhysicalDeviceLegacyVertexAttributesPropertiesExt
    LayerSettingsCreateInfoExt = 1000496000
    PhysicalDeviceShaderCoreBuiltinsFeaturesArm = 1000497000
    PhysicalDeviceShaderCoreBuiltinsPropertiesArm
    PhysicalDevicePipelineLibraryGroupHandlesFeaturesExt = 1000498000
    PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesExt = 1000499000
    PhysicalDeviceInternallySynchronizedQueuesFeaturesKhr = 1000504000
    LatencySleepModeInfoNv = 1000505000
    LatencySleepInfoNv
    SetLatencyMarkerInfoNv
    GetLatencyMarkerInfoNv
    LatencyTimingsFrameReportNv
    LatencySubmissionPresentIdNv
    OutOfBandQueueTypeInfoNv
    SwapchainLatencyCreateInfoNv
    LatencySurfaceCapabilitiesNv
    PhysicalDeviceCooperativeMatrixFeaturesKhr = 1000506000
    CooperativeMatrixPropertiesKhr
    PhysicalDeviceCooperativeMatrixPropertiesKhr
    DataGraphPipelineCreateInfoArm = 1000507000
    DataGraphPipelineSessionCreateInfoArm
    DataGraphPipelineResourceInfoArm
    DataGraphPipelineConstantArm
    DataGraphPipelineSessionMemoryRequirementsInfoArm
    BindDataGraphPipelineSessionMemoryInfoArm
    PhysicalDeviceDataGraphFeaturesArm
    DataGraphPipelineShaderModuleCreateInfoArm
    DataGraphPipelinePropertyQueryResultArm
    DataGraphPipelineInfoArm
    DataGraphPipelineCompilerControlCreateInfoArm
    DataGraphPipelineSessionBindPointRequirementsInfoArm
    DataGraphPipelineSessionBindPointRequirementArm
    DataGraphPipelineIdentifierCreateInfoArm
    DataGraphPipelineDispatchInfoArm
    DataGraphPipelineConstantTensorSemiStructuredSparsityInfoArm
    DataGraphProcessingEngineCreateInfoArm
    QueueFamilyDataGraphProcessingEnginePropertiesArm
    QueueFamilyDataGraphPropertiesArm
    PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoArm
    PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQcom = 1000510000
    MultiviewPerViewRenderAreasRenderPassBeginInfoQcom
    PhysicalDeviceComputeShaderDerivativesPropertiesKhr = 1000511000
    VideoDecodeAv1CapabilitiesKhr = 1000512000
    VideoDecodeAv1PictureInfoKhr
    VideoDecodeAv1ProfileInfoKhr = 1000512003
    VideoDecodeAv1SessionParametersCreateInfoKhr
    VideoDecodeAv1DpbSlotInfoKhr
    VideoEncodeAv1CapabilitiesKhr = 1000513000
    VideoEncodeAv1SessionParametersCreateInfoKhr
    VideoEncodeAv1PictureInfoKhr
    VideoEncodeAv1DpbSlotInfoKhr
    PhysicalDeviceVideoEncodeAv1FeaturesKhr
    VideoEncodeAv1ProfileInfoKhr
    VideoEncodeAv1RateControlInfoKhr
    VideoEncodeAv1RateControlLayerInfoKhr
    VideoEncodeAv1QualityLevelPropertiesKhr
    VideoEncodeAv1SessionCreateInfoKhr
    VideoEncodeAv1GopRemainingFrameInfoKhr
    PhysicalDeviceVideoDecodeVp9FeaturesKhr = 1000514000
    VideoDecodeVp9CapabilitiesKhr
    VideoDecodeVp9PictureInfoKhr
    VideoDecodeVp9ProfileInfoKhr
    PhysicalDeviceVideoMaintenance1FeaturesKhr = 1000515000
    VideoInlineQueryInfoKhr
    PhysicalDevicePerStageDescriptorSetFeaturesNv = 1000516000
    PhysicalDeviceImageProcessing2FeaturesQcom = 1000518000
    PhysicalDeviceImageProcessing2PropertiesQcom
    SamplerBlockMatchWindowCreateInfoQcom
    SamplerCubicWeightsCreateInfoQcom = 1000519000
    PhysicalDeviceCubicWeightsFeaturesQcom
    BlitImageCubicWeightsInfoQcom
    PhysicalDeviceYcbcrDegammaFeaturesQcom = 1000520000
    SamplerYcbcrConversionYcbcrDegammaCreateInfoQcom
    PhysicalDeviceCubicClampFeaturesQcom = 1000521000
    PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesExt = 1000524000
    PhysicalDeviceVertexAttributeDivisorProperties = 1000525000
    PhysicalDeviceUnifiedImageLayoutsFeaturesKhr = 1000527000
    AttachmentFeedbackLoopInfoExt
    PhysicalDeviceShaderFloatControls2Features = 1000528000
    ScreenBufferPropertiesQnx = 1000529000
    ScreenBufferFormatPropertiesQnx
    ImportScreenBufferInfoQnx
    ExternalFormatQnx
    PhysicalDeviceExternalMemoryScreenBufferFeaturesQnx
    PhysicalDeviceLayeredDriverPropertiesMsft = 1000530000
    PhysicalDeviceShaderExpectAssumeFeatures = 1000544000
    PhysicalDeviceMaintenance6Features = 1000545000
    PhysicalDeviceMaintenance6Properties
    BindMemoryStatus
    BindDescriptorSetsInfo
    PushConstantsInfo
    PushDescriptorSetInfo
    PushDescriptorSetWithTemplateInfo
    SetDescriptorBufferOffsetsInfoExt
    BindDescriptorBufferEmbeddedSamplersInfoExt
    PhysicalDeviceDescriptorPoolOverallocationFeaturesNv = 1000546000
    PhysicalDeviceTileMemoryHeapFeaturesQcom = 1000547000
    PhysicalDeviceTileMemoryHeapPropertiesQcom
    TileMemoryRequirementsQcom
    TileMemoryBindInfoQcom
    TileMemorySizeInfoQcom
    PhysicalDeviceCopyMemoryIndirectFeaturesKhr = 1000549000
    CopyMemoryIndirectInfoKhr = 1000549002
    CopyMemoryToImageIndirectInfoKhr
    DecompressMemoryInfoExt = 1000550002
    DisplaySurfaceStereoCreateInfoNv = 1000551000
    DisplayModeStereoPropertiesNv
    VideoEncodeIntraRefreshCapabilitiesKhr = 1000552000
    VideoEncodeSessionIntraRefreshCreateInfoKhr
    VideoEncodeIntraRefreshInfoKhr
    VideoReferenceIntraRefreshInfoKhr
    PhysicalDeviceVideoEncodeIntraRefreshFeaturesKhr
    VideoEncodeQuantizationMapCapabilitiesKhr = 1000553000
    VideoFormatQuantizationMapPropertiesKhr
    VideoEncodeQuantizationMapInfoKhr
    VideoEncodeH264QuantizationMapCapabilitiesKhr
    VideoEncodeH265QuantizationMapCapabilitiesKhr
    VideoEncodeQuantizationMapSessionParametersCreateInfoKhr
    VideoFormatH265QuantizationMapPropertiesKhr
    VideoEncodeAv1QuantizationMapCapabilitiesKhr
    VideoFormatAv1QuantizationMapPropertiesKhr
    PhysicalDeviceVideoEncodeQuantizationMapFeaturesKhr
    PhysicalDeviceRawAccessChainsFeaturesNv = 1000555000
    ExternalComputeQueueDeviceCreateInfoNv = 1000556000
    ExternalComputeQueueCreateInfoNv
    ExternalComputeQueueDataParamsNv
    PhysicalDeviceExternalComputeQueuePropertiesNv
    PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKhr = 1000558000
    PhysicalDeviceCommandBufferInheritanceFeaturesNv = 1000559000
    PhysicalDeviceMaintenance7FeaturesKhr = 1000562000
    PhysicalDeviceMaintenance7PropertiesKhr
    PhysicalDeviceLayeredApiPropertiesListKhr
    PhysicalDeviceLayeredApiPropertiesKhr
    PhysicalDeviceLayeredApiVulkanPropertiesKhr
    PhysicalDeviceShaderAtomicFloat16VectorFeaturesNv = 1000563000
    PhysicalDeviceShaderReplicatedCompositesFeaturesExt = 1000564000
    PhysicalDeviceShaderFloat8FeaturesExt = 1000567000
    PhysicalDeviceRayTracingValidationFeaturesNv = 1000568000
    PhysicalDeviceClusterAccelerationStructureFeaturesNv = 1000569000
    PhysicalDeviceClusterAccelerationStructurePropertiesNv
    ClusterAccelerationStructureClustersBottomLevelInputNv
    ClusterAccelerationStructureTriangleClusterInputNv
    ClusterAccelerationStructureMoveObjectsInputNv
    ClusterAccelerationStructureInputInfoNv
    ClusterAccelerationStructureCommandsInfoNv
    RayTracingPipelineClusterAccelerationStructureCreateInfoNv
    PhysicalDevicePartitionedAccelerationStructureFeaturesNv = 1000570000
    PhysicalDevicePartitionedAccelerationStructurePropertiesNv
    WriteDescriptorSetPartitionedAccelerationStructureNv
    PartitionedAccelerationStructureInstancesInputNv
    BuildPartitionedAccelerationStructureInfoNv
    PartitionedAccelerationStructureFlagsNv
    PhysicalDeviceDeviceGeneratedCommandsFeaturesExt = 1000572000
    PhysicalDeviceDeviceGeneratedCommandsPropertiesExt
    GeneratedCommandsMemoryRequirementsInfoExt
    IndirectExecutionSetCreateInfoExt
    GeneratedCommandsInfoExt
    IndirectCommandsLayoutCreateInfoExt = 1000572006
    IndirectCommandsLayoutTokenExt
    WriteIndirectExecutionSetPipelineExt
    WriteIndirectExecutionSetShaderExt
    IndirectExecutionSetPipelineInfoExt
    IndirectExecutionSetShaderInfoExt
    IndirectExecutionSetShaderLayoutInfoExt
    GeneratedCommandsPipelineInfoExt
    GeneratedCommandsShaderInfoExt
    PhysicalDeviceMaintenance8FeaturesKhr = 1000574000
    MemoryBarrierAccessFlags3Khr = 1000574002
    PhysicalDeviceImageAlignmentControlFeaturesMesa = 1000575000
    PhysicalDeviceImageAlignmentControlPropertiesMesa
    ImageAlignmentControlCreateInfoMesa
    PhysicalDeviceShaderFmaFeaturesKhr = 1000579000
    PushConstantBankInfoNv = 1000580000
    PhysicalDevicePushConstantBankFeaturesNv
    PhysicalDevicePushConstantBankPropertiesNv
    PhysicalDeviceRayTracingInvocationReorderFeaturesExt = 1000581000
    PhysicalDeviceRayTracingInvocationReorderPropertiesExt
    PhysicalDeviceDepthClampControlFeaturesExt = 1000582000
    PipelineViewportDepthClampControlCreateInfoExt
    PhysicalDeviceMaintenance9FeaturesKhr = 1000584000
    PhysicalDeviceMaintenance9PropertiesKhr
    QueueFamilyOwnershipTransferPropertiesKhr
    PhysicalDeviceVideoMaintenance2FeaturesKhr = 1000586000
    VideoDecodeH264InlineSessionParametersInfoKhr
    VideoDecodeH265InlineSessionParametersInfoKhr
    VideoDecodeAv1InlineSessionParametersInfoKhr
    PhysicalDeviceHdrVividFeaturesHuawei = 1000590000
    HdrVividDynamicMetadataHuawei
    PhysicalDeviceCooperativeMatrix2FeaturesNv = 1000593000
    CooperativeMatrixFlexibleDimensionsPropertiesNv
    PhysicalDeviceCooperativeMatrix2PropertiesNv
    PhysicalDevicePipelineOpacityMicromapFeaturesArm = 1000596000
    ImportMemoryMetalHandleInfoExt = 1000602000
    MemoryMetalHandlePropertiesExt
    MemoryGetMetalHandleInfoExt
    PhysicalDevicePerformanceCountersByRegionFeaturesArm = 1000605000
    PhysicalDevicePerformanceCountersByRegionPropertiesArm
    PerformanceCounterArm
    PerformanceCounterDescriptionArm
    RenderPassPerformanceCountersByRegionBeginInfoArm
    PhysicalDeviceVertexAttributeRobustnessFeaturesExt = 1000608000
    PhysicalDeviceFormatPackFeaturesArm = 1000609000
    PhysicalDeviceFragmentDensityMapLayeredFeaturesValve = 1000611000
    PhysicalDeviceFragmentDensityMapLayeredPropertiesValve
    PipelineFragmentDensityMapLayeredCreateInfoValve
    SetPresentConfigNv = 1000613000
    PhysicalDevicePresentMeteringFeaturesNv
    RenderingEndInfoKhr = 1000619003
    PhysicalDeviceZeroInitializeDeviceMemoryFeaturesExt = 1000620000
    PhysicalDeviceShader64BitIndexingFeaturesExt = 1000627000
    PhysicalDeviceCustomResolveFeaturesExt = 1000628000
    BeginCustomResolveInfoExt
    CustomResolveCreateInfoExt
    PhysicalDeviceDataGraphModelFeaturesQcom = 1000629000
    DataGraphPipelineBuiltinModelCreateInfoQcom
    PhysicalDeviceMaintenance10FeaturesKhr = 1000630000
    PhysicalDeviceMaintenance10PropertiesKhr
    RenderingAttachmentFlagsInfoKhr
    ResolveImageModeInfoKhr = 1000630004
    PhysicalDeviceShaderLongVectorFeaturesExt = 1000635000
    PhysicalDeviceShaderLongVectorPropertiesExt
    PhysicalDevicePipelineCacheIncrementalModeFeaturesSec = 1000637000
    PhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesExt = 1000642000
    ComputeOccupancyPriorityParametersNv = 1000645000
    PhysicalDeviceComputeOccupancyPriorityFeaturesNv
    PhysicalDeviceShaderSubgroupPartitionedFeaturesExt = 1000662000
    UbmSurfaceCreateInfoSec = 1000664000
    PhysicalDeviceShaderMixedFloatDotProductFeaturesValve = 1000673000
    SurfaceCreateInfoOhos = 1000685000

  VkSubpassContents* {.size: sizeof(int32).} = enum
    Inline
    SecondaryCommandBuffers
    InlineAndSecondaryCommandBuffersKhr = 1000451000

  VkResult* {.size: sizeof(int32).} = enum
    VkErrorNotEnoughSpaceKhr = -1000483000
    VkErrorCompressionExhaustedExt = -1000338000
    VkErrorInvalidVideoStdParametersKhr = -1000299000
    VkErrorNoPipelineMatch = -1000298001
    VkErrorInvalidPipelineCacheData
    VkErrorInvalidOpaqueCaptureAddress = -1000257000
    VkErrorFullScreenExclusiveModeLostExt = -1000255000
    VkErrorPresentTimingQueueFullExt = -1000208000
    VkErrorNotPermitted = -1000174001
    VkErrorFragmentation = -1000161000
    VkErrorInvalidDrmFormatModifierPlaneLayoutExt = -1000158000
    VkErrorInvalidExternalHandle = -1000072003
    VkErrorOutOfPoolMemory = -1000069000
    VkErrorVideoStdVersionNotSupportedKhr = -1000023005
    VkErrorVideoProfileCodecNotSupportedKhr
    VkErrorVideoProfileFormatNotSupportedKhr
    VkErrorVideoProfileOperationNotSupportedKhr
    VkErrorVideoPictureLayoutNotSupportedKhr
    VkErrorImageUsageNotSupportedKhr
    VkErrorInvalidShaderNv = -1000012000
    VkErrorValidationFailed = -1000011001
    VkErrorIncompatibleDisplayKhr = -1000003001
    VkErrorOutOfDateKhr = -1000001004
    VkErrorNativeWindowInUseKhr = -1000000001
    VkErrorSurfaceLostKhr
    VkErrorUnknown = -13
    VkErrorFragmentedPool
    VkErrorFormatNotSupported
    VkErrorTooManyObjects
    VkErrorIncompatibleDriver
    VkErrorFeatureNotPresent
    VkErrorExtensionNotPresent
    VkErrorLayerNotPresent
    VkErrorMemoryMapFailed
    VkErrorDeviceLost
    VkErrorInitializationFailed
    VkErrorOutOfDeviceMemory
    VkErrorOutOfHostMemory
    VkSuccess
    VkNotReady
    VkTimeout
    VkEventSet
    VkEventReset
    VkIncomplete
    VkSuboptimalKhr = 1000001003
    VkThreadIdleKhr = 1000268000
    VkThreadDoneKhr
    VkOperationDeferredKhr
    VkOperationNotDeferredKhr
    VkPipelineCompileRequired = 1000297000
    VkIncompatibleShaderBinaryExt = 1000482000
    VkPipelineBinaryMissingKhr = 1000483000

  VkDynamicState* {.size: sizeof(int32).} = enum
    Viewport
    Scissor
    LineWidth
    DepthBias
    BlendConstants
    DepthBounds
    StencilCompareMask
    StencilWriteMask
    StencilReference
    ViewportWScalingNv = 1000087000
    DiscardRectangleExt = 1000099000
    DiscardRectangleEnableExt
    DiscardRectangleModeExt
    SampleLocationsExt = 1000143000
    ViewportShadingRatePaletteNv = 1000164004
    ViewportCoarseSampleOrderNv = 1000164006
    ExclusiveScissorEnableNv = 1000205000
    ExclusiveScissorNv
    FragmentShadingRateKhr = 1000226000
    LineStipple = 1000259000
    CullMode = 1000267000
    FrontFace
    PrimitiveTopology
    ViewportWithCount
    ScissorWithCount
    VertexInputBindingStride
    DepthTestEnable
    DepthWriteEnable
    DepthCompareOp
    DepthBoundsTestEnable
    StencilTestEnable
    StencilOp
    RayTracingPipelineStackSizeKhr = 1000347000
    VertexInputExt = 1000352000
    PatchControlPointsExt = 1000377000
    RasterizerDiscardEnable
    DepthBiasEnable
    LogicOpExt
    PrimitiveRestartEnable
    ColorWriteEnableExt = 1000381000
    TessellationDomainOriginExt = 1000455002
    DepthClampEnableExt
    PolygonModeExt
    RasterizationSamplesExt
    SampleMaskExt
    AlphaToCoverageEnableExt
    AlphaToOneEnableExt
    LogicOpEnableExt
    ColorBlendEnableExt
    ColorBlendEquationExt
    ColorWriteMaskExt
    RasterizationStreamExt
    ConservativeRasterizationModeExt
    ExtraPrimitiveOverestimationSizeExt
    DepthClipEnableExt
    SampleLocationsEnableExt
    ColorBlendAdvancedExt
    ProvokingVertexModeExt
    LineRasterizationModeExt
    LineStippleEnableExt
    DepthClipNegativeOneToOneExt
    ViewportWScalingEnableNv
    ViewportSwizzleNv
    CoverageToColorEnableNv
    CoverageToColorLocationNv
    CoverageModulationModeNv
    CoverageModulationTableEnableNv
    CoverageModulationTableNv
    ShadingRateImageEnableNv
    RepresentativeFragmentTestEnableNv
    CoverageReductionModeNv
    AttachmentFeedbackLoopEnableExt = 1000524000
    DepthClampRangeExt = 1000582000

  VkDescriptorUpdateTemplateType* {.size: sizeof(int32).} = enum
    DescriptorSet
    PushDescriptors

  VkObjectType* {.size: sizeof(int32).} = enum
    Unknown
    Instance
    PhysicalDevice
    Device
    Queue
    Semaphore
    CommandBuffer
    Fence
    DeviceMemory
    Buffer
    Image
    Event
    QueryPool
    BufferView
    ImageView
    ShaderModule
    PipelineCache
    PipelineLayout
    RenderPass
    Pipeline
    DescriptorSetLayout
    Sampler
    DescriptorPool
    DescriptorSet
    Framebuffer
    CommandPool
    SurfaceKhr = 1000000000
    SwapchainKhr = 1000001000
    DisplayKhr = 1000002000
    DisplayModeKhr
    DebugReportCallbackExt = 1000011000
    VideoSessionKhr = 1000023000
    VideoSessionParametersKhr
    CuModuleNvx = 1000029000
    CuFunctionNvx
    DescriptorUpdateTemplate = 1000085000
    DebugUtilsMessengerExt = 1000128000
    AccelerationStructureKhr = 1000150000
    SamplerYcbcrConversion = 1000156000
    ValidationCacheExt = 1000160000
    AccelerationStructureNv = 1000165000
    PerformanceConfigurationIntel = 1000210000
    DeferredOperationKhr = 1000268000
    IndirectCommandsLayoutNv = 1000277000
    PrivateDataSlot = 1000295000
    CudaModuleNv = 1000307000
    CudaFunctionNv
    BufferCollectionFuchsia = 1000366000
    MicromapExt = 1000396000
    TensorArm = 1000460000
    TensorViewArm
    OpticalFlowSessionNv = 1000464000
    ShaderExt = 1000482000
    PipelineBinaryKhr = 1000483000
    SemaphoreSciSyncPoolNv = 1000489000
    DataGraphPipelineSessionArm = 1000507000
    ExternalComputeQueueNv = 1000556000
    IndirectCommandsLayoutExt = 1000572000
    IndirectExecutionSetExt

  VkRayTracingInvocationReorderModeEXT* {.size: sizeof(int32).} = enum
    None
    Reorder

  VkRayTracingLssIndexingModeNV* {.size: sizeof(int32).} = enum
    List
    Successive

  VkRayTracingLssPrimitiveEndCapsModeNV* {.size: sizeof(int32).} = enum
    None
    Chained

  VkDirectDriverLoadingModeLUNARG* {.size: sizeof(int32).} = enum
    Exclusive
    Inclusive

  VkAntiLagModeAMD* {.size: sizeof(int32).} = enum
    DriverControl
    On
    Off

  VkAntiLagStageAMD* {.size: sizeof(int32).} = enum
    Input
    Present

  VkQueueFlagBits* {.size: sizeof(int32).} = enum
    GraphicsBit = 1
    ComputeBit
    TransferBit = 4
    SparseBindingBit = 8
    ProtectedBit = 16
    VideoDecodeBitKhr = 32
    VideoEncodeBitKhr = 64
    OpticalFlowBitNv = 256
    DataGraphBitArm = 1024

  VkCullModeFlagBits* {.size: sizeof(int32).} = enum
    None
    FrontBit
    BackBit
    FrontAndBack

  VkRenderPassCreateFlagBits* {.size: sizeof(int32).} = enum
    TransformBitQcom = 2
    PerLayerFragmentDensityBitValve = 4

  VkDeviceQueueCreateFlagBits* {.size: sizeof(int32).} = enum
    ProtectedBit = 1
    InternallySynchronizedBitKhr = 4

  VkMemoryPropertyFlagBits* {.size: sizeof(int32).} = enum
    DeviceLocalBit = 1
    HostVisibleBit
    HostCoherentBit = 4
    HostCachedBit = 8
    LazilyAllocatedBit = 16
    ProtectedBit = 32
    DeviceCoherentBitAmd = 64
    DeviceUncachedBitAmd = 128
    RdmaCapableBitNv = 256

  VkMemoryHeapFlagBits* {.size: sizeof(int32).} = enum
    DeviceLocalBit = 1
    MultiInstanceBit
    SeuSafeBit = 4
    TileMemoryBitQcom = 8

  VkAccessFlagBits* {.size: sizeof(int32).} = enum
    None
    IndirectCommandReadBit
    IndexReadBit
    VertexAttributeReadBit = 4
    UniformReadBit = 8
    InputAttachmentReadBit = 16
    ShaderReadBit = 32
    ShaderWriteBit = 64
    ColorAttachmentReadBit = 128
    ColorAttachmentWriteBit = 256
    DepthStencilAttachmentReadBit = 512
    DepthStencilAttachmentWriteBit = 1024
    TransferReadBit = 2048
    TransferWriteBit = 4096
    HostReadBit = 8192
    HostWriteBit = 16384
    MemoryReadBit = 32768
    MemoryWriteBit = 65536
    CommandPreprocessReadBitExt = 131072
    CommandPreprocessWriteBitExt = 262144
    ColorAttachmentReadNoncoherentBitExt = 524288
    ConditionalRenderingReadBitExt = 1048576
    AccelerationStructureReadBitKhr = 2097152
    AccelerationStructureWriteBitKhr = 4194304
    FragmentShadingRateAttachmentReadBitKhr = 8388608
    FragmentDensityMapReadBitExt = 16777216
    TransformFeedbackWriteBitExt = 33554432
    TransformFeedbackCounterReadBitExt = 67108864
    TransformFeedbackCounterWriteBitExt = 134217728

  VkBufferUsageFlagBits* {.size: sizeof(int32).} = enum
    TransferSrcBit = 1
    TransferDstBit
    UniformTexelBufferBit = 4
    StorageTexelBufferBit = 8
    UniformBufferBit = 16
    StorageBufferBit = 32
    IndexBufferBit = 64
    VertexBufferBit = 128
    IndirectBufferBit = 256
    ConditionalRenderingBitExt = 512
    ShaderBindingTableBitKhr = 1024
    TransformFeedbackBufferBitExt = 2048
    TransformFeedbackCounterBufferBitExt = 4096
    VideoDecodeSrcBitKhr = 8192
    VideoDecodeDstBitKhr = 16384
    VideoEncodeDstBitKhr = 32768
    VideoEncodeSrcBitKhr = 65536
    ShaderDeviceAddressBit = 131072
    AccelerationStructureBuildInputReadOnlyBitKhr = 524288
    AccelerationStructureStorageBitKhr = 1048576
    SamplerDescriptorBufferBitExt = 2097152
    ResourceDescriptorBufferBitExt = 4194304
    MicromapBuildInputReadOnlyBitExt = 8388608
    MicromapStorageBitExt = 16777216
    ExecutionGraphScratchBitAmdx = 33554432
    PushDescriptorsDescriptorBufferBitExt = 67108864
    TileMemoryBitQcom = 134217728
    DescriptorHeapBitExt = 268435456

  VkBufferUsageFlagBits2* {.size: sizeof(int32).} = enum
    TransferSrcBit = 1
    TransferDstBit
    UniformTexelBufferBit = 4
    StorageTexelBufferBit = 8
    UniformBufferBit = 16
    StorageBufferBit = 32
    IndexBufferBit = 64
    VertexBufferBit = 128
    IndirectBufferBit = 256
    ConditionalRenderingBitExt = 512
    ShaderBindingTableBitKhr = 1024
    TransformFeedbackBufferBitExt = 2048
    TransformFeedbackCounterBufferBitExt = 4096
    VideoDecodeSrcBitKhr = 8192
    VideoDecodeDstBitKhr = 16384
    VideoEncodeDstBitKhr = 32768
    VideoEncodeSrcBitKhr = 65536
    ShaderDeviceAddressBit = 131072
    AccelerationStructureBuildInputReadOnlyBitKhr = 524288
    AccelerationStructureStorageBitKhr = 1048576
    SamplerDescriptorBufferBitExt = 2097152
    ResourceDescriptorBufferBitExt = 4194304
    MicromapBuildInputReadOnlyBitExt = 8388608
    MicromapStorageBitExt = 16777216
    ExecutionGraphScratchBitAmdx = 33554432
    PushDescriptorsDescriptorBufferBitExt = 67108864
    TileMemoryBitQcom = 134217728
    DescriptorHeapBitExt = 268435456
    DataGraphForeignDescriptorBitArm = 536870912
    PreprocessBufferBitExt = 2147483648
    MemoryDecompressionBitExt = 4294967296
    CompressedDataDgf1BitAmdx = 8589934592

  VkBufferCreateFlagBits* {.size: sizeof(int32).} = enum
    SparseBindingBit = 1
    SparseResidencyBit
    SparseAliasedBit = 4
    ProtectedBit = 8
    DeviceAddressCaptureReplayBit = 16
    DescriptorBufferCaptureReplayBitExt = 32
    VideoProfileIndependentBitKhr = 64

  VkShaderStageFlagBits* {.size: sizeof(int32).} = enum
    VertexBit = 1
    TessellationControlBit
    TessellationEvaluationBit = 4
    GeometryBit = 8
    FragmentBit = 16
    AllGraphics = 31
    ComputeBit
    TaskBitExt = 64
    MeshBitExt = 128
    RaygenBitKhr = 256
    AnyHitBitKhr = 512
    ClosestHitBitKhr = 1024
    MissBitKhr = 2048
    IntersectionBitKhr = 4096
    CallableBitKhr = 8192
    SubpassShadingBitHuawei = 16384
    ClusterCullingBitHuawei = 524288
    All = 2147483647

  VkImageUsageFlagBits* {.size: sizeof(int32).} = enum
    TransferSrcBit = 1
    TransferDstBit
    SampledBit = 4
    StorageBit = 8
    ColorAttachmentBit = 16
    DepthStencilAttachmentBit = 32
    TransientAttachmentBit = 64
    InputAttachmentBit = 128
    FragmentShadingRateAttachmentBitKhr = 256
    FragmentDensityMapBitExt = 512
    VideoDecodeDstBitKhr = 1024
    VideoDecodeSrcBitKhr = 2048
    VideoDecodeDpbBitKhr = 4096
    VideoEncodeDstBitKhr = 8192
    VideoEncodeSrcBitKhr = 16384
    VideoEncodeDpbBitKhr = 32768
    InvocationMaskBitHuawei = 262144
    AttachmentFeedbackLoopBitExt = 524288
    SampleWeightBitQcom = 1048576
    SampleBlockMatchBitQcom = 2097152
    HostTransferBit = 4194304
    TensorAliasingBitArm = 8388608
    VideoEncodeQuantizationDeltaMapBitKhr = 33554432
    VideoEncodeEmphasisMapBitKhr = 67108864
    TileMemoryBitQcom = 134217728

  VkImageCreateFlagBits* {.size: sizeof(int32).} = enum
    SparseBindingBit = 1
    SparseResidencyBit
    SparseAliasedBit = 4
    MutableFormatBit = 8
    CubeCompatibleBit = 16
    N2dArrayCompatibleBit = 32
    SplitInstanceBindRegionsBit = 64
    BlockTexelViewCompatibleBit = 128
    ExtendedUsageBit = 256
    DisjointBit = 512
    AliasBit = 1024
    ProtectedBit = 2048
    SampleLocationsCompatibleDepthBitExt = 4096
    CornerSampledBitNv = 8192
    SubsampledBitExt = 16384
    FragmentDensityMapOffsetBitExt = 32768
    DescriptorHeapCaptureReplayBitExt = 65536
    N2dViewCompatibleBitExt = 131072
    MultisampledRenderToSingleSampledBitExt = 262144
    VideoProfileIndependentBitKhr = 1048576

  VkImageViewCreateFlagBits* {.size: sizeof(int32).} = enum
    FragmentDensityMapDynamicBitExt = 1
    FragmentDensityMapDeferredBitExt
    DescriptorBufferCaptureReplayBitExt = 4

  VkSamplerCreateFlagBits* {.size: sizeof(int32).} = enum
    SubsampledBitExt = 1
    SubsampledCoarseReconstructionBitExt
    NonSeamlessCubeMapBitExt = 4
    DescriptorBufferCaptureReplayBitExt = 8
    ImageProcessingBitQcom = 16

  VkPipelineCreateFlagBits* {.size: sizeof(int32).} = enum
    DisableOptimizationBit = 1
    AllowDerivativesBit
    DerivativeBit = 4
    ViewIndexFromDeviceIndexBit = 8
    DispatchBaseBit = 16
    DeferCompileBitNv = 32
    CaptureStatisticsBitKhr = 64
    CaptureInternalRepresentationsBitKhr = 128
    FailOnPipelineCompileRequiredBit = 256
    EarlyReturnOnFailureBit = 512
    LinkTimeOptimizationBitExt = 1024
    LibraryBitKhr = 2048
    RayTracingSkipTrianglesBitKhr = 4096
    RayTracingSkipAabbsBitKhr = 8192
    RayTracingNoNullAnyHitShadersBitKhr = 16384
    RayTracingNoNullClosestHitShadersBitKhr = 32768
    RayTracingNoNullMissShadersBitKhr = 65536
    RayTracingNoNullIntersectionShadersBitKhr = 131072
    IndirectBindableBitNv = 262144
    RayTracingShaderGroupHandleCaptureReplayBitKhr = 524288
    RayTracingAllowMotionBitNv = 1048576
    RenderingFragmentShadingRateAttachmentBitKhr = 2097152
    RenderingFragmentDensityMapAttachmentBitExt = 4194304
    RetainLinkTimeOptimizationInfoBitExt = 8388608
    RayTracingOpacityMicromapBitExt = 16777216
    ColorAttachmentFeedbackLoopBitExt = 33554432
    DepthStencilAttachmentFeedbackLoopBitExt = 67108864
    NoProtectedAccessBit = 134217728
    RayTracingDisplacementMicromapBitNv = 268435456
    DescriptorBufferBitExt = 536870912
    ProtectedAccessOnlyBit = 1073741824

  VkPipelineCreateFlagBits2* {.size: sizeof(int32).} = enum
    DisableOptimizationBit = 1
    AllowDerivativesBit
    DerivativeBit = 4
    ViewIndexFromDeviceIndexBit = 8
    DispatchBaseBit = 16
    DeferCompileBitNv = 32
    CaptureStatisticsBitKhr = 64
    CaptureInternalRepresentationsBitKhr = 128
    FailOnPipelineCompileRequiredBit = 256
    EarlyReturnOnFailureBit = 512
    LinkTimeOptimizationBitExt = 1024
    LibraryBitKhr = 2048
    RayTracingSkipTrianglesBitKhr = 4096
    RayTracingSkipAabbsBitKhr = 8192
    RayTracingNoNullAnyHitShadersBitKhr = 16384
    RayTracingNoNullClosestHitShadersBitKhr = 32768
    RayTracingNoNullMissShadersBitKhr = 65536
    RayTracingNoNullIntersectionShadersBitKhr = 131072
    IndirectBindableBitNv = 262144
    RayTracingShaderGroupHandleCaptureReplayBitKhr = 524288
    RayTracingAllowMotionBitNv = 1048576
    RenderingFragmentShadingRateAttachmentBitKhr = 2097152
    RenderingFragmentDensityMapAttachmentBitExt = 4194304
    RetainLinkTimeOptimizationInfoBitExt = 8388608
    RayTracingOpacityMicromapBitExt = 16777216
    ColorAttachmentFeedbackLoopBitExt = 33554432
    DepthStencilAttachmentFeedbackLoopBitExt = 67108864
    NoProtectedAccessBit = 134217728
    RayTracingDisplacementMicromapBitNv = 268435456
    DescriptorBufferBitExt = 536870912
    ProtectedAccessOnlyBit = 1073741824
    CaptureDataBitKhr = 2147483648
    ExecutionGraphBitAmdx = 4294967296
    RayTracingAllowSpheresAndLinearSweptSpheresBitNv = 8589934592
    EnableLegacyDitheringBitExt = 17179869184
    DescriptorHeapBitExt = 68719476736
    DisallowOpacityMicromapBitArm = 137438953472
    IndirectBindableBitExt = 274877906944
    PerLayerFragmentDensityBitValve = 1099511627776
    N64BitIndexingBitExt = 8796093022208

  VkPipelineShaderStageCreateFlagBits* {.size: sizeof(int32).} = enum
    AllowVaryingSubgroupSizeBit = 1
    RequireFullSubgroupsBit

  VkColorComponentFlagBits* {.size: sizeof(int32).} = enum
    RBit = 1
    GBit
    BBit = 4
    ABit = 8

  VkFenceCreateFlagBits* {.size: sizeof(int32).} = enum
    SignaledBit = 1

  VkFormatFeatureFlagBits* {.size: sizeof(int32).} = enum
    SampledImageBit = 1
    StorageImageBit
    StorageImageAtomicBit = 4
    UniformTexelBufferBit = 8
    StorageTexelBufferBit = 16
    StorageTexelBufferAtomicBit = 32
    VertexBufferBit = 64
    ColorAttachmentBit = 128
    ColorAttachmentBlendBit = 256
    DepthStencilAttachmentBit = 512
    BlitSrcBit = 1024
    BlitDstBit = 2048
    SampledImageFilterLinearBit = 4096
    SampledImageFilterCubicBitExt = 8192
    TransferSrcBit = 16384
    TransferDstBit = 32768
    SampledImageFilterMinmaxBit = 65536
    MidpointChromaSamplesBit = 131072
    SampledImageYcbcrConversionLinearFilterBit = 262144
    SampledImageYcbcrConversionSeparateReconstructionFilterBit = 524288
    SampledImageYcbcrConversionChromaReconstructionExplicitBit = 1048576
    SampledImageYcbcrConversionChromaReconstructionExplicitForceableBit = 2097152
    DisjointBit = 4194304
    CositedChromaSamplesBit = 8388608
    FragmentDensityMapBitExt = 16777216
    VideoDecodeOutputBitKhr = 33554432
    VideoDecodeDpbBitKhr = 67108864
    VideoEncodeInputBitKhr = 134217728
    VideoEncodeDpbBitKhr = 268435456
    AccelerationStructureVertexBufferBitKhr = 536870912
    FragmentShadingRateAttachmentBitKhr = 1073741824

  VkQueryControlFlagBits* {.size: sizeof(int32).} = enum
    PreciseBit = 1

  VkQueryResultFlagBits* {.size: sizeof(int32).} = enum
    N64Bit = 1
    WaitBit
    WithAvailabilityBit = 4
    PartialBit = 8
    WithStatusBitKhr = 16

  VkCommandBufferUsageFlagBits* {.size: sizeof(int32).} = enum
    OneTimeSubmitBit = 1
    RenderPassContinueBit
    SimultaneousUseBit = 4

  VkQueryPipelineStatisticFlagBits* {.size: sizeof(int32).} = enum
    InputAssemblyVerticesBit = 1
    InputAssemblyPrimitivesBit
    VertexShaderInvocationsBit = 4
    GeometryShaderInvocationsBit = 8
    GeometryShaderPrimitivesBit = 16
    ClippingInvocationsBit = 32
    ClippingPrimitivesBit = 64
    FragmentShaderInvocationsBit = 128
    TessellationControlShaderPatchesBit = 256
    TessellationEvaluationShaderInvocationsBit = 512
    ComputeShaderInvocationsBit = 1024
    TaskShaderInvocationsBitExt = 2048
    MeshShaderInvocationsBitExt = 4096
    ClusterCullingShaderInvocationsBitHuawei = 8192

  VkMemoryMapFlagBits* {.size: sizeof(int32).} = enum
    PlacedBitExt = 1

  VkImageAspectFlagBits* {.size: sizeof(int32).} = enum
    None
    ColorBit
    DepthBit
    StencilBit = 4
    MetadataBit = 8
    Plane0Bit = 16
    Plane1Bit = 32
    Plane2Bit = 64
    MemoryPlane0BitExt = 128
    MemoryPlane1BitExt = 256
    MemoryPlane2BitExt = 512
    MemoryPlane3BitExt = 1024

  VkSparseImageFormatFlagBits* {.size: sizeof(int32).} = enum
    SingleMiptailBit = 1
    AlignedMipSizeBit
    NonstandardBlockSizeBit = 4

  VkSparseMemoryBindFlagBits* {.size: sizeof(int32).} = enum
    MetadataBit = 1

  VkPipelineStageFlagBits* {.size: sizeof(int32).} = enum
    None
    TopOfPipeBit
    DrawIndirectBit
    VertexInputBit = 4
    VertexShaderBit = 8
    TessellationControlShaderBit = 16
    TessellationEvaluationShaderBit = 32
    GeometryShaderBit = 64
    FragmentShaderBit = 128
    EarlyFragmentTestsBit = 256
    LateFragmentTestsBit = 512
    ColorAttachmentOutputBit = 1024
    ComputeShaderBit = 2048
    TransferBit = 4096
    BottomOfPipeBit = 8192
    HostBit = 16384
    AllGraphicsBit = 32768
    AllCommandsBit = 65536
    CommandPreprocessBitExt = 131072
    ConditionalRenderingBitExt = 262144
    TaskShaderBitExt = 524288
    MeshShaderBitExt = 1048576
    RayTracingShaderBitKhr = 2097152
    FragmentShadingRateAttachmentBitKhr = 4194304
    FragmentDensityProcessBitExt = 8388608
    TransformFeedbackBitExt = 16777216
    AccelerationStructureBuildBitKhr = 33554432

  VkCommandPoolCreateFlagBits* {.size: sizeof(int32).} = enum
    TransientBit = 1
    ResetCommandBufferBit
    ProtectedBit = 4

  VkCommandPoolResetFlagBits* {.size: sizeof(int32).} = enum
    ReleaseResourcesBit = 1

  VkCommandBufferResetFlagBits* {.size: sizeof(int32).} = enum
    ReleaseResourcesBit = 1

  VkSampleCountFlagBits* {.size: sizeof(int32).} = enum
    N1Bit = 1
    N2Bit
    N4Bit = 4
    N8Bit = 8
    N16Bit = 16
    N32Bit = 32
    N64Bit = 64

  VkAttachmentDescriptionFlagBits* {.size: sizeof(int32).} = enum
    MayAliasBit = 1
    ResolveSkipTransferFunctionBitKhr
    ResolveEnableTransferFunctionBitKhr = 4

  VkStencilFaceFlagBits* {.size: sizeof(int32).} = enum
    FrontBit = 1
    BackBit
    FrontAndBack

  VkDescriptorPoolCreateFlagBits* {.size: sizeof(int32).} = enum
    FreeDescriptorSetBit = 1
    UpdateAfterBindBit
    HostOnlyBitExt = 4
    AllowOverallocationSetsBitNv = 8
    AllowOverallocationPoolsBitNv = 16

  VkDependencyFlagBits* {.size: sizeof(int32).} = enum
    ByRegionBit = 1
    ViewLocalBit
    DeviceGroupBit = 4
    FeedbackLoopBitExt = 8
    QueueFamilyOwnershipTransferUseAllStagesBitKhr = 32
    AsymmetricEventBitKhr = 64

  VkSemaphoreType* {.size: sizeof(int32).} = enum
    Binary
    Timeline

  VkSemaphoreWaitFlagBits* {.size: sizeof(int32).} = enum
    AnyBit = 1

  VkPresentModeKHR* {.size: sizeof(int32).} = enum
    Immediate
    Mailbox
    Fifo
    FifoRelaxed
    SharedDemandRefresh = 1000111000
    SharedContinuousRefresh
    FifoLatestReady = 1000361000

  VkColorSpaceKHR* {.size: sizeof(int32).} = enum
    SrgbNonlinear
    DisplayP3NonlinearExt = 1000104001
    ExtendedSrgbLinearExt
    DisplayP3LinearExt
    DciP3NonlinearExt
    Bt709LinearExt
    Bt709NonlinearExt
    Bt2020LinearExt
    Hdr10St2084Ext
    Hdr10HlgExt = 1000104010
    AdobergbLinearExt
    AdobergbNonlinearExt
    PassThroughExt
    ExtendedSrgbNonlinearExt
    DisplayNativeAmd = 1000213000

  VkDisplayPlaneAlphaFlagBitsKHR* {.size: sizeof(int32).} = enum
    OpaqueBit = 1
    GlobalBit
    PerPixelBit = 4
    PerPixelPremultipliedBit = 8

  VkCompositeAlphaFlagBitsKHR* {.size: sizeof(int32).} = enum
    OpaqueBit = 1
    PreMultipliedBit
    PostMultipliedBit = 4
    InheritBit = 8

  VkSurfaceTransformFlagBitsKHR* {.size: sizeof(int32).} = enum
    IdentityBit = 1
    Rotate90Bit
    Rotate180Bit = 4
    Rotate270Bit = 8
    HorizontalMirrorBit = 16
    HorizontalMirrorRotate90Bit = 32
    HorizontalMirrorRotate180Bit = 64
    HorizontalMirrorRotate270Bit = 128
    InheritBit = 256

  VkDisplaySurfaceStereoTypeNV* {.size: sizeof(int32).} = enum
    None
    OnboardDin
    Hdmi3d
    InbandDisplayport

  VkSwapchainImageUsageFlagBitsANDROID* {.size: sizeof(int32).} = enum
    SharedBit = 1

  VkTimeDomainKHR* {.size: sizeof(int32).} = enum
    Device
    ClockMonotonic
    ClockMonotonicRaw
    QueryPerformanceCounter
    PresentStageLocalExt = 1000208000
    SwapchainLocalExt

  VkDebugReportFlagBitsEXT* {.size: sizeof(int32).} = enum
    InformationBit = 1
    WarningBit
    PerformanceWarningBit = 4
    ErrorBit = 8
    DebugBit = 16

  VkDebugReportObjectTypeEXT* {.size: sizeof(int32).} = enum
    Unknown
    Instance
    PhysicalDevice
    Device
    Queue
    Semaphore
    CommandBuffer
    Fence
    DeviceMemory
    Buffer
    Image
    Event
    QueryPool
    BufferView
    ImageView
    ShaderModule
    PipelineCache
    PipelineLayout
    RenderPass
    Pipeline
    DescriptorSetLayout
    Sampler
    DescriptorPool
    DescriptorSet
    Framebuffer
    CommandPool
    SurfaceKhr
    SwapchainKhr
    DebugReportCallbackExt
    DisplayKhr
    DisplayModeKhr
    ValidationCacheExt = 33
    CuModuleNvx = 1000029000
    CuFunctionNvx
    DescriptorUpdateTemplate = 1000085000
    AccelerationStructureKhr = 1000150000
    SamplerYcbcrConversion = 1000156000
    AccelerationStructureNv = 1000165000
    CudaModuleNv = 1000307000
    CudaFunctionNv
    BufferCollectionFuchsia = 1000366000

  VkDeviceMemoryReportEventTypeEXT* {.size: sizeof(int32).} = enum
    Allocate
    Free
    Import
    Unimport
    AllocationFailed

  VkRasterizationOrderAMD* {.size: sizeof(int32).} = enum
    Strict
    Relaxed

  VkExternalMemoryHandleTypeFlagBitsNV* {.size: sizeof(int32).} = enum
    OpaqueWin32Bit = 1
    OpaqueWin32KmtBit
    D3d11ImageBit = 4
    D3d11ImageKmtBit = 8

  VkExternalMemoryFeatureFlagBitsNV* {.size: sizeof(int32).} = enum
    DedicatedOnlyBit = 1
    ExportableBit
    ImportableBit = 4

  VkClusterAccelerationStructureIndexFormatFlagBitsNV* {.size: sizeof(int32).} = enum
    N8bit = 1
    N16bit
    N32bit = 4

  VkClusterAccelerationStructureTypeNV* {.size: sizeof(int32).} = enum
    ClustersBottomLevel
    TriangleCluster
    TriangleClusterTemplate

  VkClusterAccelerationStructureOpTypeNV* {.size: sizeof(int32).} = enum
    MoveObjects
    BuildClustersBottomLevel
    BuildTriangleCluster
    BuildTriangleClusterTemplate
    InstantiateTriangleCluster
    GetClusterTemplateIndices

  VkClusterAccelerationStructureOpModeNV* {.size: sizeof(int32).} = enum
    ImplicitDestinations
    ExplicitDestinations
    ComputeSizes

  VkClusterAccelerationStructureClusterFlagBitsNV* {.size: sizeof(int32).} = enum
    AllowDisableOpacityMicromaps = 1

  VkClusterAccelerationStructureGeometryFlagBitsNV* {.size: sizeof(int32).} = enum
    CullDisableBit = 1
    NoDuplicateAnyhitInvocationBit
    OpaqueBit = 4

  VkClusterAccelerationStructureAddressResolutionFlagBitsNV* {.size: sizeof(int32).} = enum
    None
    IndirectedDstImplicitDataBit
    IndirectedScratchDataBit
    IndirectedDstAddressArrayBit = 4
    IndirectedDstSizesArrayBit = 8
    IndirectedSrcInfosArrayBit = 16
    IndirectedSrcInfosCountBit = 32

  VkValidationCheckEXT* {.size: sizeof(int32).} = enum
    All
    Shaders

  VkValidationFeatureEnableEXT* {.size: sizeof(int32).} = enum
    GpuAssisted
    GpuAssistedReserveBindingSlot
    BestPractices
    DebugPrintf
    SynchronizationValidation

  VkValidationFeatureDisableEXT* {.size: sizeof(int32).} = enum
    All
    Shaders
    ThreadSafety
    ApiParameters
    ObjectLifetimes
    CoreChecks
    UniqueHandles
    ShaderValidationCache

  VkLayerSettingTypeEXT* {.size: sizeof(int32).} = enum
    Bool32
    Int32
    Int64
    Uint32
    Uint64
    Float32
    Float64
    String

  VkSubgroupFeatureFlagBits* {.size: sizeof(int32).} = enum
    BasicBit = 1
    VoteBit
    ArithmeticBit = 4
    BallotBit = 8
    ShuffleBit = 16
    ShuffleRelativeBit = 32
    ClusteredBit = 64
    QuadBit = 128
    PartitionedBitExt = 256
    RotateBit = 512
    RotateClusteredBit = 1024

  VkIndirectCommandsLayoutUsageFlagBitsNV* {.size: sizeof(int32).} = enum
    ExplicitPreprocessBit = 1
    IndexedSequencesBit
    UnorderedSequencesBit = 4

  VkIndirectStateFlagBitsNV* {.size: sizeof(int32).} = enum
    FlagFrontfaceBit = 1

  VkIndirectCommandsTokenTypeNV* {.size: sizeof(int32).} = enum
    ShaderGroup
    StateFlags
    IndexBuffer
    VertexBuffer
    PushConstant
    DrawIndexed
    Draw
    DrawTasks
    PushData = 1000135000
    DrawMeshTasks = 1000328000
    Pipeline = 1000428003
    Dispatch

  VkDescriptorSetLayoutCreateFlagBits* {.size: sizeof(int32).} = enum
    PushDescriptorBit = 1
    UpdateAfterBindPoolBit
    HostOnlyPoolBitExt = 4
    DescriptorBufferBitExt = 16
    EmbeddedImmutableSamplersBitExt = 32
    PerStageBitNv = 64
    IndirectBindableBitNv = 128

  VkExternalMemoryHandleTypeFlagBits* {.size: sizeof(int32).} = enum
    OpaqueFdBit = 1
    OpaqueWin32Bit
    OpaqueWin32KmtBit = 4
    D3d11TextureBit = 8
    D3d11TextureKmtBit = 16
    D3d12HeapBit = 32
    D3d12ResourceBit = 64
    HostAllocationBitExt = 128
    HostMappedForeignMemoryBitExt = 256
    DmaBufBitExt = 512
    AndroidHardwareBufferBitAndroid = 1024
    ZirconVmoBitFuchsia = 2048
    RdmaAddressBitNv = 4096
    SciBufBitNv = 8192
    ScreenBufferBitQnx = 16384
    OhNativeBufferBitOhos = 32768
    MtlbufferBitExt = 65536
    MtltextureBitExt = 131072
    MtlheapBitExt = 262144

  VkExternalMemoryFeatureFlagBits* {.size: sizeof(int32).} = enum
    DedicatedOnlyBit = 1
    ExportableBit
    ImportableBit = 4

  VkExternalSemaphoreHandleTypeFlagBits* {.size: sizeof(int32).} = enum
    OpaqueFdBit = 1
    OpaqueWin32Bit
    OpaqueWin32KmtBit = 4
    D3d12FenceBit = 8
    SyncFdBit = 16
    SciSyncObjBitNv = 32
    ZirconEventBitFuchsia = 128

  VkExternalSemaphoreFeatureFlagBits* {.size: sizeof(int32).} = enum
    ExportableBit = 1
    ImportableBit

  VkSemaphoreImportFlagBits* {.size: sizeof(int32).} = enum
    TemporaryBit = 1

  VkExternalFenceHandleTypeFlagBits* {.size: sizeof(int32).} = enum
    OpaqueFdBit = 1
    OpaqueWin32Bit
    OpaqueWin32KmtBit = 4
    SyncFdBit = 8
    SciSyncObjBitNv = 16
    SciSyncFenceBitNv = 32

  VkExternalFenceFeatureFlagBits* {.size: sizeof(int32).} = enum
    ExportableBit = 1
    ImportableBit

  VkFenceImportFlagBits* {.size: sizeof(int32).} = enum
    TemporaryBit = 1

  VkSurfaceCounterFlagBitsEXT* {.size: sizeof(int32).} = enum
    VblankBit = 1

  VkDisplayPowerStateEXT* {.size: sizeof(int32).} = enum
    Off
    Suspend
    On

  VkDeviceEventTypeEXT* {.size: sizeof(int32).} = enum
    DisplayHotplug

  VkDisplayEventTypeEXT* {.size: sizeof(int32).} = enum
    FirstPixelOut

  VkPeerMemoryFeatureFlagBits* {.size: sizeof(int32).} = enum
    CopySrcBit = 1
    CopyDstBit
    GenericSrcBit = 4
    GenericDstBit = 8

  VkMemoryAllocateFlagBits* {.size: sizeof(int32).} = enum
    DeviceMaskBit = 1
    DeviceAddressBit
    DeviceAddressCaptureReplayBit = 4
    ZeroInitializeBitExt = 8

  VkDeviceGroupPresentModeFlagBitsKHR* {.size: sizeof(int32).} = enum
    LocalBit = 1
    RemoteBit
    SumBit = 4
    LocalMultiDeviceBit = 8

  VkSwapchainCreateFlagBitsKHR* {.size: sizeof(int32).} = enum
    SplitInstanceBindRegionsBit = 1
    ProtectedBit
    MutableFormatBit = 4
    DeferredMemoryAllocationBit = 8
    PresentId2Bit = 64
    PresentWait2Bit = 128
    PresentTimingBitExt = 512

  VkViewportCoordinateSwizzleNV* {.size: sizeof(int32).} = enum
    PositiveX
    NegativeX
    PositiveY
    NegativeY
    PositiveZ
    NegativeZ
    PositiveW
    NegativeW

  VkDiscardRectangleModeEXT* {.size: sizeof(int32).} = enum
    Inclusive
    Exclusive

  VkSubpassDescriptionFlagBits* {.size: sizeof(int32).} = enum
    PerViewAttributesBitNvx = 1
    PerViewPositionXOnlyBitNvx
    FragmentRegionBitExt = 4
    CustomResolveBitExt = 8
    RasterizationOrderAttachmentColorAccessBitExt = 16
    RasterizationOrderAttachmentDepthAccessBitExt = 32
    RasterizationOrderAttachmentStencilAccessBitExt = 64
    EnableLegacyDitheringBitExt = 128
    TileShadingApronBitQcom = 256

  VkPointClippingBehavior* {.size: sizeof(int32).} = enum
    AllClipPlanes
    UserClipPlanesOnly

  VkSamplerReductionMode* {.size: sizeof(int32).} = enum
    WeightedAverage
    Min
    Max
    WeightedAverageRangeclampQcom = 1000521000

  VkTessellationDomainOrigin* {.size: sizeof(int32).} = enum
    UpperLeft
    LowerLeft

  VkSamplerYcbcrModelConversion* {.size: sizeof(int32).} = enum
    RgbIdentity
    YcbcrIdentity
    Ycbcr709
    Ycbcr601
    Ycbcr2020

  VkSamplerYcbcrRange* {.size: sizeof(int32).} = enum
    ItuFull
    ItuNarrow

  VkChromaLocation* {.size: sizeof(int32).} = enum
    CositedEven
    Midpoint

  VkBlendOverlapEXT* {.size: sizeof(int32).} = enum
    Uncorrelated
    Disjoint
    Conjoint

  VkCoverageModulationModeNV* {.size: sizeof(int32).} = enum
    None
    Rgb
    Alpha
    Rgba

  VkCoverageReductionModeNV* {.size: sizeof(int32).} = enum
    Merge
    Truncate

  VkValidationCacheHeaderVersionEXT* {.size: sizeof(int32).} = enum
    One = 1

  VkShaderInfoTypeAMD* {.size: sizeof(int32).} = enum
    Statistics
    Binary
    Disassembly

  VkQueueGlobalPriority* {.size: sizeof(int32).} = enum
    Low = 128
    Medium = 256
    High = 512
    Realtime = 1024

  VkDebugUtilsMessageSeverityFlagBitsEXT* {.size: sizeof(int32).} = enum
    VerboseBit = 1
    InfoBit = 16
    WarningBit = 256
    ErrorBit = 4096

  VkDebugUtilsMessageTypeFlagBitsEXT* {.size: sizeof(int32).} = enum
    GeneralBit = 1
    ValidationBit
    PerformanceBit = 4
    DeviceAddressBindingBit = 8

  VkConservativeRasterizationModeEXT* {.size: sizeof(int32).} = enum
    Disabled
    Overestimate
    Underestimate

  VkDescriptorBindingFlagBits* {.size: sizeof(int32).} = enum
    UpdateAfterBindBit = 1
    UpdateUnusedWhilePendingBit
    PartiallyBoundBit = 4
    VariableDescriptorCountBit = 8

  VkVendorId* {.size: sizeof(int32).} = enum
    Khronos = 65536
    Viv
    Vsi
    Kazan
    Codeplay
    Mesa
    Pocl
    Mobileye

  VkDriverId* {.size: sizeof(int32).} = enum
    AmdProprietary = 1
    AmdOpenSource
    MesaRadv
    NvidiaProprietary
    IntelProprietaryWindows
    IntelOpenSourceMesa
    ImaginationProprietary
    QualcommProprietary
    ArmProprietary
    GoogleSwiftshader
    GgpProprietary
    BroadcomProprietary
    MesaLlvmpipe
    Moltenvk
    CoreaviProprietary
    JuiceProprietary
    VerisiliconProprietary
    MesaTurnip
    MesaV3dv
    MesaPanvk
    SamsungProprietary
    MesaVenus
    MesaDozen
    MesaNvk
    ImaginationOpenSourceMesa
    MesaHoneykrisp
    VulkanScEmulationOnVulkan
    MesaKosmickrisp

  VkConditionalRenderingFlagBitsEXT* {.size: sizeof(int32).} = enum
    InvertedBit = 1

  VkResolveModeFlagBits* {.size: sizeof(int32).} = enum
    None
    SampleZeroBit
    AverageBit
    MinBit = 4
    MaxBit = 8
    ExternalFormatDownsampleBitAndroid = 16
    CustomBitExt = 32

  VkShadingRatePaletteEntryNV* {.size: sizeof(int32).} = enum
    NoInvocations
    N16InvocationsPerPixel
    N8InvocationsPerPixel
    N4InvocationsPerPixel
    N2InvocationsPerPixel
    N1InvocationPerPixel
    N1InvocationPer2x1Pixels
    N1InvocationPer1x2Pixels
    N1InvocationPer2x2Pixels
    N1InvocationPer4x2Pixels
    N1InvocationPer2x4Pixels
    N1InvocationPer4x4Pixels

  VkCoarseSampleOrderTypeNV* {.size: sizeof(int32).} = enum
    Default
    Custom
    PixelMajor
    SampleMajor

  VkGeometryInstanceFlagBitsKHR* {.size: sizeof(int32).} = enum
    TriangleFacingCullDisableBit = 1
    TriangleFlipFacingBit
    ForceOpaqueBit = 4
    ForceNoOpaqueBit = 8
    ForceOpacityMicromap2StateBitExt = 16
    DisableOpacityMicromapsBitExt = 32

  VkGeometryFlagBitsKHR* {.size: sizeof(int32).} = enum
    OpaqueBit = 1
    NoDuplicateAnyHitInvocationBit

  VkBuildAccelerationStructureFlagBitsKHR* {.size: sizeof(int32).} = enum
    AllowUpdateBit = 1
    AllowCompactionBit
    PreferFastTraceBit = 4
    PreferFastBuildBit = 8
    LowMemoryBit = 16
    MotionBitNv = 32
    AllowOpacityMicromapUpdateBitExt = 64
    AllowDisableOpacityMicromapsBitExt = 128
    AllowOpacityMicromapDataUpdateBitExt = 256
    AllowDisplacementMicromapUpdateBitNv = 512
    AllowDataAccessBit = 2048
    AllowClusterOpacityMicromapsBitNv = 4096

  VkAccelerationStructureCreateFlagBitsKHR* {.size: sizeof(int32).} = enum
    DeviceAddressCaptureReplayBit = 1
    MotionBitNv = 4
    DescriptorBufferCaptureReplayBitExt = 8

  VkCopyAccelerationStructureModeKHR* {.size: sizeof(int32).} = enum
    Clone
    Compact
    Serialize
    Deserialize

  VkBuildAccelerationStructureModeKHR* {.size: sizeof(int32).} = enum
    Build
    Update

  VkAccelerationStructureTypeKHR* {.size: sizeof(int32).} = enum
    TopLevel
    BottomLevel
    Generic

  VkGeometryTypeKHR* {.size: sizeof(int32).} = enum
    Triangles
    Aabbs
    Instances
    SpheresNv = 1000429004
    LinearSweptSpheresNv
    DenseGeometryFormatTrianglesAmdx = 1000478000

  VkAccelerationStructureMemoryRequirementsTypeNV* {.size: sizeof(int32).} = enum
    Object
    BuildScratch
    UpdateScratch

  VkAccelerationStructureBuildTypeKHR* {.size: sizeof(int32).} = enum
    Host
    Device
    HostOrDevice

  VkRayTracingShaderGroupTypeKHR* {.size: sizeof(int32).} = enum
    General
    TrianglesHitGroup
    ProceduralHitGroup

  VkAccelerationStructureCompatibilityKHR* {.size: sizeof(int32).} = enum
    Compatible
    Incompatible

  VkShaderGroupShaderKHR* {.size: sizeof(int32).} = enum
    General
    ClosestHit
    AnyHit
    Intersection

  VkMemoryOverallocationBehaviorAMD* {.size: sizeof(int32).} = enum
    Default
    Allowed
    Disallowed

  VkFramebufferCreateFlagBits* {.size: sizeof(int32).} = enum
    ImagelessBit = 1

  VkQueryPoolCreateFlagBits* {.size: sizeof(int32).} = enum
    ResetBitKhr = 1

  VkDeviceDiagnosticsConfigFlagBitsNV* {.size: sizeof(int32).} = enum
    EnableShaderDebugInfoBit = 1
    EnableResourceTrackingBit
    EnableAutomaticCheckpointsBit = 4
    EnableShaderErrorReportingBit = 8

  VkPipelineCreationFeedbackFlagBits* {.size: sizeof(int32).} = enum
    ValidBit = 1
    ApplicationPipelineCacheHitBit
    BasePipelineAccelerationBit = 4

  VkFullScreenExclusiveEXT* {.size: sizeof(int32).} = enum
    Default
    Allowed
    Disallowed
    ApplicationControlled

  VkPerformanceCounterScopeKHR* {.size: sizeof(int32).} = enum
    CommandBuffer
    RenderPass
    Command

  VkMemoryDecompressionMethodFlagBitsEXT* {.size: sizeof(int32).} = enum
    Gdeflate10Bit = 1

  VkPerformanceCounterUnitKHR* {.size: sizeof(int32).} = enum
    Generic
    Percentage
    Nanoseconds
    Bytes
    BytesPerSecond
    Kelvin
    Watts
    Volts
    Amps
    Hertz
    Cycles

  VkPerformanceCounterStorageKHR* {.size: sizeof(int32).} = enum
    Int32
    Int64
    Uint32
    Uint64
    Float32
    Float64

  VkPerformanceCounterDescriptionFlagBitsKHR* {.size: sizeof(int32).} = enum
    PerformanceImpactingBit = 1
    ConcurrentlyImpactedBit

  VkPerformanceConfigurationTypeINTEL* {.size: sizeof(int32).} = enum
    CommandQueueMetricsDiscoveryActivated

  VkQueryPoolSamplingModeINTEL* {.size: sizeof(int32).} = enum
    Manual

  VkPerformanceOverrideTypeINTEL* {.size: sizeof(int32).} = enum
    NullHardware
    FlushGpuCaches

  VkPerformanceParameterTypeINTEL* {.size: sizeof(int32).} = enum
    HwCountersSupported
    StreamMarkerValidBits

  VkPerformanceValueTypeINTEL* {.size: sizeof(int32).} = enum
    Uint32
    Uint64
    Float
    Bool
    String

  VkShaderFloatControlsIndependence* {.size: sizeof(int32).} = enum
    N32BitOnly
    All
    None

  VkPipelineExecutableStatisticFormatKHR* {.size: sizeof(int32).} = enum
    Bool32
    Int64
    Uint64
    Float64

  VkLineRasterizationMode* {.size: sizeof(int32).} = enum
    Default
    Rectangular
    Bresenham
    RectangularSmooth

  VkFaultLevel* {.size: sizeof(int32).} = enum
    Unassigned
    Critical
    Recoverable
    Warning

  VkFaultType* {.size: sizeof(int32).} = enum
    Invalid
    Unassigned
    Implementation
    System
    PhysicalDevice
    CommandBufferFull
    InvalidApiUsage

  VkFaultQueryBehavior* {.size: sizeof(int32).} = enum
    GetAndClearAllFaults

  VkToolPurposeFlagBits* {.size: sizeof(int32).} = enum
    ValidationBit = 1
    ProfilingBit
    TracingBit = 4
    AdditionalFeaturesBit = 8
    ModifyingFeaturesBit = 16
    DebugReportingBitExt = 32
    DebugMarkersBitExt = 64

  VkPipelineMatchControl* {.size: sizeof(int32).} = enum
    ApplicationUuidExactMatch

  VkFragmentShadingRateCombinerOpKHR* {.size: sizeof(int32).} = enum
    Keep
    Replace
    Min
    Max
    Mul

  VkFragmentShadingRateNV* {.size: sizeof(int32).} = enum
    N1InvocationPerPixel
    N1InvocationPer1x2Pixels
    N1InvocationPer2x1Pixels = 4
    N1InvocationPer2x2Pixels
    N1InvocationPer2x4Pixels
    N1InvocationPer4x2Pixels = 9
    N1InvocationPer4x4Pixels
    N2InvocationsPerPixel
    N4InvocationsPerPixel
    N8InvocationsPerPixel
    N16InvocationsPerPixel
    NoInvocations

  VkFragmentShadingRateTypeNV* {.size: sizeof(int32).} = enum
    FragmentSize
    Enums

  VkSubpassMergeStatusEXT* {.size: sizeof(int32).} = enum
    Merged
    Disallowed
    NotMergedSideEffects
    NotMergedSamplesMismatch
    NotMergedViewsMismatch
    NotMergedAliasing
    NotMergedDependencies
    NotMergedIncompatibleInputAttachment
    NotMergedTooManyAttachments
    NotMergedInsufficientStorage
    NotMergedDepthStencilCount
    NotMergedResolveAttachmentReuse
    NotMergedSingleSubpass
    NotMergedUnspecified

  VkAccessFlagBits2* {.size: sizeof(int32).} = enum
    None
    IndirectCommandReadBit
    IndexReadBit
    VertexAttributeReadBit = 4
    UniformReadBit = 8
    InputAttachmentReadBit = 16
    ShaderReadBit = 32
    ShaderWriteBit = 64
    ColorAttachmentReadBit = 128
    ColorAttachmentWriteBit = 256
    DepthStencilAttachmentReadBit = 512
    DepthStencilAttachmentWriteBit = 1024
    TransferReadBit = 2048
    TransferWriteBit = 4096
    HostReadBit = 8192
    HostWriteBit = 16384
    MemoryReadBit = 32768
    MemoryWriteBit = 65536
    CommandPreprocessReadBitExt = 131072
    CommandPreprocessWriteBitExt = 262144
    ColorAttachmentReadNoncoherentBitExt = 524288
    ConditionalRenderingReadBitExt = 1048576
    AccelerationStructureReadBitKhr = 2097152
    AccelerationStructureWriteBitKhr = 4194304
    FragmentShadingRateAttachmentReadBitKhr = 8388608
    FragmentDensityMapReadBitExt = 16777216
    TransformFeedbackWriteBitExt = 33554432
    TransformFeedbackCounterReadBitExt = 67108864
    TransformFeedbackCounterWriteBitExt = 134217728
    ShaderSampledReadBit = 4294967296
    ShaderStorageReadBit = 8589934592
    ShaderStorageWriteBit = 17179869184
    VideoDecodeReadBitKhr = 34359738368
    VideoDecodeWriteBitKhr = 68719476736
    VideoEncodeReadBitKhr = 137438953472
    VideoEncodeWriteBitKhr = 274877906944
    InvocationMaskReadBitHuawei = 549755813888
    ShaderBindingTableReadBitKhr = 1099511627776
    DescriptorBufferReadBitExt = 2199023255552
    OpticalFlowReadBitNv = 4398046511104
    OpticalFlowWriteBitNv = 8796093022208
    MicromapReadBitExt = 17592186044416
    MicromapWriteBitExt = 35184372088832
    DataGraphReadBitArm = 140737488355328
    DataGraphWriteBitArm = 281474976710656
    ShaderTileAttachmentReadBitQcom = 2251799813685248
    ShaderTileAttachmentWriteBitQcom = 4503599627370496
    MemoryDecompressionReadBitExt = 36028797018963968
    MemoryDecompressionWriteBitExt = 72057594037927936
    SamplerHeapReadBitExt = 144115188075855872
    ResourceHeapReadBitExt = 288230376151711744

  VkPipelineStageFlagBits2* {.size: sizeof(int32).} = enum
    None
    TopOfPipeBit
    DrawIndirectBit
    VertexInputBit = 4
    VertexShaderBit = 8
    TessellationControlShaderBit = 16
    TessellationEvaluationShaderBit = 32
    GeometryShaderBit = 64
    FragmentShaderBit = 128
    EarlyFragmentTestsBit = 256
    LateFragmentTestsBit = 512
    ColorAttachmentOutputBit = 1024
    ComputeShaderBit = 2048
    AllTransferBit = 4096
    BottomOfPipeBit = 8192
    HostBit = 16384
    AllGraphicsBit = 32768
    AllCommandsBit = 65536
    CommandPreprocessBitExt = 131072
    ConditionalRenderingBitExt = 262144
    TaskShaderBitExt = 524288
    MeshShaderBitExt = 1048576
    RayTracingShaderBitKhr = 2097152
    FragmentShadingRateAttachmentBitKhr = 4194304
    FragmentDensityProcessBitExt = 8388608
    TransformFeedbackBitExt = 16777216
    AccelerationStructureBuildBitKhr = 33554432
    VideoDecodeBitKhr = 67108864
    VideoEncodeBitKhr = 134217728
    AccelerationStructureCopyBitKhr = 268435456
    OpticalFlowBitNv = 536870912
    MicromapBuildBitExt = 1073741824
    CopyBit = 4294967296
    ResolveBit = 8589934592
    BlitBit = 17179869184
    ClearBit = 34359738368
    IndexInputBit = 68719476736
    VertexAttributeInputBit = 137438953472
    PreRasterizationShadersBit = 274877906944
    SubpassShaderBitHuawei = 549755813888
    InvocationMaskBitHuawei = 1099511627776
    ClusterCullingShaderBitHuawei = 2199023255552
    DataGraphBitArm = 4398046511104
    ConvertCooperativeVectorMatrixBitNv = 17592186044416
    MemoryDecompressionBitExt = 35184372088832
    CopyIndirectBitKhr = 70368744177664

  VkSubmitFlagBits* {.size: sizeof(int32).} = enum
    ProtectedBit = 1

  VkEventCreateFlagBits* {.size: sizeof(int32).} = enum
    DeviceOnlyBit = 1

  VkPipelineLayoutCreateFlagBits* {.size: sizeof(int32).} = enum
    IndependentSetsBitExt = 2

  VkSciSyncClientTypeNV* {.size: sizeof(int32).} = enum
    Signaler
    Waiter
    SignalerWaiter

  VkSciSyncPrimitiveTypeNV* {.size: sizeof(int32).} = enum
    Fence
    Semaphore

  VkProvokingVertexModeEXT* {.size: sizeof(int32).} = enum
    FirstVertex
    LastVertex

  VkPipelineCacheValidationVersion* {.size: sizeof(int32).} = enum
    SafetyCriticalOne = 1

  VkAccelerationStructureMotionInstanceTypeNV* {.size: sizeof(int32).} = enum
    Static
    MatrixMotion
    SrtMotion

  VkPipelineColorBlendStateCreateFlagBits* {.size: sizeof(int32).} = enum
    RasterizationOrderAttachmentAccessBitExt = 1

  VkPipelineDepthStencilStateCreateFlagBits* {.size: sizeof(int32).} = enum
    RasterizationOrderAttachmentDepthAccessBitExt = 1
    RasterizationOrderAttachmentStencilAccessBitExt

  VkGraphicsPipelineLibraryFlagBitsEXT* {.size: sizeof(int32).} = enum
    VertexInputInterfaceBit = 1
    PreRasterizationShadersBit
    FragmentShaderBit = 4
    FragmentOutputInterfaceBit = 8

  VkRenderingAttachmentFlagBitsKHR* {.size: sizeof(int32).} = enum
    InputAttachmentFeedbackBit = 1
    ResolveSkipTransferFunctionBit
    ResolveEnableTransferFunctionBit = 4

  VkResolveImageFlagBitsKHR* {.size: sizeof(int32).} = enum
    SkipTransferFunctionBit = 1
    EnableTransferFunctionBit

  VkDeviceAddressBindingFlagBitsEXT* {.size: sizeof(int32).} = enum
    InternalObjectBit = 1

  VkDeviceAddressBindingTypeEXT* {.size: sizeof(int32).} = enum
    Bind
    Unbind

  VkFrameBoundaryFlagBitsEXT* {.size: sizeof(int32).} = enum
    FrameEndBit = 1

  VkPresentScalingFlagBitsKHR* {.size: sizeof(int32).} = enum
    OneToOneBit = 1
    AspectRatioStretchBit
    StretchBit = 4

  VkPresentGravityFlagBitsKHR* {.size: sizeof(int32).} = enum
    MinBit = 1
    MaxBit
    CenteredBit = 4

  VkPhysicalDeviceSchedulingControlsFlagBitsARM* {.size: sizeof(int32).} = enum
    ShaderCoreCount = 1

  VkPresentStageFlagBitsEXT* {.size: sizeof(int32).} = enum
    QueueOperationsEndBit = 1
    RequestDequeuedBit
    ImageFirstPixelOutBit = 4
    ImageFirstPixelVisibleBit = 8

  VkPastPresentationTimingFlagBitsEXT* {.size: sizeof(int32).} = enum
    AllowPartialResultsBit = 1
    AllowOutOfOrderResultsBit

  VkPresentTimingInfoFlagBitsEXT* {.size: sizeof(int32).} = enum
    PresentAtRelativeTimeBit = 1
    PresentAtNearestRefreshCycleBit

  VkVideoCodecOperationFlagBitsKHR* {.size: sizeof(int32).} = enum
    None
    DecodeH264Bit
    DecodeH265Bit
    DecodeAv1Bit = 4
    DecodeVp9Bit = 8
    EncodeH264Bit = 65536
    EncodeH265Bit = 131072
    EncodeAv1Bit = 262144

  VkVideoChromaSubsamplingFlagBitsKHR* {.size: sizeof(int32).} = enum
    Invalid
    MonochromeBit
    N420Bit
    N422Bit = 4
    N444Bit = 8

  VkVideoComponentBitDepthFlagBitsKHR* {.size: sizeof(int32).} = enum
    Invalid
    N8Bit
    N10Bit = 4
    N12Bit = 16

  VkVideoCapabilityFlagBitsKHR* {.size: sizeof(int32).} = enum
    ProtectedContentBit = 1
    SeparateReferenceImagesBit

  VkVideoSessionCreateFlagBitsKHR* {.size: sizeof(int32).} = enum
    ProtectedContentBit = 1
    AllowEncodeParameterOptimizationsBit
    InlineQueriesBit = 4
    AllowEncodeQuantizationDeltaMapBit = 8
    AllowEncodeEmphasisMapBit = 16
    InlineSessionParametersBit = 32

  VkVideoSessionParametersCreateFlagBitsKHR* {.size: sizeof(int32).} = enum
    QuantizationMapCompatibleBit = 1

  VkVideoDecodeH264PictureLayoutFlagBitsKHR* {.size: sizeof(int32).} = enum
    Progressive
    InterlacedInterleavedLinesBit
    InterlacedSeparatePlanesBit

  VkVideoCodingControlFlagBitsKHR* {.size: sizeof(int32).} = enum
    ResetBit = 1
    EncodeRateControlBit
    EncodeQualityLevelBit = 4

  VkQueryResultStatusKHR* {.size: sizeof(int32).} = enum
    InsufficientBitstreamBufferRange = -1000299000
    Error = -1
    NotReady
    Complete

  VkVideoDecodeUsageFlagBitsKHR* {.size: sizeof(int32).} = enum
    Default
    TranscodingBit
    OfflineBit
    StreamingBit = 4

  VkVideoDecodeCapabilityFlagBitsKHR* {.size: sizeof(int32).} = enum
    DpbAndOutputCoincideBit = 1
    DpbAndOutputDistinctBit

  VkVideoEncodeFlagBitsKHR* {.size: sizeof(int32).} = enum
    WithQuantizationDeltaMapBit = 1
    WithEmphasisMapBit
    IntraRefreshBit = 4

  VkVideoEncodeUsageFlagBitsKHR* {.size: sizeof(int32).} = enum
    Default
    TranscodingBit
    StreamingBit
    RecordingBit = 4
    ConferencingBit = 8

  VkVideoEncodeContentFlagBitsKHR* {.size: sizeof(int32).} = enum
    Default
    CameraBit
    DesktopBit
    RenderedBit = 4

  VkVideoEncodeTuningModeKHR* {.size: sizeof(int32).} = enum
    Default
    HighQuality
    LowLatency
    UltraLowLatency
    Lossless

  VkVideoEncodeCapabilityFlagBitsKHR* {.size: sizeof(int32).} = enum
    PrecedingExternallyEncodedBytesBit = 1
    InsufficientBitstreamBufferRangeDetectionBit
    QuantizationDeltaMapBit = 4
    EmphasisMapBit = 8

  VkVideoEncodeFeedbackFlagBitsKHR* {.size: sizeof(int32).} = enum
    BitstreamBufferOffsetBit = 1
    BitstreamBytesWrittenBit
    BitstreamHasOverridesBit = 4

  VkVideoEncodeRateControlModeFlagBitsKHR* {.size: sizeof(int32).} = enum
    Default
    DisabledBit
    CbrBit
    VbrBit = 4

  VkVideoEncodeIntraRefreshModeFlagBitsKHR* {.size: sizeof(int32).} = enum
    None
    PerPicturePartitionBit
    BlockBasedBit
    BlockRowBasedBit = 4
    BlockColumnBasedBit = 8

  VkVideoEncodeH264CapabilityFlagBitsKHR* {.size: sizeof(int32).} = enum
    HrdComplianceBit = 1
    PredictionWeightTableGeneratedBit
    RowUnalignedSliceBit = 4
    DifferentSliceTypeBit = 8
    BFrameInL0ListBit = 16
    BFrameInL1ListBit = 32
    PerPictureTypeMinMaxQpBit = 64
    PerSliceConstantQpBit = 128
    GeneratePrefixNaluBit = 256
    MbQpDiffWraparoundBit = 512
    BPictureIntraRefreshBit = 1024

  VkVideoEncodeH264StdFlagBitsKHR* {.size: sizeof(int32).} = enum
    SeparateColorPlaneFlagSetBit = 1
    QpprimeYZeroTransformBypassFlagSetBit
    ScalingMatrixPresentFlagSetBit = 4
    ChromaQpIndexOffsetBit = 8
    SecondChromaQpIndexOffsetBit = 16
    PicInitQpMinus26Bit = 32
    WeightedPredFlagSetBit = 64
    WeightedBipredIdcExplicitBit = 128
    WeightedBipredIdcImplicitBit = 256
    Transform8x8ModeFlagSetBit = 512
    DirectSpatialMvPredFlagUnsetBit = 1024
    EntropyCodingModeFlagUnsetBit = 2048
    EntropyCodingModeFlagSetBit = 4096
    Direct8x8InferenceFlagUnsetBit = 8192
    ConstrainedIntraPredFlagSetBit = 16384
    DeblockingFilterDisabledBit = 32768
    DeblockingFilterEnabledBit = 65536
    DeblockingFilterPartialBit = 131072
    SliceQpDeltaBit = 524288
    DifferentSliceQpDeltaBit = 1048576

  VkVideoEncodeH264RateControlFlagBitsKHR* {.size: sizeof(int32).} = enum
    AttemptHrdComplianceBit = 1
    RegularGopBit
    ReferencePatternFlatBit = 4
    ReferencePatternDyadicBit = 8
    TemporalLayerPatternDyadicBit = 16

  VkHostImageCopyFlagBits* {.size: sizeof(int32).} = enum
    MemcpyBit = 1

  VkPartitionedAccelerationStructureOpTypeNV* {.size: sizeof(int32).} = enum
    WriteInstance
    UpdateInstance
    WritePartitionTranslation

  VkPartitionedAccelerationStructureInstanceFlagBitsNV* {.size: sizeof(int32).} = enum
    FlagTriangleFacingCullDisableBit = 1
    FlagTriangleFlipFacingBit
    FlagForceOpaqueBit = 4
    FlagForceNoOpaqueBit = 8
    FlagEnableExplicitBoundingBox = 16

  VkImageConstraintsInfoFlagBitsFUCHSIA* {.size: sizeof(int32).} = enum
    VkImageConstraintsInfoCpuReadRarelyFuchsia = 1
    VkImageConstraintsInfoCpuReadOftenFuchsia
    VkImageConstraintsInfoCpuWriteRarelyFuchsia = 4
    VkImageConstraintsInfoCpuWriteOftenFuchsia = 8
    VkImageConstraintsInfoProtectedOptionalFuchsia = 16

  VkFormatFeatureFlagBits2* {.size: sizeof(int32).} = enum
    SampledImageBit = 1
    StorageImageBit
    StorageImageAtomicBit = 4
    UniformTexelBufferBit = 8
    StorageTexelBufferBit = 16
    StorageTexelBufferAtomicBit = 32
    VertexBufferBit = 64
    ColorAttachmentBit = 128
    ColorAttachmentBlendBit = 256
    DepthStencilAttachmentBit = 512
    BlitSrcBit = 1024
    BlitDstBit = 2048
    SampledImageFilterLinearBit = 4096
    SampledImageFilterCubicBit = 8192
    TransferSrcBit = 16384
    TransferDstBit = 32768
    SampledImageFilterMinmaxBit = 65536
    MidpointChromaSamplesBit = 131072
    SampledImageYcbcrConversionLinearFilterBit = 262144
    SampledImageYcbcrConversionSeparateReconstructionFilterBit = 524288
    SampledImageYcbcrConversionChromaReconstructionExplicitBit = 1048576
    SampledImageYcbcrConversionChromaReconstructionExplicitForceableBit = 2097152
    DisjointBit = 4194304
    CositedChromaSamplesBit = 8388608
    FragmentDensityMapBitExt = 16777216
    VideoDecodeOutputBitKhr = 33554432
    VideoDecodeDpbBitKhr = 67108864
    VideoEncodeInputBitKhr = 134217728
    VideoEncodeDpbBitKhr = 268435456
    AccelerationStructureVertexBufferBitKhr = 536870912
    FragmentShadingRateAttachmentBitKhr = 1073741824
    StorageReadWithoutFormatBit = 2147483648
    StorageWriteWithoutFormatBit = 4294967296
    SampledImageDepthComparisonBit = 8589934592
    WeightImageBitQcom = 17179869184
    WeightSampledImageBitQcom = 34359738368
    BlockMatchingBitQcom = 68719476736
    BoxFilterSampledBitQcom = 137438953472
    LinearColorAttachmentBitNv = 274877906944
    TensorShaderBitArm = 549755813888
    OpticalFlowImageBitNv = 1099511627776
    OpticalFlowVectorBitNv = 2199023255552
    OpticalFlowCostBitNv = 4398046511104
    TensorImageAliasingBitArm = 8796093022208
    HostImageTransferBit = 70368744177664
    TensorDataGraphBitArm = 281474976710656
    VideoEncodeQuantizationDeltaMapBitKhr = 562949953421312
    VideoEncodeEmphasisMapBitKhr = 1125899906842624
    AccelerationStructureRadiusBufferBitNv = 2251799813685248
    DepthCopyOnComputeQueueBitKhr = 4503599627370496
    DepthCopyOnTransferQueueBitKhr = 9007199254740992
    StencilCopyOnComputeQueueBitKhr = 18014398509481984
    StencilCopyOnTransferQueueBitKhr = 36028797018963968
    CopyImageIndirectDstBitKhr = 576460752303423488

  VkRenderingFlagBits* {.size: sizeof(int32).} = enum
    ContentsSecondaryCommandBuffersBit = 1
    SuspendingBit
    ResumingBit = 4
    EnableLegacyDitheringBitExt = 8
    ContentsInlineBitKhr = 16
    PerLayerFragmentDensityBitValve = 32
    FragmentRegionBitExt = 64
    CustomResolveBitExt = 128
    LocalReadConcurrentAccessControlBitKhr = 256

  VkVideoEncodeH265CapabilityFlagBitsKHR* {.size: sizeof(int32).} = enum
    HrdComplianceBit = 1
    PredictionWeightTableGeneratedBit
    RowUnalignedSliceSegmentBit = 4
    DifferentSliceSegmentTypeBit = 8
    BFrameInL0ListBit = 16
    BFrameInL1ListBit = 32
    PerPictureTypeMinMaxQpBit = 64
    PerSliceSegmentConstantQpBit = 128
    MultipleTilesPerSliceSegmentBit = 256
    MultipleSliceSegmentsPerTileBit = 512
    CuQpDiffWraparoundBit = 1024
    BPictureIntraRefreshBit = 2048

  VkVideoEncodeH265StdFlagBitsKHR* {.size: sizeof(int32).} = enum
    SeparateColorPlaneFlagSetBit = 1
    SampleAdaptiveOffsetEnabledFlagSetBit
    ScalingListDataPresentFlagSetBit = 4
    PcmEnabledFlagSetBit = 8
    SpsTemporalMvpEnabledFlagSetBit = 16
    InitQpMinus26Bit = 32
    WeightedPredFlagSetBit = 64
    WeightedBipredFlagSetBit = 128
    Log2ParallelMergeLevelMinus2Bit = 256
    SignDataHidingEnabledFlagSetBit = 512
    TransformSkipEnabledFlagSetBit = 1024
    TransformSkipEnabledFlagUnsetBit = 2048
    PpsSliceChromaQpOffsetsPresentFlagSetBit = 4096
    TransquantBypassEnabledFlagSetBit = 8192
    ConstrainedIntraPredFlagSetBit = 16384
    EntropyCodingSyncEnabledFlagSetBit = 32768
    DeblockingFilterOverrideEnabledFlagSetBit = 65536
    DependentSliceSegmentsEnabledFlagSetBit = 131072
    DependentSliceSegmentFlagSetBit = 262144
    SliceQpDeltaBit = 524288
    DifferentSliceQpDeltaBit = 1048576

  VkVideoEncodeH265RateControlFlagBitsKHR* {.size: sizeof(int32).} = enum
    AttemptHrdComplianceBit = 1
    RegularGopBit
    ReferencePatternFlatBit = 4
    ReferencePatternDyadicBit = 8
    TemporalSubLayerPatternDyadicBit = 16

  VkVideoEncodeH265CtbSizeFlagBitsKHR* {.size: sizeof(int32).} = enum
    N16Bit = 1
    N32Bit
    N64Bit = 4

  VkVideoEncodeH265TransformBlockSizeFlagBitsKHR* {.size: sizeof(int32).} = enum
    N4Bit = 1
    N8Bit
    N16Bit = 4
    N32Bit = 8

  VkVideoEncodeAV1CapabilityFlagBitsKHR* {.size: sizeof(int32).} = enum
    VkVideoEncodeAv1CapabilityPerRateControlGroupMinMaxQIndexBit = 1
    VkVideoEncodeAv1CapabilityGenerateObuExtensionHeaderBit
    VkVideoEncodeAv1CapabilityPrimaryReferenceCdfOnlyBit = 4
    VkVideoEncodeAv1CapabilityFrameSizeOverrideBit = 8
    VkVideoEncodeAv1CapabilityMotionVectorScalingBit = 16
    VkVideoEncodeAv1CapabilityCompoundPredictionIntraRefreshBit = 32

  VkVideoEncodeAV1StdFlagBitsKHR* {.size: sizeof(int32).} = enum
    VkVideoEncodeAv1StdUniformTileSpacingFlagSetBit = 1
    VkVideoEncodeAv1StdSkipModePresentUnsetBit
    VkVideoEncodeAv1StdPrimaryRefFrameBit = 4
    VkVideoEncodeAv1StdDeltaQBit = 8

  VkVideoEncodeAV1RateControlFlagBitsKHR* {.size: sizeof(int32).} = enum
    VkVideoEncodeAv1RateControlRegularGopBit = 1
    VkVideoEncodeAv1RateControlTemporalLayerPatternDyadicBit
    VkVideoEncodeAv1RateControlReferencePatternFlatBit = 4
    VkVideoEncodeAv1RateControlReferencePatternDyadicBit = 8

  VkVideoEncodeAV1SuperblockSizeFlagBitsKHR* {.size: sizeof(int32).} = enum
    VkVideoEncodeAv1SuperblockSize64Bit = 1
    VkVideoEncodeAv1SuperblockSize128Bit

  VkVideoEncodeAV1PredictionModeKHR* {.size: sizeof(int32).} = enum
    VkVideoEncodeAv1PredictionModeIntraOnly
    VkVideoEncodeAv1PredictionModeSingleReference
    VkVideoEncodeAv1PredictionModeUnidirectionalCompound
    VkVideoEncodeAv1PredictionModeBidirectionalCompound

  VkVideoEncodeAV1RateControlGroupKHR* {.size: sizeof(int32).} = enum
    VkVideoEncodeAv1RateControlGroupIntra
    VkVideoEncodeAv1RateControlGroupPredictive
    VkVideoEncodeAv1RateControlGroupBipredictive

  VkExportMetalObjectTypeFlagBitsEXT* {.size: sizeof(int32).} = enum
    MetalDeviceBit = 1
    MetalCommandQueueBit
    MetalBufferBit = 4
    MetalTextureBit = 8
    MetalIosurfaceBit = 16
    MetalSharedEventBit = 32

  VkInstanceCreateFlagBits* {.size: sizeof(int32).} = enum
    EnumeratePortabilityBitKhr = 1

  VkImageCompressionFlagBitsEXT* {.size: sizeof(int32).} = enum
    Default
    FixedRateDefault
    FixedRateExplicit
    Disabled = 4

  VkImageCompressionFixedRateFlagBitsEXT* {.size: sizeof(int32).} = enum
    None
    N1bpcBit
    N2bpcBit
    N3bpcBit = 4
    N4bpcBit = 8
    N5bpcBit = 16
    N6bpcBit = 32
    N7bpcBit = 64
    N8bpcBit = 128
    N9bpcBit = 256
    N10bpcBit = 512
    N11bpcBit = 1024
    N12bpcBit = 2048
    N13bpcBit = 4096
    N14bpcBit = 8192
    N15bpcBit = 16384
    N16bpcBit = 32768
    N17bpcBit = 65536
    N18bpcBit = 131072
    N19bpcBit = 262144
    N20bpcBit = 524288
    N21bpcBit = 1048576
    N22bpcBit = 2097152
    N23bpcBit = 4194304
    N24bpcBit = 8388608

  VkPipelineRobustnessBufferBehavior* {.size: sizeof(int32).} = enum
    DeviceDefault
    Disabled
    RobustBufferAccess
    RobustBufferAccess2

  VkPipelineRobustnessImageBehavior* {.size: sizeof(int32).} = enum
    DeviceDefault
    Disabled
    RobustImageAccess
    RobustImageAccess2

  VkOpticalFlowGridSizeFlagBitsNV* {.size: sizeof(int32).} = enum
    Unknown
    N1x1Bit
    N2x2Bit
    N4x4Bit = 4
    N8x8Bit = 8

  VkOpticalFlowUsageFlagBitsNV* {.size: sizeof(int32).} = enum
    Unknown
    InputBit
    OutputBit
    HintBit = 4
    CostBit = 8
    GlobalFlowBit = 16

  VkOpticalFlowPerformanceLevelNV* {.size: sizeof(int32).} = enum
    Unknown
    Slow
    Medium
    Fast

  VkOpticalFlowSessionBindingPointNV* {.size: sizeof(int32).} = enum
    Unknown
    Input
    Reference
    Hint
    FlowVector
    BackwardFlowVector
    Cost
    BackwardCost
    GlobalFlow

  VkOpticalFlowSessionCreateFlagBitsNV* {.size: sizeof(int32).} = enum
    EnableHintBit = 1
    EnableCostBit
    EnableGlobalFlowBit = 4
    AllowRegionsBit = 8
    BothDirectionsBit = 16

  VkOpticalFlowExecuteFlagBitsNV* {.size: sizeof(int32).} = enum
    DisableTemporalHintsBit = 1

  VkMicromapTypeEXT* {.size: sizeof(int32).} = enum
    OpacityMicromap
    DisplacementMicromapNv = 1000397000

  VkBuildMicromapFlagBitsEXT* {.size: sizeof(int32).} = enum
    PreferFastTraceBit = 1
    PreferFastBuildBit
    AllowCompactionBit = 4

  VkMicromapCreateFlagBitsEXT* {.size: sizeof(int32).} = enum
    DeviceAddressCaptureReplayBit = 1

  VkCopyMicromapModeEXT* {.size: sizeof(int32).} = enum
    Clone
    Serialize
    Deserialize
    Compact

  VkBuildMicromapModeEXT* {.size: sizeof(int32).} = enum
    Build

  VkOpacityMicromapFormatEXT* {.size: sizeof(int32).} = enum
    N2State = 1
    N4State

  VkOpacityMicromapSpecialIndexEXT* {.size: sizeof(int32).} = enum
    ClusterGeometryDisableOpacityMicromapNv = -5
    FullyUnknownOpaque
    FullyUnknownTransparent
    FullyOpaque
    FullyTransparent

  VkDepthBiasRepresentationEXT* {.size: sizeof(int32).} = enum
    LeastRepresentableValueFormat
    LeastRepresentableValueForceUnorm
    Float

  VkDeviceFaultAddressTypeEXT* {.size: sizeof(int32).} = enum
    None
    ReadInvalid
    WriteInvalid
    ExecuteInvalid
    InstructionPointerUnknown
    InstructionPointerInvalid
    InstructionPointerFault

  VkDeviceFaultVendorBinaryHeaderVersionEXT* {.size: sizeof(int32).} = enum
    One = 1

  VkIndirectCommandsLayoutUsageFlagBitsEXT* {.size: sizeof(int32).} = enum
    ExplicitPreprocessBit = 1
    UnorderedSequencesBit

  VkIndirectExecutionSetInfoTypeEXT* {.size: sizeof(int32).} = enum
    Pipelines
    ShaderObjects

  VkIndirectCommandsInputModeFlagBitsEXT* {.size: sizeof(int32).} = enum
    VulkanIndexBuffer = 1
    DxgiIndexBuffer

  VkIndirectCommandsTokenTypeEXT* {.size: sizeof(int32).} = enum
    ExecutionSet
    PushConstant
    SequenceIndex
    IndexBuffer
    VertexBuffer
    DrawIndexed
    Draw
    DrawIndexedCount
    DrawCount
    Dispatch
    PushData = 1000135000
    PushDataSequenceIndex
    DrawMeshTasksNv = 1000202002
    DrawMeshTasksCountNv
    DrawMeshTasks = 1000328000
    DrawMeshTasksCount
    TraceRays2 = 1000386004

  VkDisplacementMicromapFormatNV* {.size: sizeof(int32).} = enum
    N64Triangles64Bytes = 1
    N256Triangles128Bytes
    N1024Triangles128Bytes

  VkShaderCreateFlagBitsEXT* {.size: sizeof(int32).} = enum
    LinkStageBit = 1
    AllowVaryingSubgroupSizeBit
    RequireFullSubgroupsBit = 4
    NoTaskShaderBit = 8
    DispatchBaseBit = 16
    FragmentShadingRateAttachmentBit = 32
    FragmentDensityMapAttachmentBit = 64
    IndirectBindableBit = 128
    DescriptorHeapBit = 1024
    N64BitIndexingBit = 32768

  VkShaderCodeTypeEXT* {.size: sizeof(int32).} = enum
    Binary
    Spirv

  VkScopeKHR* {.size: sizeof(int32).} = enum
    Device = 1
    Workgroup
    Subgroup
    QueueFamily = 5

  VkComponentTypeKHR* {.size: sizeof(int32).} = enum
    Float16
    Float32
    Float64
    Sint8
    Sint16
    Sint32
    Sint64
    Uint8
    Uint16
    Uint32
    Uint64
    Bfloat16 = 1000141000
    Sint8PackedNv = 1000491000
    Uint8PackedNv
    Float8E4m3Ext
    Float8E5m2Ext

  VkCubicFilterWeightsQCOM* {.size: sizeof(int32).} = enum
    CatmullRom
    ZeroTangentCardinal
    BSpline
    MitchellNetravali

  VkBlockMatchWindowCompareModeQCOM* {.size: sizeof(int32).} = enum
    Min
    Max

  VkPhysicalDeviceLayeredApiKHR* {.size: sizeof(int32).} = enum
    Vulkan
    D3d12
    Metal
    Opengl
    Opengles

  VkLayeredDriverUnderlyingApiMSFT* {.size: sizeof(int32).} = enum
    None
    D3d12

  VkLatencyMarkerNV* {.size: sizeof(int32).} = enum
    SimulationStart
    SimulationEnd
    RendersubmitStart
    RendersubmitEnd
    PresentStart
    PresentEnd
    InputSample
    TriggerFlash
    OutOfBandRendersubmitStart
    OutOfBandRendersubmitEnd
    OutOfBandPresentStart
    OutOfBandPresentEnd

  VkOutOfBandQueueTypeNV* {.size: sizeof(int32).} = enum
    Render
    Present

  VkMemoryUnmapFlagBits* {.size: sizeof(int32).} = enum
    ReserveBitExt = 1

  VkCompressedTriangleFormatAMDX* {.size: sizeof(int32).} = enum
    VkCompressedTriangleFormatDgf1Amdx

  VkDepthClampModeEXT* {.size: sizeof(int32).} = enum
    ViewportRange
    UserDefinedRange

  VkAccessFlagBits3KHR* {.size: sizeof(int32).} = enum
    None

  VkTileShadingRenderPassFlagBitsQCOM* {.size: sizeof(int32).} = enum
    EnableBit = 1
    PerTileExecutionBit

  VkCooperativeVectorMatrixLayoutNV* {.size: sizeof(int32).} = enum
    RowMajor
    ColumnMajor
    InferencingOptimal
    TrainingOptimal

  VkAddressCopyFlagBitsKHR* {.size: sizeof(int32).} = enum
    DeviceLocalBit = 1
    SparseBit
    ProtectedBit = 4

  VkTensorCreateFlagBitsARM* {.size: sizeof(int32).} = enum
    MutableFormatBit = 1
    ProtectedBit
    DescriptorBufferCaptureReplayBit = 4
    DescriptorHeapCaptureReplayBit = 8

  VkTensorUsageFlagBitsARM* {.size: sizeof(int32).} = enum
    ShaderBit = 2
    TransferSrcBit = 4
    TransferDstBit = 8
    ImageAliasingBit = 16
    DataGraphBit = 32

  VkTensorTilingARM* {.size: sizeof(int32).} = enum
    Optimal
    Linear

  VkTensorViewCreateFlagBitsARM* {.size: sizeof(int32).} = enum
    DescriptorBufferCaptureReplayBit = 1

  VkDefaultVertexAttributeValueKHR* {.size: sizeof(int32).} = enum
    ZeroZeroZeroZero
    ZeroZeroZeroOne

  VkDataGraphPipelineSessionCreateFlagBitsARM* {.size: sizeof(int32).} = enum
    ProtectedBit = 1

  VkDataGraphPipelineSessionBindPointARM* {.size: sizeof(int32).} = enum
    Transient

  VkDataGraphPipelineSessionBindPointTypeARM* {.size: sizeof(int32).} = enum
    Memory

  VkDataGraphPipelinePropertyARM* {.size: sizeof(int32).} = enum
    CreationLog
    Identifier

  VkPhysicalDeviceDataGraphProcessingEngineTypeARM* {.size: sizeof(int32).} = enum
    Default
    NeuralQcom = 1000629000
    ComputeQcom

  VkPhysicalDeviceDataGraphOperationTypeARM* {.size: sizeof(int32).} = enum
    SpirvExtendedInstructionSet
    NeuralModelQcom = 1000629000
    BuiltinModelQcom

  VkDataGraphModelCacheTypeQCOM* {.size: sizeof(int32).} = enum
    GenericBinary

  VkVideoEncodeRgbModelConversionFlagBitsVALVE* {.size: sizeof(int32).} = enum
    VkVideoEncodeRgbModelConversionRgbIdentityBitValve = 1
    VkVideoEncodeRgbModelConversionYcbcrIdentityBitValve
    VkVideoEncodeRgbModelConversionYcbcr709BitValve = 4
    VkVideoEncodeRgbModelConversionYcbcr601BitValve = 8
    VkVideoEncodeRgbModelConversionYcbcr2020BitValve = 16

  VkVideoEncodeRgbRangeCompressionFlagBitsVALVE* {.size: sizeof(int32).} = enum
    VkVideoEncodeRgbRangeCompressionFullRangeBitValve = 1
    VkVideoEncodeRgbRangeCompressionNarrowRangeBitValve

  VkVideoEncodeRgbChromaOffsetFlagBitsVALVE* {.size: sizeof(int32).} = enum
    VkVideoEncodeRgbChromaOffsetCositedEvenBitValve = 1
    VkVideoEncodeRgbChromaOffsetMidpointBitValve

  VkSwapchainImageUsageFlagBitsOHOS* {.size: sizeof(int32).} = enum
    VkSwapchainImageUsageSharedBitOhos = 1

  VkDescriptorMappingSourceEXT* {.size: sizeof(int32).} = enum
    HeapWithConstantOffset
    HeapWithPushIndex
    HeapWithIndirectIndex
    HeapWithIndirectIndexArray
    ResourceHeapData
    PushData
    PushAddress
    IndirectAddress
    HeapWithShaderRecordIndex
    ShaderRecordData
    ShaderRecordAddress

  VkSpirvResourceTypeFlagBitsEXT* {.size: sizeof(int32).} = enum
    SamplerBit = 1
    SampledImageBit
    ReadOnlyImageBit = 4
    ReadWriteImageBit = 8
    CombinedSampledImageBit = 16
    UniformBufferBit = 32
    ReadOnlyStorageBufferBit = 64
    ReadWriteStorageBufferBit = 128
    AccelerationStructureBit = 256
    TensorBitArm = 512
    All = 2147483647


# Types

type
  Display* {.nodecl.} = object
  VisualID* {.nodecl.} = object
  Window* {.nodecl.} = object
  RROutput* {.nodecl.} = object
  wl_display* {.nodecl.} = object
  wl_surface* {.nodecl.} = object
  ubm_device* {.nodecl.} = object
  ubm_surface* {.nodecl.} = object
  HINSTANCE* {.nodecl.} = object
  HWND* {.nodecl.} = object
  HMONITOR* {.nodecl.} = object
  HANDLE* {.nodecl.} = object
  SECURITY_ATTRIBUTES* {.nodecl.} = object
  DWORD* {.nodecl.} = object
  LPCWSTR* {.nodecl.} = object
  xcb_connection_t* {.nodecl.} = object
  xcb_visualid_t* {.nodecl.} = object
  xcb_window_t* {.nodecl.} = object
  IDirectFB* {.nodecl.} = object
  IDirectFBSurface* {.nodecl.} = object
  zx_handle_t* {.nodecl.} = object
  GgpStreamDescriptor* {.nodecl.} = object
  GgpFrameToken* {.nodecl.} = object
  screen_context* {.nodecl.} = object
  screen_window* {.nodecl.} = object
  screen_buffer* {.nodecl.} = object
  NvSciSyncAttrList* {.nodecl.} = object
  NvSciSyncObj* {.nodecl.} = object
  NvSciSyncFence* {.nodecl.} = object
  NvSciBufAttrList* {.nodecl.} = object
  NvSciBufObj* {.nodecl.} = object

template vkMakeVersion*(variant, major, minor, patch: untyped): untyped =
  (variant shl 29) or (major shl 22) or (minor shl 12) or patch

template vkVersionVariant*(version: untyped): untyped =
  uint32(version) shr 29

template vkVersionMajor*(version: untyped): untyped =
  uint32(version) shr 22

template vkVersionMinor*(version: untyped): untyped =
  (uint32(version) shr 12) and 0x000003FF

template vkVersionPatch*(version: untyped): untyped =
  uint32(version) and 0x00000FFF

const vkApiVersion1_0* = vkMakeVersion(0, 1, 0, 0)
const vkApiVersion1_1* = vkMakeVersion(0, 1, 1, 0)
const vkApiVersion1_2* = vkMakeVersion(0, 1, 2, 0)
const vkApiVersion1_3* = vkMakeVersion(0, 1, 3, 0)
const vkApiVersion1_4* = vkMakeVersion(0, 1, 4, 0)
const vkHeaderVersion* = 344
const vkHeaderVersionComplete* = vkMakeVersion(0, 1, 4, vkHeaderVersion)

type
  VkSampleMask* = distinct uint32
  VkBool32* = distinct uint32
  VkFlags* = distinct uint32
  VkFlags64* = distinct uint64
  VkDeviceSize* = distinct uint64
  VkDeviceAddress* = distinct uint64
  OHNativeWindow* {.nodecl.} = object
  OHBufferHandle* {.nodecl.} = object
  OH_NativeBuffer* {.nodecl.} = object
  VkFramebufferCreateFlags* = distinct VkFlags
  VkQueryPoolCreateFlags* = distinct VkFlags
  VkRenderPassCreateFlags* = distinct VkFlags
  VkSamplerCreateFlags* = distinct VkFlags
  VkPipelineLayoutCreateFlags* = distinct VkFlags
  VkPipelineCacheCreateFlags* = distinct VkFlags
  VkPipelineDepthStencilStateCreateFlags* = distinct VkFlags
  VkPipelineDynamicStateCreateFlags* = distinct VkFlags
  VkPipelineColorBlendStateCreateFlags* = distinct VkFlags
  VkPipelineMultisampleStateCreateFlags* = distinct VkFlags
  VkPipelineRasterizationStateCreateFlags* = distinct VkFlags
  VkPipelineViewportStateCreateFlags* = distinct VkFlags
  VkPipelineTessellationStateCreateFlags* = distinct VkFlags
  VkPipelineInputAssemblyStateCreateFlags* = distinct VkFlags
  VkPipelineVertexInputStateCreateFlags* = distinct VkFlags
  VkPipelineShaderStageCreateFlags* = distinct VkFlags
  VkDescriptorSetLayoutCreateFlags* = distinct VkFlags
  VkBufferViewCreateFlags* = distinct VkFlags
  VkInstanceCreateFlags* = distinct VkFlags
  VkDeviceCreateFlags* = distinct VkFlags
  VkDeviceQueueCreateFlags* = distinct VkFlags
  VkQueueFlags* = distinct VkFlags
  VkMemoryPropertyFlags* = distinct VkFlags
  VkMemoryHeapFlags* = distinct VkFlags
  VkAccessFlags* = distinct VkFlags
  VkBufferUsageFlags* = distinct VkFlags
  VkBufferCreateFlags* = distinct VkFlags
  VkShaderStageFlags* = distinct VkFlags
  VkImageUsageFlags* = distinct VkFlags
  VkImageCreateFlags* = distinct VkFlags
  VkImageViewCreateFlags* = distinct VkFlags
  VkPipelineCreateFlags* = distinct VkFlags
  VkColorComponentFlags* = distinct VkFlags
  VkFenceCreateFlags* = distinct VkFlags
  VkSemaphoreCreateFlags* = distinct VkFlags
  VkFormatFeatureFlags* = distinct VkFlags
  VkQueryControlFlags* = distinct VkFlags
  VkQueryResultFlags* = distinct VkFlags
  VkShaderModuleCreateFlags* = distinct VkFlags
  VkEventCreateFlags* = distinct VkFlags
  VkCommandPoolCreateFlags* = distinct VkFlags
  VkCommandPoolResetFlags* = distinct VkFlags
  VkCommandBufferResetFlags* = distinct VkFlags
  VkCommandBufferUsageFlags* = distinct VkFlags
  VkQueryPipelineStatisticFlags* = distinct VkFlags
  VkMemoryMapFlags* = distinct VkFlags
  VkMemoryUnmapFlags* = distinct VkFlags
  VkMemoryUnmapFlagsKHR* = VkMemoryUnmapFlags
  VkImageAspectFlags* = distinct VkFlags
  VkSparseMemoryBindFlags* = distinct VkFlags
  VkSparseImageFormatFlags* = distinct VkFlags
  VkSubpassDescriptionFlags* = distinct VkFlags
  VkPipelineStageFlags* = distinct VkFlags
  VkSampleCountFlags* = distinct VkFlags
  VkAttachmentDescriptionFlags* = distinct VkFlags
  VkStencilFaceFlags* = distinct VkFlags
  VkCullModeFlags* = distinct VkFlags
  VkDescriptorPoolCreateFlags* = distinct VkFlags
  VkDescriptorPoolResetFlags* = distinct VkFlags
  VkDependencyFlags* = distinct VkFlags
  VkSubgroupFeatureFlags* = distinct VkFlags
  VkIndirectCommandsLayoutUsageFlagsNV* = distinct VkFlags
  VkIndirectStateFlagsNV* = distinct VkFlags
  VkGeometryFlagsKHR* = distinct VkFlags
  VkGeometryFlagsNV* = VkGeometryFlagsKHR
  VkGeometryInstanceFlagsKHR* = distinct VkFlags
  VkGeometryInstanceFlagsNV* = VkGeometryInstanceFlagsKHR
  VkClusterAccelerationStructureGeometryFlagsNV* = distinct VkFlags
  VkClusterAccelerationStructureClusterFlagsNV* = distinct VkFlags
  VkClusterAccelerationStructureAddressResolutionFlagsNV* = distinct VkFlags
  VkBuildAccelerationStructureFlagsKHR* = distinct VkFlags
  VkBuildAccelerationStructureFlagsNV* = VkBuildAccelerationStructureFlagsKHR
  VkPrivateDataSlotCreateFlags* = distinct VkFlags
  VkPrivateDataSlotCreateFlagsEXT* = VkPrivateDataSlotCreateFlags
  VkAccelerationStructureCreateFlagsKHR* = distinct VkFlags
  VkDescriptorUpdateTemplateCreateFlags* = distinct VkFlags
  VkDescriptorUpdateTemplateCreateFlagsKHR* = VkDescriptorUpdateTemplateCreateFlags
  VkPipelineCreationFeedbackFlags* = distinct VkFlags
  VkPipelineCreationFeedbackFlagsEXT* = VkPipelineCreationFeedbackFlags
  VkPerformanceCounterDescriptionFlagsKHR* = distinct VkFlags
  VkAcquireProfilingLockFlagsKHR* = distinct VkFlags
  VkSemaphoreWaitFlags* = distinct VkFlags
  VkSemaphoreWaitFlagsKHR* = VkSemaphoreWaitFlags
  VkPipelineCompilerControlFlagsAMD* = distinct VkFlags
  VkShaderCorePropertiesFlagsAMD* = distinct VkFlags
  VkDeviceDiagnosticsConfigFlagsNV* = distinct VkFlags
  VkRefreshObjectFlagsKHR* = distinct VkFlags
  VkAccessFlags2* = distinct VkFlags64
  VkAccessFlags2KHR* = VkAccessFlags2
  VkPipelineStageFlags2* = distinct VkFlags64
  VkPipelineStageFlags2KHR* = VkPipelineStageFlags2
  VkAccelerationStructureMotionInfoFlagsNV* = distinct VkFlags
  VkAccelerationStructureMotionInstanceFlagsNV* = distinct VkFlags
  VkFormatFeatureFlags2* = distinct VkFlags64
  VkFormatFeatureFlags2KHR* = VkFormatFeatureFlags2
  VkRenderingFlags* = distinct VkFlags
  VkMemoryDecompressionMethodFlagsEXT* = distinct VkFlags64
  VkMemoryDecompressionMethodFlagsNV* = VkMemoryDecompressionMethodFlagsEXT
  VkRenderingFlagsKHR* = VkRenderingFlags
  VkBuildMicromapFlagsEXT* = distinct VkFlags
  VkMicromapCreateFlagsEXT* = distinct VkFlags
  VkIndirectCommandsLayoutUsageFlagsEXT* = distinct VkFlags
  VkIndirectCommandsInputModeFlagsEXT* = distinct VkFlags
  VkDirectDriverLoadingFlagsLUNARG* = distinct VkFlags
  VkPipelineCreateFlags2* = distinct VkFlags64
  VkPipelineCreateFlags2KHR* = VkPipelineCreateFlags2
  VkBufferUsageFlags2* = distinct VkFlags64
  VkBufferUsageFlags2KHR* = VkBufferUsageFlags2
  VkAddressCopyFlagsKHR* = distinct VkFlags
  VkTensorCreateFlagsARM* = distinct VkFlags64
  VkTensorUsageFlagsARM* = distinct VkFlags64
  VkTensorViewCreateFlagsARM* = distinct VkFlags64
  VkDataGraphPipelineSessionCreateFlagsARM* = distinct VkFlags64
  VkDataGraphPipelineDispatchFlagsARM* = distinct VkFlags64
  VkVideoEncodeRgbModelConversionFlagsVALVE* = distinct VkFlags
  VkVideoEncodeRgbRangeCompressionFlagsVALVE* = distinct VkFlags
  VkVideoEncodeRgbChromaOffsetFlagsVALVE* = distinct VkFlags
  VkSpirvResourceTypeFlagsEXT* = distinct VkFlags
  VkCompositeAlphaFlagsKHR* = distinct VkFlags
  VkDisplayPlaneAlphaFlagsKHR* = distinct VkFlags
  VkSurfaceTransformFlagsKHR* = distinct VkFlags
  VkSwapchainCreateFlagsKHR* = distinct VkFlags
  VkDisplayModeCreateFlagsKHR* = distinct VkFlags
  VkDisplaySurfaceCreateFlagsKHR* = distinct VkFlags
  VkAndroidSurfaceCreateFlagsKHR* = distinct VkFlags
  VkViSurfaceCreateFlagsNN* = distinct VkFlags
  VkWaylandSurfaceCreateFlagsKHR* = distinct VkFlags
  VkUbmSurfaceCreateFlagsSEC* = distinct VkFlags
  VkWin32SurfaceCreateFlagsKHR* = distinct VkFlags
  VkXlibSurfaceCreateFlagsKHR* = distinct VkFlags
  VkXcbSurfaceCreateFlagsKHR* = distinct VkFlags
  VkDirectFBSurfaceCreateFlagsEXT* = distinct VkFlags
  VkIOSSurfaceCreateFlagsMVK* = distinct VkFlags
  VkMacOSSurfaceCreateFlagsMVK* = distinct VkFlags
  VkMetalSurfaceCreateFlagsEXT* = distinct VkFlags
  VkImagePipeSurfaceCreateFlagsFUCHSIA* = distinct VkFlags
  VkStreamDescriptorSurfaceCreateFlagsGGP* = distinct VkFlags
  VkHeadlessSurfaceCreateFlagsEXT* = distinct VkFlags
  VkScreenSurfaceCreateFlagsQNX* = distinct VkFlags
  VkPeerMemoryFeatureFlags* = distinct VkFlags
  VkPeerMemoryFeatureFlagsKHR* = VkPeerMemoryFeatureFlags
  VkMemoryAllocateFlags* = distinct VkFlags
  VkMemoryAllocateFlagsKHR* = VkMemoryAllocateFlags
  VkDeviceGroupPresentModeFlagsKHR* = distinct VkFlags
  VkDebugReportFlagsEXT* = distinct VkFlags
  VkCommandPoolTrimFlags* = distinct VkFlags
  VkCommandPoolTrimFlagsKHR* = VkCommandPoolTrimFlags
  VkExternalMemoryHandleTypeFlagsNV* = distinct VkFlags
  VkClusterAccelerationStructureIndexFormatFlagsNV* = distinct VkFlags
  VkExternalMemoryFeatureFlagsNV* = distinct VkFlags
  VkExternalMemoryHandleTypeFlags* = distinct VkFlags
  VkExternalMemoryHandleTypeFlagsKHR* = VkExternalMemoryHandleTypeFlags
  VkExternalMemoryFeatureFlags* = distinct VkFlags
  VkExternalMemoryFeatureFlagsKHR* = VkExternalMemoryFeatureFlags
  VkExternalSemaphoreHandleTypeFlags* = distinct VkFlags
  VkExternalSemaphoreHandleTypeFlagsKHR* = VkExternalSemaphoreHandleTypeFlags
  VkExternalSemaphoreFeatureFlags* = distinct VkFlags
  VkExternalSemaphoreFeatureFlagsKHR* = VkExternalSemaphoreFeatureFlags
  VkSemaphoreImportFlags* = distinct VkFlags
  VkSemaphoreImportFlagsKHR* = VkSemaphoreImportFlags
  VkExternalFenceHandleTypeFlags* = distinct VkFlags
  VkExternalFenceHandleTypeFlagsKHR* = VkExternalFenceHandleTypeFlags
  VkExternalFenceFeatureFlags* = distinct VkFlags
  VkExternalFenceFeatureFlagsKHR* = VkExternalFenceFeatureFlags
  VkFenceImportFlags* = distinct VkFlags
  VkFenceImportFlagsKHR* = VkFenceImportFlags
  VkSurfaceCounterFlagsEXT* = distinct VkFlags
  VkPipelineViewportSwizzleStateCreateFlagsNV* = distinct VkFlags
  VkPipelineDiscardRectangleStateCreateFlagsEXT* = distinct VkFlags
  VkPipelineCoverageToColorStateCreateFlagsNV* = distinct VkFlags
  VkPipelineCoverageModulationStateCreateFlagsNV* = distinct VkFlags
  VkPipelineCoverageReductionStateCreateFlagsNV* = distinct VkFlags
  VkValidationCacheCreateFlagsEXT* = distinct VkFlags
  VkDebugUtilsMessageSeverityFlagsEXT* = distinct VkFlags
  VkDebugUtilsMessageTypeFlagsEXT* = distinct VkFlags
  VkDebugUtilsMessengerCreateFlagsEXT* = distinct VkFlags
  VkDebugUtilsMessengerCallbackDataFlagsEXT* = distinct VkFlags
  VkDeviceMemoryReportFlagsEXT* = distinct VkFlags
  VkPipelineRasterizationConservativeStateCreateFlagsEXT* = distinct VkFlags
  VkDescriptorBindingFlags* = distinct VkFlags
  VkDescriptorBindingFlagsEXT* = VkDescriptorBindingFlags
  VkConditionalRenderingFlagsEXT* = distinct VkFlags
  VkResolveModeFlags* = distinct VkFlags
  VkResolveModeFlagsKHR* = VkResolveModeFlags
  VkPipelineRasterizationStateStreamCreateFlagsEXT* = distinct VkFlags
  VkPipelineRasterizationDepthClipStateCreateFlagsEXT* = distinct VkFlags
  VkSwapchainImageUsageFlagsANDROID* = distinct VkFlags
  VkToolPurposeFlags* = distinct VkFlags
  VkToolPurposeFlagsEXT* = VkToolPurposeFlags
  VkSubmitFlags* = distinct VkFlags
  VkSubmitFlagsKHR* = VkSubmitFlags
  VkImageFormatConstraintsFlagsFUCHSIA* = distinct VkFlags
  VkHostImageCopyFlags* = distinct VkFlags
  VkHostImageCopyFlagsEXT* = VkHostImageCopyFlags
  VkPartitionedAccelerationStructureInstanceFlagsNV* = distinct VkFlags
  VkImageConstraintsInfoFlagsFUCHSIA* = distinct VkFlags
  VkGraphicsPipelineLibraryFlagsEXT* = distinct VkFlags
  VkImageCompressionFlagsEXT* = distinct VkFlags
  VkImageCompressionFixedRateFlagsEXT* = distinct VkFlags
  VkExportMetalObjectTypeFlagsEXT* = distinct VkFlags
  VkRenderingAttachmentFlagsKHR* = distinct VkFlags
  VkResolveImageFlagsKHR* = distinct VkFlags
  VkDeviceAddressBindingFlagsEXT* = distinct VkFlags
  VkOpticalFlowGridSizeFlagsNV* = distinct VkFlags
  VkOpticalFlowUsageFlagsNV* = distinct VkFlags
  VkOpticalFlowSessionCreateFlagsNV* = distinct VkFlags
  VkOpticalFlowExecuteFlagsNV* = distinct VkFlags
  VkFrameBoundaryFlagsEXT* = distinct VkFlags
  VkPresentScalingFlagsKHR* = distinct VkFlags
  VkPresentScalingFlagsEXT* = VkPresentScalingFlagsKHR
  VkPresentGravityFlagsKHR* = distinct VkFlags
  VkPresentGravityFlagsEXT* = VkPresentGravityFlagsKHR
  VkShaderCreateFlagsEXT* = distinct VkFlags
  VkTileShadingRenderPassFlagsQCOM* = distinct VkFlags
  VkPhysicalDeviceSchedulingControlsFlagsARM* = distinct VkFlags64
  VkSurfaceCreateFlagsOHOS* = distinct VkFlags
  VkPresentStageFlagsEXT* = distinct VkFlags
  VkPastPresentationTimingFlagsEXT* = distinct VkFlags
  VkPresentTimingInfoFlagsEXT* = distinct VkFlags
  VkSwapchainImageUsageFlagsOHOS* = distinct VkFlags
  VkPerformanceCounterDescriptionFlagsARM* = distinct VkFlags
  VkVideoCodecOperationFlagsKHR* = distinct VkFlags
  VkVideoCapabilityFlagsKHR* = distinct VkFlags
  VkVideoSessionCreateFlagsKHR* = distinct VkFlags
  VkVideoSessionParametersCreateFlagsKHR* = distinct VkFlags
  VkVideoBeginCodingFlagsKHR* = distinct VkFlags
  VkVideoEndCodingFlagsKHR* = distinct VkFlags
  VkVideoCodingControlFlagsKHR* = distinct VkFlags
  VkVideoDecodeUsageFlagsKHR* = distinct VkFlags
  VkVideoDecodeCapabilityFlagsKHR* = distinct VkFlags
  VkVideoDecodeFlagsKHR* = distinct VkFlags
  VkVideoDecodeH264PictureLayoutFlagsKHR* = distinct VkFlags
  VkVideoEncodeFlagsKHR* = distinct VkFlags
  VkVideoEncodeUsageFlagsKHR* = distinct VkFlags
  VkVideoEncodeContentFlagsKHR* = distinct VkFlags
  VkVideoEncodeCapabilityFlagsKHR* = distinct VkFlags
  VkVideoEncodeFeedbackFlagsKHR* = distinct VkFlags
  VkVideoEncodeRateControlFlagsKHR* = distinct VkFlags
  VkVideoEncodeRateControlModeFlagsKHR* = distinct VkFlags
  VkVideoEncodeIntraRefreshModeFlagsKHR* = distinct VkFlags
  VkVideoChromaSubsamplingFlagsKHR* = distinct VkFlags
  VkVideoComponentBitDepthFlagsKHR* = distinct VkFlags
  VkVideoEncodeH264CapabilityFlagsKHR* = distinct VkFlags
  VkVideoEncodeH264StdFlagsKHR* = distinct VkFlags
  VkVideoEncodeH264RateControlFlagsKHR* = distinct VkFlags
  VkVideoEncodeH265CapabilityFlagsKHR* = distinct VkFlags
  VkVideoEncodeH265StdFlagsKHR* = distinct VkFlags
  VkVideoEncodeH265RateControlFlagsKHR* = distinct VkFlags
  VkVideoEncodeH265CtbSizeFlagsKHR* = distinct VkFlags
  VkVideoEncodeH265TransformBlockSizeFlagsKHR* = distinct VkFlags
  VkVideoEncodeAV1CapabilityFlagsKHR* = distinct VkFlags
  VkVideoEncodeAV1StdFlagsKHR* = distinct VkFlags
  VkVideoEncodeAV1RateControlFlagsKHR* = distinct VkFlags
  VkVideoEncodeAV1SuperblockSizeFlagsKHR* = distinct VkFlags
  VkAccessFlags3KHR* = distinct VkFlags64
  VkInstance* = distinct VkHandle
  VkPhysicalDevice* = distinct VkHandle
  VkDevice* = distinct VkHandle
  VkQueue* = distinct VkHandle
  VkCommandBuffer* = distinct VkHandle
  VkDeviceMemory* = distinct VkNonDispatchableHandle
  VkCommandPool* = distinct VkNonDispatchableHandle
  VkBuffer* = distinct VkNonDispatchableHandle
  VkBufferView* = distinct VkNonDispatchableHandle
  VkImage* = distinct VkNonDispatchableHandle
  VkImageView* = distinct VkNonDispatchableHandle
  VkShaderModule* = distinct VkNonDispatchableHandle
  VkPipeline* = distinct VkNonDispatchableHandle
  VkPipelineLayout* = distinct VkNonDispatchableHandle
  VkSampler* = distinct VkNonDispatchableHandle
  VkDescriptorSet* = distinct VkNonDispatchableHandle
  VkDescriptorSetLayout* = distinct VkNonDispatchableHandle
  VkDescriptorPool* = distinct VkNonDispatchableHandle
  VkFence* = distinct VkNonDispatchableHandle
  VkSemaphore* = distinct VkNonDispatchableHandle
  VkEvent* = distinct VkNonDispatchableHandle
  VkQueryPool* = distinct VkNonDispatchableHandle
  VkFramebuffer* = distinct VkNonDispatchableHandle
  VkRenderPass* = distinct VkNonDispatchableHandle
  VkPipelineCache* = distinct VkNonDispatchableHandle
  VkPipelineBinaryKHR* = distinct VkNonDispatchableHandle
  VkIndirectCommandsLayoutNV* = distinct VkNonDispatchableHandle
  VkIndirectCommandsLayoutEXT* = distinct VkNonDispatchableHandle
  VkIndirectExecutionSetEXT* = distinct VkNonDispatchableHandle
  VkDescriptorUpdateTemplate* = distinct VkNonDispatchableHandle
  VkDescriptorUpdateTemplateKHR* = VkDescriptorUpdateTemplate
  VkSamplerYcbcrConversion* = distinct VkNonDispatchableHandle
  VkSamplerYcbcrConversionKHR* = VkSamplerYcbcrConversion
  VkValidationCacheEXT* = distinct VkNonDispatchableHandle
  VkAccelerationStructureKHR* = distinct VkNonDispatchableHandle
  VkAccelerationStructureNV* = distinct VkNonDispatchableHandle
  VkPerformanceConfigurationINTEL* = distinct VkNonDispatchableHandle
  VkBufferCollectionFUCHSIA* = distinct VkNonDispatchableHandle
  VkDeferredOperationKHR* = distinct VkNonDispatchableHandle
  VkPrivateDataSlot* = distinct VkNonDispatchableHandle
  VkPrivateDataSlotEXT* = VkPrivateDataSlot
  VkCuModuleNVX* = distinct VkNonDispatchableHandle
  VkCuFunctionNVX* = distinct VkNonDispatchableHandle
  VkOpticalFlowSessionNV* = distinct VkNonDispatchableHandle
  VkMicromapEXT* = distinct VkNonDispatchableHandle
  VkShaderEXT* = distinct VkNonDispatchableHandle
  VkTensorARM* = distinct VkNonDispatchableHandle
  VkTensorViewARM* = distinct VkNonDispatchableHandle
  VkDataGraphPipelineSessionARM* = distinct VkNonDispatchableHandle
  VkDisplayKHR* = distinct VkNonDispatchableHandle
  VkDisplayModeKHR* = distinct VkNonDispatchableHandle
  VkSurfaceKHR* = distinct VkNonDispatchableHandle
  VkSwapchainKHR* = distinct VkNonDispatchableHandle
  VkDebugReportCallbackEXT* = distinct VkNonDispatchableHandle
  VkDebugUtilsMessengerEXT* = distinct VkNonDispatchableHandle
  VkVideoSessionKHR* = distinct VkNonDispatchableHandle
  VkVideoSessionParametersKHR* = distinct VkNonDispatchableHandle
  VkSemaphoreSciSyncPoolNV* = distinct VkNonDispatchableHandle
  VkRayTracingInvocationReorderModeNV* = VkRayTracingInvocationReorderModeEXT
  VkDescriptorUpdateTemplateTypeKHR* = VkDescriptorUpdateTemplateType
  VkPointClippingBehaviorKHR* = VkPointClippingBehavior
  VkQueueGlobalPriorityKHR* = VkQueueGlobalPriority
  VkQueueGlobalPriorityEXT* = VkQueueGlobalPriority
  VkTimeDomainEXT* = VkTimeDomainKHR
  VkResolveModeFlagBitsKHR* = VkResolveModeFlagBits
  VkDescriptorBindingFlagBitsEXT* = VkDescriptorBindingFlagBits
  VkSemaphoreTypeKHR* = VkSemaphoreType
  VkGeometryFlagBitsNV* = VkGeometryFlagBitsKHR
  VkGeometryInstanceFlagBitsNV* = VkGeometryInstanceFlagBitsKHR
  VkBuildAccelerationStructureFlagBitsNV* = VkBuildAccelerationStructureFlagBitsKHR
  VkCopyAccelerationStructureModeNV* = VkCopyAccelerationStructureModeKHR
  VkAccelerationStructureTypeNV* = VkAccelerationStructureTypeKHR
  VkGeometryTypeNV* = VkGeometryTypeKHR
  VkRayTracingShaderGroupTypeNV* = VkRayTracingShaderGroupTypeKHR
  VkPipelineCreationFeedbackFlagBitsEXT* = VkPipelineCreationFeedbackFlagBits
  VkSemaphoreWaitFlagBitsKHR* = VkSemaphoreWaitFlagBits
  VkLineRasterizationModeKHR* = VkLineRasterizationMode
  VkLineRasterizationModeEXT* = VkLineRasterizationMode
  VkToolPurposeFlagBitsEXT* = VkToolPurposeFlagBits
  VkAccessFlagBits2KHR* = VkAccessFlagBits2
  VkPipelineStageFlagBits2KHR* = VkPipelineStageFlagBits2
  VkHostImageCopyFlagBitsEXT* = VkHostImageCopyFlagBits
  VkFormatFeatureFlagBits2KHR* = VkFormatFeatureFlagBits2
  VkRenderingFlagBitsKHR* = VkRenderingFlagBits
  VkPipelineRobustnessBufferBehaviorEXT* = VkPipelineRobustnessBufferBehavior
  VkPipelineRobustnessImageBehaviorEXT* = VkPipelineRobustnessImageBehavior
  VkMemoryDecompressionMethodFlagBitsNV* = VkMemoryDecompressionMethodFlagBitsEXT
  VkPipelineCreateFlagBits2KHR* = VkPipelineCreateFlagBits2
  VkBufferUsageFlagBits2KHR* = VkBufferUsageFlagBits2
  VkScopeNV* = VkScopeKHR
  VkComponentTypeNV* = VkComponentTypeKHR
  VkExternalMemoryHandleTypeFlagBitsKHR* = VkExternalMemoryHandleTypeFlagBits
  VkExternalMemoryFeatureFlagBitsKHR* = VkExternalMemoryFeatureFlagBits
  VkExternalSemaphoreHandleTypeFlagBitsKHR* = VkExternalSemaphoreHandleTypeFlagBits
  VkExternalSemaphoreFeatureFlagBitsKHR* = VkExternalSemaphoreFeatureFlagBits
  VkSemaphoreImportFlagBitsKHR* = VkSemaphoreImportFlagBits
  VkExternalFenceHandleTypeFlagBitsKHR* = VkExternalFenceHandleTypeFlagBits
  VkExternalFenceFeatureFlagBitsKHR* = VkExternalFenceFeatureFlagBits
  VkFenceImportFlagBitsKHR* = VkFenceImportFlagBits
  VkPeerMemoryFeatureFlagBitsKHR* = VkPeerMemoryFeatureFlagBits
  VkMemoryAllocateFlagBitsKHR* = VkMemoryAllocateFlagBits
  VkTessellationDomainOriginKHR* = VkTessellationDomainOrigin
  VkSamplerYcbcrModelConversionKHR* = VkSamplerYcbcrModelConversion
  VkSamplerYcbcrRangeKHR* = VkSamplerYcbcrRange
  VkChromaLocationKHR* = VkChromaLocation
  VkSamplerReductionModeEXT* = VkSamplerReductionMode
  VkShaderFloatControlsIndependenceKHR* = VkShaderFloatControlsIndependence
  VkSubmitFlagBitsKHR* = VkSubmitFlagBits
  VkPresentScalingFlagBitsEXT* = VkPresentScalingFlagBitsKHR
  VkPresentGravityFlagBitsEXT* = VkPresentGravityFlagBitsKHR
  VkMemoryUnmapFlagBitsKHR* = VkMemoryUnmapFlagBits
  VkDriverIdKHR* = VkDriverId
  PFN_vkInternalAllocationNotification* = proc (pUserData: pointer; size: uint; allocationType: VkInternalAllocationType; allocationScope: VkSystemAllocationScope) {.cdecl.}
  PFN_vkInternalFreeNotification* = proc (pUserData: pointer; size: uint; allocationType: VkInternalAllocationType; allocationScope: VkSystemAllocationScope) {.cdecl.}
  PFN_vkReallocationFunction* = proc (pUserData: pointer; pOriginal: pointer; size: uint; alignment: uint; allocationScope: VkSystemAllocationScope): pointer {.cdecl.}
  PFN_vkAllocationFunction* = proc (pUserData: pointer; size: uint; alignment: uint; allocationScope: VkSystemAllocationScope): pointer {.cdecl.}
  PFN_vkFreeFunction* = proc (pUserData: pointer; pMemory: pointer) {.cdecl.}
  PFN_vkVoidFunction* = proc () {.cdecl.}
  PFN_vkDebugReportCallbackEXT* = proc (flags: VkDebugReportFlagsEXT; objectType: VkDebugReportObjectTypeEXT; cbObject: uint64; location: uint; messageCode: int32; pLayerPrefix: cstring; pMessage: cstring; pUserData: pointer): VkBool32 {.cdecl.}
  PFN_vkDebugUtilsMessengerCallbackEXT* = proc (messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: ptr VkDebugUtilsMessengerCallbackDataEXT, userData: pointer): VkBool32 {.cdecl.}
  PFN_vkFaultCallbackFunction* = proc (unrecordedFaults: VkBool32; faultCount: uint32; pFaults: ptr VkFaultData) {.cdecl.}
  PFN_vkDeviceMemoryReportCallbackEXT* = proc (pCallbackData: ptr VkDeviceMemoryReportCallbackDataEXT; pUserData: pointer) {.cdecl.}
  PFN_vkGetInstanceProcAddrLUNARG* = proc (instance: VkInstance; pName: cstring): PFN_vkVoidFunction {.cdecl.}

  VkBaseOutStructure* = object
    sType*: VkStructureType
    pNext*: ptr VkBaseOutStructure

  VkBaseInStructure* = object
    sType*: VkStructureType
    pNext*: ptr VkBaseInStructure

  VkOffset2D* = object
    x*: int32
    y*: int32

  VkOffset3D* = object
    x*: int32
    y*: int32
    z*: int32

  VkExtent2D* = object
    width*: uint32
    height*: uint32

  VkExtent3D* = object
    width*: uint32
    height*: uint32
    depth*: uint32

  VkViewport* = object
    x*: float32
    y*: float32
    width*: float32
    height*: float32
    minDepth*: float32
    maxDepth*: float32

  VkRect2D* = object
    offset*: VkOffset2D
    extent*: VkExtent2D

  VkClearRect* = object
    rect*: VkRect2D
    baseArrayLayer*: uint32
    layerCount*: uint32

  VkComponentMapping* = object
    r*: VkComponentSwizzle
    g*: VkComponentSwizzle
    b*: VkComponentSwizzle
    a*: VkComponentSwizzle

  VkPhysicalDeviceProperties* = object
    apiVersion*: uint32
    driverVersion*: uint32
    vendorID*: uint32
    deviceID*: uint32
    deviceType*: VkPhysicalDeviceType
    deviceName*: array[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, char]
    pipelineCacheUUID*: array[VK_UUID_SIZE, uint8]
    limits*: VkPhysicalDeviceLimits
    sparseProperties*: VkPhysicalDeviceSparseProperties

  VkExtensionProperties* = object
    extensionName*: array[VK_MAX_EXTENSION_NAME_SIZE, char]
    specVersion*: uint32

  VkLayerProperties* = object
    layerName*: array[VK_MAX_EXTENSION_NAME_SIZE, char]
    specVersion*: uint32
    implementationVersion*: uint32
    description*: array[VK_MAX_DESCRIPTION_SIZE, char]

  VkApplicationInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    pApplicationName*: cstring
    applicationVersion*: uint32
    pEngineName*: cstring
    engineVersion*: uint32
    apiVersion*: uint32

  VkAllocationCallbacks* = object
    pUserData*: pointer
    pfnAllocation*: PFN_vkAllocationFunction
    pfnReallocation*: PFN_vkReallocationFunction
    pfnFree*: PFN_vkFreeFunction
    pfnInternalAllocation*: PFN_vkInternalAllocationNotification
    pfnInternalFree*: PFN_vkInternalFreeNotification

  VkDeviceQueueCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDeviceQueueCreateFlags
    queueFamilyIndex*: uint32
    queueCount*: uint32
    pQueuePriorities*: ptr float32

  VkDeviceCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDeviceCreateFlags
    queueCreateInfoCount*: uint32
    pQueueCreateInfos*: ptr VkDeviceQueueCreateInfo
    enabledLayerCount*: uint32
    ppEnabledLayerNames*: cstringArray
    enabledExtensionCount*: uint32
    ppEnabledExtensionNames*: cstringArray
    pEnabledFeatures*: ptr VkPhysicalDeviceFeatures

  VkInstanceCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkInstanceCreateFlags
    pApplicationInfo*: ptr VkApplicationInfo
    enabledLayerCount*: uint32
    ppEnabledLayerNames*: cstringArray
    enabledExtensionCount*: uint32
    ppEnabledExtensionNames*: cstringArray

  VkQueueFamilyProperties* = object
    queueFlags*: VkQueueFlags
    queueCount*: uint32
    timestampValidBits*: uint32
    minImageTransferGranularity*: VkExtent3D

  VkPhysicalDeviceMemoryProperties* = object
    memoryTypeCount*: uint32
    memoryTypes*: array[VK_MAX_MEMORY_TYPES, VkMemoryType]
    memoryHeapCount*: uint32
    memoryHeaps*: array[VK_MAX_MEMORY_HEAPS, VkMemoryHeap]

  VkMemoryAllocateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    allocationSize*: VkDeviceSize
    memoryTypeIndex*: uint32

  VkMemoryRequirements* = object
    size*: VkDeviceSize
    alignment*: VkDeviceSize
    memoryTypeBits*: uint32

  VkSparseImageFormatProperties* = object
    aspectMask*: VkImageAspectFlags
    imageGranularity*: VkExtent3D
    flags*: VkSparseImageFormatFlags

  VkSparseImageMemoryRequirements* = object
    formatProperties*: VkSparseImageFormatProperties
    imageMipTailFirstLod*: uint32
    imageMipTailSize*: VkDeviceSize
    imageMipTailOffset*: VkDeviceSize
    imageMipTailStride*: VkDeviceSize

  VkMemoryType* = object
    propertyFlags*: VkMemoryPropertyFlags
    heapIndex*: uint32

  VkMemoryHeap* = object
    size*: VkDeviceSize
    flags*: VkMemoryHeapFlags

  VkMappedMemoryRange* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory
    offset*: VkDeviceSize
    size*: VkDeviceSize

  VkFormatProperties* = object
    linearTilingFeatures*: VkFormatFeatureFlags
    optimalTilingFeatures*: VkFormatFeatureFlags
    bufferFeatures*: VkFormatFeatureFlags

  VkImageFormatProperties* = object
    maxExtent*: VkExtent3D
    maxMipLevels*: uint32
    maxArrayLayers*: uint32
    sampleCounts*: VkSampleCountFlags
    maxResourceSize*: VkDeviceSize

  VkDescriptorBufferInfo* = object
    buffer*: VkBuffer
    offset*: VkDeviceSize
    range*: VkDeviceSize

  VkDescriptorImageInfo* = object
    sampler*: VkSampler
    imageView*: VkImageView
    imageLayout*: VkImageLayout

  VkWriteDescriptorSet* = object
    sType*: VkStructureType
    pNext*: pointer
    dstSet*: VkDescriptorSet
    dstBinding*: uint32
    dstArrayElement*: uint32
    descriptorCount*: uint32
    descriptorType*: VkDescriptorType
    pImageInfo*: ptr VkDescriptorImageInfo
    pBufferInfo*: ptr VkDescriptorBufferInfo
    pTexelBufferView*: ptr VkBufferView

  VkCopyDescriptorSet* = object
    sType*: VkStructureType
    pNext*: pointer
    srcSet*: VkDescriptorSet
    srcBinding*: uint32
    srcArrayElement*: uint32
    dstSet*: VkDescriptorSet
    dstBinding*: uint32
    dstArrayElement*: uint32
    descriptorCount*: uint32

  VkBufferUsageFlags2CreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    usage*: VkBufferUsageFlags2

  VkBufferUsageFlags2CreateInfoKHR* = VkBufferUsageFlags2CreateInfo

  VkBufferCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkBufferCreateFlags
    size*: VkDeviceSize
    usage*: VkBufferUsageFlags
    sharingMode*: VkSharingMode
    queueFamilyIndexCount*: uint32
    pQueueFamilyIndices*: ptr uint32

  VkBufferViewCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkBufferViewCreateFlags
    buffer*: VkBuffer
    format*: VkFormat
    offset*: VkDeviceSize
    range*: VkDeviceSize

  VkImageSubresource* = object
    aspectMask*: VkImageAspectFlags
    mipLevel*: uint32
    arrayLayer*: uint32

  VkImageSubresourceLayers* = object
    aspectMask*: VkImageAspectFlags
    mipLevel*: uint32
    baseArrayLayer*: uint32
    layerCount*: uint32

  VkImageSubresourceRange* = object
    aspectMask*: VkImageAspectFlags
    baseMipLevel*: uint32
    levelCount*: uint32
    baseArrayLayer*: uint32
    layerCount*: uint32

  VkMemoryBarrier* = object
    sType*: VkStructureType
    pNext*: pointer
    srcAccessMask*: VkAccessFlags
    dstAccessMask*: VkAccessFlags

  VkBufferMemoryBarrier* = object
    sType*: VkStructureType
    pNext*: pointer
    srcAccessMask*: VkAccessFlags
    dstAccessMask*: VkAccessFlags
    srcQueueFamilyIndex*: uint32
    dstQueueFamilyIndex*: uint32
    buffer*: VkBuffer
    offset*: VkDeviceSize
    size*: VkDeviceSize

  VkImageMemoryBarrier* = object
    sType*: VkStructureType
    pNext*: pointer
    srcAccessMask*: VkAccessFlags
    dstAccessMask*: VkAccessFlags
    oldLayout*: VkImageLayout
    newLayout*: VkImageLayout
    srcQueueFamilyIndex*: uint32
    dstQueueFamilyIndex*: uint32
    image*: VkImage
    subresourceRange*: VkImageSubresourceRange

  VkImageCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkImageCreateFlags
    imageType*: VkImageType
    format*: VkFormat
    extent*: VkExtent3D
    mipLevels*: uint32
    arrayLayers*: uint32
    samples*: VkSampleCountFlagBits
    tiling*: VkImageTiling
    usage*: VkImageUsageFlags
    sharingMode*: VkSharingMode
    queueFamilyIndexCount*: uint32
    pQueueFamilyIndices*: ptr uint32
    initialLayout*: VkImageLayout

  VkSubresourceLayout* = object
    offset*: VkDeviceSize
    size*: VkDeviceSize
    rowPitch*: VkDeviceSize
    arrayPitch*: VkDeviceSize
    depthPitch*: VkDeviceSize

  VkImageViewCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkImageViewCreateFlags
    image*: VkImage
    viewType*: VkImageViewType
    format*: VkFormat
    components*: VkComponentMapping
    subresourceRange*: VkImageSubresourceRange

  VkBufferCopy* = object
    srcOffset*: VkDeviceSize
    dstOffset*: VkDeviceSize
    size*: VkDeviceSize

  VkSparseMemoryBind* = object
    resourceOffset*: VkDeviceSize
    size*: VkDeviceSize
    memory*: VkDeviceMemory
    memoryOffset*: VkDeviceSize
    flags*: VkSparseMemoryBindFlags

  VkSparseImageMemoryBind* = object
    subresource*: VkImageSubresource
    offset*: VkOffset3D
    extent*: VkExtent3D
    memory*: VkDeviceMemory
    memoryOffset*: VkDeviceSize
    flags*: VkSparseMemoryBindFlags

  VkSparseBufferMemoryBindInfo* = object
    buffer*: VkBuffer
    bindCount*: uint32
    pBinds*: ptr VkSparseMemoryBind

  VkSparseImageOpaqueMemoryBindInfo* = object
    image*: VkImage
    bindCount*: uint32
    pBinds*: ptr VkSparseMemoryBind

  VkSparseImageMemoryBindInfo* = object
    image*: VkImage
    bindCount*: uint32
    pBinds*: ptr VkSparseImageMemoryBind

  VkBindSparseInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    waitSemaphoreCount*: uint32
    pWaitSemaphores*: ptr VkSemaphore
    bufferBindCount*: uint32
    pBufferBinds*: ptr VkSparseBufferMemoryBindInfo
    imageOpaqueBindCount*: uint32
    pImageOpaqueBinds*: ptr VkSparseImageOpaqueMemoryBindInfo
    imageBindCount*: uint32
    pImageBinds*: ptr VkSparseImageMemoryBindInfo
    signalSemaphoreCount*: uint32
    pSignalSemaphores*: ptr VkSemaphore

  VkImageCopy* = object
    srcSubresource*: VkImageSubresourceLayers
    srcOffset*: VkOffset3D
    dstSubresource*: VkImageSubresourceLayers
    dstOffset*: VkOffset3D
    extent*: VkExtent3D

  VkImageBlit* = object
    srcSubresource*: VkImageSubresourceLayers
    srcOffsets*: array[2, VkOffset3D]
    dstSubresource*: VkImageSubresourceLayers
    dstOffsets*: array[2, VkOffset3D]

  VkBufferImageCopy* = object
    bufferOffset*: VkDeviceSize
    bufferRowLength*: uint32
    bufferImageHeight*: uint32
    imageSubresource*: VkImageSubresourceLayers
    imageOffset*: VkOffset3D
    imageExtent*: VkExtent3D

  VkStridedDeviceAddressRangeKHR* = object
    address*: VkDeviceAddress
    size*: VkDeviceSize
    stride*: VkDeviceSize

  VkCopyMemoryIndirectCommandKHR* = object
    srcAddress*: VkDeviceAddress
    dstAddress*: VkDeviceAddress
    size*: VkDeviceSize

  VkCopyMemoryIndirectCommandNV* = VkCopyMemoryIndirectCommandKHR

  VkCopyMemoryIndirectInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    srcCopyFlags*: VkAddressCopyFlagsKHR
    dstCopyFlags*: VkAddressCopyFlagsKHR
    copyCount*: uint32
    copyAddressRange*: VkStridedDeviceAddressRangeKHR

  VkCopyMemoryToImageIndirectCommandKHR* = object
    srcAddress*: VkDeviceAddress
    bufferRowLength*: uint32
    bufferImageHeight*: uint32
    imageSubresource*: VkImageSubresourceLayers
    imageOffset*: VkOffset3D
    imageExtent*: VkExtent3D

  VkCopyMemoryToImageIndirectCommandNV* = VkCopyMemoryToImageIndirectCommandKHR

  VkCopyMemoryToImageIndirectInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    srcCopyFlags*: VkAddressCopyFlagsKHR
    copyCount*: uint32
    copyAddressRange*: VkStridedDeviceAddressRangeKHR
    dstImage*: VkImage
    dstImageLayout*: VkImageLayout
    pImageSubresources*: ptr VkImageSubresourceLayers

  VkImageResolve* = object
    srcSubresource*: VkImageSubresourceLayers
    srcOffset*: VkOffset3D
    dstSubresource*: VkImageSubresourceLayers
    dstOffset*: VkOffset3D
    extent*: VkExtent3D

  VkShaderModuleCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkShaderModuleCreateFlags
    codeSize*: uint
    pCode*: ptr uint32

  VkDescriptorSetLayoutBinding* = object
    binding*: uint32
    descriptorType*: VkDescriptorType
    descriptorCount*: uint32
    stageFlags*: VkShaderStageFlags
    pImmutableSamplers*: ptr VkSampler

  VkDescriptorSetLayoutCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDescriptorSetLayoutCreateFlags
    bindingCount*: uint32
    pBindings*: ptr VkDescriptorSetLayoutBinding

  VkDescriptorPoolSize* = object
    `type`*: VkDescriptorType
    descriptorCount*: uint32

  VkDescriptorPoolCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDescriptorPoolCreateFlags
    maxSets*: uint32
    poolSizeCount*: uint32
    pPoolSizes*: ptr VkDescriptorPoolSize

  VkDescriptorSetAllocateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorPool*: VkDescriptorPool
    descriptorSetCount*: uint32
    pSetLayouts*: ptr VkDescriptorSetLayout

  VkSpecializationMapEntry* = object
    constantID*: uint32
    offset*: uint32
    size*: uint

  VkSpecializationInfo* = object
    mapEntryCount*: uint32
    pMapEntries*: ptr VkSpecializationMapEntry
    dataSize*: uint
    pData*: pointer

  VkPipelineShaderStageCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineShaderStageCreateFlags
    stage*: VkShaderStageFlagBits
    module*: VkShaderModule
    pName*: cstring
    pSpecializationInfo*: ptr VkSpecializationInfo

  VkComputePipelineCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCreateFlags
    stage*: VkPipelineShaderStageCreateInfo
    layout*: VkPipelineLayout
    basePipelineHandle*: VkPipeline
    basePipelineIndex*: int32

  VkComputePipelineIndirectBufferInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceAddress*: VkDeviceAddress
    size*: VkDeviceSize
    pipelineDeviceAddressCaptureReplay*: VkDeviceAddress

  VkPipelineCreateFlags2CreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCreateFlags2

  VkPipelineCreateFlags2CreateInfoKHR* = VkPipelineCreateFlags2CreateInfo

  VkVertexInputBindingDescription* = object
    binding*: uint32
    stride*: uint32
    inputRate*: VkVertexInputRate

  VkVertexInputAttributeDescription* = object
    location*: uint32
    binding*: uint32
    format*: VkFormat
    offset*: uint32

  VkPipelineVertexInputStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineVertexInputStateCreateFlags
    vertexBindingDescriptionCount*: uint32
    pVertexBindingDescriptions*: ptr VkVertexInputBindingDescription
    vertexAttributeDescriptionCount*: uint32
    pVertexAttributeDescriptions*: ptr VkVertexInputAttributeDescription

  VkPipelineInputAssemblyStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineInputAssemblyStateCreateFlags
    topology*: VkPrimitiveTopology
    primitiveRestartEnable*: VkBool32

  VkPipelineTessellationStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineTessellationStateCreateFlags
    patchControlPoints*: uint32

  VkPipelineViewportStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineViewportStateCreateFlags
    viewportCount*: uint32
    pViewports*: ptr VkViewport
    scissorCount*: uint32
    pScissors*: ptr VkRect2D

  VkPipelineRasterizationStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineRasterizationStateCreateFlags
    depthClampEnable*: VkBool32
    rasterizerDiscardEnable*: VkBool32
    polygonMode*: VkPolygonMode
    cullMode*: VkCullModeFlags
    frontFace*: VkFrontFace
    depthBiasEnable*: VkBool32
    depthBiasConstantFactor*: float32
    depthBiasClamp*: float32
    depthBiasSlopeFactor*: float32
    lineWidth*: float32

  VkPipelineMultisampleStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineMultisampleStateCreateFlags
    rasterizationSamples*: VkSampleCountFlagBits
    sampleShadingEnable*: VkBool32
    minSampleShading*: float32
    pSampleMask*: ptr VkSampleMask
    alphaToCoverageEnable*: VkBool32
    alphaToOneEnable*: VkBool32

  VkPipelineColorBlendAttachmentState* = object
    blendEnable*: VkBool32
    srcColorBlendFactor*: VkBlendFactor
    dstColorBlendFactor*: VkBlendFactor
    colorBlendOp*: VkBlendOp
    srcAlphaBlendFactor*: VkBlendFactor
    dstAlphaBlendFactor*: VkBlendFactor
    alphaBlendOp*: VkBlendOp
    colorWriteMask*: VkColorComponentFlags

  VkPipelineColorBlendStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineColorBlendStateCreateFlags
    logicOpEnable*: VkBool32
    logicOp*: VkLogicOp
    attachmentCount*: uint32
    pAttachments*: ptr VkPipelineColorBlendAttachmentState
    blendConstants*: array[4, float32]

  VkPipelineDynamicStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineDynamicStateCreateFlags
    dynamicStateCount*: uint32
    pDynamicStates*: ptr VkDynamicState

  VkStencilOpState* = object
    failOp*: VkStencilOp
    passOp*: VkStencilOp
    depthFailOp*: VkStencilOp
    compareOp*: VkCompareOp
    compareMask*: uint32
    writeMask*: uint32
    reference*: uint32

  VkPipelineDepthStencilStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineDepthStencilStateCreateFlags
    depthTestEnable*: VkBool32
    depthWriteEnable*: VkBool32
    depthCompareOp*: VkCompareOp
    depthBoundsTestEnable*: VkBool32
    stencilTestEnable*: VkBool32
    front*: VkStencilOpState
    back*: VkStencilOpState
    minDepthBounds*: float32
    maxDepthBounds*: float32

  VkGraphicsPipelineCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCreateFlags
    stageCount*: uint32
    pStages*: ptr VkPipelineShaderStageCreateInfo
    pVertexInputState*: ptr VkPipelineVertexInputStateCreateInfo
    pInputAssemblyState*: ptr VkPipelineInputAssemblyStateCreateInfo
    pTessellationState*: ptr VkPipelineTessellationStateCreateInfo
    pViewportState*: ptr VkPipelineViewportStateCreateInfo
    pRasterizationState*: ptr VkPipelineRasterizationStateCreateInfo
    pMultisampleState*: ptr VkPipelineMultisampleStateCreateInfo
    pDepthStencilState*: ptr VkPipelineDepthStencilStateCreateInfo
    pColorBlendState*: ptr VkPipelineColorBlendStateCreateInfo
    pDynamicState*: ptr VkPipelineDynamicStateCreateInfo
    layout*: VkPipelineLayout
    renderPass*: VkRenderPass
    subpass*: uint32
    basePipelineHandle*: VkPipeline
    basePipelineIndex*: int32

  VkPipelineCacheCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCacheCreateFlags
    initialDataSize*: uint
    pInitialData*: pointer

  VkPipelineCacheHeaderVersionOne* = object
    headerSize*: uint32
    headerVersion*: VkPipelineCacheHeaderVersion
    vendorID*: uint32
    deviceID*: uint32
    pipelineCacheUUID*: array[VK_UUID_SIZE, uint8]

  VkPipelineCacheStageValidationIndexEntry* = object
    codeSize*: uint64
    codeOffset*: uint64

  VkPipelineCacheSafetyCriticalIndexEntry* = object
    pipelineIdentifier*: array[VK_UUID_SIZE, uint8]
    pipelineMemorySize*: uint64
    jsonSize*: uint64
    jsonOffset*: uint64
    stageIndexCount*: uint32
    stageIndexStride*: uint32
    stageIndexOffset*: uint64

  VkPipelineCacheHeaderVersionSafetyCriticalOne* = object
    headerVersionOne*: VkPipelineCacheHeaderVersionOne
    validationVersion*: VkPipelineCacheValidationVersion
    implementationData*: uint32
    pipelineIndexCount*: uint32
    pipelineIndexStride*: uint32
    pipelineIndexOffset*: uint64

  VkPipelineCacheHeaderVersionDataGraphQCOM* = object
    headerSize*: uint32
    headerVersion*: VkPipelineCacheHeaderVersion
    cacheType*: VkDataGraphModelCacheTypeQCOM
    cacheVersion*: uint32
    toolchainVersion*: array[VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM, uint32]

  VkPushConstantRange* = object
    stageFlags*: VkShaderStageFlags
    offset*: uint32
    size*: uint32

  VkPipelineBinaryCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pKeysAndDataInfo*: ptr VkPipelineBinaryKeysAndDataKHR
    pipeline*: VkPipeline
    pPipelineCreateInfo*: ptr VkPipelineCreateInfoKHR

  VkPipelineBinaryHandlesInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineBinaryCount*: uint32
    pPipelineBinaries*: ptr VkPipelineBinaryKHR

  VkPipelineBinaryDataKHR* = object
    dataSize*: uint
    pData*: pointer

  VkPipelineBinaryKeysAndDataKHR* = object
    binaryCount*: uint32
    pPipelineBinaryKeys*: ptr VkPipelineBinaryKeyKHR
    pPipelineBinaryData*: ptr VkPipelineBinaryDataKHR

  VkPipelineBinaryKeyKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    keySize*: uint32
    key*: array[VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR, uint8]

  VkPipelineBinaryInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    binaryCount*: uint32
    pPipelineBinaries*: ptr VkPipelineBinaryKHR

  VkReleaseCapturedPipelineDataInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pipeline*: VkPipeline

  VkPipelineBinaryDataInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineBinary*: VkPipelineBinaryKHR

  VkPipelineCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer

  VkPipelineLayoutCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineLayoutCreateFlags
    setLayoutCount*: uint32
    pSetLayouts*: ptr VkDescriptorSetLayout
    pushConstantRangeCount*: uint32
    pPushConstantRanges*: ptr VkPushConstantRange

  VkSamplerCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkSamplerCreateFlags
    magFilter*: VkFilter
    minFilter*: VkFilter
    mipmapMode*: VkSamplerMipmapMode
    addressModeU*: VkSamplerAddressMode
    addressModeV*: VkSamplerAddressMode
    addressModeW*: VkSamplerAddressMode
    mipLodBias*: float32
    anisotropyEnable*: VkBool32
    maxAnisotropy*: float32
    compareEnable*: VkBool32
    compareOp*: VkCompareOp
    minLod*: float32
    maxLod*: float32
    borderColor*: VkBorderColor
    unnormalizedCoordinates*: VkBool32

  VkCommandPoolCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkCommandPoolCreateFlags
    queueFamilyIndex*: uint32

  VkCommandBufferAllocateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    commandPool*: VkCommandPool
    level*: VkCommandBufferLevel
    commandBufferCount*: uint32

  VkCommandBufferInheritanceInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    renderPass*: VkRenderPass
    subpass*: uint32
    framebuffer*: VkFramebuffer
    occlusionQueryEnable*: VkBool32
    queryFlags*: VkQueryControlFlags
    pipelineStatistics*: VkQueryPipelineStatisticFlags

  VkCommandBufferBeginInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkCommandBufferUsageFlags
    pInheritanceInfo*: ptr VkCommandBufferInheritanceInfo

  VkRenderPassBeginInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    renderPass*: VkRenderPass
    framebuffer*: VkFramebuffer
    renderArea*: VkRect2D
    clearValueCount*: uint32
    pClearValues*: ptr VkClearValue

  VkClearColorValue* {.union.} = object
    float32*: array[4, float32]
    int32*: array[4, int32]
    uint32*: array[4, uint32]

  VkClearDepthStencilValue* = object
    depth*: float32
    stencil*: uint32

  VkClearValue* {.union.} = object
    color*: VkClearColorValue
    depthStencil*: VkClearDepthStencilValue

  VkClearAttachment* = object
    aspectMask*: VkImageAspectFlags
    colorAttachment*: uint32
    clearValue*: VkClearValue

  VkAttachmentDescription* = object
    flags*: VkAttachmentDescriptionFlags
    format*: VkFormat
    samples*: VkSampleCountFlagBits
    loadOp*: VkAttachmentLoadOp
    storeOp*: VkAttachmentStoreOp
    stencilLoadOp*: VkAttachmentLoadOp
    stencilStoreOp*: VkAttachmentStoreOp
    initialLayout*: VkImageLayout
    finalLayout*: VkImageLayout

  VkAttachmentReference* = object
    attachment*: uint32
    layout*: VkImageLayout

  VkSubpassDescription* = object
    flags*: VkSubpassDescriptionFlags
    pipelineBindPoint*: VkPipelineBindPoint
    inputAttachmentCount*: uint32
    pInputAttachments*: ptr VkAttachmentReference
    colorAttachmentCount*: uint32
    pColorAttachments*: ptr VkAttachmentReference
    pResolveAttachments*: ptr VkAttachmentReference
    pDepthStencilAttachment*: ptr VkAttachmentReference
    preserveAttachmentCount*: uint32
    pPreserveAttachments*: ptr uint32

  VkSubpassDependency* = object
    srcSubpass*: uint32
    dstSubpass*: uint32
    srcStageMask*: VkPipelineStageFlags
    dstStageMask*: VkPipelineStageFlags
    srcAccessMask*: VkAccessFlags
    dstAccessMask*: VkAccessFlags
    dependencyFlags*: VkDependencyFlags

  VkRenderPassCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkRenderPassCreateFlags
    attachmentCount*: uint32
    pAttachments*: ptr VkAttachmentDescription
    subpassCount*: uint32
    pSubpasses*: ptr VkSubpassDescription
    dependencyCount*: uint32
    pDependencies*: ptr VkSubpassDependency

  VkEventCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkEventCreateFlags

  VkFenceCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkFenceCreateFlags

  VkPhysicalDeviceFeatures* = object
    robustBufferAccess*: VkBool32
    fullDrawIndexUint32*: VkBool32
    imageCubeArray*: VkBool32
    independentBlend*: VkBool32
    geometryShader*: VkBool32
    tessellationShader*: VkBool32
    sampleRateShading*: VkBool32
    dualSrcBlend*: VkBool32
    logicOp*: VkBool32
    multiDrawIndirect*: VkBool32
    drawIndirectFirstInstance*: VkBool32
    depthClamp*: VkBool32
    depthBiasClamp*: VkBool32
    fillModeNonSolid*: VkBool32
    depthBounds*: VkBool32
    wideLines*: VkBool32
    largePoints*: VkBool32
    alphaToOne*: VkBool32
    multiViewport*: VkBool32
    samplerAnisotropy*: VkBool32
    textureCompressionETC2*: VkBool32
    textureCompressionASTC_LDR*: VkBool32
    textureCompressionBC*: VkBool32
    occlusionQueryPrecise*: VkBool32
    pipelineStatisticsQuery*: VkBool32
    vertexPipelineStoresAndAtomics*: VkBool32
    fragmentStoresAndAtomics*: VkBool32
    shaderTessellationAndGeometryPointSize*: VkBool32
    shaderImageGatherExtended*: VkBool32
    shaderStorageImageExtendedFormats*: VkBool32
    shaderStorageImageMultisample*: VkBool32
    shaderStorageImageReadWithoutFormat*: VkBool32
    shaderStorageImageWriteWithoutFormat*: VkBool32
    shaderUniformBufferArrayDynamicIndexing*: VkBool32
    shaderSampledImageArrayDynamicIndexing*: VkBool32
    shaderStorageBufferArrayDynamicIndexing*: VkBool32
    shaderStorageImageArrayDynamicIndexing*: VkBool32
    shaderClipDistance*: VkBool32
    shaderCullDistance*: VkBool32
    shaderFloat64*: VkBool32
    shaderInt64*: VkBool32
    shaderInt16*: VkBool32
    shaderResourceResidency*: VkBool32
    shaderResourceMinLod*: VkBool32
    sparseBinding*: VkBool32
    sparseResidencyBuffer*: VkBool32
    sparseResidencyImage2D*: VkBool32
    sparseResidencyImage3D*: VkBool32
    sparseResidency2Samples*: VkBool32
    sparseResidency4Samples*: VkBool32
    sparseResidency8Samples*: VkBool32
    sparseResidency16Samples*: VkBool32
    sparseResidencyAliased*: VkBool32
    variableMultisampleRate*: VkBool32
    inheritedQueries*: VkBool32

  VkPhysicalDeviceSparseProperties* = object
    residencyStandard2DBlockShape*: VkBool32
    residencyStandard2DMultisampleBlockShape*: VkBool32
    residencyStandard3DBlockShape*: VkBool32
    residencyAlignedMipSize*: VkBool32
    residencyNonResidentStrict*: VkBool32

  VkPhysicalDeviceLimits* = object
    maxImageDimension1D*: uint32
    maxImageDimension2D*: uint32
    maxImageDimension3D*: uint32
    maxImageDimensionCube*: uint32
    maxImageArrayLayers*: uint32
    maxTexelBufferElements*: uint32
    maxUniformBufferRange*: uint32
    maxStorageBufferRange*: uint32
    maxPushConstantsSize*: uint32
    maxMemoryAllocationCount*: uint32
    maxSamplerAllocationCount*: uint32
    bufferImageGranularity*: VkDeviceSize
    sparseAddressSpaceSize*: VkDeviceSize
    maxBoundDescriptorSets*: uint32
    maxPerStageDescriptorSamplers*: uint32
    maxPerStageDescriptorUniformBuffers*: uint32
    maxPerStageDescriptorStorageBuffers*: uint32
    maxPerStageDescriptorSampledImages*: uint32
    maxPerStageDescriptorStorageImages*: uint32
    maxPerStageDescriptorInputAttachments*: uint32
    maxPerStageResources*: uint32
    maxDescriptorSetSamplers*: uint32
    maxDescriptorSetUniformBuffers*: uint32
    maxDescriptorSetUniformBuffersDynamic*: uint32
    maxDescriptorSetStorageBuffers*: uint32
    maxDescriptorSetStorageBuffersDynamic*: uint32
    maxDescriptorSetSampledImages*: uint32
    maxDescriptorSetStorageImages*: uint32
    maxDescriptorSetInputAttachments*: uint32
    maxVertexInputAttributes*: uint32
    maxVertexInputBindings*: uint32
    maxVertexInputAttributeOffset*: uint32
    maxVertexInputBindingStride*: uint32
    maxVertexOutputComponents*: uint32
    maxTessellationGenerationLevel*: uint32
    maxTessellationPatchSize*: uint32
    maxTessellationControlPerVertexInputComponents*: uint32
    maxTessellationControlPerVertexOutputComponents*: uint32
    maxTessellationControlPerPatchOutputComponents*: uint32
    maxTessellationControlTotalOutputComponents*: uint32
    maxTessellationEvaluationInputComponents*: uint32
    maxTessellationEvaluationOutputComponents*: uint32
    maxGeometryShaderInvocations*: uint32
    maxGeometryInputComponents*: uint32
    maxGeometryOutputComponents*: uint32
    maxGeometryOutputVertices*: uint32
    maxGeometryTotalOutputComponents*: uint32
    maxFragmentInputComponents*: uint32
    maxFragmentOutputAttachments*: uint32
    maxFragmentDualSrcAttachments*: uint32
    maxFragmentCombinedOutputResources*: uint32
    maxComputeSharedMemorySize*: uint32
    maxComputeWorkGroupCount*: array[3, uint32]
    maxComputeWorkGroupInvocations*: uint32
    maxComputeWorkGroupSize*: array[3, uint32]
    subPixelPrecisionBits*: uint32
    subTexelPrecisionBits*: uint32
    mipmapPrecisionBits*: uint32
    maxDrawIndexedIndexValue*: uint32
    maxDrawIndirectCount*: uint32
    maxSamplerLodBias*: float32
    maxSamplerAnisotropy*: float32
    maxViewports*: uint32
    maxViewportDimensions*: array[2, uint32]
    viewportBoundsRange*: array[2, float32]
    viewportSubPixelBits*: uint32
    minMemoryMapAlignment*: uint
    minTexelBufferOffsetAlignment*: VkDeviceSize
    minUniformBufferOffsetAlignment*: VkDeviceSize
    minStorageBufferOffsetAlignment*: VkDeviceSize
    minTexelOffset*: int32
    maxTexelOffset*: uint32
    minTexelGatherOffset*: int32
    maxTexelGatherOffset*: uint32
    minInterpolationOffset*: float32
    maxInterpolationOffset*: float32
    subPixelInterpolationOffsetBits*: uint32
    maxFramebufferWidth*: uint32
    maxFramebufferHeight*: uint32
    maxFramebufferLayers*: uint32
    framebufferColorSampleCounts*: VkSampleCountFlags
    framebufferDepthSampleCounts*: VkSampleCountFlags
    framebufferStencilSampleCounts*: VkSampleCountFlags
    framebufferNoAttachmentsSampleCounts*: VkSampleCountFlags
    maxColorAttachments*: uint32
    sampledImageColorSampleCounts*: VkSampleCountFlags
    sampledImageIntegerSampleCounts*: VkSampleCountFlags
    sampledImageDepthSampleCounts*: VkSampleCountFlags
    sampledImageStencilSampleCounts*: VkSampleCountFlags
    storageImageSampleCounts*: VkSampleCountFlags
    maxSampleMaskWords*: uint32
    timestampComputeAndGraphics*: VkBool32
    timestampPeriod*: float32
    maxClipDistances*: uint32
    maxCullDistances*: uint32
    maxCombinedClipAndCullDistances*: uint32
    discreteQueuePriorities*: uint32
    pointSizeRange*: array[2, float32]
    lineWidthRange*: array[2, float32]
    pointSizeGranularity*: float32
    lineWidthGranularity*: float32
    strictLines*: VkBool32
    standardSampleLocations*: VkBool32
    optimalBufferCopyOffsetAlignment*: VkDeviceSize
    optimalBufferCopyRowPitchAlignment*: VkDeviceSize
    nonCoherentAtomSize*: VkDeviceSize

  VkSemaphoreCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkSemaphoreCreateFlags

  VkQueryPoolCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkQueryPoolCreateFlags
    queryType*: VkQueryType
    queryCount*: uint32
    pipelineStatistics*: VkQueryPipelineStatisticFlags

  VkFramebufferCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkFramebufferCreateFlags
    renderPass*: VkRenderPass
    attachmentCount*: uint32
    pAttachments*: ptr VkImageView
    width*: uint32
    height*: uint32
    layers*: uint32

  VkDrawIndirectCommand* = object
    vertexCount*: uint32
    instanceCount*: uint32
    firstVertex*: uint32
    firstInstance*: uint32

  VkDrawIndexedIndirectCommand* = object
    indexCount*: uint32
    instanceCount*: uint32
    firstIndex*: uint32
    vertexOffset*: int32
    firstInstance*: uint32

  VkDispatchIndirectCommand* = object
    x*: uint32
    y*: uint32
    z*: uint32

  VkMultiDrawInfoEXT* = object
    firstVertex*: uint32
    vertexCount*: uint32

  VkMultiDrawIndexedInfoEXT* = object
    firstIndex*: uint32
    indexCount*: uint32
    vertexOffset*: int32

  VkSubmitInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    waitSemaphoreCount*: uint32
    pWaitSemaphores*: ptr VkSemaphore
    pWaitDstStageMask*: ptr VkPipelineStageFlags
    commandBufferCount*: uint32
    pCommandBuffers*: ptr VkCommandBuffer
    signalSemaphoreCount*: uint32
    pSignalSemaphores*: ptr VkSemaphore

  VkDisplayPropertiesKHR* = object
    display*: VkDisplayKHR
    displayName*: cstring
    physicalDimensions*: VkExtent2D
    physicalResolution*: VkExtent2D
    supportedTransforms*: VkSurfaceTransformFlagsKHR
    planeReorderPossible*: VkBool32
    persistentContent*: VkBool32

  VkDisplayPlanePropertiesKHR* = object
    currentDisplay*: VkDisplayKHR
    currentStackIndex*: uint32

  VkDisplayModeParametersKHR* = object
    visibleRegion*: VkExtent2D
    refreshRate*: uint32

  VkDisplayModePropertiesKHR* = object
    displayMode*: VkDisplayModeKHR
    parameters*: VkDisplayModeParametersKHR

  VkDisplayModeCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDisplayModeCreateFlagsKHR
    parameters*: VkDisplayModeParametersKHR

  VkDisplayPlaneCapabilitiesKHR* = object
    supportedAlpha*: VkDisplayPlaneAlphaFlagsKHR
    minSrcPosition*: VkOffset2D
    maxSrcPosition*: VkOffset2D
    minSrcExtent*: VkExtent2D
    maxSrcExtent*: VkExtent2D
    minDstPosition*: VkOffset2D
    maxDstPosition*: VkOffset2D
    minDstExtent*: VkExtent2D
    maxDstExtent*: VkExtent2D

  VkDisplaySurfaceCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDisplaySurfaceCreateFlagsKHR
    displayMode*: VkDisplayModeKHR
    planeIndex*: uint32
    planeStackIndex*: uint32
    transform*: VkSurfaceTransformFlagBitsKHR
    globalAlpha*: float32
    alphaMode*: VkDisplayPlaneAlphaFlagBitsKHR
    imageExtent*: VkExtent2D

  VkDisplaySurfaceStereoCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    stereoType*: VkDisplaySurfaceStereoTypeNV

  VkDisplayPresentInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    srcRect*: VkRect2D
    dstRect*: VkRect2D
    persistent*: VkBool32

  VkSurfaceCapabilitiesKHR* = object
    minImageCount*: uint32
    maxImageCount*: uint32
    currentExtent*: VkExtent2D
    minImageExtent*: VkExtent2D
    maxImageExtent*: VkExtent2D
    maxImageArrayLayers*: uint32
    supportedTransforms*: VkSurfaceTransformFlagsKHR
    currentTransform*: VkSurfaceTransformFlagBitsKHR
    supportedCompositeAlpha*: VkCompositeAlphaFlagsKHR
    supportedUsageFlags*: VkImageUsageFlags

  VkAndroidSurfaceCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkAndroidSurfaceCreateFlagsKHR
    window*: ptr ANativeWindow

  VkViSurfaceCreateInfoNN* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkViSurfaceCreateFlagsNN
    window*: pointer

  VkWaylandSurfaceCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkWaylandSurfaceCreateFlagsKHR
    display*: ptr wl_display
    surface*: ptr wl_surface

  VkUbmSurfaceCreateInfoSEC* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkUbmSurfaceCreateFlagsSEC
    device*: ptr ubm_device
    surface*: ptr ubm_surface

  VkWin32SurfaceCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkWin32SurfaceCreateFlagsKHR
    hinstance*: HINSTANCE
    hwnd*: HWND

  VkXlibSurfaceCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkXlibSurfaceCreateFlagsKHR
    dpy*: ptr Display
    window*: Window

  VkXcbSurfaceCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkXcbSurfaceCreateFlagsKHR
    connection*: ptr xcb_connection_t
    window*: xcb_window_t

  VkDirectFBSurfaceCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDirectFBSurfaceCreateFlagsEXT
    dfb*: ptr IDirectFB
    surface*: ptr IDirectFBSurface

  VkImagePipeSurfaceCreateInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkImagePipeSurfaceCreateFlagsFUCHSIA
    imagePipeHandle*: zx_handle_t

  VkStreamDescriptorSurfaceCreateInfoGGP* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkStreamDescriptorSurfaceCreateFlagsGGP
    streamDescriptor*: GgpStreamDescriptor

  VkScreenSurfaceCreateInfoQNX* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkScreenSurfaceCreateFlagsQNX
    context*: ptr screen_context
    window*: ptr screen_window

  VkSurfaceFormatKHR* = object
    format*: VkFormat
    colorSpace*: VkColorSpaceKHR

  VkSwapchainCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkSwapchainCreateFlagsKHR
    surface*: VkSurfaceKHR
    minImageCount*: uint32
    imageFormat*: VkFormat
    imageColorSpace*: VkColorSpaceKHR
    imageExtent*: VkExtent2D
    imageArrayLayers*: uint32
    imageUsage*: VkImageUsageFlags
    imageSharingMode*: VkSharingMode
    queueFamilyIndexCount*: uint32
    pQueueFamilyIndices*: ptr uint32
    preTransform*: VkSurfaceTransformFlagBitsKHR
    compositeAlpha*: VkCompositeAlphaFlagBitsKHR
    presentMode*: VkPresentModeKHR
    clipped*: VkBool32
    oldSwapchain*: VkSwapchainKHR

  VkPresentInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    waitSemaphoreCount*: uint32
    pWaitSemaphores*: ptr VkSemaphore
    swapchainCount*: uint32
    pSwapchains*: ptr VkSwapchainKHR
    pImageIndices*: ptr uint32
    pResults*: ptr VkResult

  VkDebugReportCallbackCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDebugReportFlagsEXT
    pfnCallback*: PFN_vkDebugReportCallbackEXT
    pUserData*: pointer

  VkValidationFlagsEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    disabledValidationCheckCount*: uint32
    pDisabledValidationChecks*: ptr VkValidationCheckEXT

  VkValidationFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    enabledValidationFeatureCount*: uint32
    pEnabledValidationFeatures*: ptr VkValidationFeatureEnableEXT
    disabledValidationFeatureCount*: uint32
    pDisabledValidationFeatures*: ptr VkValidationFeatureDisableEXT

  VkLayerSettingsCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    settingCount*: uint32
    pSettings*: ptr VkLayerSettingEXT

  VkLayerSettingEXT* = object
    pLayerName*: cstring
    pSettingName*: cstring
    `type`*: VkLayerSettingTypeEXT
    valueCount*: uint32
    pValues*: pointer

  VkApplicationParametersEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    vendorID*: uint32
    deviceID*: uint32
    key*: uint32
    value*: uint64

  VkPipelineRasterizationStateRasterizationOrderAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    rasterizationOrder*: VkRasterizationOrderAMD

  VkDebugMarkerObjectNameInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    objectType*: VkDebugReportObjectTypeEXT
    `object`*: uint64
    pObjectName*: cstring

  VkDebugMarkerObjectTagInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    objectType*: VkDebugReportObjectTypeEXT
    `object`*: uint64
    tagName*: uint64
    tagSize*: uint
    pTag*: pointer

  VkDebugMarkerMarkerInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pMarkerName*: cstring
    color*: array[4, float32]

  VkDedicatedAllocationImageCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    dedicatedAllocation*: VkBool32

  VkDedicatedAllocationBufferCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    dedicatedAllocation*: VkBool32

  VkDedicatedAllocationMemoryAllocateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    image*: VkImage
    buffer*: VkBuffer

  VkExternalImageFormatPropertiesNV* = object
    imageFormatProperties*: VkImageFormatProperties
    externalMemoryFeatures*: VkExternalMemoryFeatureFlagsNV
    exportFromImportedHandleTypes*: VkExternalMemoryHandleTypeFlagsNV
    compatibleHandleTypes*: VkExternalMemoryHandleTypeFlagsNV

  VkExternalMemoryImageCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    handleTypes*: VkExternalMemoryHandleTypeFlagsNV

  VkExportMemoryAllocateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    handleTypes*: VkExternalMemoryHandleTypeFlagsNV

  VkImportMemoryWin32HandleInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalMemoryHandleTypeFlagsNV
    handle*: HANDLE

  VkExportMemoryWin32HandleInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pAttributes*: ptr SECURITY_ATTRIBUTES
    dwAccess*: DWORD

  VkExportMemorySciBufInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pAttributes*: NvSciBufAttrList

  VkImportMemorySciBufInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalMemoryHandleTypeFlagBits
    handle*: NvSciBufObj

  VkMemoryGetSciBufInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory
    handleType*: VkExternalMemoryHandleTypeFlagBits

  VkMemorySciBufPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryTypeBits*: uint32

  VkPhysicalDeviceExternalMemorySciBufFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    sciBufImport*: VkBool32
    sciBufExport*: VkBool32

  VkPhysicalDeviceExternalSciBufFeaturesNV* = VkPhysicalDeviceExternalMemorySciBufFeaturesNV

  VkWin32KeyedMutexAcquireReleaseInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    acquireCount*: uint32
    pAcquireSyncs*: ptr VkDeviceMemory
    pAcquireKeys*: ptr uint64
    pAcquireTimeoutMilliseconds*: ptr uint32
    releaseCount*: uint32
    pReleaseSyncs*: ptr VkDeviceMemory
    pReleaseKeys*: ptr uint64

  VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceGeneratedCommands*: VkBool32

  VkPushConstantBankInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    bank*: uint32

  VkPhysicalDevicePushConstantBankFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pushConstantBank*: VkBool32

  VkPhysicalDevicePushConstantBankPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxGraphicsPushConstantBanks*: uint32
    maxComputePushConstantBanks*: uint32
    maxGraphicsPushDataBanks*: uint32
    maxComputePushDataBanks*: uint32

  VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceGeneratedCompute*: VkBool32
    deviceGeneratedComputePipelines*: VkBool32
    deviceGeneratedComputeCaptureReplay*: VkBool32

  VkDevicePrivateDataCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    privateDataSlotRequestCount*: uint32

  VkDevicePrivateDataCreateInfoEXT* = VkDevicePrivateDataCreateInfo

  VkPrivateDataSlotCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPrivateDataSlotCreateFlags

  VkPrivateDataSlotCreateInfoEXT* = VkPrivateDataSlotCreateInfo

  VkPhysicalDevicePrivateDataFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    privateData*: VkBool32

  VkPhysicalDevicePrivateDataFeaturesEXT* = VkPhysicalDevicePrivateDataFeatures

  VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxGraphicsShaderGroupCount*: uint32
    maxIndirectSequenceCount*: uint32
    maxIndirectCommandsTokenCount*: uint32
    maxIndirectCommandsStreamCount*: uint32
    maxIndirectCommandsTokenOffset*: uint32
    maxIndirectCommandsStreamStride*: uint32
    minSequencesCountBufferOffsetAlignment*: uint32
    minSequencesIndexBufferOffsetAlignment*: uint32
    minIndirectCommandsBufferOffsetAlignment*: uint32

  VkPhysicalDeviceClusterAccelerationStructureFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    clusterAccelerationStructure*: VkBool32

  VkPhysicalDeviceClusterAccelerationStructurePropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxVerticesPerCluster*: uint32
    maxTrianglesPerCluster*: uint32
    clusterScratchByteAlignment*: uint32
    clusterByteAlignment*: uint32
    clusterTemplateByteAlignment*: uint32
    clusterBottomLevelByteAlignment*: uint32
    clusterTemplateBoundsByteAlignment*: uint32
    maxClusterGeometryIndex*: uint32

  VkStridedDeviceAddressNV* = object
    startAddress*: VkDeviceAddress
    strideInBytes*: VkDeviceSize

  VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    allowClusterAccelerationStructure*: VkBool32

  VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV* = object
    geometryIndex*: uint32
    reserved*: uint32
    geometryFlags*: uint32

  VkClusterAccelerationStructureMoveObjectsInfoNV* = object
    srcAccelerationStructure*: VkDeviceAddress

  VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV* = object
    clusterReferencesCount*: uint32
    clusterReferencesStride*: uint32
    clusterReferences*: VkDeviceAddress

  VkClusterAccelerationStructureGetTemplateIndicesInfoNV* = object
    clusterTemplateAddress*: VkDeviceAddress

  VkClusterAccelerationStructureBuildTriangleClusterInfoNV* = object
    clusterID*: uint32
    clusterFlags*: VkClusterAccelerationStructureClusterFlagsNV
    triangleCount*: uint32
    vertexCount*: uint32
    positionTruncateBitCount*: uint32
    indexType*: uint32
    opacityMicromapIndexType*: uint32
    baseGeometryIndexAndGeometryFlags*: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
    indexBufferStride*: uint16
    vertexBufferStride*: uint16
    geometryIndexAndFlagsBufferStride*: uint16
    opacityMicromapIndexBufferStride*: uint16
    indexBuffer*: VkDeviceAddress
    vertexBuffer*: VkDeviceAddress
    geometryIndexAndFlagsBuffer*: VkDeviceAddress
    opacityMicromapArray*: VkDeviceAddress
    opacityMicromapIndexBuffer*: VkDeviceAddress

  VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV* = object
    clusterID*: uint32
    clusterFlags*: VkClusterAccelerationStructureClusterFlagsNV
    triangleCount*: uint32
    vertexCount*: uint32
    positionTruncateBitCount*: uint32
    indexType*: uint32
    opacityMicromapIndexType*: uint32
    baseGeometryIndexAndGeometryFlags*: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
    indexBufferStride*: uint16
    vertexBufferStride*: uint16
    geometryIndexAndFlagsBufferStride*: uint16
    opacityMicromapIndexBufferStride*: uint16
    indexBuffer*: VkDeviceAddress
    vertexBuffer*: VkDeviceAddress
    geometryIndexAndFlagsBuffer*: VkDeviceAddress
    opacityMicromapArray*: VkDeviceAddress
    opacityMicromapIndexBuffer*: VkDeviceAddress
    instantiationBoundingBoxLimit*: VkDeviceAddress

  VkClusterAccelerationStructureInstantiateClusterInfoNV* = object
    clusterIdOffset*: uint32
    geometryIndexOffset*: uint32
    reserved*: uint32
    clusterTemplateAddress*: VkDeviceAddress
    vertexBuffer*: VkStridedDeviceAddressNV

  VkClusterAccelerationStructureClustersBottomLevelInputNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxTotalClusterCount*: uint32
    maxClusterCountPerAccelerationStructure*: uint32

  VkClusterAccelerationStructureTriangleClusterInputNV* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexFormat*: VkFormat
    maxGeometryIndexValue*: uint32
    maxClusterUniqueGeometryCount*: uint32
    maxClusterTriangleCount*: uint32
    maxClusterVertexCount*: uint32
    maxTotalTriangleCount*: uint32
    maxTotalVertexCount*: uint32
    minPositionTruncateBitCount*: uint32

  VkClusterAccelerationStructureMoveObjectsInputNV* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkClusterAccelerationStructureTypeNV
    noMoveOverlap*: VkBool32
    maxMovedBytes*: VkDeviceSize

  VkClusterAccelerationStructureOpInputNV* {.union.} = object
    pClustersBottomLevel*: ptr VkClusterAccelerationStructureClustersBottomLevelInputNV
    pTriangleClusters*: ptr VkClusterAccelerationStructureTriangleClusterInputNV
    pMoveObjects*: ptr VkClusterAccelerationStructureMoveObjectsInputNV

  VkClusterAccelerationStructureInputInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxAccelerationStructureCount*: uint32
    flags*: VkBuildAccelerationStructureFlagsKHR
    opType*: VkClusterAccelerationStructureOpTypeNV
    opMode*: VkClusterAccelerationStructureOpModeNV
    opInput*: VkClusterAccelerationStructureOpInputNV

  VkClusterAccelerationStructureCommandsInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    input*: VkClusterAccelerationStructureInputInfoNV
    dstImplicitData*: VkDeviceAddress
    scratchData*: VkDeviceAddress
    dstAddressesArray*: VkStridedDeviceAddressRegionKHR
    dstSizesArray*: VkStridedDeviceAddressRegionKHR
    srcInfosArray*: VkStridedDeviceAddressRegionKHR
    srcInfosCount*: VkDeviceAddress
    addressResolutionFlags*: VkClusterAccelerationStructureAddressResolutionFlagsNV

  VkPhysicalDeviceMultiDrawPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxMultiDrawCount*: uint32

  VkGraphicsShaderGroupCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    stageCount*: uint32
    pStages*: ptr VkPipelineShaderStageCreateInfo
    pVertexInputState*: ptr VkPipelineVertexInputStateCreateInfo
    pTessellationState*: ptr VkPipelineTessellationStateCreateInfo

  VkGraphicsPipelineShaderGroupsCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    groupCount*: uint32
    pGroups*: ptr VkGraphicsShaderGroupCreateInfoNV
    pipelineCount*: uint32
    pPipelines*: ptr VkPipeline

  VkBindShaderGroupIndirectCommandNV* = object
    groupIndex*: uint32

  VkBindIndexBufferIndirectCommandNV* = object
    bufferAddress*: VkDeviceAddress
    size*: uint32
    indexType*: VkIndexType

  VkBindVertexBufferIndirectCommandNV* = object
    bufferAddress*: VkDeviceAddress
    size*: uint32
    stride*: uint32

  VkSetStateFlagsIndirectCommandNV* = object
    data*: uint32

  VkIndirectCommandsStreamNV* = object
    buffer*: VkBuffer
    offset*: VkDeviceSize

  VkIndirectCommandsLayoutTokenNV* = object
    sType*: VkStructureType
    pNext*: pointer
    tokenType*: VkIndirectCommandsTokenTypeNV
    stream*: uint32
    offset*: uint32
    vertexBindingUnit*: uint32
    vertexDynamicStride*: VkBool32
    pushconstantPipelineLayout*: VkPipelineLayout
    pushconstantShaderStageFlags*: VkShaderStageFlags
    pushconstantOffset*: uint32
    pushconstantSize*: uint32
    indirectStateFlags*: VkIndirectStateFlagsNV
    indexTypeCount*: uint32
    pIndexTypes*: ptr VkIndexType
    pIndexTypeValues*: ptr uint32

  VkIndirectCommandsLayoutCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkIndirectCommandsLayoutUsageFlagsNV
    pipelineBindPoint*: VkPipelineBindPoint
    tokenCount*: uint32
    pTokens*: ptr VkIndirectCommandsLayoutTokenNV
    streamCount*: uint32
    pStreamStrides*: ptr uint32

  VkGeneratedCommandsInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineBindPoint*: VkPipelineBindPoint
    pipeline*: VkPipeline
    indirectCommandsLayout*: VkIndirectCommandsLayoutNV
    streamCount*: uint32
    pStreams*: ptr VkIndirectCommandsStreamNV
    sequencesCount*: uint32
    preprocessBuffer*: VkBuffer
    preprocessOffset*: VkDeviceSize
    preprocessSize*: VkDeviceSize
    sequencesCountBuffer*: VkBuffer
    sequencesCountOffset*: VkDeviceSize
    sequencesIndexBuffer*: VkBuffer
    sequencesIndexOffset*: VkDeviceSize

  VkGeneratedCommandsMemoryRequirementsInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineBindPoint*: VkPipelineBindPoint
    pipeline*: VkPipeline
    indirectCommandsLayout*: VkIndirectCommandsLayoutNV
    maxSequencesCount*: uint32

  VkPipelineIndirectDeviceAddressInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineBindPoint*: VkPipelineBindPoint
    pipeline*: VkPipeline

  VkBindPipelineIndirectCommandNV* = object
    pipelineAddress*: VkDeviceAddress

  VkPhysicalDeviceFeatures2* = object
    sType*: VkStructureType
    pNext*: pointer
    features*: VkPhysicalDeviceFeatures

  VkPhysicalDeviceFeatures2KHR* = VkPhysicalDeviceFeatures2

  VkPhysicalDeviceProperties2* = object
    sType*: VkStructureType
    pNext*: pointer
    properties*: VkPhysicalDeviceProperties

  VkPhysicalDeviceProperties2KHR* = VkPhysicalDeviceProperties2

  VkFormatProperties2* = object
    sType*: VkStructureType
    pNext*: pointer
    formatProperties*: VkFormatProperties

  VkFormatProperties2KHR* = VkFormatProperties2

  VkImageFormatProperties2* = object
    sType*: VkStructureType
    pNext*: pointer
    imageFormatProperties*: VkImageFormatProperties

  VkImageFormatProperties2KHR* = VkImageFormatProperties2

  VkPhysicalDeviceImageFormatInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat
    `type`*: VkImageType
    tiling*: VkImageTiling
    usage*: VkImageUsageFlags
    flags*: VkImageCreateFlags

  VkPhysicalDeviceImageFormatInfo2KHR* = VkPhysicalDeviceImageFormatInfo2

  VkQueueFamilyProperties2* = object
    sType*: VkStructureType
    pNext*: pointer
    queueFamilyProperties*: VkQueueFamilyProperties

  VkQueueFamilyProperties2KHR* = VkQueueFamilyProperties2

  VkPhysicalDeviceMemoryProperties2* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryProperties*: VkPhysicalDeviceMemoryProperties

  VkPhysicalDeviceMemoryProperties2KHR* = VkPhysicalDeviceMemoryProperties2

  VkSparseImageFormatProperties2* = object
    sType*: VkStructureType
    pNext*: pointer
    properties*: VkSparseImageFormatProperties

  VkSparseImageFormatProperties2KHR* = VkSparseImageFormatProperties2

  VkPhysicalDeviceSparseImageFormatInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat
    `type`*: VkImageType
    samples*: VkSampleCountFlagBits
    usage*: VkImageUsageFlags
    tiling*: VkImageTiling

  VkPhysicalDeviceSparseImageFormatInfo2KHR* = VkPhysicalDeviceSparseImageFormatInfo2

  VkPhysicalDevicePushDescriptorProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    maxPushDescriptors*: uint32

  VkPhysicalDevicePushDescriptorPropertiesKHR* = VkPhysicalDevicePushDescriptorProperties

  VkConformanceVersion* = object
    major*: uint8
    minor*: uint8
    subminor*: uint8
    patch*: uint8

  VkConformanceVersionKHR* = VkConformanceVersion

  VkPhysicalDeviceDriverProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    driverID*: VkDriverId
    driverName*: array[VK_MAX_DRIVER_NAME_SIZE, char]
    driverInfo*: array[VK_MAX_DRIVER_INFO_SIZE, char]
    conformanceVersion*: VkConformanceVersion

  VkPhysicalDeviceDriverPropertiesKHR* = VkPhysicalDeviceDriverProperties

  VkPresentRegionsKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchainCount*: uint32
    pRegions*: ptr VkPresentRegionKHR

  VkPresentRegionKHR* = object
    rectangleCount*: uint32
    pRectangles*: ptr VkRectLayerKHR

  VkRectLayerKHR* = object
    offset*: VkOffset2D
    extent*: VkExtent2D
    layer*: uint32

  VkPhysicalDeviceVariablePointersFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    variablePointersStorageBuffer*: VkBool32
    variablePointers*: VkBool32

  VkPhysicalDeviceVariablePointersFeaturesKHR* = VkPhysicalDeviceVariablePointersFeatures

  VkPhysicalDeviceVariablePointerFeaturesKHR* = VkPhysicalDeviceVariablePointersFeatures

  VkPhysicalDeviceVariablePointerFeatures* = VkPhysicalDeviceVariablePointersFeatures

  VkExternalMemoryProperties* = object
    externalMemoryFeatures*: VkExternalMemoryFeatureFlags
    exportFromImportedHandleTypes*: VkExternalMemoryHandleTypeFlags
    compatibleHandleTypes*: VkExternalMemoryHandleTypeFlags

  VkExternalMemoryPropertiesKHR* = VkExternalMemoryProperties

  VkPhysicalDeviceExternalImageFormatInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalMemoryHandleTypeFlagBits

  VkPhysicalDeviceExternalImageFormatInfoKHR* = VkPhysicalDeviceExternalImageFormatInfo

  VkExternalImageFormatProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    externalMemoryProperties*: VkExternalMemoryProperties

  VkExternalImageFormatPropertiesKHR* = VkExternalImageFormatProperties

  VkPhysicalDeviceExternalBufferInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkBufferCreateFlags
    usage*: VkBufferUsageFlags
    handleType*: VkExternalMemoryHandleTypeFlagBits

  VkPhysicalDeviceExternalBufferInfoKHR* = VkPhysicalDeviceExternalBufferInfo

  VkExternalBufferProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    externalMemoryProperties*: VkExternalMemoryProperties

  VkExternalBufferPropertiesKHR* = VkExternalBufferProperties

  VkPhysicalDeviceIDProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceUUID*: array[VK_UUID_SIZE, uint8]
    driverUUID*: array[VK_UUID_SIZE, uint8]
    deviceLUID*: array[VK_LUID_SIZE, uint8]
    deviceNodeMask*: uint32
    deviceLUIDValid*: VkBool32

  VkPhysicalDeviceIDPropertiesKHR* = VkPhysicalDeviceIDProperties

  VkExternalMemoryImageCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    handleTypes*: VkExternalMemoryHandleTypeFlags

  VkExternalMemoryImageCreateInfoKHR* = VkExternalMemoryImageCreateInfo

  VkExternalMemoryBufferCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    handleTypes*: VkExternalMemoryHandleTypeFlags

  VkExternalMemoryBufferCreateInfoKHR* = VkExternalMemoryBufferCreateInfo

  VkExportMemoryAllocateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    handleTypes*: VkExternalMemoryHandleTypeFlags

  VkExportMemoryAllocateInfoKHR* = VkExportMemoryAllocateInfo

  VkImportMemoryWin32HandleInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalMemoryHandleTypeFlagBits
    handle*: HANDLE
    name*: LPCWSTR

  VkExportMemoryWin32HandleInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pAttributes*: ptr SECURITY_ATTRIBUTES
    dwAccess*: DWORD
    name*: LPCWSTR

  VkImportMemoryZirconHandleInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalMemoryHandleTypeFlagBits
    handle*: zx_handle_t

  VkMemoryZirconHandlePropertiesFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryTypeBits*: uint32

  VkMemoryGetZirconHandleInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory
    handleType*: VkExternalMemoryHandleTypeFlagBits

  VkMemoryWin32HandlePropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryTypeBits*: uint32

  VkMemoryGetWin32HandleInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory
    handleType*: VkExternalMemoryHandleTypeFlagBits

  VkImportMemoryFdInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalMemoryHandleTypeFlagBits
    fd*: int

  VkMemoryFdPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryTypeBits*: uint32

  VkMemoryGetFdInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory
    handleType*: VkExternalMemoryHandleTypeFlagBits

  VkWin32KeyedMutexAcquireReleaseInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    acquireCount*: uint32
    pAcquireSyncs*: ptr VkDeviceMemory
    pAcquireKeys*: ptr uint64
    pAcquireTimeouts*: ptr uint32
    releaseCount*: uint32
    pReleaseSyncs*: ptr VkDeviceMemory
    pReleaseKeys*: ptr uint64

  VkImportMemoryMetalHandleInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalMemoryHandleTypeFlagBits
    handle*: pointer

  VkMemoryMetalHandlePropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryTypeBits*: uint32

  VkMemoryGetMetalHandleInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory
    handleType*: VkExternalMemoryHandleTypeFlagBits

  VkPhysicalDeviceExternalSemaphoreInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalSemaphoreHandleTypeFlagBits

  VkPhysicalDeviceExternalSemaphoreInfoKHR* = VkPhysicalDeviceExternalSemaphoreInfo

  VkExternalSemaphoreProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    exportFromImportedHandleTypes*: VkExternalSemaphoreHandleTypeFlags
    compatibleHandleTypes*: VkExternalSemaphoreHandleTypeFlags
    externalSemaphoreFeatures*: VkExternalSemaphoreFeatureFlags

  VkExternalSemaphorePropertiesKHR* = VkExternalSemaphoreProperties

  VkExportSemaphoreCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    handleTypes*: VkExternalSemaphoreHandleTypeFlags

  VkExportSemaphoreCreateInfoKHR* = VkExportSemaphoreCreateInfo

  VkImportSemaphoreWin32HandleInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    flags*: VkSemaphoreImportFlags
    handleType*: VkExternalSemaphoreHandleTypeFlagBits
    handle*: HANDLE
    name*: LPCWSTR

  VkExportSemaphoreWin32HandleInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pAttributes*: ptr SECURITY_ATTRIBUTES
    dwAccess*: DWORD
    name*: LPCWSTR

  VkD3D12FenceSubmitInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    waitSemaphoreValuesCount*: uint32
    pWaitSemaphoreValues*: ptr uint64
    signalSemaphoreValuesCount*: uint32
    pSignalSemaphoreValues*: ptr uint64

  VkSemaphoreGetWin32HandleInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    handleType*: VkExternalSemaphoreHandleTypeFlagBits

  VkImportSemaphoreFdInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    flags*: VkSemaphoreImportFlags
    handleType*: VkExternalSemaphoreHandleTypeFlagBits
    fd*: int

  VkSemaphoreGetFdInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    handleType*: VkExternalSemaphoreHandleTypeFlagBits

  VkImportSemaphoreZirconHandleInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    flags*: VkSemaphoreImportFlags
    handleType*: VkExternalSemaphoreHandleTypeFlagBits
    zirconHandle*: zx_handle_t

  VkSemaphoreGetZirconHandleInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    handleType*: VkExternalSemaphoreHandleTypeFlagBits

  VkPhysicalDeviceExternalFenceInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalFenceHandleTypeFlagBits

  VkPhysicalDeviceExternalFenceInfoKHR* = VkPhysicalDeviceExternalFenceInfo

  VkExternalFenceProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    exportFromImportedHandleTypes*: VkExternalFenceHandleTypeFlags
    compatibleHandleTypes*: VkExternalFenceHandleTypeFlags
    externalFenceFeatures*: VkExternalFenceFeatureFlags

  VkExternalFencePropertiesKHR* = VkExternalFenceProperties

  VkExportFenceCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    handleTypes*: VkExternalFenceHandleTypeFlags

  VkExportFenceCreateInfoKHR* = VkExportFenceCreateInfo

  VkImportFenceWin32HandleInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    fence*: VkFence
    flags*: VkFenceImportFlags
    handleType*: VkExternalFenceHandleTypeFlagBits
    handle*: HANDLE
    name*: LPCWSTR

  VkExportFenceWin32HandleInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pAttributes*: ptr SECURITY_ATTRIBUTES
    dwAccess*: DWORD
    name*: LPCWSTR

  VkFenceGetWin32HandleInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    fence*: VkFence
    handleType*: VkExternalFenceHandleTypeFlagBits

  VkImportFenceFdInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    fence*: VkFence
    flags*: VkFenceImportFlags
    handleType*: VkExternalFenceHandleTypeFlagBits
    fd*: int

  VkFenceGetFdInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    fence*: VkFence
    handleType*: VkExternalFenceHandleTypeFlagBits

  VkExportFenceSciSyncInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pAttributes*: NvSciSyncAttrList

  VkImportFenceSciSyncInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    fence*: VkFence
    handleType*: VkExternalFenceHandleTypeFlagBits
    handle*: pointer

  VkFenceGetSciSyncInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    fence*: VkFence
    handleType*: VkExternalFenceHandleTypeFlagBits

  VkExportSemaphoreSciSyncInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pAttributes*: NvSciSyncAttrList

  VkImportSemaphoreSciSyncInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    handleType*: VkExternalSemaphoreHandleTypeFlagBits
    handle*: pointer

  VkSemaphoreGetSciSyncInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    handleType*: VkExternalSemaphoreHandleTypeFlagBits

  VkSciSyncAttributesInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    clientType*: VkSciSyncClientTypeNV
    primitiveType*: VkSciSyncPrimitiveTypeNV

  VkPhysicalDeviceExternalSciSyncFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    sciSyncFence*: VkBool32
    sciSyncSemaphore*: VkBool32
    sciSyncImport*: VkBool32
    sciSyncExport*: VkBool32

  VkPhysicalDeviceExternalSciSync2FeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    sciSyncFence*: VkBool32
    sciSyncSemaphore2*: VkBool32
    sciSyncImport*: VkBool32
    sciSyncExport*: VkBool32

  VkSemaphoreSciSyncPoolCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    handle*: NvSciSyncObj

  VkSemaphoreSciSyncCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphorePool*: VkSemaphoreSciSyncPoolNV
    pFence*: ptr NvSciSyncFence

  VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphoreSciSyncPoolRequestCount*: uint32

  VkPhysicalDeviceMultiviewFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    multiview*: VkBool32
    multiviewGeometryShader*: VkBool32
    multiviewTessellationShader*: VkBool32

  VkPhysicalDeviceMultiviewFeaturesKHR* = VkPhysicalDeviceMultiviewFeatures

  VkPhysicalDeviceMultiviewProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    maxMultiviewViewCount*: uint32
    maxMultiviewInstanceIndex*: uint32

  VkPhysicalDeviceMultiviewPropertiesKHR* = VkPhysicalDeviceMultiviewProperties

  VkRenderPassMultiviewCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    subpassCount*: uint32
    pViewMasks*: ptr uint32
    dependencyCount*: uint32
    pViewOffsets*: ptr int32
    correlationMaskCount*: uint32
    pCorrelationMasks*: ptr uint32

  VkRenderPassMultiviewCreateInfoKHR* = VkRenderPassMultiviewCreateInfo

  VkSurfaceCapabilities2EXT* = object
    sType*: VkStructureType
    pNext*: pointer
    minImageCount*: uint32
    maxImageCount*: uint32
    currentExtent*: VkExtent2D
    minImageExtent*: VkExtent2D
    maxImageExtent*: VkExtent2D
    maxImageArrayLayers*: uint32
    supportedTransforms*: VkSurfaceTransformFlagsKHR
    currentTransform*: VkSurfaceTransformFlagBitsKHR
    supportedCompositeAlpha*: VkCompositeAlphaFlagsKHR
    supportedUsageFlags*: VkImageUsageFlags
    supportedSurfaceCounters*: VkSurfaceCounterFlagsEXT

  VkDisplayPowerInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    powerState*: VkDisplayPowerStateEXT

  VkDeviceEventInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceEvent*: VkDeviceEventTypeEXT

  VkDisplayEventInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    displayEvent*: VkDisplayEventTypeEXT

  VkSwapchainCounterCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    surfaceCounters*: VkSurfaceCounterFlagsEXT

  VkPhysicalDeviceGroupProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    physicalDeviceCount*: uint32
    physicalDevices*: array[VK_MAX_DEVICE_GROUP_SIZE, VkPhysicalDevice]
    subsetAllocation*: VkBool32

  VkPhysicalDeviceGroupPropertiesKHR* = VkPhysicalDeviceGroupProperties

  VkMemoryAllocateFlagsInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkMemoryAllocateFlags
    deviceMask*: uint32

  VkMemoryAllocateFlagsInfoKHR* = VkMemoryAllocateFlagsInfo

  VkBindBufferMemoryInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    buffer*: VkBuffer
    memory*: VkDeviceMemory
    memoryOffset*: VkDeviceSize

  VkBindBufferMemoryInfoKHR* = VkBindBufferMemoryInfo

  VkBindBufferMemoryDeviceGroupInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceIndexCount*: uint32
    pDeviceIndices*: ptr uint32

  VkBindBufferMemoryDeviceGroupInfoKHR* = VkBindBufferMemoryDeviceGroupInfo

  VkBindImageMemoryInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    image*: VkImage
    memory*: VkDeviceMemory
    memoryOffset*: VkDeviceSize

  VkBindImageMemoryInfoKHR* = VkBindImageMemoryInfo

  VkBindImageMemoryDeviceGroupInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceIndexCount*: uint32
    pDeviceIndices*: ptr uint32
    splitInstanceBindRegionCount*: uint32
    pSplitInstanceBindRegions*: ptr VkRect2D

  VkBindImageMemoryDeviceGroupInfoKHR* = VkBindImageMemoryDeviceGroupInfo

  VkDeviceGroupRenderPassBeginInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceMask*: uint32
    deviceRenderAreaCount*: uint32
    pDeviceRenderAreas*: ptr VkRect2D

  VkDeviceGroupRenderPassBeginInfoKHR* = VkDeviceGroupRenderPassBeginInfo

  VkDeviceGroupCommandBufferBeginInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceMask*: uint32

  VkDeviceGroupCommandBufferBeginInfoKHR* = VkDeviceGroupCommandBufferBeginInfo

  VkDeviceGroupSubmitInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    waitSemaphoreCount*: uint32
    pWaitSemaphoreDeviceIndices*: ptr uint32
    commandBufferCount*: uint32
    pCommandBufferDeviceMasks*: ptr uint32
    signalSemaphoreCount*: uint32
    pSignalSemaphoreDeviceIndices*: ptr uint32

  VkDeviceGroupSubmitInfoKHR* = VkDeviceGroupSubmitInfo

  VkDeviceGroupBindSparseInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    resourceDeviceIndex*: uint32
    memoryDeviceIndex*: uint32

  VkDeviceGroupBindSparseInfoKHR* = VkDeviceGroupBindSparseInfo

  VkDeviceGroupPresentCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentMask*: array[VK_MAX_DEVICE_GROUP_SIZE, uint32]
    modes*: VkDeviceGroupPresentModeFlagsKHR

  VkImageSwapchainCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchain*: VkSwapchainKHR

  VkBindImageMemorySwapchainInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchain*: VkSwapchainKHR
    imageIndex*: uint32

  VkAcquireNextImageInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchain*: VkSwapchainKHR
    timeout*: uint64
    semaphore*: VkSemaphore
    fence*: VkFence
    deviceMask*: uint32

  VkDeviceGroupPresentInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchainCount*: uint32
    pDeviceMasks*: ptr uint32
    mode*: VkDeviceGroupPresentModeFlagBitsKHR

  VkDeviceGroupDeviceCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    physicalDeviceCount*: uint32
    pPhysicalDevices*: ptr VkPhysicalDevice

  VkDeviceGroupDeviceCreateInfoKHR* = VkDeviceGroupDeviceCreateInfo

  VkDeviceGroupSwapchainCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    modes*: VkDeviceGroupPresentModeFlagsKHR

  VkDescriptorUpdateTemplateEntry* = object
    dstBinding*: uint32
    dstArrayElement*: uint32
    descriptorCount*: uint32
    descriptorType*: VkDescriptorType
    offset*: uint
    stride*: uint

  VkDescriptorUpdateTemplateEntryKHR* = VkDescriptorUpdateTemplateEntry

  VkDescriptorUpdateTemplateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDescriptorUpdateTemplateCreateFlags
    descriptorUpdateEntryCount*: uint32
    pDescriptorUpdateEntries*: ptr VkDescriptorUpdateTemplateEntry
    templateType*: VkDescriptorUpdateTemplateType
    descriptorSetLayout*: VkDescriptorSetLayout
    pipelineBindPoint*: VkPipelineBindPoint
    pipelineLayout*: VkPipelineLayout
    set*: uint32

  VkDescriptorUpdateTemplateCreateInfoKHR* = VkDescriptorUpdateTemplateCreateInfo

  VkXYColorEXT* = object
    x*: float32
    y*: float32

  VkPhysicalDevicePresentIdFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentId*: VkBool32

  VkPresentIdKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchainCount*: uint32
    pPresentIds*: ptr uint64

  VkPhysicalDevicePresentId2FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentId2*: VkBool32

  VkPresentId2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchainCount*: uint32
    pPresentIds*: ptr uint64

  VkPresentWait2InfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentId*: uint64
    timeout*: uint64

  VkPhysicalDevicePresentWaitFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentWait*: VkBool32

  VkPhysicalDevicePresentWait2FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentWait2*: VkBool32

  VkPhysicalDevicePresentTimingFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    presentTiming*: VkBool32
    presentAtAbsoluteTime*: VkBool32
    presentAtRelativeTime*: VkBool32

  VkPresentTimingSurfaceCapabilitiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    presentTimingSupported*: VkBool32
    presentAtAbsoluteTimeSupported*: VkBool32
    presentAtRelativeTimeSupported*: VkBool32
    presentStageQueries*: VkPresentStageFlagsEXT

  VkSwapchainTimingPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    refreshDuration*: uint64
    refreshInterval*: uint64

  VkSwapchainTimeDomainPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    timeDomainCount*: uint32
    pTimeDomains*: ptr VkTimeDomainKHR
    pTimeDomainIds*: ptr uint64

  VkPresentStageTimeEXT* = object
    stage*: VkPresentStageFlagsEXT
    time*: uint64

  VkPastPresentationTimingInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPastPresentationTimingFlagsEXT
    swapchain*: VkSwapchainKHR

  VkPastPresentationTimingPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    timingPropertiesCounter*: uint64
    timeDomainsCounter*: uint64
    presentationTimingCount*: uint32
    pPresentationTimings*: ptr VkPastPresentationTimingEXT

  VkPastPresentationTimingEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    presentId*: uint64
    targetTime*: uint64
    presentStageCount*: uint32
    pPresentStages*: ptr VkPresentStageTimeEXT
    timeDomain*: VkTimeDomainKHR
    timeDomainId*: uint64
    reportComplete*: VkBool32

  VkPresentTimingsInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchainCount*: uint32
    pTimingInfos*: ptr VkPresentTimingInfoEXT

  VkPresentTimingInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPresentTimingInfoFlagsEXT
    targetTime*: uint64
    timeDomainId*: uint64
    presentStageQueries*: VkPresentStageFlagsEXT
    targetTimeDomainPresentStage*: VkPresentStageFlagsEXT

  VkSwapchainCalibratedTimestampInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchain*: VkSwapchainKHR
    presentStage*: VkPresentStageFlagsEXT
    timeDomainId*: uint64

  VkHdrMetadataEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    displayPrimaryRed*: VkXYColorEXT
    displayPrimaryGreen*: VkXYColorEXT
    displayPrimaryBlue*: VkXYColorEXT
    whitePoint*: VkXYColorEXT
    maxLuminance*: float32
    minLuminance*: float32
    maxContentLightLevel*: float32
    maxFrameAverageLightLevel*: float32

  VkHdrVividDynamicMetadataHUAWEI* = object
    sType*: VkStructureType
    pNext*: pointer
    dynamicMetadataSize*: uint
    pDynamicMetadata*: pointer

  VkDisplayNativeHdrSurfaceCapabilitiesAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    localDimmingSupport*: VkBool32

  VkSwapchainDisplayNativeHdrCreateInfoAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    localDimmingEnable*: VkBool32

  VkRefreshCycleDurationGOOGLE* = object
    refreshDuration*: uint64

  VkPastPresentationTimingGOOGLE* = object
    presentID*: uint32
    desiredPresentTime*: uint64
    actualPresentTime*: uint64
    earliestPresentTime*: uint64
    presentMargin*: uint64

  VkPresentTimesInfoGOOGLE* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchainCount*: uint32
    pTimes*: ptr VkPresentTimeGOOGLE

  VkPresentTimeGOOGLE* = object
    presentID*: uint32
    desiredPresentTime*: uint64

  VkIOSSurfaceCreateInfoMVK* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkIOSSurfaceCreateFlagsMVK
    pView*: pointer

  VkMacOSSurfaceCreateInfoMVK* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkMacOSSurfaceCreateFlagsMVK
    pView*: pointer

  VkMetalSurfaceCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkMetalSurfaceCreateFlagsEXT
    pLayer*: ptr CAMetalLayer

  VkViewportWScalingNV* = object
    xcoeff*: float32
    ycoeff*: float32

  VkPipelineViewportWScalingStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    viewportWScalingEnable*: VkBool32
    viewportCount*: uint32
    pViewportWScalings*: ptr VkViewportWScalingNV

  VkViewportSwizzleNV* = object
    x*: VkViewportCoordinateSwizzleNV
    y*: VkViewportCoordinateSwizzleNV
    z*: VkViewportCoordinateSwizzleNV
    w*: VkViewportCoordinateSwizzleNV

  VkPipelineViewportSwizzleStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineViewportSwizzleStateCreateFlagsNV
    viewportCount*: uint32
    pViewportSwizzles*: ptr VkViewportSwizzleNV

  VkPhysicalDeviceDiscardRectanglePropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxDiscardRectangles*: uint32

  VkPipelineDiscardRectangleStateCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineDiscardRectangleStateCreateFlagsEXT
    discardRectangleMode*: VkDiscardRectangleModeEXT
    discardRectangleCount*: uint32
    pDiscardRectangles*: ptr VkRect2D

  VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* = object
    sType*: VkStructureType
    pNext*: pointer
    perViewPositionAllComponents*: VkBool32

  VkInputAttachmentAspectReference* = object
    subpass*: uint32
    inputAttachmentIndex*: uint32
    aspectMask*: VkImageAspectFlags

  VkInputAttachmentAspectReferenceKHR* = VkInputAttachmentAspectReference

  VkRenderPassInputAttachmentAspectCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    aspectReferenceCount*: uint32
    pAspectReferences*: ptr VkInputAttachmentAspectReference

  VkRenderPassInputAttachmentAspectCreateInfoKHR* = VkRenderPassInputAttachmentAspectCreateInfo

  VkPhysicalDeviceSurfaceInfo2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    surface*: VkSurfaceKHR

  VkSurfaceCapabilities2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    surfaceCapabilities*: VkSurfaceCapabilitiesKHR

  VkSurfaceFormat2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    surfaceFormat*: VkSurfaceFormatKHR

  VkDisplayProperties2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    displayProperties*: VkDisplayPropertiesKHR

  VkDisplayPlaneProperties2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    displayPlaneProperties*: VkDisplayPlanePropertiesKHR

  VkDisplayModeProperties2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    displayModeProperties*: VkDisplayModePropertiesKHR

  VkDisplayModeStereoPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    hdmi3DSupported*: VkBool32

  VkDisplayPlaneInfo2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    mode*: VkDisplayModeKHR
    planeIndex*: uint32

  VkDisplayPlaneCapabilities2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    capabilities*: VkDisplayPlaneCapabilitiesKHR

  VkSharedPresentSurfaceCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    sharedPresentSupportedUsageFlags*: VkImageUsageFlags

  VkPhysicalDevice16BitStorageFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    storageBuffer16BitAccess*: VkBool32
    uniformAndStorageBuffer16BitAccess*: VkBool32
    storagePushConstant16*: VkBool32
    storageInputOutput16*: VkBool32

  VkPhysicalDevice16BitStorageFeaturesKHR* = VkPhysicalDevice16BitStorageFeatures

  VkPhysicalDeviceSubgroupProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    subgroupSize*: uint32
    supportedStages*: VkShaderStageFlags
    supportedOperations*: VkSubgroupFeatureFlags
    quadOperationsInAllStages*: VkBool32

  VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderSubgroupExtendedTypes*: VkBool32

  VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR* = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures

  VkBufferMemoryRequirementsInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    buffer*: VkBuffer

  VkBufferMemoryRequirementsInfo2KHR* = VkBufferMemoryRequirementsInfo2

  VkDeviceBufferMemoryRequirements* = object
    sType*: VkStructureType
    pNext*: pointer
    pCreateInfo*: ptr VkBufferCreateInfo

  VkDeviceBufferMemoryRequirementsKHR* = VkDeviceBufferMemoryRequirements

  VkImageMemoryRequirementsInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    image*: VkImage

  VkImageMemoryRequirementsInfo2KHR* = VkImageMemoryRequirementsInfo2

  VkImageSparseMemoryRequirementsInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    image*: VkImage

  VkImageSparseMemoryRequirementsInfo2KHR* = VkImageSparseMemoryRequirementsInfo2

  VkDeviceImageMemoryRequirements* = object
    sType*: VkStructureType
    pNext*: pointer
    pCreateInfo*: ptr VkImageCreateInfo
    planeAspect*: VkImageAspectFlagBits

  VkDeviceImageMemoryRequirementsKHR* = VkDeviceImageMemoryRequirements

  VkMemoryRequirements2* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryRequirements*: VkMemoryRequirements

  VkMemoryRequirements2KHR* = VkMemoryRequirements2

  VkSparseImageMemoryRequirements2* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryRequirements*: VkSparseImageMemoryRequirements

  VkSparseImageMemoryRequirements2KHR* = VkSparseImageMemoryRequirements2

  VkPhysicalDevicePointClippingProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    pointClippingBehavior*: VkPointClippingBehavior

  VkPhysicalDevicePointClippingPropertiesKHR* = VkPhysicalDevicePointClippingProperties

  VkMemoryDedicatedRequirements* = object
    sType*: VkStructureType
    pNext*: pointer
    prefersDedicatedAllocation*: VkBool32
    requiresDedicatedAllocation*: VkBool32

  VkMemoryDedicatedRequirementsKHR* = VkMemoryDedicatedRequirements

  VkMemoryDedicatedAllocateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    image*: VkImage
    buffer*: VkBuffer

  VkMemoryDedicatedAllocateInfoKHR* = VkMemoryDedicatedAllocateInfo

  VkImageViewUsageCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    usage*: VkImageUsageFlags

  VkImageViewSlicedCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    sliceOffset*: uint32
    sliceCount*: uint32

  VkImageViewUsageCreateInfoKHR* = VkImageViewUsageCreateInfo

  VkPipelineTessellationDomainOriginStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    domainOrigin*: VkTessellationDomainOrigin

  VkPipelineTessellationDomainOriginStateCreateInfoKHR* = VkPipelineTessellationDomainOriginStateCreateInfo

  VkSamplerYcbcrConversionInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    conversion*: VkSamplerYcbcrConversion

  VkSamplerYcbcrConversionInfoKHR* = VkSamplerYcbcrConversionInfo

  VkSamplerYcbcrConversionCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat
    ycbcrModel*: VkSamplerYcbcrModelConversion
    ycbcrRange*: VkSamplerYcbcrRange
    components*: VkComponentMapping
    xChromaOffset*: VkChromaLocation
    yChromaOffset*: VkChromaLocation
    chromaFilter*: VkFilter
    forceExplicitReconstruction*: VkBool32

  VkSamplerYcbcrConversionCreateInfoKHR* = VkSamplerYcbcrConversionCreateInfo

  VkBindImagePlaneMemoryInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    planeAspect*: VkImageAspectFlagBits

  VkBindImagePlaneMemoryInfoKHR* = VkBindImagePlaneMemoryInfo

  VkImagePlaneMemoryRequirementsInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    planeAspect*: VkImageAspectFlagBits

  VkImagePlaneMemoryRequirementsInfoKHR* = VkImagePlaneMemoryRequirementsInfo

  VkPhysicalDeviceSamplerYcbcrConversionFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    samplerYcbcrConversion*: VkBool32

  VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR* = VkPhysicalDeviceSamplerYcbcrConversionFeatures

  VkSamplerYcbcrConversionImageFormatProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    combinedImageSamplerDescriptorCount*: uint32

  VkSamplerYcbcrConversionImageFormatPropertiesKHR* = VkSamplerYcbcrConversionImageFormatProperties

  VkTextureLODGatherFormatPropertiesAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    supportsTextureGatherLODBiasAMD*: VkBool32

  VkConditionalRenderingBeginInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    buffer*: VkBuffer
    offset*: VkDeviceSize
    flags*: VkConditionalRenderingFlagsEXT

  VkProtectedSubmitInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    protectedSubmit*: VkBool32

  VkPhysicalDeviceProtectedMemoryFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    protectedMemory*: VkBool32

  VkPhysicalDeviceProtectedMemoryProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    protectedNoFault*: VkBool32

  VkDeviceQueueInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDeviceQueueCreateFlags
    queueFamilyIndex*: uint32
    queueIndex*: uint32

  VkPipelineCoverageToColorStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCoverageToColorStateCreateFlagsNV
    coverageToColorEnable*: VkBool32
    coverageToColorLocation*: uint32

  VkPhysicalDeviceSamplerFilterMinmaxProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    filterMinmaxSingleComponentFormats*: VkBool32
    filterMinmaxImageComponentMapping*: VkBool32

  VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* = VkPhysicalDeviceSamplerFilterMinmaxProperties

  VkSampleLocationEXT* = object
    x*: float32
    y*: float32

  VkSampleLocationsInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    sampleLocationsPerPixel*: VkSampleCountFlagBits
    sampleLocationGridSize*: VkExtent2D
    sampleLocationsCount*: uint32
    pSampleLocations*: ptr VkSampleLocationEXT

  VkAttachmentSampleLocationsEXT* = object
    attachmentIndex*: uint32
    sampleLocationsInfo*: VkSampleLocationsInfoEXT

  VkSubpassSampleLocationsEXT* = object
    subpassIndex*: uint32
    sampleLocationsInfo*: VkSampleLocationsInfoEXT

  VkRenderPassSampleLocationsBeginInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    attachmentInitialSampleLocationsCount*: uint32
    pAttachmentInitialSampleLocations*: ptr VkAttachmentSampleLocationsEXT
    postSubpassSampleLocationsCount*: uint32
    pPostSubpassSampleLocations*: ptr VkSubpassSampleLocationsEXT

  VkPipelineSampleLocationsStateCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    sampleLocationsEnable*: VkBool32
    sampleLocationsInfo*: VkSampleLocationsInfoEXT

  VkPhysicalDeviceSampleLocationsPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    sampleLocationSampleCounts*: VkSampleCountFlags
    maxSampleLocationGridSize*: VkExtent2D
    sampleLocationCoordinateRange*: array[2, float32]
    sampleLocationSubPixelBits*: uint32
    variableSampleLocations*: VkBool32

  VkMultisamplePropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxSampleLocationGridSize*: VkExtent2D

  VkSamplerReductionModeCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    reductionMode*: VkSamplerReductionMode

  VkSamplerReductionModeCreateInfoEXT* = VkSamplerReductionModeCreateInfo

  VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    advancedBlendCoherentOperations*: VkBool32

  VkPhysicalDeviceMultiDrawFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    multiDraw*: VkBool32

  VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    advancedBlendMaxColorAttachments*: uint32
    advancedBlendIndependentBlend*: VkBool32
    advancedBlendNonPremultipliedSrcColor*: VkBool32
    advancedBlendNonPremultipliedDstColor*: VkBool32
    advancedBlendCorrelatedOverlap*: VkBool32
    advancedBlendAllOperations*: VkBool32

  VkPipelineColorBlendAdvancedStateCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    srcPremultiplied*: VkBool32
    dstPremultiplied*: VkBool32
    blendOverlap*: VkBlendOverlapEXT

  VkPhysicalDeviceInlineUniformBlockFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    inlineUniformBlock*: VkBool32
    descriptorBindingInlineUniformBlockUpdateAfterBind*: VkBool32

  VkPhysicalDeviceInlineUniformBlockFeaturesEXT* = VkPhysicalDeviceInlineUniformBlockFeatures

  VkPhysicalDeviceInlineUniformBlockProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    maxInlineUniformBlockSize*: uint32
    maxPerStageDescriptorInlineUniformBlocks*: uint32
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks*: uint32
    maxDescriptorSetInlineUniformBlocks*: uint32
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks*: uint32

  VkPhysicalDeviceInlineUniformBlockPropertiesEXT* = VkPhysicalDeviceInlineUniformBlockProperties

  VkWriteDescriptorSetInlineUniformBlock* = object
    sType*: VkStructureType
    pNext*: pointer
    dataSize*: uint32
    pData*: pointer

  VkWriteDescriptorSetInlineUniformBlockEXT* = VkWriteDescriptorSetInlineUniformBlock

  VkDescriptorPoolInlineUniformBlockCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    maxInlineUniformBlockBindings*: uint32

  VkDescriptorPoolInlineUniformBlockCreateInfoEXT* = VkDescriptorPoolInlineUniformBlockCreateInfo

  VkPipelineCoverageModulationStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCoverageModulationStateCreateFlagsNV
    coverageModulationMode*: VkCoverageModulationModeNV
    coverageModulationTableEnable*: VkBool32
    coverageModulationTableCount*: uint32
    pCoverageModulationTable*: ptr float32

  VkImageFormatListCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    viewFormatCount*: uint32
    pViewFormats*: ptr VkFormat

  VkImageFormatListCreateInfoKHR* = VkImageFormatListCreateInfo

  VkValidationCacheCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkValidationCacheCreateFlagsEXT
    initialDataSize*: uint
    pInitialData*: pointer

  VkShaderModuleValidationCacheCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    validationCache*: VkValidationCacheEXT

  VkPhysicalDeviceMaintenance3Properties* = object
    sType*: VkStructureType
    pNext*: pointer
    maxPerSetDescriptors*: uint32
    maxMemoryAllocationSize*: VkDeviceSize

  VkPhysicalDeviceMaintenance3PropertiesKHR* = VkPhysicalDeviceMaintenance3Properties

  VkPhysicalDeviceMaintenance4Features* = object
    sType*: VkStructureType
    pNext*: pointer
    maintenance4*: VkBool32

  VkPhysicalDeviceMaintenance4FeaturesKHR* = VkPhysicalDeviceMaintenance4Features

  VkPhysicalDeviceMaintenance4Properties* = object
    sType*: VkStructureType
    pNext*: pointer
    maxBufferSize*: VkDeviceSize

  VkPhysicalDeviceMaintenance4PropertiesKHR* = VkPhysicalDeviceMaintenance4Properties

  VkPhysicalDeviceMaintenance5Features* = object
    sType*: VkStructureType
    pNext*: pointer
    maintenance5*: VkBool32

  VkPhysicalDeviceMaintenance5FeaturesKHR* = VkPhysicalDeviceMaintenance5Features

  VkPhysicalDeviceMaintenance5Properties* = object
    sType*: VkStructureType
    pNext*: pointer
    earlyFragmentMultisampleCoverageAfterSampleCounting*: VkBool32
    earlyFragmentSampleMaskTestBeforeSampleCounting*: VkBool32
    depthStencilSwizzleOneSupport*: VkBool32
    polygonModePointSize*: VkBool32
    nonStrictSinglePixelWideLinesUseParallelogram*: VkBool32
    nonStrictWideLinesUseParallelogram*: VkBool32

  VkPhysicalDeviceMaintenance5PropertiesKHR* = VkPhysicalDeviceMaintenance5Properties

  VkPhysicalDeviceMaintenance6Features* = object
    sType*: VkStructureType
    pNext*: pointer
    maintenance6*: VkBool32

  VkPhysicalDeviceMaintenance6FeaturesKHR* = VkPhysicalDeviceMaintenance6Features

  VkPhysicalDeviceMaintenance6Properties* = object
    sType*: VkStructureType
    pNext*: pointer
    blockTexelViewCompatibleMultipleLayers*: VkBool32
    maxCombinedImageSamplerDescriptorCount*: uint32
    fragmentShadingRateClampCombinerInputs*: VkBool32

  VkPhysicalDeviceMaintenance6PropertiesKHR* = VkPhysicalDeviceMaintenance6Properties

  VkPhysicalDeviceMaintenance7FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maintenance7*: VkBool32

  VkPhysicalDeviceMaintenance7PropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    robustFragmentShadingRateAttachmentAccess*: VkBool32
    separateDepthStencilAttachmentAccess*: VkBool32
    maxDescriptorSetTotalUniformBuffersDynamic*: uint32
    maxDescriptorSetTotalStorageBuffersDynamic*: uint32
    maxDescriptorSetTotalBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindTotalBuffersDynamic*: uint32

  VkPhysicalDeviceLayeredApiPropertiesListKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    layeredApiCount*: uint32
    pLayeredApis*: ptr VkPhysicalDeviceLayeredApiPropertiesKHR

  VkPhysicalDeviceLayeredApiPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    vendorID*: uint32
    deviceID*: uint32
    layeredAPI*: VkPhysicalDeviceLayeredApiKHR
    deviceName*: array[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, char]

  VkPhysicalDeviceLayeredApiVulkanPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    properties*: VkPhysicalDeviceProperties2

  VkPhysicalDeviceMaintenance8FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maintenance8*: VkBool32

  VkPhysicalDeviceMaintenance9FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maintenance9*: VkBool32

  VkPhysicalDeviceMaintenance9PropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    image2DViewOf3DSparse*: VkBool32
    defaultVertexAttributeValue*: VkDefaultVertexAttributeValueKHR

  VkPhysicalDeviceMaintenance10PropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    rgba4OpaqueBlackSwizzled*: VkBool32
    resolveSrgbFormatAppliesTransferFunction*: VkBool32
    resolveSrgbFormatSupportsTransferFunctionControl*: VkBool32

  VkPhysicalDeviceMaintenance10FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maintenance10*: VkBool32

  VkQueueFamilyOwnershipTransferPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    optimalImageTransferToQueueFamilies*: uint32

  VkRenderingAreaInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    viewMask*: uint32
    colorAttachmentCount*: uint32
    pColorAttachmentFormats*: ptr VkFormat
    depthAttachmentFormat*: VkFormat
    stencilAttachmentFormat*: VkFormat

  VkRenderingAreaInfoKHR* = VkRenderingAreaInfo

  VkDescriptorSetLayoutSupport* = object
    sType*: VkStructureType
    pNext*: pointer
    supported*: VkBool32

  VkDescriptorSetLayoutSupportKHR* = VkDescriptorSetLayoutSupport

  VkPhysicalDeviceShaderDrawParametersFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderDrawParameters*: VkBool32

  VkPhysicalDeviceShaderDrawParameterFeatures* = VkPhysicalDeviceShaderDrawParametersFeatures

  VkPhysicalDeviceShaderFloat16Int8Features* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderFloat16*: VkBool32
    shaderInt8*: VkBool32

  VkPhysicalDeviceShaderFloat16Int8FeaturesKHR* = VkPhysicalDeviceShaderFloat16Int8Features

  VkPhysicalDeviceFloat16Int8FeaturesKHR* = VkPhysicalDeviceShaderFloat16Int8Features

  VkPhysicalDeviceFloatControlsProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    denormBehaviorIndependence*: VkShaderFloatControlsIndependence
    roundingModeIndependence*: VkShaderFloatControlsIndependence
    shaderSignedZeroInfNanPreserveFloat16*: VkBool32
    shaderSignedZeroInfNanPreserveFloat32*: VkBool32
    shaderSignedZeroInfNanPreserveFloat64*: VkBool32
    shaderDenormPreserveFloat16*: VkBool32
    shaderDenormPreserveFloat32*: VkBool32
    shaderDenormPreserveFloat64*: VkBool32
    shaderDenormFlushToZeroFloat16*: VkBool32
    shaderDenormFlushToZeroFloat32*: VkBool32
    shaderDenormFlushToZeroFloat64*: VkBool32
    shaderRoundingModeRTEFloat16*: VkBool32
    shaderRoundingModeRTEFloat32*: VkBool32
    shaderRoundingModeRTEFloat64*: VkBool32
    shaderRoundingModeRTZFloat16*: VkBool32
    shaderRoundingModeRTZFloat32*: VkBool32
    shaderRoundingModeRTZFloat64*: VkBool32

  VkPhysicalDeviceFloatControlsPropertiesKHR* = VkPhysicalDeviceFloatControlsProperties

  VkPhysicalDeviceHostQueryResetFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    hostQueryReset*: VkBool32

  VkPhysicalDeviceHostQueryResetFeaturesEXT* = VkPhysicalDeviceHostQueryResetFeatures

  VkNativeBufferUsage2ANDROID* = object
    consumer*: uint64
    producer*: uint64

  VkNativeBufferANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    handle*: pointer
    stride*: int
    format*: int
    usage*: int
    usage2*: VkNativeBufferUsage2ANDROID

  VkSwapchainImageCreateInfoANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    usage*: VkSwapchainImageUsageFlagsANDROID

  VkPhysicalDevicePresentationPropertiesANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    sharedImage*: VkBool32

  VkShaderResourceUsageAMD* = object
    numUsedVgprs*: uint32
    numUsedSgprs*: uint32
    ldsSizePerLocalWorkGroup*: uint32
    ldsUsageSizeInBytes*: uint
    scratchMemUsageInBytes*: uint

  VkShaderStatisticsInfoAMD* = object
    shaderStageMask*: VkShaderStageFlags
    resourceUsage*: VkShaderResourceUsageAMD
    numPhysicalVgprs*: uint32
    numPhysicalSgprs*: uint32
    numAvailableVgprs*: uint32
    numAvailableSgprs*: uint32
    computeWorkGroupSize*: array[3, uint32]

  VkDeviceQueueGlobalPriorityCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    globalPriority*: VkQueueGlobalPriority

  VkDeviceQueueGlobalPriorityCreateInfoKHR* = VkDeviceQueueGlobalPriorityCreateInfo

  VkDeviceQueueGlobalPriorityCreateInfoEXT* = VkDeviceQueueGlobalPriorityCreateInfo

  VkPhysicalDeviceGlobalPriorityQueryFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    globalPriorityQuery*: VkBool32

  VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* = VkPhysicalDeviceGlobalPriorityQueryFeatures

  VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT* = VkPhysicalDeviceGlobalPriorityQueryFeatures

  VkQueueFamilyGlobalPriorityProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    priorityCount*: uint32
    priorities*: array[VK_MAX_GLOBAL_PRIORITY_SIZE, VkQueueGlobalPriority]

  VkQueueFamilyGlobalPriorityPropertiesKHR* = VkQueueFamilyGlobalPriorityProperties

  VkQueueFamilyGlobalPriorityPropertiesEXT* = VkQueueFamilyGlobalPriorityProperties

  VkDebugUtilsObjectNameInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    objectType*: VkObjectType
    objectHandle*: uint64
    pObjectName*: cstring

  VkDebugUtilsObjectTagInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    objectType*: VkObjectType
    objectHandle*: uint64
    tagName*: uint64
    tagSize*: uint
    pTag*: pointer

  VkDebugUtilsLabelEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pLabelName*: cstring
    color*: array[4, float32]

  VkDebugUtilsMessengerCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDebugUtilsMessengerCreateFlagsEXT
    messageSeverity*: VkDebugUtilsMessageSeverityFlagsEXT
    messageType*: VkDebugUtilsMessageTypeFlagsEXT
    pfnUserCallback*: PFN_vkDebugUtilsMessengerCallbackEXT
    pUserData*: pointer

  VkDebugUtilsMessengerCallbackDataEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDebugUtilsMessengerCallbackDataFlagsEXT
    pMessageIdName*: cstring
    messageIdNumber*: int32
    pMessage*: cstring
    queueLabelCount*: uint32
    pQueueLabels*: ptr VkDebugUtilsLabelEXT
    cmdBufLabelCount*: uint32
    pCmdBufLabels*: ptr VkDebugUtilsLabelEXT
    objectCount*: uint32
    pObjects*: ptr VkDebugUtilsObjectNameInfoEXT

  VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceMemoryReport*: VkBool32

  VkDeviceDeviceMemoryReportCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDeviceMemoryReportFlagsEXT
    pfnUserCallback*: PFN_vkDeviceMemoryReportCallbackEXT
    pUserData*: pointer

  VkDeviceMemoryReportCallbackDataEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDeviceMemoryReportFlagsEXT
    `type`*: VkDeviceMemoryReportEventTypeEXT
    memoryObjectId*: uint64
    size*: VkDeviceSize
    objectType*: VkObjectType
    objectHandle*: uint64
    heapIndex*: uint32

  VkImportMemoryHostPointerInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    handleType*: VkExternalMemoryHandleTypeFlagBits
    pHostPointer*: pointer

  VkMemoryHostPointerPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryTypeBits*: uint32

  VkPhysicalDeviceExternalMemoryHostPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    minImportedHostPointerAlignment*: VkDeviceSize

  VkPhysicalDeviceConservativeRasterizationPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    primitiveOverestimationSize*: float32
    maxExtraPrimitiveOverestimationSize*: float32
    extraPrimitiveOverestimationSizeGranularity*: float32
    primitiveUnderestimation*: VkBool32
    conservativePointAndLineRasterization*: VkBool32
    degenerateTrianglesRasterized*: VkBool32
    degenerateLinesRasterized*: VkBool32
    fullyCoveredFragmentShaderInputVariable*: VkBool32
    conservativeRasterizationPostDepthCoverage*: VkBool32

  VkCalibratedTimestampInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    timeDomain*: VkTimeDomainKHR

  VkCalibratedTimestampInfoEXT* = VkCalibratedTimestampInfoKHR

  VkPhysicalDeviceShaderCorePropertiesAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderEngineCount*: uint32
    shaderArraysPerEngineCount*: uint32
    computeUnitsPerShaderArray*: uint32
    simdPerComputeUnit*: uint32
    wavefrontsPerSimd*: uint32
    wavefrontSize*: uint32
    sgprsPerSimd*: uint32
    minSgprAllocation*: uint32
    maxSgprAllocation*: uint32
    sgprAllocationGranularity*: uint32
    vgprsPerSimd*: uint32
    minVgprAllocation*: uint32
    maxVgprAllocation*: uint32
    vgprAllocationGranularity*: uint32

  VkPhysicalDeviceShaderCoreProperties2AMD* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderCoreFeatures*: VkShaderCorePropertiesFlagsAMD
    activeComputeUnitCount*: uint32

  VkPipelineRasterizationConservativeStateCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineRasterizationConservativeStateCreateFlagsEXT
    conservativeRasterizationMode*: VkConservativeRasterizationModeEXT
    extraPrimitiveOverestimationSize*: float32

  VkPhysicalDeviceDescriptorIndexingFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderInputAttachmentArrayDynamicIndexing*: VkBool32
    shaderUniformTexelBufferArrayDynamicIndexing*: VkBool32
    shaderStorageTexelBufferArrayDynamicIndexing*: VkBool32
    shaderUniformBufferArrayNonUniformIndexing*: VkBool32
    shaderSampledImageArrayNonUniformIndexing*: VkBool32
    shaderStorageBufferArrayNonUniformIndexing*: VkBool32
    shaderStorageImageArrayNonUniformIndexing*: VkBool32
    shaderInputAttachmentArrayNonUniformIndexing*: VkBool32
    shaderUniformTexelBufferArrayNonUniformIndexing*: VkBool32
    shaderStorageTexelBufferArrayNonUniformIndexing*: VkBool32
    descriptorBindingUniformBufferUpdateAfterBind*: VkBool32
    descriptorBindingSampledImageUpdateAfterBind*: VkBool32
    descriptorBindingStorageImageUpdateAfterBind*: VkBool32
    descriptorBindingStorageBufferUpdateAfterBind*: VkBool32
    descriptorBindingUniformTexelBufferUpdateAfterBind*: VkBool32
    descriptorBindingStorageTexelBufferUpdateAfterBind*: VkBool32
    descriptorBindingUpdateUnusedWhilePending*: VkBool32
    descriptorBindingPartiallyBound*: VkBool32
    descriptorBindingVariableDescriptorCount*: VkBool32
    runtimeDescriptorArray*: VkBool32

  VkPhysicalDeviceDescriptorIndexingFeaturesEXT* = VkPhysicalDeviceDescriptorIndexingFeatures

  VkPhysicalDeviceDescriptorIndexingProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    maxUpdateAfterBindDescriptorsInAllPools*: uint32
    shaderUniformBufferArrayNonUniformIndexingNative*: VkBool32
    shaderSampledImageArrayNonUniformIndexingNative*: VkBool32
    shaderStorageBufferArrayNonUniformIndexingNative*: VkBool32
    shaderStorageImageArrayNonUniformIndexingNative*: VkBool32
    shaderInputAttachmentArrayNonUniformIndexingNative*: VkBool32
    robustBufferAccessUpdateAfterBind*: VkBool32
    quadDivergentImplicitLod*: VkBool32
    maxPerStageDescriptorUpdateAfterBindSamplers*: uint32
    maxPerStageDescriptorUpdateAfterBindUniformBuffers*: uint32
    maxPerStageDescriptorUpdateAfterBindStorageBuffers*: uint32
    maxPerStageDescriptorUpdateAfterBindSampledImages*: uint32
    maxPerStageDescriptorUpdateAfterBindStorageImages*: uint32
    maxPerStageDescriptorUpdateAfterBindInputAttachments*: uint32
    maxPerStageUpdateAfterBindResources*: uint32
    maxDescriptorSetUpdateAfterBindSamplers*: uint32
    maxDescriptorSetUpdateAfterBindUniformBuffers*: uint32
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindStorageBuffers*: uint32
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindSampledImages*: uint32
    maxDescriptorSetUpdateAfterBindStorageImages*: uint32
    maxDescriptorSetUpdateAfterBindInputAttachments*: uint32

  VkPhysicalDeviceDescriptorIndexingPropertiesEXT* = VkPhysicalDeviceDescriptorIndexingProperties

  VkDescriptorSetLayoutBindingFlagsCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    bindingCount*: uint32
    pBindingFlags*: ptr VkDescriptorBindingFlags

  VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* = VkDescriptorSetLayoutBindingFlagsCreateInfo

  VkDescriptorSetVariableDescriptorCountAllocateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorSetCount*: uint32
    pDescriptorCounts*: ptr uint32

  VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* = VkDescriptorSetVariableDescriptorCountAllocateInfo

  VkDescriptorSetVariableDescriptorCountLayoutSupport* = object
    sType*: VkStructureType
    pNext*: pointer
    maxVariableDescriptorCount*: uint32

  VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* = VkDescriptorSetVariableDescriptorCountLayoutSupport

  VkAttachmentDescription2* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkAttachmentDescriptionFlags
    format*: VkFormat
    samples*: VkSampleCountFlagBits
    loadOp*: VkAttachmentLoadOp
    storeOp*: VkAttachmentStoreOp
    stencilLoadOp*: VkAttachmentLoadOp
    stencilStoreOp*: VkAttachmentStoreOp
    initialLayout*: VkImageLayout
    finalLayout*: VkImageLayout

  VkAttachmentDescription2KHR* = VkAttachmentDescription2

  VkAttachmentReference2* = object
    sType*: VkStructureType
    pNext*: pointer
    attachment*: uint32
    layout*: VkImageLayout
    aspectMask*: VkImageAspectFlags

  VkAttachmentReference2KHR* = VkAttachmentReference2

  VkSubpassDescription2* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkSubpassDescriptionFlags
    pipelineBindPoint*: VkPipelineBindPoint
    viewMask*: uint32
    inputAttachmentCount*: uint32
    pInputAttachments*: ptr VkAttachmentReference2
    colorAttachmentCount*: uint32
    pColorAttachments*: ptr VkAttachmentReference2
    pResolveAttachments*: ptr VkAttachmentReference2
    pDepthStencilAttachment*: ptr VkAttachmentReference2
    preserveAttachmentCount*: uint32
    pPreserveAttachments*: ptr uint32

  VkSubpassDescription2KHR* = VkSubpassDescription2

  VkSubpassDependency2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcSubpass*: uint32
    dstSubpass*: uint32
    srcStageMask*: VkPipelineStageFlags
    dstStageMask*: VkPipelineStageFlags
    srcAccessMask*: VkAccessFlags
    dstAccessMask*: VkAccessFlags
    dependencyFlags*: VkDependencyFlags
    viewOffset*: int32

  VkSubpassDependency2KHR* = VkSubpassDependency2

  VkRenderPassCreateInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkRenderPassCreateFlags
    attachmentCount*: uint32
    pAttachments*: ptr VkAttachmentDescription2
    subpassCount*: uint32
    pSubpasses*: ptr VkSubpassDescription2
    dependencyCount*: uint32
    pDependencies*: ptr VkSubpassDependency2
    correlatedViewMaskCount*: uint32
    pCorrelatedViewMasks*: ptr uint32

  VkRenderPassCreateInfo2KHR* = VkRenderPassCreateInfo2

  VkSubpassBeginInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    contents*: VkSubpassContents

  VkSubpassBeginInfoKHR* = VkSubpassBeginInfo

  VkSubpassEndInfo* = object
    sType*: VkStructureType
    pNext*: pointer

  VkSubpassEndInfoKHR* = VkSubpassEndInfo

  VkPhysicalDeviceTimelineSemaphoreFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    timelineSemaphore*: VkBool32

  VkPhysicalDeviceTimelineSemaphoreFeaturesKHR* = VkPhysicalDeviceTimelineSemaphoreFeatures

  VkPhysicalDeviceTimelineSemaphoreProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    maxTimelineSemaphoreValueDifference*: uint64

  VkPhysicalDeviceTimelineSemaphorePropertiesKHR* = VkPhysicalDeviceTimelineSemaphoreProperties

  VkSemaphoreTypeCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphoreType*: VkSemaphoreType
    initialValue*: uint64

  VkSemaphoreTypeCreateInfoKHR* = VkSemaphoreTypeCreateInfo

  VkTimelineSemaphoreSubmitInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    waitSemaphoreValueCount*: uint32
    pWaitSemaphoreValues*: ptr uint64
    signalSemaphoreValueCount*: uint32
    pSignalSemaphoreValues*: ptr uint64

  VkTimelineSemaphoreSubmitInfoKHR* = VkTimelineSemaphoreSubmitInfo

  VkSemaphoreWaitInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkSemaphoreWaitFlags
    semaphoreCount*: uint32
    pSemaphores*: ptr VkSemaphore
    pValues*: ptr uint64

  VkSemaphoreWaitInfoKHR* = VkSemaphoreWaitInfo

  VkSemaphoreSignalInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    value*: uint64

  VkSemaphoreSignalInfoKHR* = VkSemaphoreSignalInfo

  VkVertexInputBindingDivisorDescription* = object
    binding*: uint32
    divisor*: uint32

  VkVertexInputBindingDivisorDescriptionKHR* = VkVertexInputBindingDivisorDescription

  VkVertexInputBindingDivisorDescriptionEXT* = VkVertexInputBindingDivisorDescription

  VkPipelineVertexInputDivisorStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexBindingDivisorCount*: uint32
    pVertexBindingDivisors*: ptr VkVertexInputBindingDivisorDescription

  VkPipelineVertexInputDivisorStateCreateInfoKHR* = VkPipelineVertexInputDivisorStateCreateInfo

  VkPipelineVertexInputDivisorStateCreateInfoEXT* = VkPipelineVertexInputDivisorStateCreateInfo

  VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxVertexAttribDivisor*: uint32

  VkPhysicalDeviceVertexAttributeDivisorProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    maxVertexAttribDivisor*: uint32
    supportsNonZeroFirstInstance*: VkBool32

  VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR* = VkPhysicalDeviceVertexAttributeDivisorProperties

  VkPhysicalDevicePCIBusInfoPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pciDomain*: uint32
    pciBus*: uint32
    pciDevice*: uint32
    pciFunction*: uint32

  VkImportAndroidHardwareBufferInfoANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    buffer*: ptr AHardwareBuffer

  VkAndroidHardwareBufferUsageANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    androidHardwareBufferUsage*: uint64

  VkAndroidHardwareBufferPropertiesANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    allocationSize*: VkDeviceSize
    memoryTypeBits*: uint32

  VkMemoryGetAndroidHardwareBufferInfoANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory

  VkAndroidHardwareBufferFormatPropertiesANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat
    externalFormat*: uint64
    formatFeatures*: VkFormatFeatureFlags
    samplerYcbcrConversionComponents*: VkComponentMapping
    suggestedYcbcrModel*: VkSamplerYcbcrModelConversion
    suggestedYcbcrRange*: VkSamplerYcbcrRange
    suggestedXChromaOffset*: VkChromaLocation
    suggestedYChromaOffset*: VkChromaLocation

  VkCommandBufferInheritanceConditionalRenderingInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    conditionalRenderingEnable*: VkBool32

  VkExternalFormatANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    externalFormat*: uint64

  VkPhysicalDevice8BitStorageFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    storageBuffer8BitAccess*: VkBool32
    uniformAndStorageBuffer8BitAccess*: VkBool32
    storagePushConstant8*: VkBool32

  VkPhysicalDevice8BitStorageFeaturesKHR* = VkPhysicalDevice8BitStorageFeatures

  VkPhysicalDeviceConditionalRenderingFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    conditionalRendering*: VkBool32
    inheritedConditionalRendering*: VkBool32

  VkPhysicalDeviceVulkanMemoryModelFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    vulkanMemoryModel*: VkBool32
    vulkanMemoryModelDeviceScope*: VkBool32
    vulkanMemoryModelAvailabilityVisibilityChains*: VkBool32

  VkPhysicalDeviceVulkanMemoryModelFeaturesKHR* = VkPhysicalDeviceVulkanMemoryModelFeatures

  VkPhysicalDeviceShaderAtomicInt64Features* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderBufferInt64Atomics*: VkBool32
    shaderSharedInt64Atomics*: VkBool32

  VkPhysicalDeviceShaderAtomicInt64FeaturesKHR* = VkPhysicalDeviceShaderAtomicInt64Features

  VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderBufferFloat32Atomics*: VkBool32
    shaderBufferFloat32AtomicAdd*: VkBool32
    shaderBufferFloat64Atomics*: VkBool32
    shaderBufferFloat64AtomicAdd*: VkBool32
    shaderSharedFloat32Atomics*: VkBool32
    shaderSharedFloat32AtomicAdd*: VkBool32
    shaderSharedFloat64Atomics*: VkBool32
    shaderSharedFloat64AtomicAdd*: VkBool32
    shaderImageFloat32Atomics*: VkBool32
    shaderImageFloat32AtomicAdd*: VkBool32
    sparseImageFloat32Atomics*: VkBool32
    sparseImageFloat32AtomicAdd*: VkBool32

  VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderBufferFloat16Atomics*: VkBool32
    shaderBufferFloat16AtomicAdd*: VkBool32
    shaderBufferFloat16AtomicMinMax*: VkBool32
    shaderBufferFloat32AtomicMinMax*: VkBool32
    shaderBufferFloat64AtomicMinMax*: VkBool32
    shaderSharedFloat16Atomics*: VkBool32
    shaderSharedFloat16AtomicAdd*: VkBool32
    shaderSharedFloat16AtomicMinMax*: VkBool32
    shaderSharedFloat32AtomicMinMax*: VkBool32
    shaderSharedFloat64AtomicMinMax*: VkBool32
    shaderImageFloat32AtomicMinMax*: VkBool32
    sparseImageFloat32AtomicMinMax*: VkBool32

  VkPhysicalDeviceVertexAttributeDivisorFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexAttributeInstanceRateDivisor*: VkBool32
    vertexAttributeInstanceRateZeroDivisor*: VkBool32

  VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR* = VkPhysicalDeviceVertexAttributeDivisorFeatures

  VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* = VkPhysicalDeviceVertexAttributeDivisorFeatures

  VkQueueFamilyCheckpointPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    checkpointExecutionStageMask*: VkPipelineStageFlags

  VkCheckpointDataNV* = object
    sType*: VkStructureType
    pNext*: pointer
    stage*: VkPipelineStageFlagBits
    pCheckpointMarker*: pointer

  VkPhysicalDeviceDepthStencilResolveProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    supportedDepthResolveModes*: VkResolveModeFlags
    supportedStencilResolveModes*: VkResolveModeFlags
    independentResolveNone*: VkBool32
    independentResolve*: VkBool32

  VkPhysicalDeviceDepthStencilResolvePropertiesKHR* = VkPhysicalDeviceDepthStencilResolveProperties

  VkSubpassDescriptionDepthStencilResolve* = object
    sType*: VkStructureType
    pNext*: pointer
    depthResolveMode*: VkResolveModeFlagBits
    stencilResolveMode*: VkResolveModeFlagBits
    pDepthStencilResolveAttachment*: ptr VkAttachmentReference2

  VkSubpassDescriptionDepthStencilResolveKHR* = VkSubpassDescriptionDepthStencilResolve

  VkImageViewASTCDecodeModeEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    decodeMode*: VkFormat

  VkPhysicalDeviceASTCDecodeFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    decodeModeSharedExponent*: VkBool32

  VkPhysicalDeviceTransformFeedbackFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    transformFeedback*: VkBool32
    geometryStreams*: VkBool32

  VkPhysicalDeviceTransformFeedbackPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxTransformFeedbackStreams*: uint32
    maxTransformFeedbackBuffers*: uint32
    maxTransformFeedbackBufferSize*: VkDeviceSize
    maxTransformFeedbackStreamDataSize*: uint32
    maxTransformFeedbackBufferDataSize*: uint32
    maxTransformFeedbackBufferDataStride*: uint32
    transformFeedbackQueries*: VkBool32
    transformFeedbackStreamsLinesTriangles*: VkBool32
    transformFeedbackRasterizationStreamSelect*: VkBool32
    transformFeedbackDraw*: VkBool32

  VkPipelineRasterizationStateStreamCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineRasterizationStateStreamCreateFlagsEXT
    rasterizationStream*: uint32

  VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    representativeFragmentTest*: VkBool32

  VkPipelineRepresentativeFragmentTestStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    representativeFragmentTestEnable*: VkBool32

  VkPhysicalDeviceExclusiveScissorFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    exclusiveScissor*: VkBool32

  VkPipelineViewportExclusiveScissorStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    exclusiveScissorCount*: uint32
    pExclusiveScissors*: ptr VkRect2D

  VkPhysicalDeviceCornerSampledImageFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    cornerSampledImage*: VkBool32

  VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    computeDerivativeGroupQuads*: VkBool32
    computeDerivativeGroupLinear*: VkBool32

  VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* = VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR

  VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    meshAndTaskShaderDerivatives*: VkBool32

  VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR

  VkPhysicalDeviceShaderImageFootprintFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    imageFootprint*: VkBool32

  VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    dedicatedAllocationImageAliasing*: VkBool32

  VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    indirectMemoryCopy*: VkBool32
    indirectMemoryToImageCopy*: VkBool32

  VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    indirectCopy*: VkBool32

  VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    supportedQueues*: VkQueueFlags

  VkPhysicalDeviceCopyMemoryIndirectPropertiesNV* = VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR

  VkPhysicalDeviceMemoryDecompressionFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryDecompression*: VkBool32

  VkPhysicalDeviceMemoryDecompressionFeaturesNV* = VkPhysicalDeviceMemoryDecompressionFeaturesEXT

  VkPhysicalDeviceMemoryDecompressionPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    decompressionMethods*: VkMemoryDecompressionMethodFlagsEXT
    maxDecompressionIndirectCount*: uint64

  VkPhysicalDeviceMemoryDecompressionPropertiesNV* = VkPhysicalDeviceMemoryDecompressionPropertiesEXT

  VkShadingRatePaletteNV* = object
    shadingRatePaletteEntryCount*: uint32
    pShadingRatePaletteEntries*: ptr VkShadingRatePaletteEntryNV

  VkPipelineViewportShadingRateImageStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    shadingRateImageEnable*: VkBool32
    viewportCount*: uint32
    pShadingRatePalettes*: ptr VkShadingRatePaletteNV

  VkPhysicalDeviceShadingRateImageFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    shadingRateImage*: VkBool32
    shadingRateCoarseSampleOrder*: VkBool32

  VkPhysicalDeviceShadingRateImagePropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    shadingRateTexelSize*: VkExtent2D
    shadingRatePaletteSize*: uint32
    shadingRateMaxCoarseSamples*: uint32

  VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* = object
    sType*: VkStructureType
    pNext*: pointer
    invocationMask*: VkBool32

  VkCoarseSampleLocationNV* = object
    pixelX*: uint32
    pixelY*: uint32
    sample*: uint32

  VkCoarseSampleOrderCustomNV* = object
    shadingRate*: VkShadingRatePaletteEntryNV
    sampleCount*: uint32
    sampleLocationCount*: uint32
    pSampleLocations*: ptr VkCoarseSampleLocationNV

  VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    sampleOrderType*: VkCoarseSampleOrderTypeNV
    customSampleOrderCount*: uint32
    pCustomSampleOrders*: ptr VkCoarseSampleOrderCustomNV

  VkPhysicalDeviceMeshShaderFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    taskShader*: VkBool32
    meshShader*: VkBool32

  VkPhysicalDeviceMeshShaderPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxDrawMeshTasksCount*: uint32
    maxTaskWorkGroupInvocations*: uint32
    maxTaskWorkGroupSize*: array[3, uint32]
    maxTaskTotalMemorySize*: uint32
    maxTaskOutputCount*: uint32
    maxMeshWorkGroupInvocations*: uint32
    maxMeshWorkGroupSize*: array[3, uint32]
    maxMeshTotalMemorySize*: uint32
    maxMeshOutputVertices*: uint32
    maxMeshOutputPrimitives*: uint32
    maxMeshMultiviewViewCount*: uint32
    meshOutputPerVertexGranularity*: uint32
    meshOutputPerPrimitiveGranularity*: uint32

  VkDrawMeshTasksIndirectCommandNV* = object
    taskCount*: uint32
    firstTask*: uint32

  VkPhysicalDeviceMeshShaderFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    taskShader*: VkBool32
    meshShader*: VkBool32
    multiviewMeshShader*: VkBool32
    primitiveFragmentShadingRateMeshShader*: VkBool32
    meshShaderQueries*: VkBool32

  VkPhysicalDeviceMeshShaderPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxTaskWorkGroupTotalCount*: uint32
    maxTaskWorkGroupCount*: array[3, uint32]
    maxTaskWorkGroupInvocations*: uint32
    maxTaskWorkGroupSize*: array[3, uint32]
    maxTaskPayloadSize*: uint32
    maxTaskSharedMemorySize*: uint32
    maxTaskPayloadAndSharedMemorySize*: uint32
    maxMeshWorkGroupTotalCount*: uint32
    maxMeshWorkGroupCount*: array[3, uint32]
    maxMeshWorkGroupInvocations*: uint32
    maxMeshWorkGroupSize*: array[3, uint32]
    maxMeshSharedMemorySize*: uint32
    maxMeshPayloadAndSharedMemorySize*: uint32
    maxMeshOutputMemorySize*: uint32
    maxMeshPayloadAndOutputMemorySize*: uint32
    maxMeshOutputComponents*: uint32
    maxMeshOutputVertices*: uint32
    maxMeshOutputPrimitives*: uint32
    maxMeshOutputLayers*: uint32
    maxMeshMultiviewViewCount*: uint32
    meshOutputPerVertexGranularity*: uint32
    meshOutputPerPrimitiveGranularity*: uint32
    maxPreferredTaskWorkGroupInvocations*: uint32
    maxPreferredMeshWorkGroupInvocations*: uint32
    prefersLocalInvocationVertexOutput*: VkBool32
    prefersLocalInvocationPrimitiveOutput*: VkBool32
    prefersCompactVertexOutput*: VkBool32
    prefersCompactPrimitiveOutput*: VkBool32

  VkDrawMeshTasksIndirectCommandEXT* = object
    groupCountX*: uint32
    groupCountY*: uint32
    groupCountZ*: uint32

  VkRayTracingShaderGroupCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkRayTracingShaderGroupTypeKHR
    generalShader*: uint32
    closestHitShader*: uint32
    anyHitShader*: uint32
    intersectionShader*: uint32

  VkRayTracingShaderGroupCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkRayTracingShaderGroupTypeKHR
    generalShader*: uint32
    closestHitShader*: uint32
    anyHitShader*: uint32
    intersectionShader*: uint32
    pShaderGroupCaptureReplayHandle*: pointer

  VkRayTracingPipelineCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCreateFlags
    stageCount*: uint32
    pStages*: ptr VkPipelineShaderStageCreateInfo
    groupCount*: uint32
    pGroups*: ptr VkRayTracingShaderGroupCreateInfoNV
    maxRecursionDepth*: uint32
    layout*: VkPipelineLayout
    basePipelineHandle*: VkPipeline
    basePipelineIndex*: int32

  VkRayTracingPipelineCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCreateFlags
    stageCount*: uint32
    pStages*: ptr VkPipelineShaderStageCreateInfo
    groupCount*: uint32
    pGroups*: ptr VkRayTracingShaderGroupCreateInfoKHR
    maxPipelineRayRecursionDepth*: uint32
    pLibraryInfo*: ptr VkPipelineLibraryCreateInfoKHR
    pLibraryInterface*: ptr VkRayTracingPipelineInterfaceCreateInfoKHR
    pDynamicState*: ptr VkPipelineDynamicStateCreateInfo
    layout*: VkPipelineLayout
    basePipelineHandle*: VkPipeline
    basePipelineIndex*: int32

  VkGeometryTrianglesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexData*: VkBuffer
    vertexOffset*: VkDeviceSize
    vertexCount*: uint32
    vertexStride*: VkDeviceSize
    vertexFormat*: VkFormat
    indexData*: VkBuffer
    indexOffset*: VkDeviceSize
    indexCount*: uint32
    indexType*: VkIndexType
    transformData*: VkBuffer
    transformOffset*: VkDeviceSize

  VkGeometryAABBNV* = object
    sType*: VkStructureType
    pNext*: pointer
    aabbData*: VkBuffer
    numAABBs*: uint32
    stride*: uint32
    offset*: VkDeviceSize

  VkGeometryDataNV* = object
    triangles*: VkGeometryTrianglesNV
    aabbs*: VkGeometryAABBNV

  VkGeometryNV* = object
    sType*: VkStructureType
    pNext*: pointer
    geometryType*: VkGeometryTypeKHR
    geometry*: VkGeometryDataNV
    flags*: VkGeometryFlagsKHR

  VkAccelerationStructureInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkAccelerationStructureTypeNV
    flags*: VkBuildAccelerationStructureFlagsNV
    instanceCount*: uint32
    geometryCount*: uint32
    pGeometries*: ptr VkGeometryNV

  VkAccelerationStructureCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    compactedSize*: VkDeviceSize
    info*: VkAccelerationStructureInfoNV

  VkBindAccelerationStructureMemoryInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    accelerationStructure*: VkAccelerationStructureNV
    memory*: VkDeviceMemory
    memoryOffset*: VkDeviceSize
    deviceIndexCount*: uint32
    pDeviceIndices*: ptr uint32

  VkWriteDescriptorSetAccelerationStructureKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    accelerationStructureCount*: uint32
    pAccelerationStructures*: ptr VkAccelerationStructureKHR

  VkWriteDescriptorSetAccelerationStructureNV* = object
    sType*: VkStructureType
    pNext*: pointer
    accelerationStructureCount*: uint32
    pAccelerationStructures*: ptr VkAccelerationStructureNV

  VkAccelerationStructureMemoryRequirementsInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkAccelerationStructureMemoryRequirementsTypeNV
    accelerationStructure*: VkAccelerationStructureNV

  VkPhysicalDeviceAccelerationStructureFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    accelerationStructure*: VkBool32
    accelerationStructureCaptureReplay*: VkBool32
    accelerationStructureIndirectBuild*: VkBool32
    accelerationStructureHostCommands*: VkBool32
    descriptorBindingAccelerationStructureUpdateAfterBind*: VkBool32

  VkPhysicalDeviceRayTracingPipelineFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    rayTracingPipeline*: VkBool32
    rayTracingPipelineShaderGroupHandleCaptureReplay*: VkBool32
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed*: VkBool32
    rayTracingPipelineTraceRaysIndirect*: VkBool32
    rayTraversalPrimitiveCulling*: VkBool32

  VkPhysicalDeviceRayQueryFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    rayQuery*: VkBool32

  VkPhysicalDeviceAccelerationStructurePropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxGeometryCount*: uint64
    maxInstanceCount*: uint64
    maxPrimitiveCount*: uint64
    maxPerStageDescriptorAccelerationStructures*: uint32
    maxPerStageDescriptorUpdateAfterBindAccelerationStructures*: uint32
    maxDescriptorSetAccelerationStructures*: uint32
    maxDescriptorSetUpdateAfterBindAccelerationStructures*: uint32
    minAccelerationStructureScratchOffsetAlignment*: uint32

  VkPhysicalDeviceRayTracingPipelinePropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderGroupHandleSize*: uint32
    maxRayRecursionDepth*: uint32
    maxShaderGroupStride*: uint32
    shaderGroupBaseAlignment*: uint32
    shaderGroupHandleCaptureReplaySize*: uint32
    maxRayDispatchInvocationCount*: uint32
    shaderGroupHandleAlignment*: uint32
    maxRayHitAttributeSize*: uint32

  VkPhysicalDeviceRayTracingPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderGroupHandleSize*: uint32
    maxRecursionDepth*: uint32
    maxShaderGroupStride*: uint32
    shaderGroupBaseAlignment*: uint32
    maxGeometryCount*: uint64
    maxInstanceCount*: uint64
    maxTriangleCount*: uint64
    maxDescriptorSetAccelerationStructures*: uint32

  VkStridedDeviceAddressRegionKHR* = object
    deviceAddress*: VkDeviceAddress
    stride*: VkDeviceSize
    size*: VkDeviceSize

  VkTraceRaysIndirectCommandKHR* = object
    width*: uint32
    height*: uint32
    depth*: uint32

  VkTraceRaysIndirectCommand2KHR* = object
    raygenShaderRecordAddress*: VkDeviceAddress
    raygenShaderRecordSize*: VkDeviceSize
    missShaderBindingTableAddress*: VkDeviceAddress
    missShaderBindingTableSize*: VkDeviceSize
    missShaderBindingTableStride*: VkDeviceSize
    hitShaderBindingTableAddress*: VkDeviceAddress
    hitShaderBindingTableSize*: VkDeviceSize
    hitShaderBindingTableStride*: VkDeviceSize
    callableShaderBindingTableAddress*: VkDeviceAddress
    callableShaderBindingTableSize*: VkDeviceSize
    callableShaderBindingTableStride*: VkDeviceSize
    width*: uint32
    height*: uint32
    depth*: uint32

  VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    rayTracingMaintenance1*: VkBool32
    rayTracingPipelineTraceRaysIndirect2*: VkBool32

  VkDrmFormatModifierPropertiesListEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    drmFormatModifierCount*: uint32
    pDrmFormatModifierProperties*: ptr VkDrmFormatModifierPropertiesEXT

  VkDrmFormatModifierPropertiesEXT* = object
    drmFormatModifier*: uint64
    drmFormatModifierPlaneCount*: uint32
    drmFormatModifierTilingFeatures*: VkFormatFeatureFlags

  VkPhysicalDeviceImageDrmFormatModifierInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    drmFormatModifier*: uint64
    sharingMode*: VkSharingMode
    queueFamilyIndexCount*: uint32
    pQueueFamilyIndices*: ptr uint32

  VkImageDrmFormatModifierListCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    drmFormatModifierCount*: uint32
    pDrmFormatModifiers*: ptr uint64

  VkImageDrmFormatModifierExplicitCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    drmFormatModifier*: uint64
    drmFormatModifierPlaneCount*: uint32
    pPlaneLayouts*: ptr VkSubresourceLayout

  VkImageDrmFormatModifierPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    drmFormatModifier*: uint64

  VkImageStencilUsageCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    stencilUsage*: VkImageUsageFlags

  VkImageStencilUsageCreateInfoEXT* = VkImageStencilUsageCreateInfo

  VkDeviceMemoryOverallocationCreateInfoAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    overallocationBehavior*: VkMemoryOverallocationBehaviorAMD

  VkPhysicalDeviceFragmentDensityMapFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentDensityMap*: VkBool32
    fragmentDensityMapDynamic*: VkBool32
    fragmentDensityMapNonSubsampledImages*: VkBool32

  VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentDensityMapDeferred*: VkBool32

  VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentDensityMapOffset*: VkBool32

  VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* = VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT

  VkPhysicalDeviceFragmentDensityMapPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    minFragmentDensityTexelSize*: VkExtent2D
    maxFragmentDensityTexelSize*: VkExtent2D
    fragmentDensityInvocations*: VkBool32

  VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    subsampledLoads*: VkBool32
    subsampledCoarseReconstructionEarlyAccess*: VkBool32
    maxSubsampledArrayLayers*: uint32
    maxDescriptorSetSubsampledSamplers*: uint32

  VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentDensityOffsetGranularity*: VkExtent2D

  VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* = VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT

  VkRenderPassFragmentDensityMapCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentDensityMapAttachment*: VkAttachmentReference

  VkRenderPassFragmentDensityMapOffsetEndInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentDensityOffsetCount*: uint32
    pFragmentDensityOffsets*: ptr VkOffset2D

  VkSubpassFragmentDensityMapOffsetEndInfoQCOM* = VkRenderPassFragmentDensityMapOffsetEndInfoEXT

  VkPhysicalDeviceScalarBlockLayoutFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    scalarBlockLayout*: VkBool32

  VkPhysicalDeviceScalarBlockLayoutFeaturesEXT* = VkPhysicalDeviceScalarBlockLayoutFeatures

  VkSurfaceProtectedCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    supportsProtected*: VkBool32

  VkPhysicalDeviceUniformBufferStandardLayoutFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    uniformBufferStandardLayout*: VkBool32

  VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR* = VkPhysicalDeviceUniformBufferStandardLayoutFeatures

  VkPhysicalDeviceDepthClipEnableFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    depthClipEnable*: VkBool32

  VkPipelineRasterizationDepthClipStateCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineRasterizationDepthClipStateCreateFlagsEXT
    depthClipEnable*: VkBool32

  VkPhysicalDeviceMemoryBudgetPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    heapBudget*: array[VK_MAX_MEMORY_HEAPS, VkDeviceSize]
    heapUsage*: array[VK_MAX_MEMORY_HEAPS, VkDeviceSize]

  VkPhysicalDeviceMemoryPriorityFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryPriority*: VkBool32

  VkMemoryPriorityAllocateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    priority*: float32

  VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pageableDeviceLocalMemory*: VkBool32

  VkPhysicalDeviceBufferDeviceAddressFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    bufferDeviceAddress*: VkBool32
    bufferDeviceAddressCaptureReplay*: VkBool32
    bufferDeviceAddressMultiDevice*: VkBool32

  VkPhysicalDeviceBufferDeviceAddressFeaturesKHR* = VkPhysicalDeviceBufferDeviceAddressFeatures

  VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    bufferDeviceAddress*: VkBool32
    bufferDeviceAddressCaptureReplay*: VkBool32
    bufferDeviceAddressMultiDevice*: VkBool32

  VkPhysicalDeviceBufferAddressFeaturesEXT* = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT

  VkBufferDeviceAddressInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    buffer*: VkBuffer

  VkBufferDeviceAddressInfoKHR* = VkBufferDeviceAddressInfo

  VkBufferDeviceAddressInfoEXT* = VkBufferDeviceAddressInfo

  VkBufferOpaqueCaptureAddressCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    opaqueCaptureAddress*: uint64

  VkBufferOpaqueCaptureAddressCreateInfoKHR* = VkBufferOpaqueCaptureAddressCreateInfo

  VkBufferDeviceAddressCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceAddress*: VkDeviceAddress

  VkPhysicalDeviceImageViewImageFormatInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    imageViewType*: VkImageViewType

  VkFilterCubicImageViewImageFormatPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    filterCubic*: VkBool32
    filterCubicMinmax*: VkBool32

  VkPhysicalDeviceImagelessFramebufferFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    imagelessFramebuffer*: VkBool32

  VkPhysicalDeviceImagelessFramebufferFeaturesKHR* = VkPhysicalDeviceImagelessFramebufferFeatures

  VkFramebufferAttachmentsCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    attachmentImageInfoCount*: uint32
    pAttachmentImageInfos*: ptr VkFramebufferAttachmentImageInfo

  VkFramebufferAttachmentsCreateInfoKHR* = VkFramebufferAttachmentsCreateInfo

  VkFramebufferAttachmentImageInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkImageCreateFlags
    usage*: VkImageUsageFlags
    width*: uint32
    height*: uint32
    layerCount*: uint32
    viewFormatCount*: uint32
    pViewFormats*: ptr VkFormat

  VkFramebufferAttachmentImageInfoKHR* = VkFramebufferAttachmentImageInfo

  VkRenderPassAttachmentBeginInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    attachmentCount*: uint32
    pAttachments*: ptr VkImageView

  VkRenderPassAttachmentBeginInfoKHR* = VkRenderPassAttachmentBeginInfo

  VkPhysicalDeviceTextureCompressionASTCHDRFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    textureCompressionASTC_HDR*: VkBool32

  VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT* = VkPhysicalDeviceTextureCompressionASTCHDRFeatures

  VkPhysicalDeviceCooperativeMatrixFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    cooperativeMatrix*: VkBool32
    cooperativeMatrixRobustBufferAccess*: VkBool32

  VkPhysicalDeviceCooperativeMatrixPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    cooperativeMatrixSupportedStages*: VkShaderStageFlags

  VkCooperativeMatrixPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    MSize*: uint32
    NSize*: uint32
    KSize*: uint32
    AType*: VkComponentTypeNV
    BType*: VkComponentTypeNV
    CType*: VkComponentTypeNV
    DType*: VkComponentTypeNV
    scope*: VkScopeNV

  VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    ycbcrImageArrays*: VkBool32

  VkImageViewHandleInfoNVX* = object
    sType*: VkStructureType
    pNext*: pointer
    imageView*: VkImageView
    descriptorType*: VkDescriptorType
    sampler*: VkSampler

  VkImageViewAddressPropertiesNVX* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceAddress*: VkDeviceAddress
    size*: VkDeviceSize

  VkPresentFrameTokenGGP* = object
    sType*: VkStructureType
    pNext*: pointer
    frameToken*: GgpFrameToken

  VkPipelineCreationFeedback* = object
    flags*: VkPipelineCreationFeedbackFlags
    duration*: uint64

  VkPipelineCreationFeedbackEXT* = VkPipelineCreationFeedback

  VkPipelineCreationFeedbackCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    pPipelineCreationFeedback*: ptr VkPipelineCreationFeedback
    pipelineStageCreationFeedbackCount*: uint32
    pPipelineStageCreationFeedbacks*: ptr ptr VkPipelineCreationFeedback

  VkPipelineCreationFeedbackCreateInfoEXT* = VkPipelineCreationFeedbackCreateInfo

  VkSurfaceFullScreenExclusiveInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    fullScreenExclusive*: VkFullScreenExclusiveEXT

  VkSurfaceFullScreenExclusiveWin32InfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    hmonitor*: HMONITOR

  VkSurfaceCapabilitiesFullScreenExclusiveEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    fullScreenExclusiveSupported*: VkBool32

  VkPhysicalDevicePresentBarrierFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    presentBarrier*: VkBool32

  VkSurfaceCapabilitiesPresentBarrierNV* = object
    sType*: VkStructureType
    pNext*: pointer
    presentBarrierSupported*: VkBool32

  VkSwapchainPresentBarrierCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    presentBarrierEnable*: VkBool32

  VkPhysicalDevicePerformanceQueryFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    performanceCounterQueryPools*: VkBool32
    performanceCounterMultipleQueryPools*: VkBool32

  VkPhysicalDevicePerformanceQueryPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    allowCommandBufferQueryCopies*: VkBool32

  VkPerformanceCounterKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    unit*: VkPerformanceCounterUnitKHR
    scope*: VkPerformanceCounterScopeKHR
    storage*: VkPerformanceCounterStorageKHR
    uuid*: array[VK_UUID_SIZE, uint8]

  VkPerformanceCounterDescriptionKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPerformanceCounterDescriptionFlagsKHR
    name*: array[VK_MAX_DESCRIPTION_SIZE, char]
    category*: array[VK_MAX_DESCRIPTION_SIZE, char]
    description*: array[VK_MAX_DESCRIPTION_SIZE, char]

  VkQueryPoolPerformanceCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    queueFamilyIndex*: uint32
    counterIndexCount*: uint32
    pCounterIndices*: ptr uint32

  VkPerformanceCounterResultKHR* {.union.} = object
    int32*: int32
    int64*: int64
    uint32*: uint32
    uint64*: uint64
    float32*: float32
    float64*: float64

  VkAcquireProfilingLockInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkAcquireProfilingLockFlagsKHR
    timeout*: uint64

  VkPerformanceQuerySubmitInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    counterPassIndex*: uint32

  VkPerformanceQueryReservationInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxPerformanceQueriesPerPool*: uint32

  VkHeadlessSurfaceCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkHeadlessSurfaceCreateFlagsEXT

  VkPhysicalDeviceCoverageReductionModeFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    coverageReductionMode*: VkBool32

  VkPipelineCoverageReductionStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCoverageReductionStateCreateFlagsNV
    coverageReductionMode*: VkCoverageReductionModeNV

  VkFramebufferMixedSamplesCombinationNV* = object
    sType*: VkStructureType
    pNext*: pointer
    coverageReductionMode*: VkCoverageReductionModeNV
    rasterizationSamples*: VkSampleCountFlagBits
    depthStencilSamples*: VkSampleCountFlags
    colorSamples*: VkSampleCountFlags

  VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderIntegerFunctions2*: VkBool32

  VkPerformanceValueDataINTEL* {.union.} = object
    value32*: uint32
    value64*: uint64
    valueFloat*: float32
    valueBool*: VkBool32
    valueString*: cstring

  VkPerformanceValueINTEL* = object
    `type`*: VkPerformanceValueTypeINTEL
    data*: VkPerformanceValueDataINTEL

  VkInitializePerformanceApiInfoINTEL* = object
    sType*: VkStructureType
    pNext*: pointer
    pUserData*: pointer

  VkQueryPoolPerformanceQueryCreateInfoINTEL* = object
    sType*: VkStructureType
    pNext*: pointer
    performanceCountersSampling*: VkQueryPoolSamplingModeINTEL

  VkQueryPoolCreateInfoINTEL* = VkQueryPoolPerformanceQueryCreateInfoINTEL

  VkPerformanceMarkerInfoINTEL* = object
    sType*: VkStructureType
    pNext*: pointer
    marker*: uint64

  VkPerformanceStreamMarkerInfoINTEL* = object
    sType*: VkStructureType
    pNext*: pointer
    marker*: uint32

  VkPerformanceOverrideInfoINTEL* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkPerformanceOverrideTypeINTEL
    enable*: VkBool32
    parameter*: uint64

  VkPerformanceConfigurationAcquireInfoINTEL* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkPerformanceConfigurationTypeINTEL

  VkPhysicalDeviceShaderClockFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderSubgroupClock*: VkBool32
    shaderDeviceClock*: VkBool32

  VkPhysicalDeviceIndexTypeUint8Features* = object
    sType*: VkStructureType
    pNext*: pointer
    indexTypeUint8*: VkBool32

  VkPhysicalDeviceIndexTypeUint8FeaturesKHR* = VkPhysicalDeviceIndexTypeUint8Features

  VkPhysicalDeviceIndexTypeUint8FeaturesEXT* = VkPhysicalDeviceIndexTypeUint8Features

  VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderSMCount*: uint32
    shaderWarpsPerSM*: uint32

  VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderSMBuiltins*: VkBool32

  VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentShaderSampleInterlock*: VkBool32
    fragmentShaderPixelInterlock*: VkBool32
    fragmentShaderShadingRateInterlock*: VkBool32

  VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    separateDepthStencilLayouts*: VkBool32

  VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR* = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures

  VkAttachmentReferenceStencilLayout* = object
    sType*: VkStructureType
    pNext*: pointer
    stencilLayout*: VkImageLayout

  VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    primitiveTopologyListRestart*: VkBool32
    primitiveTopologyPatchListRestart*: VkBool32

  VkAttachmentReferenceStencilLayoutKHR* = VkAttachmentReferenceStencilLayout

  VkAttachmentDescriptionStencilLayout* = object
    sType*: VkStructureType
    pNext*: pointer
    stencilInitialLayout*: VkImageLayout
    stencilFinalLayout*: VkImageLayout

  VkAttachmentDescriptionStencilLayoutKHR* = VkAttachmentDescriptionStencilLayout

  VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineExecutableInfo*: VkBool32

  VkPipelineInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pipeline*: VkPipeline

  VkPipelineInfoEXT* = VkPipelineInfoKHR

  VkPipelineExecutablePropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stages*: VkShaderStageFlags
    name*: array[VK_MAX_DESCRIPTION_SIZE, char]
    description*: array[VK_MAX_DESCRIPTION_SIZE, char]
    subgroupSize*: uint32

  VkPipelineExecutableInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pipeline*: VkPipeline
    executableIndex*: uint32

  VkPipelineExecutableStatisticValueKHR* {.union.} = object
    b32*: VkBool32
    i64*: int64
    u64*: uint64
    f64*: float64

  VkPipelineExecutableStatisticKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    name*: array[VK_MAX_DESCRIPTION_SIZE, char]
    description*: array[VK_MAX_DESCRIPTION_SIZE, char]
    format*: VkPipelineExecutableStatisticFormatKHR
    value*: VkPipelineExecutableStatisticValueKHR

  VkPipelineExecutableInternalRepresentationKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    name*: array[VK_MAX_DESCRIPTION_SIZE, char]
    description*: array[VK_MAX_DESCRIPTION_SIZE, char]
    isText*: VkBool32
    dataSize*: uint
    pData*: pointer

  VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderDemoteToHelperInvocation*: VkBool32

  VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT* = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures

  VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    texelBufferAlignment*: VkBool32

  VkPhysicalDeviceTexelBufferAlignmentProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    storageTexelBufferOffsetAlignmentBytes*: VkDeviceSize
    storageTexelBufferOffsetSingleTexelAlignment*: VkBool32
    uniformTexelBufferOffsetAlignmentBytes*: VkDeviceSize
    uniformTexelBufferOffsetSingleTexelAlignment*: VkBool32

  VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT* = VkPhysicalDeviceTexelBufferAlignmentProperties

  VkPhysicalDeviceSubgroupSizeControlFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    subgroupSizeControl*: VkBool32
    computeFullSubgroups*: VkBool32

  VkPhysicalDeviceSubgroupSizeControlFeaturesEXT* = VkPhysicalDeviceSubgroupSizeControlFeatures

  VkPhysicalDeviceSubgroupSizeControlProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    minSubgroupSize*: uint32
    maxSubgroupSize*: uint32
    maxComputeWorkgroupSubgroups*: uint32
    requiredSubgroupSizeStages*: VkShaderStageFlags

  VkPhysicalDeviceSubgroupSizeControlPropertiesEXT* = VkPhysicalDeviceSubgroupSizeControlProperties

  VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    requiredSubgroupSize*: uint32

  VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT* = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo

  VkShaderRequiredSubgroupSizeCreateInfoEXT* = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo

  VkSubpassShadingPipelineCreateInfoHUAWEI* = object
    sType*: VkStructureType
    pNext*: pointer
    renderPass*: VkRenderPass
    subpass*: uint32

  VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* = object
    sType*: VkStructureType
    pNext*: pointer
    maxSubpassShadingWorkgroupSizeAspectRatio*: uint32

  VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* = object
    sType*: VkStructureType
    pNext*: pointer
    maxWorkGroupCount*: array[3, uint32]
    maxWorkGroupSize*: array[3, uint32]
    maxOutputClusterCount*: uint32
    indirectBufferOffsetAlignment*: VkDeviceSize

  VkMemoryOpaqueCaptureAddressAllocateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    opaqueCaptureAddress*: uint64

  VkMemoryOpaqueCaptureAddressAllocateInfoKHR* = VkMemoryOpaqueCaptureAddressAllocateInfo

  VkDeviceMemoryOpaqueCaptureAddressInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory

  VkDeviceMemoryOpaqueCaptureAddressInfoKHR* = VkDeviceMemoryOpaqueCaptureAddressInfo

  VkPhysicalDeviceLineRasterizationFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    rectangularLines*: VkBool32
    bresenhamLines*: VkBool32
    smoothLines*: VkBool32
    stippledRectangularLines*: VkBool32
    stippledBresenhamLines*: VkBool32
    stippledSmoothLines*: VkBool32

  VkPhysicalDeviceLineRasterizationFeaturesKHR* = VkPhysicalDeviceLineRasterizationFeatures

  VkPhysicalDeviceLineRasterizationFeaturesEXT* = VkPhysicalDeviceLineRasterizationFeatures

  VkPhysicalDeviceLineRasterizationProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    lineSubPixelPrecisionBits*: uint32

  VkPhysicalDeviceLineRasterizationPropertiesKHR* = VkPhysicalDeviceLineRasterizationProperties

  VkPhysicalDeviceLineRasterizationPropertiesEXT* = VkPhysicalDeviceLineRasterizationProperties

  VkPipelineRasterizationLineStateCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    lineRasterizationMode*: VkLineRasterizationMode
    stippledLineEnable*: VkBool32
    lineStippleFactor*: uint32
    lineStipplePattern*: uint16

  VkPipelineRasterizationLineStateCreateInfoKHR* = VkPipelineRasterizationLineStateCreateInfo

  VkPipelineRasterizationLineStateCreateInfoEXT* = VkPipelineRasterizationLineStateCreateInfo

  VkPhysicalDevicePipelineCreationCacheControlFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineCreationCacheControl*: VkBool32

  VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT* = VkPhysicalDevicePipelineCreationCacheControlFeatures

  VkPhysicalDeviceVulkan11Features* = object
    sType*: VkStructureType
    pNext*: pointer
    storageBuffer16BitAccess*: VkBool32
    uniformAndStorageBuffer16BitAccess*: VkBool32
    storagePushConstant16*: VkBool32
    storageInputOutput16*: VkBool32
    multiview*: VkBool32
    multiviewGeometryShader*: VkBool32
    multiviewTessellationShader*: VkBool32
    variablePointersStorageBuffer*: VkBool32
    variablePointers*: VkBool32
    protectedMemory*: VkBool32
    samplerYcbcrConversion*: VkBool32
    shaderDrawParameters*: VkBool32

  VkPhysicalDeviceVulkan11Properties* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceUUID*: array[VK_UUID_SIZE, uint8]
    driverUUID*: array[VK_UUID_SIZE, uint8]
    deviceLUID*: array[VK_LUID_SIZE, uint8]
    deviceNodeMask*: uint32
    deviceLUIDValid*: VkBool32
    subgroupSize*: uint32
    subgroupSupportedStages*: VkShaderStageFlags
    subgroupSupportedOperations*: VkSubgroupFeatureFlags
    subgroupQuadOperationsInAllStages*: VkBool32
    pointClippingBehavior*: VkPointClippingBehavior
    maxMultiviewViewCount*: uint32
    maxMultiviewInstanceIndex*: uint32
    protectedNoFault*: VkBool32
    maxPerSetDescriptors*: uint32
    maxMemoryAllocationSize*: VkDeviceSize

  VkPhysicalDeviceVulkan12Features* = object
    sType*: VkStructureType
    pNext*: pointer
    samplerMirrorClampToEdge*: VkBool32
    drawIndirectCount*: VkBool32
    storageBuffer8BitAccess*: VkBool32
    uniformAndStorageBuffer8BitAccess*: VkBool32
    storagePushConstant8*: VkBool32
    shaderBufferInt64Atomics*: VkBool32
    shaderSharedInt64Atomics*: VkBool32
    shaderFloat16*: VkBool32
    shaderInt8*: VkBool32
    descriptorIndexing*: VkBool32
    shaderInputAttachmentArrayDynamicIndexing*: VkBool32
    shaderUniformTexelBufferArrayDynamicIndexing*: VkBool32
    shaderStorageTexelBufferArrayDynamicIndexing*: VkBool32
    shaderUniformBufferArrayNonUniformIndexing*: VkBool32
    shaderSampledImageArrayNonUniformIndexing*: VkBool32
    shaderStorageBufferArrayNonUniformIndexing*: VkBool32
    shaderStorageImageArrayNonUniformIndexing*: VkBool32
    shaderInputAttachmentArrayNonUniformIndexing*: VkBool32
    shaderUniformTexelBufferArrayNonUniformIndexing*: VkBool32
    shaderStorageTexelBufferArrayNonUniformIndexing*: VkBool32
    descriptorBindingUniformBufferUpdateAfterBind*: VkBool32
    descriptorBindingSampledImageUpdateAfterBind*: VkBool32
    descriptorBindingStorageImageUpdateAfterBind*: VkBool32
    descriptorBindingStorageBufferUpdateAfterBind*: VkBool32
    descriptorBindingUniformTexelBufferUpdateAfterBind*: VkBool32
    descriptorBindingStorageTexelBufferUpdateAfterBind*: VkBool32
    descriptorBindingUpdateUnusedWhilePending*: VkBool32
    descriptorBindingPartiallyBound*: VkBool32
    descriptorBindingVariableDescriptorCount*: VkBool32
    runtimeDescriptorArray*: VkBool32
    samplerFilterMinmax*: VkBool32
    scalarBlockLayout*: VkBool32
    imagelessFramebuffer*: VkBool32
    uniformBufferStandardLayout*: VkBool32
    shaderSubgroupExtendedTypes*: VkBool32
    separateDepthStencilLayouts*: VkBool32
    hostQueryReset*: VkBool32
    timelineSemaphore*: VkBool32
    bufferDeviceAddress*: VkBool32
    bufferDeviceAddressCaptureReplay*: VkBool32
    bufferDeviceAddressMultiDevice*: VkBool32
    vulkanMemoryModel*: VkBool32
    vulkanMemoryModelDeviceScope*: VkBool32
    vulkanMemoryModelAvailabilityVisibilityChains*: VkBool32
    shaderOutputViewportIndex*: VkBool32
    shaderOutputLayer*: VkBool32
    subgroupBroadcastDynamicId*: VkBool32

  VkPhysicalDeviceVulkan12Properties* = object
    sType*: VkStructureType
    pNext*: pointer
    driverID*: VkDriverId
    driverName*: array[VK_MAX_DRIVER_NAME_SIZE, char]
    driverInfo*: array[VK_MAX_DRIVER_INFO_SIZE, char]
    conformanceVersion*: VkConformanceVersion
    denormBehaviorIndependence*: VkShaderFloatControlsIndependence
    roundingModeIndependence*: VkShaderFloatControlsIndependence
    shaderSignedZeroInfNanPreserveFloat16*: VkBool32
    shaderSignedZeroInfNanPreserveFloat32*: VkBool32
    shaderSignedZeroInfNanPreserveFloat64*: VkBool32
    shaderDenormPreserveFloat16*: VkBool32
    shaderDenormPreserveFloat32*: VkBool32
    shaderDenormPreserveFloat64*: VkBool32
    shaderDenormFlushToZeroFloat16*: VkBool32
    shaderDenormFlushToZeroFloat32*: VkBool32
    shaderDenormFlushToZeroFloat64*: VkBool32
    shaderRoundingModeRTEFloat16*: VkBool32
    shaderRoundingModeRTEFloat32*: VkBool32
    shaderRoundingModeRTEFloat64*: VkBool32
    shaderRoundingModeRTZFloat16*: VkBool32
    shaderRoundingModeRTZFloat32*: VkBool32
    shaderRoundingModeRTZFloat64*: VkBool32
    maxUpdateAfterBindDescriptorsInAllPools*: uint32
    shaderUniformBufferArrayNonUniformIndexingNative*: VkBool32
    shaderSampledImageArrayNonUniformIndexingNative*: VkBool32
    shaderStorageBufferArrayNonUniformIndexingNative*: VkBool32
    shaderStorageImageArrayNonUniformIndexingNative*: VkBool32
    shaderInputAttachmentArrayNonUniformIndexingNative*: VkBool32
    robustBufferAccessUpdateAfterBind*: VkBool32
    quadDivergentImplicitLod*: VkBool32
    maxPerStageDescriptorUpdateAfterBindSamplers*: uint32
    maxPerStageDescriptorUpdateAfterBindUniformBuffers*: uint32
    maxPerStageDescriptorUpdateAfterBindStorageBuffers*: uint32
    maxPerStageDescriptorUpdateAfterBindSampledImages*: uint32
    maxPerStageDescriptorUpdateAfterBindStorageImages*: uint32
    maxPerStageDescriptorUpdateAfterBindInputAttachments*: uint32
    maxPerStageUpdateAfterBindResources*: uint32
    maxDescriptorSetUpdateAfterBindSamplers*: uint32
    maxDescriptorSetUpdateAfterBindUniformBuffers*: uint32
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindStorageBuffers*: uint32
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic*: uint32
    maxDescriptorSetUpdateAfterBindSampledImages*: uint32
    maxDescriptorSetUpdateAfterBindStorageImages*: uint32
    maxDescriptorSetUpdateAfterBindInputAttachments*: uint32
    supportedDepthResolveModes*: VkResolveModeFlags
    supportedStencilResolveModes*: VkResolveModeFlags
    independentResolveNone*: VkBool32
    independentResolve*: VkBool32
    filterMinmaxSingleComponentFormats*: VkBool32
    filterMinmaxImageComponentMapping*: VkBool32
    maxTimelineSemaphoreValueDifference*: uint64
    framebufferIntegerColorSampleCounts*: VkSampleCountFlags

  VkPhysicalDeviceVulkan13Features* = object
    sType*: VkStructureType
    pNext*: pointer
    robustImageAccess*: VkBool32
    inlineUniformBlock*: VkBool32
    descriptorBindingInlineUniformBlockUpdateAfterBind*: VkBool32
    pipelineCreationCacheControl*: VkBool32
    privateData*: VkBool32
    shaderDemoteToHelperInvocation*: VkBool32
    shaderTerminateInvocation*: VkBool32
    subgroupSizeControl*: VkBool32
    computeFullSubgroups*: VkBool32
    synchronization2*: VkBool32
    textureCompressionASTC_HDR*: VkBool32
    shaderZeroInitializeWorkgroupMemory*: VkBool32
    dynamicRendering*: VkBool32
    shaderIntegerDotProduct*: VkBool32
    maintenance4*: VkBool32

  VkPhysicalDeviceVulkan13Properties* = object
    sType*: VkStructureType
    pNext*: pointer
    minSubgroupSize*: uint32
    maxSubgroupSize*: uint32
    maxComputeWorkgroupSubgroups*: uint32
    requiredSubgroupSizeStages*: VkShaderStageFlags
    maxInlineUniformBlockSize*: uint32
    maxPerStageDescriptorInlineUniformBlocks*: uint32
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks*: uint32
    maxDescriptorSetInlineUniformBlocks*: uint32
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks*: uint32
    maxInlineUniformTotalSize*: uint32
    integerDotProduct8BitUnsignedAccelerated*: VkBool32
    integerDotProduct8BitSignedAccelerated*: VkBool32
    integerDotProduct8BitMixedSignednessAccelerated*: VkBool32
    integerDotProduct4x8BitPackedUnsignedAccelerated*: VkBool32
    integerDotProduct4x8BitPackedSignedAccelerated*: VkBool32
    integerDotProduct4x8BitPackedMixedSignednessAccelerated*: VkBool32
    integerDotProduct16BitUnsignedAccelerated*: VkBool32
    integerDotProduct16BitSignedAccelerated*: VkBool32
    integerDotProduct16BitMixedSignednessAccelerated*: VkBool32
    integerDotProduct32BitUnsignedAccelerated*: VkBool32
    integerDotProduct32BitSignedAccelerated*: VkBool32
    integerDotProduct32BitMixedSignednessAccelerated*: VkBool32
    integerDotProduct64BitUnsignedAccelerated*: VkBool32
    integerDotProduct64BitSignedAccelerated*: VkBool32
    integerDotProduct64BitMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating8BitSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating16BitSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating32BitSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating64BitSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated*: VkBool32
    storageTexelBufferOffsetAlignmentBytes*: VkDeviceSize
    storageTexelBufferOffsetSingleTexelAlignment*: VkBool32
    uniformTexelBufferOffsetAlignmentBytes*: VkDeviceSize
    uniformTexelBufferOffsetSingleTexelAlignment*: VkBool32
    maxBufferSize*: VkDeviceSize

  VkPhysicalDeviceVulkan14Features* = object
    sType*: VkStructureType
    pNext*: pointer
    globalPriorityQuery*: VkBool32
    shaderSubgroupRotate*: VkBool32
    shaderSubgroupRotateClustered*: VkBool32
    shaderFloatControls2*: VkBool32
    shaderExpectAssume*: VkBool32
    rectangularLines*: VkBool32
    bresenhamLines*: VkBool32
    smoothLines*: VkBool32
    stippledRectangularLines*: VkBool32
    stippledBresenhamLines*: VkBool32
    stippledSmoothLines*: VkBool32
    vertexAttributeInstanceRateDivisor*: VkBool32
    vertexAttributeInstanceRateZeroDivisor*: VkBool32
    indexTypeUint8*: VkBool32
    dynamicRenderingLocalRead*: VkBool32
    maintenance5*: VkBool32
    maintenance6*: VkBool32
    pipelineProtectedAccess*: VkBool32
    pipelineRobustness*: VkBool32
    hostImageCopy*: VkBool32
    pushDescriptor*: VkBool32

  VkPhysicalDeviceVulkan14Properties* = object
    sType*: VkStructureType
    pNext*: pointer
    lineSubPixelPrecisionBits*: uint32
    maxVertexAttribDivisor*: uint32
    supportsNonZeroFirstInstance*: VkBool32
    maxPushDescriptors*: uint32
    dynamicRenderingLocalReadDepthStencilAttachments*: VkBool32
    dynamicRenderingLocalReadMultisampledAttachments*: VkBool32
    earlyFragmentMultisampleCoverageAfterSampleCounting*: VkBool32
    earlyFragmentSampleMaskTestBeforeSampleCounting*: VkBool32
    depthStencilSwizzleOneSupport*: VkBool32
    polygonModePointSize*: VkBool32
    nonStrictSinglePixelWideLinesUseParallelogram*: VkBool32
    nonStrictWideLinesUseParallelogram*: VkBool32
    blockTexelViewCompatibleMultipleLayers*: VkBool32
    maxCombinedImageSamplerDescriptorCount*: uint32
    fragmentShadingRateClampCombinerInputs*: VkBool32
    defaultRobustnessStorageBuffers*: VkPipelineRobustnessBufferBehavior
    defaultRobustnessUniformBuffers*: VkPipelineRobustnessBufferBehavior
    defaultRobustnessVertexInputs*: VkPipelineRobustnessBufferBehavior
    defaultRobustnessImages*: VkPipelineRobustnessImageBehavior
    copySrcLayoutCount*: uint32
    pCopySrcLayouts*: ptr VkImageLayout
    copyDstLayoutCount*: uint32
    pCopyDstLayouts*: ptr VkImageLayout
    optimalTilingLayoutUUID*: array[VK_UUID_SIZE, uint8]
    identicalMemoryTypeRequirements*: VkBool32

  VkPipelineCompilerControlCreateInfoAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    compilerControlFlags*: VkPipelineCompilerControlFlagsAMD

  VkPhysicalDeviceCoherentMemoryFeaturesAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceCoherentMemory*: VkBool32

  VkFaultData* = object
    sType*: VkStructureType
    pNext*: pointer
    faultLevel*: VkFaultLevel
    faultType*: VkFaultType

  VkFaultCallbackInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    faultCount*: uint32
    pFaults*: ptr VkFaultData
    pfnFaultCallback*: PFN_vkFaultCallbackFunction

  VkPhysicalDeviceToolProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    name*: array[VK_MAX_EXTENSION_NAME_SIZE, char]
    version*: array[VK_MAX_EXTENSION_NAME_SIZE, char]
    purposes*: VkToolPurposeFlags
    description*: array[VK_MAX_DESCRIPTION_SIZE, char]
    layer*: array[VK_MAX_EXTENSION_NAME_SIZE, char]

  VkPhysicalDeviceToolPropertiesEXT* = VkPhysicalDeviceToolProperties

  VkSamplerCustomBorderColorCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    customBorderColor*: VkClearColorValue
    format*: VkFormat

  VkPhysicalDeviceCustomBorderColorPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxCustomBorderColorSamplers*: uint32

  VkPhysicalDeviceCustomBorderColorFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    customBorderColors*: VkBool32
    customBorderColorWithoutFormat*: VkBool32

  VkSamplerBorderColorComponentMappingCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    components*: VkComponentMapping
    srgb*: VkBool32

  VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    borderColorSwizzle*: VkBool32
    borderColorSwizzleFromImage*: VkBool32

  VkDeviceOrHostAddressKHR* {.union.} = object
    deviceAddress*: VkDeviceAddress
    hostAddress*: pointer

  VkDeviceOrHostAddressConstKHR* {.union.} = object
    deviceAddress*: VkDeviceAddress
    hostAddress*: pointer

  VkDeviceOrHostAddressConstAMDX* {.union.} = object
    deviceAddress*: VkDeviceAddress
    hostAddress*: pointer

  VkAccelerationStructureGeometryTrianglesDataKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexFormat*: VkFormat
    vertexData*: VkDeviceOrHostAddressConstKHR
    vertexStride*: VkDeviceSize
    maxVertex*: uint32
    indexType*: VkIndexType
    indexData*: VkDeviceOrHostAddressConstKHR
    transformData*: VkDeviceOrHostAddressConstKHR

  VkAccelerationStructureGeometryAabbsDataKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    data*: VkDeviceOrHostAddressConstKHR
    stride*: VkDeviceSize

  VkAccelerationStructureGeometryInstancesDataKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    arrayOfPointers*: VkBool32
    data*: VkDeviceOrHostAddressConstKHR

  VkAccelerationStructureGeometryLinearSweptSpheresDataNV* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexFormat*: VkFormat
    vertexData*: VkDeviceOrHostAddressConstKHR
    vertexStride*: VkDeviceSize
    radiusFormat*: VkFormat
    radiusData*: VkDeviceOrHostAddressConstKHR
    radiusStride*: VkDeviceSize
    indexType*: VkIndexType
    indexData*: VkDeviceOrHostAddressConstKHR
    indexStride*: VkDeviceSize
    indexingMode*: VkRayTracingLssIndexingModeNV
    endCapsMode*: VkRayTracingLssPrimitiveEndCapsModeNV

  VkAccelerationStructureGeometrySpheresDataNV* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexFormat*: VkFormat
    vertexData*: VkDeviceOrHostAddressConstKHR
    vertexStride*: VkDeviceSize
    radiusFormat*: VkFormat
    radiusData*: VkDeviceOrHostAddressConstKHR
    radiusStride*: VkDeviceSize
    indexType*: VkIndexType
    indexData*: VkDeviceOrHostAddressConstKHR
    indexStride*: VkDeviceSize

  VkAccelerationStructureGeometryDataKHR* {.union.} = object
    triangles*: VkAccelerationStructureGeometryTrianglesDataKHR
    aabbs*: VkAccelerationStructureGeometryAabbsDataKHR
    instances*: VkAccelerationStructureGeometryInstancesDataKHR

  VkAccelerationStructureGeometryKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    geometryType*: VkGeometryTypeKHR
    geometry*: VkAccelerationStructureGeometryDataKHR
    flags*: VkGeometryFlagsKHR

  VkAccelerationStructureBuildGeometryInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkAccelerationStructureTypeKHR
    flags*: VkBuildAccelerationStructureFlagsKHR
    mode*: VkBuildAccelerationStructureModeKHR
    srcAccelerationStructure*: VkAccelerationStructureKHR
    dstAccelerationStructure*: VkAccelerationStructureKHR
    geometryCount*: uint32
    pGeometries*: ptr VkAccelerationStructureGeometryKHR
    ppGeometries*: ptr ptr VkAccelerationStructureGeometryKHR
    scratchData*: VkDeviceOrHostAddressKHR

  VkAccelerationStructureBuildRangeInfoKHR* = object
    primitiveCount*: uint32
    primitiveOffset*: uint32
    firstVertex*: uint32
    transformOffset*: uint32

  VkAccelerationStructureCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    createFlags*: VkAccelerationStructureCreateFlagsKHR
    buffer*: VkBuffer
    offset*: VkDeviceSize
    size*: VkDeviceSize
    `type`*: VkAccelerationStructureTypeKHR
    deviceAddress*: VkDeviceAddress

  VkAabbPositionsKHR* = object
    minX*: float32
    minY*: float32
    minZ*: float32
    maxX*: float32
    maxY*: float32
    maxZ*: float32

  VkAabbPositionsNV* = VkAabbPositionsKHR

  VkTransformMatrixKHR* = object
    matrix*: array[3, float32]

  VkTransformMatrixNV* = VkTransformMatrixKHR

  VkAccelerationStructureInstanceKHR* = object
    transform*: VkTransformMatrixKHR
    instanceCustomIndex*: uint32
    mask*: uint32
    instanceShaderBindingTableRecordOffset*: uint32
    flags*: VkGeometryInstanceFlagsKHR
    accelerationStructureReference*: uint64

  VkAccelerationStructureInstanceNV* = VkAccelerationStructureInstanceKHR

  VkAccelerationStructureDeviceAddressInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    accelerationStructure*: VkAccelerationStructureKHR

  VkAccelerationStructureVersionInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pVersionData*: ptr uint8

  VkCopyAccelerationStructureInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    src*: VkAccelerationStructureKHR
    dst*: VkAccelerationStructureKHR
    mode*: VkCopyAccelerationStructureModeKHR

  VkCopyAccelerationStructureToMemoryInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    src*: VkAccelerationStructureKHR
    dst*: VkDeviceOrHostAddressKHR
    mode*: VkCopyAccelerationStructureModeKHR

  VkCopyMemoryToAccelerationStructureInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    src*: VkDeviceOrHostAddressConstKHR
    dst*: VkAccelerationStructureKHR
    mode*: VkCopyAccelerationStructureModeKHR

  VkRayTracingPipelineInterfaceCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxPipelineRayPayloadSize*: uint32
    maxPipelineRayHitAttributeSize*: uint32

  VkPipelineLibraryCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    libraryCount*: uint32
    pLibraries*: ptr VkPipeline

  VkRefreshObjectKHR* = object
    objectType*: VkObjectType
    objectHandle*: uint64
    flags*: VkRefreshObjectFlagsKHR

  VkRefreshObjectListKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    objectCount*: uint32
    pObjects*: ptr VkRefreshObjectKHR

  VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    extendedDynamicState*: VkBool32

  VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    extendedDynamicState2*: VkBool32
    extendedDynamicState2LogicOp*: VkBool32
    extendedDynamicState2PatchControlPoints*: VkBool32

  VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    extendedDynamicState3TessellationDomainOrigin*: VkBool32
    extendedDynamicState3DepthClampEnable*: VkBool32
    extendedDynamicState3PolygonMode*: VkBool32
    extendedDynamicState3RasterizationSamples*: VkBool32
    extendedDynamicState3SampleMask*: VkBool32
    extendedDynamicState3AlphaToCoverageEnable*: VkBool32
    extendedDynamicState3AlphaToOneEnable*: VkBool32
    extendedDynamicState3LogicOpEnable*: VkBool32
    extendedDynamicState3ColorBlendEnable*: VkBool32
    extendedDynamicState3ColorBlendEquation*: VkBool32
    extendedDynamicState3ColorWriteMask*: VkBool32
    extendedDynamicState3RasterizationStream*: VkBool32
    extendedDynamicState3ConservativeRasterizationMode*: VkBool32
    extendedDynamicState3ExtraPrimitiveOverestimationSize*: VkBool32
    extendedDynamicState3DepthClipEnable*: VkBool32
    extendedDynamicState3SampleLocationsEnable*: VkBool32
    extendedDynamicState3ColorBlendAdvanced*: VkBool32
    extendedDynamicState3ProvokingVertexMode*: VkBool32
    extendedDynamicState3LineRasterizationMode*: VkBool32
    extendedDynamicState3LineStippleEnable*: VkBool32
    extendedDynamicState3DepthClipNegativeOneToOne*: VkBool32
    extendedDynamicState3ViewportWScalingEnable*: VkBool32
    extendedDynamicState3ViewportSwizzle*: VkBool32
    extendedDynamicState3CoverageToColorEnable*: VkBool32
    extendedDynamicState3CoverageToColorLocation*: VkBool32
    extendedDynamicState3CoverageModulationMode*: VkBool32
    extendedDynamicState3CoverageModulationTableEnable*: VkBool32
    extendedDynamicState3CoverageModulationTable*: VkBool32
    extendedDynamicState3CoverageReductionMode*: VkBool32
    extendedDynamicState3RepresentativeFragmentTestEnable*: VkBool32
    extendedDynamicState3ShadingRateImageEnable*: VkBool32

  VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    dynamicPrimitiveTopologyUnrestricted*: VkBool32

  VkColorBlendEquationEXT* = object
    srcColorBlendFactor*: VkBlendFactor
    dstColorBlendFactor*: VkBlendFactor
    colorBlendOp*: VkBlendOp
    srcAlphaBlendFactor*: VkBlendFactor
    dstAlphaBlendFactor*: VkBlendFactor
    alphaBlendOp*: VkBlendOp

  VkColorBlendAdvancedEXT* = object
    advancedBlendOp*: VkBlendOp
    srcPremultiplied*: VkBool32
    dstPremultiplied*: VkBool32
    blendOverlap*: VkBlendOverlapEXT
    clampResults*: VkBool32

  VkRenderPassTransformBeginInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    transform*: VkSurfaceTransformFlagBitsKHR

  VkCopyCommandTransformInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    transform*: VkSurfaceTransformFlagBitsKHR

  VkCommandBufferInheritanceRenderPassTransformInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    transform*: VkSurfaceTransformFlagBitsKHR
    renderArea*: VkRect2D

  VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    partitionedAccelerationStructure*: VkBool32

  VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxPartitionCount*: uint32

  VkBuildPartitionedAccelerationStructureIndirectCommandNV* = object
    opType*: VkPartitionedAccelerationStructureOpTypeNV
    argCount*: uint32
    argData*: VkStridedDeviceAddressNV

  VkPartitionedAccelerationStructureFlagsNV* = object
    sType*: VkStructureType
    pNext*: pointer
    enablePartitionTranslation*: VkBool32

  VkPartitionedAccelerationStructureWriteInstanceDataNV* = object
    transform*: VkTransformMatrixKHR
    explicitAABB*: array[6, float32]
    instanceID*: uint32
    instanceMask*: uint32
    instanceContributionToHitGroupIndex*: uint32
    instanceFlags*: VkPartitionedAccelerationStructureInstanceFlagsNV
    instanceIndex*: uint32
    partitionIndex*: uint32
    accelerationStructure*: VkDeviceAddress

  VkPartitionedAccelerationStructureUpdateInstanceDataNV* = object
    instanceIndex*: uint32
    instanceContributionToHitGroupIndex*: uint32
    accelerationStructure*: VkDeviceAddress

  VkPartitionedAccelerationStructureWritePartitionTranslationDataNV* = object
    partitionIndex*: uint32
    partitionTranslation*: array[3, float32]

  VkWriteDescriptorSetPartitionedAccelerationStructureNV* = object
    sType*: VkStructureType
    pNext*: pointer
    accelerationStructureCount*: uint32
    pAccelerationStructures*: ptr VkDeviceAddress

  VkPartitionedAccelerationStructureInstancesInputNV* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkBuildAccelerationStructureFlagsKHR
    instanceCount*: uint32
    maxInstancePerPartitionCount*: uint32
    partitionCount*: uint32
    maxInstanceInGlobalPartitionCount*: uint32

  VkBuildPartitionedAccelerationStructureInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    input*: VkPartitionedAccelerationStructureInstancesInputNV
    srcAccelerationStructureData*: VkDeviceAddress
    dstAccelerationStructureData*: VkDeviceAddress
    scratchData*: VkDeviceAddress
    srcInfos*: VkDeviceAddress
    srcInfosCount*: VkDeviceAddress

  VkPhysicalDeviceDiagnosticsConfigFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    diagnosticsConfig*: VkBool32

  VkDeviceDiagnosticsConfigCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDeviceDiagnosticsConfigFlagsNV

  VkPipelineOfflineCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineIdentifier*: array[VK_UUID_SIZE, uint8]
    matchControl*: VkPipelineMatchControl
    poolEntrySize*: VkDeviceSize

  VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderZeroInitializeWorkgroupMemory*: VkBool32

  VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR* = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures

  VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderSubgroupUniformControlFlow*: VkBool32

  VkPhysicalDeviceRobustness2FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    robustBufferAccess2*: VkBool32
    robustImageAccess2*: VkBool32
    nullDescriptor*: VkBool32

  VkPhysicalDeviceRobustness2FeaturesEXT* = VkPhysicalDeviceRobustness2FeaturesKHR

  VkPhysicalDeviceRobustness2PropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    robustStorageBufferAccessSizeAlignment*: VkDeviceSize
    robustUniformBufferAccessSizeAlignment*: VkDeviceSize

  VkPhysicalDeviceRobustness2PropertiesEXT* = VkPhysicalDeviceRobustness2PropertiesKHR

  VkPhysicalDeviceImageRobustnessFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    robustImageAccess*: VkBool32

  VkPhysicalDeviceImageRobustnessFeaturesEXT* = VkPhysicalDeviceImageRobustnessFeatures

  VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    workgroupMemoryExplicitLayout*: VkBool32
    workgroupMemoryExplicitLayoutScalarBlockLayout*: VkBool32
    workgroupMemoryExplicitLayout8BitAccess*: VkBool32
    workgroupMemoryExplicitLayout16BitAccess*: VkBool32

  VkPhysicalDevicePortabilitySubsetFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    constantAlphaColorBlendFactors*: VkBool32
    events*: VkBool32
    imageViewFormatReinterpretation*: VkBool32
    imageViewFormatSwizzle*: VkBool32
    imageView2DOn3DImage*: VkBool32
    multisampleArrayImage*: VkBool32
    mutableComparisonSamplers*: VkBool32
    pointPolygons*: VkBool32
    samplerMipLodBias*: VkBool32
    separateStencilMaskRef*: VkBool32
    shaderSampleRateInterpolationFunctions*: VkBool32
    tessellationIsolines*: VkBool32
    tessellationPointMode*: VkBool32
    triangleFans*: VkBool32
    vertexAttributeAccessBeyondStride*: VkBool32

  VkPhysicalDevicePortabilitySubsetPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    minVertexInputBindingStrideAlignment*: uint32

  VkPhysicalDevice4444FormatsFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    formatA4R4G4B4*: VkBool32
    formatA4B4G4R4*: VkBool32

  VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* = object
    sType*: VkStructureType
    pNext*: pointer
    subpassShading*: VkBool32

  VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* = object
    sType*: VkStructureType
    pNext*: pointer
    clustercullingShader*: VkBool32
    multiviewClusterCullingShader*: VkBool32

  VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* = object
    sType*: VkStructureType
    pNext*: pointer
    clusterShadingRate*: VkBool32

  VkBufferCopy2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcOffset*: VkDeviceSize
    dstOffset*: VkDeviceSize
    size*: VkDeviceSize

  VkBufferCopy2KHR* = VkBufferCopy2

  VkImageCopy2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcSubresource*: VkImageSubresourceLayers
    srcOffset*: VkOffset3D
    dstSubresource*: VkImageSubresourceLayers
    dstOffset*: VkOffset3D
    extent*: VkExtent3D

  VkImageCopy2KHR* = VkImageCopy2

  VkImageBlit2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcSubresource*: VkImageSubresourceLayers
    srcOffsets*: array[2, VkOffset3D]
    dstSubresource*: VkImageSubresourceLayers
    dstOffsets*: array[2, VkOffset3D]

  VkImageBlit2KHR* = VkImageBlit2

  VkBufferImageCopy2* = object
    sType*: VkStructureType
    pNext*: pointer
    bufferOffset*: VkDeviceSize
    bufferRowLength*: uint32
    bufferImageHeight*: uint32
    imageSubresource*: VkImageSubresourceLayers
    imageOffset*: VkOffset3D
    imageExtent*: VkExtent3D

  VkBufferImageCopy2KHR* = VkBufferImageCopy2

  VkImageResolve2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcSubresource*: VkImageSubresourceLayers
    srcOffset*: VkOffset3D
    dstSubresource*: VkImageSubresourceLayers
    dstOffset*: VkOffset3D
    extent*: VkExtent3D

  VkImageResolve2KHR* = VkImageResolve2

  VkCopyBufferInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcBuffer*: VkBuffer
    dstBuffer*: VkBuffer
    regionCount*: uint32
    pRegions*: ptr VkBufferCopy2

  VkCopyBufferInfo2KHR* = VkCopyBufferInfo2

  VkCopyImageInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcImage*: VkImage
    srcImageLayout*: VkImageLayout
    dstImage*: VkImage
    dstImageLayout*: VkImageLayout
    regionCount*: uint32
    pRegions*: ptr VkImageCopy2

  VkCopyImageInfo2KHR* = VkCopyImageInfo2

  VkBlitImageInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcImage*: VkImage
    srcImageLayout*: VkImageLayout
    dstImage*: VkImage
    dstImageLayout*: VkImageLayout
    regionCount*: uint32
    pRegions*: ptr VkImageBlit2
    filter*: VkFilter

  VkBlitImageInfo2KHR* = VkBlitImageInfo2

  VkCopyBufferToImageInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcBuffer*: VkBuffer
    dstImage*: VkImage
    dstImageLayout*: VkImageLayout
    regionCount*: uint32
    pRegions*: ptr VkBufferImageCopy2

  VkCopyBufferToImageInfo2KHR* = VkCopyBufferToImageInfo2

  VkCopyImageToBufferInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcImage*: VkImage
    srcImageLayout*: VkImageLayout
    dstBuffer*: VkBuffer
    regionCount*: uint32
    pRegions*: ptr VkBufferImageCopy2

  VkCopyImageToBufferInfo2KHR* = VkCopyImageToBufferInfo2

  VkResolveImageInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcImage*: VkImage
    srcImageLayout*: VkImageLayout
    dstImage*: VkImage
    dstImageLayout*: VkImageLayout
    regionCount*: uint32
    pRegions*: ptr VkImageResolve2

  VkResolveImageInfo2KHR* = VkResolveImageInfo2

  VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderImageInt64Atomics*: VkBool32
    sparseImageInt64Atomics*: VkBool32

  VkFragmentShadingRateAttachmentInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pFragmentShadingRateAttachment*: ptr VkAttachmentReference2
    shadingRateAttachmentTexelSize*: VkExtent2D

  VkPipelineFragmentShadingRateStateCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentSize*: VkExtent2D
    combinerOps*: array[2, VkFragmentShadingRateCombinerOpKHR]

  VkPhysicalDeviceFragmentShadingRateFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineFragmentShadingRate*: VkBool32
    primitiveFragmentShadingRate*: VkBool32
    attachmentFragmentShadingRate*: VkBool32

  VkPhysicalDeviceFragmentShadingRatePropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    minFragmentShadingRateAttachmentTexelSize*: VkExtent2D
    maxFragmentShadingRateAttachmentTexelSize*: VkExtent2D
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio*: uint32
    primitiveFragmentShadingRateWithMultipleViewports*: VkBool32
    layeredShadingRateAttachments*: VkBool32
    fragmentShadingRateNonTrivialCombinerOps*: VkBool32
    maxFragmentSize*: VkExtent2D
    maxFragmentSizeAspectRatio*: uint32
    maxFragmentShadingRateCoverageSamples*: uint32
    maxFragmentShadingRateRasterizationSamples*: VkSampleCountFlagBits
    fragmentShadingRateWithShaderDepthStencilWrites*: VkBool32
    fragmentShadingRateWithSampleMask*: VkBool32
    fragmentShadingRateWithShaderSampleMask*: VkBool32
    fragmentShadingRateWithConservativeRasterization*: VkBool32
    fragmentShadingRateWithFragmentShaderInterlock*: VkBool32
    fragmentShadingRateWithCustomSampleLocations*: VkBool32
    fragmentShadingRateStrictMultiplyCombiner*: VkBool32

  VkPhysicalDeviceFragmentShadingRateKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    sampleCounts*: VkSampleCountFlags
    fragmentSize*: VkExtent2D

  VkPhysicalDeviceShaderTerminateInvocationFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderTerminateInvocation*: VkBool32

  VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR* = VkPhysicalDeviceShaderTerminateInvocationFeatures

  VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentShadingRateEnums*: VkBool32
    supersampleFragmentShadingRates*: VkBool32
    noInvocationFragmentShadingRates*: VkBool32

  VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxFragmentShadingRateInvocationCount*: VkSampleCountFlagBits

  VkPipelineFragmentShadingRateEnumStateCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    shadingRateType*: VkFragmentShadingRateTypeNV
    shadingRate*: VkFragmentShadingRateNV
    combinerOps*: array[2, VkFragmentShadingRateCombinerOpKHR]

  VkAccelerationStructureBuildSizesInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    accelerationStructureSize*: VkDeviceSize
    updateScratchSize*: VkDeviceSize
    buildScratchSize*: VkDeviceSize

  VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    image2DViewOf3D*: VkBool32
    sampler2DViewOf3D*: VkBool32

  VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    imageSlicedViewOf3D*: VkBool32

  VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    attachmentFeedbackLoopDynamicState*: VkBool32

  VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    legacyVertexAttributes*: VkBool32

  VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    nativeUnalignedPerformance*: VkBool32

  VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    mutableDescriptorType*: VkBool32

  VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE* = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT

  VkMutableDescriptorTypeListEXT* = object
    descriptorTypeCount*: uint32
    pDescriptorTypes*: ptr VkDescriptorType

  VkMutableDescriptorTypeListVALVE* = VkMutableDescriptorTypeListEXT

  VkMutableDescriptorTypeCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    mutableDescriptorTypeListCount*: uint32
    pMutableDescriptorTypeLists*: ptr VkMutableDescriptorTypeListEXT

  VkMutableDescriptorTypeCreateInfoVALVE* = VkMutableDescriptorTypeCreateInfoEXT

  VkPhysicalDeviceDepthClipControlFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    depthClipControl*: VkBool32

  VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    zeroInitializeDeviceMemory*: VkBool32

  VkBeginCustomResolveInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer

  VkPhysicalDeviceCustomResolveFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    customResolve*: VkBool32

  VkCustomResolveCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    customResolve*: VkBool32
    colorAttachmentCount*: uint32
    pColorAttachmentFormats*: ptr VkFormat
    depthAttachmentFormat*: VkFormat
    stencilAttachmentFormat*: VkFormat

  VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceGeneratedCommands*: VkBool32
    dynamicGeneratedPipelineLayout*: VkBool32

  VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxIndirectPipelineCount*: uint32
    maxIndirectShaderObjectCount*: uint32
    maxIndirectSequenceCount*: uint32
    maxIndirectCommandsTokenCount*: uint32
    maxIndirectCommandsTokenOffset*: uint32
    maxIndirectCommandsIndirectStride*: uint32
    supportedIndirectCommandsInputModes*: VkIndirectCommandsInputModeFlagsEXT
    supportedIndirectCommandsShaderStages*: VkShaderStageFlags
    supportedIndirectCommandsShaderStagesPipelineBinding*: VkShaderStageFlags
    supportedIndirectCommandsShaderStagesShaderBinding*: VkShaderStageFlags
    deviceGeneratedCommandsTransformFeedback*: VkBool32
    deviceGeneratedCommandsMultiDrawIndirectCount*: VkBool32

  VkGeneratedCommandsPipelineInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pipeline*: VkPipeline

  VkGeneratedCommandsShaderInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderCount*: uint32
    pShaders*: ptr VkShaderEXT

  VkGeneratedCommandsMemoryRequirementsInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    indirectExecutionSet*: VkIndirectExecutionSetEXT
    indirectCommandsLayout*: VkIndirectCommandsLayoutEXT
    maxSequenceCount*: uint32
    maxDrawCount*: uint32

  VkIndirectExecutionSetPipelineInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    initialPipeline*: VkPipeline
    maxPipelineCount*: uint32

  VkIndirectExecutionSetShaderLayoutInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    setLayoutCount*: uint32
    pSetLayouts*: ptr VkDescriptorSetLayout

  VkIndirectExecutionSetShaderInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderCount*: uint32
    pInitialShaders*: ptr VkShaderEXT
    pSetLayoutInfos*: ptr VkIndirectExecutionSetShaderLayoutInfoEXT
    maxShaderCount*: uint32
    pushConstantRangeCount*: uint32
    pPushConstantRanges*: ptr VkPushConstantRange

  VkIndirectExecutionSetInfoEXT* {.union.} = object
    pPipelineInfo*: ptr VkIndirectExecutionSetPipelineInfoEXT
    pShaderInfo*: ptr VkIndirectExecutionSetShaderInfoEXT

  VkIndirectExecutionSetCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkIndirectExecutionSetInfoTypeEXT
    info*: VkIndirectExecutionSetInfoEXT

  VkGeneratedCommandsInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderStages*: VkShaderStageFlags
    indirectExecutionSet*: VkIndirectExecutionSetEXT
    indirectCommandsLayout*: VkIndirectCommandsLayoutEXT
    indirectAddress*: VkDeviceAddress
    indirectAddressSize*: VkDeviceSize
    preprocessAddress*: VkDeviceAddress
    preprocessSize*: VkDeviceSize
    maxSequenceCount*: uint32
    sequenceCountAddress*: VkDeviceAddress
    maxDrawCount*: uint32

  VkWriteIndirectExecutionSetPipelineEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    index*: uint32
    pipeline*: VkPipeline

  VkWriteIndirectExecutionSetShaderEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    index*: uint32
    shader*: VkShaderEXT

  VkIndirectCommandsLayoutCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkIndirectCommandsLayoutUsageFlagsEXT
    shaderStages*: VkShaderStageFlags
    indirectStride*: uint32
    pipelineLayout*: VkPipelineLayout
    tokenCount*: uint32
    pTokens*: ptr VkIndirectCommandsLayoutTokenEXT

  VkIndirectCommandsLayoutTokenEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkIndirectCommandsTokenTypeEXT
    data*: VkIndirectCommandsTokenDataEXT
    offset*: uint32

  VkDrawIndirectCountIndirectCommandEXT* = object
    bufferAddress*: VkDeviceAddress
    stride*: uint32
    commandCount*: uint32

  VkIndirectCommandsVertexBufferTokenEXT* = object
    vertexBindingUnit*: uint32

  VkBindVertexBufferIndirectCommandEXT* = object
    bufferAddress*: VkDeviceAddress
    size*: uint32
    stride*: uint32

  VkIndirectCommandsIndexBufferTokenEXT* = object
    mode*: VkIndirectCommandsInputModeFlagBitsEXT

  VkBindIndexBufferIndirectCommandEXT* = object
    bufferAddress*: VkDeviceAddress
    size*: uint32
    indexType*: VkIndexType

  VkIndirectCommandsPushConstantTokenEXT* = object
    updateRange*: VkPushConstantRange

  VkIndirectCommandsExecutionSetTokenEXT* = object
    `type`*: VkIndirectExecutionSetInfoTypeEXT
    shaderStages*: VkShaderStageFlags

  VkIndirectCommandsTokenDataEXT* {.union.} = object
    pPushConstant*: ptr VkIndirectCommandsPushConstantTokenEXT
    pVertexBuffer*: ptr VkIndirectCommandsVertexBufferTokenEXT
    pIndexBuffer*: ptr VkIndirectCommandsIndexBufferTokenEXT
    pExecutionSet*: ptr VkIndirectCommandsExecutionSetTokenEXT

  VkPipelineViewportDepthClipControlCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    negativeOneToOne*: VkBool32

  VkPhysicalDeviceDepthClampControlFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    depthClampControl*: VkBool32

  VkPipelineViewportDepthClampControlCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    depthClampMode*: VkDepthClampModeEXT
    pDepthClampRange*: ptr VkDepthClampRangeEXT

  VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexInputDynamicState*: VkBool32

  VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    externalMemoryRDMA*: VkBool32

  VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderRelaxedExtendedInstruction*: VkBool32

  VkVertexInputBindingDescription2EXT* = object
    sType*: VkStructureType
    pNext*: pointer
    binding*: uint32
    stride*: uint32
    inputRate*: VkVertexInputRate
    divisor*: uint32

  VkVertexInputAttributeDescription2EXT* = object
    sType*: VkStructureType
    pNext*: pointer
    location*: uint32
    binding*: uint32
    format*: VkFormat
    offset*: uint32

  VkPhysicalDeviceColorWriteEnableFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    colorWriteEnable*: VkBool32

  VkPipelineColorWriteCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    attachmentCount*: uint32
    pColorWriteEnables*: ptr VkBool32

  VkMemoryBarrier2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcStageMask*: VkPipelineStageFlags2
    srcAccessMask*: VkAccessFlags2
    dstStageMask*: VkPipelineStageFlags2
    dstAccessMask*: VkAccessFlags2

  VkMemoryBarrier2KHR* = VkMemoryBarrier2

  VkImageMemoryBarrier2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcStageMask*: VkPipelineStageFlags2
    srcAccessMask*: VkAccessFlags2
    dstStageMask*: VkPipelineStageFlags2
    dstAccessMask*: VkAccessFlags2
    oldLayout*: VkImageLayout
    newLayout*: VkImageLayout
    srcQueueFamilyIndex*: uint32
    dstQueueFamilyIndex*: uint32
    image*: VkImage
    subresourceRange*: VkImageSubresourceRange

  VkImageMemoryBarrier2KHR* = VkImageMemoryBarrier2

  VkBufferMemoryBarrier2* = object
    sType*: VkStructureType
    pNext*: pointer
    srcStageMask*: VkPipelineStageFlags2
    srcAccessMask*: VkAccessFlags2
    dstStageMask*: VkPipelineStageFlags2
    dstAccessMask*: VkAccessFlags2
    srcQueueFamilyIndex*: uint32
    dstQueueFamilyIndex*: uint32
    buffer*: VkBuffer
    offset*: VkDeviceSize
    size*: VkDeviceSize

  VkBufferMemoryBarrier2KHR* = VkBufferMemoryBarrier2

  VkMemoryBarrierAccessFlags3KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    srcAccessMask3*: VkAccessFlags3KHR
    dstAccessMask3*: VkAccessFlags3KHR

  VkDependencyInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    dependencyFlags*: VkDependencyFlags
    memoryBarrierCount*: uint32
    pMemoryBarriers*: ptr VkMemoryBarrier2
    bufferMemoryBarrierCount*: uint32
    pBufferMemoryBarriers*: ptr VkBufferMemoryBarrier2
    imageMemoryBarrierCount*: uint32
    pImageMemoryBarriers*: ptr VkImageMemoryBarrier2

  VkDependencyInfoKHR* = VkDependencyInfo

  VkSemaphoreSubmitInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    value*: uint64
    stageMask*: VkPipelineStageFlags2
    deviceIndex*: uint32

  VkSemaphoreSubmitInfoKHR* = VkSemaphoreSubmitInfo

  VkCommandBufferSubmitInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    commandBuffer*: VkCommandBuffer
    deviceMask*: uint32

  VkCommandBufferSubmitInfoKHR* = VkCommandBufferSubmitInfo

  VkSubmitInfo2* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkSubmitFlags
    waitSemaphoreInfoCount*: uint32
    pWaitSemaphoreInfos*: ptr VkSemaphoreSubmitInfo
    commandBufferInfoCount*: uint32
    pCommandBufferInfos*: ptr VkCommandBufferSubmitInfo
    signalSemaphoreInfoCount*: uint32
    pSignalSemaphoreInfos*: ptr VkSemaphoreSubmitInfo

  VkSubmitInfo2KHR* = VkSubmitInfo2

  VkQueueFamilyCheckpointProperties2NV* = object
    sType*: VkStructureType
    pNext*: pointer
    checkpointExecutionStageMask*: VkPipelineStageFlags2

  VkCheckpointData2NV* = object
    sType*: VkStructureType
    pNext*: pointer
    stage*: VkPipelineStageFlags2
    pCheckpointMarker*: pointer

  VkPhysicalDeviceSynchronization2Features* = object
    sType*: VkStructureType
    pNext*: pointer
    synchronization2*: VkBool32

  VkPhysicalDeviceSynchronization2FeaturesKHR* = VkPhysicalDeviceSynchronization2Features

  VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    unifiedImageLayouts*: VkBool32
    unifiedImageLayoutsVideo*: VkBool32

  VkPhysicalDeviceHostImageCopyFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    hostImageCopy*: VkBool32

  VkPhysicalDeviceHostImageCopyFeaturesEXT* = VkPhysicalDeviceHostImageCopyFeatures

  VkPhysicalDeviceHostImageCopyProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    copySrcLayoutCount*: uint32
    pCopySrcLayouts*: ptr VkImageLayout
    copyDstLayoutCount*: uint32
    pCopyDstLayouts*: ptr VkImageLayout
    optimalTilingLayoutUUID*: array[VK_UUID_SIZE, uint8]
    identicalMemoryTypeRequirements*: VkBool32

  VkPhysicalDeviceHostImageCopyPropertiesEXT* = VkPhysicalDeviceHostImageCopyProperties

  VkMemoryToImageCopy* = object
    sType*: VkStructureType
    pNext*: pointer
    pHostPointer*: pointer
    memoryRowLength*: uint32
    memoryImageHeight*: uint32
    imageSubresource*: VkImageSubresourceLayers
    imageOffset*: VkOffset3D
    imageExtent*: VkExtent3D

  VkMemoryToImageCopyEXT* = VkMemoryToImageCopy

  VkImageToMemoryCopy* = object
    sType*: VkStructureType
    pNext*: pointer
    pHostPointer*: pointer
    memoryRowLength*: uint32
    memoryImageHeight*: uint32
    imageSubresource*: VkImageSubresourceLayers
    imageOffset*: VkOffset3D
    imageExtent*: VkExtent3D

  VkImageToMemoryCopyEXT* = VkImageToMemoryCopy

  VkCopyMemoryToImageInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkHostImageCopyFlags
    dstImage*: VkImage
    dstImageLayout*: VkImageLayout
    regionCount*: uint32
    pRegions*: ptr VkMemoryToImageCopy

  VkCopyMemoryToImageInfoEXT* = VkCopyMemoryToImageInfo

  VkCopyImageToMemoryInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkHostImageCopyFlags
    srcImage*: VkImage
    srcImageLayout*: VkImageLayout
    regionCount*: uint32
    pRegions*: ptr VkImageToMemoryCopy

  VkCopyImageToMemoryInfoEXT* = VkCopyImageToMemoryInfo

  VkCopyImageToImageInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkHostImageCopyFlags
    srcImage*: VkImage
    srcImageLayout*: VkImageLayout
    dstImage*: VkImage
    dstImageLayout*: VkImageLayout
    regionCount*: uint32
    pRegions*: ptr VkImageCopy2

  VkCopyImageToImageInfoEXT* = VkCopyImageToImageInfo

  VkHostImageLayoutTransitionInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    image*: VkImage
    oldLayout*: VkImageLayout
    newLayout*: VkImageLayout
    subresourceRange*: VkImageSubresourceRange

  VkHostImageLayoutTransitionInfoEXT* = VkHostImageLayoutTransitionInfo

  VkSubresourceHostMemcpySize* = object
    sType*: VkStructureType
    pNext*: pointer
    size*: VkDeviceSize

  VkSubresourceHostMemcpySizeEXT* = VkSubresourceHostMemcpySize

  VkHostImageCopyDevicePerformanceQuery* = object
    sType*: VkStructureType
    pNext*: pointer
    optimalDeviceAccess*: VkBool32
    identicalMemoryLayout*: VkBool32

  VkHostImageCopyDevicePerformanceQueryEXT* = VkHostImageCopyDevicePerformanceQuery

  VkPhysicalDeviceVulkanSC10Properties* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceNoDynamicHostAllocations*: VkBool32
    deviceDestroyFreesMemory*: VkBool32
    commandPoolMultipleCommandBuffersRecording*: VkBool32
    commandPoolResetCommandBuffer*: VkBool32
    commandBufferSimultaneousUse*: VkBool32
    secondaryCommandBufferNullOrImagelessFramebuffer*: VkBool32
    recycleDescriptorSetMemory*: VkBool32
    recyclePipelineMemory*: VkBool32
    maxRenderPassSubpasses*: uint32
    maxRenderPassDependencies*: uint32
    maxSubpassInputAttachments*: uint32
    maxSubpassPreserveAttachments*: uint32
    maxFramebufferAttachments*: uint32
    maxDescriptorSetLayoutBindings*: uint32
    maxQueryFaultCount*: uint32
    maxCallbackFaultCount*: uint32
    maxCommandPoolCommandBuffers*: uint32
    maxCommandBufferSize*: VkDeviceSize

  VkPipelinePoolSize* = object
    sType*: VkStructureType
    pNext*: pointer
    poolEntrySize*: VkDeviceSize
    poolEntryCount*: uint32

  VkDeviceObjectReservationCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineCacheCreateInfoCount*: uint32
    pPipelineCacheCreateInfos*: ptr VkPipelineCacheCreateInfo
    pipelinePoolSizeCount*: uint32
    pPipelinePoolSizes*: ptr VkPipelinePoolSize
    semaphoreRequestCount*: uint32
    commandBufferRequestCount*: uint32
    fenceRequestCount*: uint32
    deviceMemoryRequestCount*: uint32
    bufferRequestCount*: uint32
    imageRequestCount*: uint32
    eventRequestCount*: uint32
    queryPoolRequestCount*: uint32
    bufferViewRequestCount*: uint32
    imageViewRequestCount*: uint32
    layeredImageViewRequestCount*: uint32
    pipelineCacheRequestCount*: uint32
    pipelineLayoutRequestCount*: uint32
    renderPassRequestCount*: uint32
    graphicsPipelineRequestCount*: uint32
    computePipelineRequestCount*: uint32
    descriptorSetLayoutRequestCount*: uint32
    samplerRequestCount*: uint32
    descriptorPoolRequestCount*: uint32
    descriptorSetRequestCount*: uint32
    framebufferRequestCount*: uint32
    commandPoolRequestCount*: uint32
    samplerYcbcrConversionRequestCount*: uint32
    surfaceRequestCount*: uint32
    swapchainRequestCount*: uint32
    displayModeRequestCount*: uint32
    subpassDescriptionRequestCount*: uint32
    attachmentDescriptionRequestCount*: uint32
    descriptorSetLayoutBindingRequestCount*: uint32
    descriptorSetLayoutBindingLimit*: uint32
    maxImageViewMipLevels*: uint32
    maxImageViewArrayLayers*: uint32
    maxLayeredImageViewMipLevels*: uint32
    maxOcclusionQueriesPerPool*: uint32
    maxPipelineStatisticsQueriesPerPool*: uint32
    maxTimestampQueriesPerPool*: uint32
    maxImmutableSamplersPerDescriptorSetLayout*: uint32

  VkCommandPoolMemoryReservationCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    commandPoolReservedSize*: VkDeviceSize
    commandPoolMaxCommandBuffers*: uint32

  VkCommandPoolMemoryConsumption* = object
    sType*: VkStructureType
    pNext*: pointer
    commandPoolAllocated*: VkDeviceSize
    commandPoolReservedSize*: VkDeviceSize
    commandBufferAllocated*: VkDeviceSize

  VkPhysicalDeviceVulkanSC10Features* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderAtomicInstructions*: VkBool32

  VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    primitivesGeneratedQuery*: VkBool32
    primitivesGeneratedQueryWithRasterizerDiscard*: VkBool32
    primitivesGeneratedQueryWithNonZeroStreams*: VkBool32

  VkPhysicalDeviceLegacyDitheringFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    legacyDithering*: VkBool32

  VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    multisampledRenderToSingleSampled*: VkBool32

  VkSurfaceCapabilitiesPresentId2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentId2Supported*: VkBool32

  VkSurfaceCapabilitiesPresentWait2KHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentWait2Supported*: VkBool32

  VkSubpassResolvePerformanceQueryEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    optimal*: VkBool32

  VkMultisampledRenderToSingleSampledInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    multisampledRenderToSingleSampledEnable*: VkBool32
    rasterizationSamples*: VkSampleCountFlagBits

  VkPhysicalDevicePipelineProtectedAccessFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineProtectedAccess*: VkBool32

  VkPhysicalDevicePipelineProtectedAccessFeaturesEXT* = VkPhysicalDevicePipelineProtectedAccessFeatures

  VkQueueFamilyVideoPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoCodecOperations*: VkVideoCodecOperationFlagsKHR

  VkQueueFamilyQueryResultStatusPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    queryResultStatusSupport*: VkBool32

  VkVideoProfileListInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    profileCount*: uint32
    pProfiles*: ptr VkVideoProfileInfoKHR

  VkPhysicalDeviceVideoFormatInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    imageUsage*: VkImageUsageFlags

  VkVideoFormatPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat
    componentMapping*: VkComponentMapping
    imageCreateFlags*: VkImageCreateFlags
    imageType*: VkImageType
    imageTiling*: VkImageTiling
    imageUsageFlags*: VkImageUsageFlags

  VkVideoEncodeQuantizationMapCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxQuantizationMapExtent*: VkExtent2D

  VkVideoEncodeH264QuantizationMapCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    minQpDelta*: int32
    maxQpDelta*: int32

  VkVideoEncodeH265QuantizationMapCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    minQpDelta*: int32
    maxQpDelta*: int32

  VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    minQIndexDelta*: int32
    maxQIndexDelta*: int32

  VkVideoFormatQuantizationMapPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    quantizationMapTexelSize*: VkExtent2D

  VkVideoFormatH265QuantizationMapPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    compatibleCtbSizes*: VkVideoEncodeH265CtbSizeFlagsKHR

  VkVideoFormatAV1QuantizationMapPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    compatibleSuperblockSizes*: VkVideoEncodeAV1SuperblockSizeFlagsKHR

  VkVideoProfileInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoCodecOperation*: VkVideoCodecOperationFlagBitsKHR
    chromaSubsampling*: VkVideoChromaSubsamplingFlagsKHR
    lumaBitDepth*: VkVideoComponentBitDepthFlagsKHR
    chromaBitDepth*: VkVideoComponentBitDepthFlagsKHR

  VkVideoCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoCapabilityFlagsKHR
    minBitstreamBufferOffsetAlignment*: VkDeviceSize
    minBitstreamBufferSizeAlignment*: VkDeviceSize
    pictureAccessGranularity*: VkExtent2D
    minCodedExtent*: VkExtent2D
    maxCodedExtent*: VkExtent2D
    maxDpbSlots*: uint32
    maxActiveReferencePictures*: uint32
    stdHeaderVersion*: VkExtensionProperties

  VkVideoSessionMemoryRequirementsKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryBindIndex*: uint32
    memoryRequirements*: VkMemoryRequirements

  VkBindVideoSessionMemoryInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryBindIndex*: uint32
    memory*: VkDeviceMemory
    memoryOffset*: VkDeviceSize
    memorySize*: VkDeviceSize

  VkVideoPictureResourceInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    codedOffset*: VkOffset2D
    codedExtent*: VkExtent2D
    baseArrayLayer*: uint32
    imageViewBinding*: VkImageView

  VkVideoReferenceSlotInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    slotIndex*: int32
    pPictureResource*: ptr VkVideoPictureResourceInfoKHR

  VkVideoDecodeCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoDecodeCapabilityFlagsKHR

  VkVideoDecodeUsageInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoUsageHints*: VkVideoDecodeUsageFlagsKHR

  VkVideoDecodeInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoDecodeFlagsKHR
    srcBuffer*: VkBuffer
    srcBufferOffset*: VkDeviceSize
    srcBufferRange*: VkDeviceSize
    dstPictureResource*: VkVideoPictureResourceInfoKHR
    pSetupReferenceSlot*: ptr VkVideoReferenceSlotInfoKHR
    referenceSlotCount*: uint32
    pReferenceSlots*: ptr VkVideoReferenceSlotInfoKHR

  VkPhysicalDeviceVideoMaintenance1FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoMaintenance1*: VkBool32

  VkPhysicalDeviceVideoMaintenance2FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoMaintenance2*: VkBool32

  VkVideoInlineQueryInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    queryPool*: VkQueryPool
    firstQuery*: uint32
    queryCount*: uint32
  StdVideoH264ProfileIdc* {.nodecl.} = object
  StdVideoH264LevelIdc* {.nodecl.} = object
  StdVideoDecodeH264PictureInfo* {.nodecl.} = object
  StdVideoDecodeH264ReferenceInfo* {.nodecl.} = object

  VkVideoDecodeH264ProfileInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdProfileIdc*: StdVideoH264ProfileIdc
    pictureLayout*: VkVideoDecodeH264PictureLayoutFlagBitsKHR

  VkVideoDecodeH264CapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxLevelIdc*: StdVideoH264LevelIdc
    fieldOffsetGranularity*: VkOffset2D
  StdVideoH264SequenceParameterSet* {.nodecl.} = object
  StdVideoH264PictureParameterSet* {.nodecl.} = object

  VkVideoDecodeH264SessionParametersAddInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdSPSCount*: uint32
    pStdSPSs*: ptr StdVideoH264SequenceParameterSet
    stdPPSCount*: uint32
    pStdPPSs*: ptr StdVideoH264PictureParameterSet

  VkVideoDecodeH264SessionParametersCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxStdSPSCount*: uint32
    maxStdPPSCount*: uint32
    pParametersAddInfo*: ptr VkVideoDecodeH264SessionParametersAddInfoKHR

  VkVideoDecodeH264InlineSessionParametersInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdSPS*: ptr StdVideoH264SequenceParameterSet
    pStdPPS*: ptr StdVideoH264PictureParameterSet

  VkVideoDecodeH264PictureInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdPictureInfo*: ptr StdVideoDecodeH264PictureInfo
    sliceCount*: uint32
    pSliceOffsets*: ptr uint32

  VkVideoDecodeH264DpbSlotInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdReferenceInfo*: ptr StdVideoDecodeH264ReferenceInfo
  StdVideoH265ProfileIdc* {.nodecl.} = object
  StdVideoH265VideoParameterSet* {.nodecl.} = object
  StdVideoH265SequenceParameterSet* {.nodecl.} = object
  StdVideoH265PictureParameterSet* {.nodecl.} = object
  StdVideoH265LevelIdc* {.nodecl.} = object
  StdVideoDecodeH265PictureInfo* {.nodecl.} = object
  StdVideoDecodeH265ReferenceInfo* {.nodecl.} = object

  VkVideoDecodeH265ProfileInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdProfileIdc*: StdVideoH265ProfileIdc

  VkVideoDecodeH265CapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxLevelIdc*: StdVideoH265LevelIdc

  VkVideoDecodeH265SessionParametersAddInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdVPSCount*: uint32
    pStdVPSs*: ptr StdVideoH265VideoParameterSet
    stdSPSCount*: uint32
    pStdSPSs*: ptr StdVideoH265SequenceParameterSet
    stdPPSCount*: uint32
    pStdPPSs*: ptr StdVideoH265PictureParameterSet

  VkVideoDecodeH265SessionParametersCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxStdVPSCount*: uint32
    maxStdSPSCount*: uint32
    maxStdPPSCount*: uint32
    pParametersAddInfo*: ptr VkVideoDecodeH265SessionParametersAddInfoKHR

  VkVideoDecodeH265InlineSessionParametersInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdVPS*: ptr StdVideoH265VideoParameterSet
    pStdSPS*: ptr StdVideoH265SequenceParameterSet
    pStdPPS*: ptr StdVideoH265PictureParameterSet

  VkVideoDecodeH265PictureInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdPictureInfo*: ptr StdVideoDecodeH265PictureInfo
    sliceSegmentCount*: uint32
    pSliceSegmentOffsets*: ptr uint32

  VkVideoDecodeH265DpbSlotInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdReferenceInfo*: ptr StdVideoDecodeH265ReferenceInfo
  StdVideoVP9Profile* {.nodecl.} = object
  StdVideoVP9Level* {.nodecl.} = object
  StdVideoDecodeVP9PictureInfo* {.nodecl.} = object

  VkPhysicalDeviceVideoDecodeVP9FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoDecodeVP9*: VkBool32

  VkVideoDecodeVP9ProfileInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdProfile*: StdVideoVP9Profile

  VkVideoDecodeVP9CapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxLevel*: StdVideoVP9Level

  VkVideoDecodeVP9PictureInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdPictureInfo*: ptr StdVideoDecodeVP9PictureInfo
    referenceNameSlotIndices*: array[VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR, int32]
    uncompressedHeaderOffset*: uint32
    compressedHeaderOffset*: uint32
    tilesOffset*: uint32
  StdVideoAV1Profile* {.nodecl.} = object
  StdVideoAV1Level* {.nodecl.} = object
  StdVideoAV1SequenceHeader* {.nodecl.} = object
  StdVideoDecodeAV1PictureInfo* {.nodecl.} = object
  StdVideoDecodeAV1ReferenceInfo* {.nodecl.} = object

  VkVideoDecodeAV1ProfileInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdProfile*: StdVideoAV1Profile
    filmGrainSupport*: VkBool32

  VkVideoDecodeAV1CapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxLevel*: StdVideoAV1Level

  VkVideoDecodeAV1SessionParametersCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdSequenceHeader*: ptr StdVideoAV1SequenceHeader

  VkVideoDecodeAV1InlineSessionParametersInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdSequenceHeader*: ptr StdVideoAV1SequenceHeader

  VkVideoDecodeAV1PictureInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdPictureInfo*: ptr StdVideoDecodeAV1PictureInfo
    referenceNameSlotIndices*: array[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR, int32]
    frameHeaderOffset*: uint32
    tileCount*: uint32
    pTileOffsets*: ptr uint32
    pTileSizes*: ptr uint32

  VkVideoDecodeAV1DpbSlotInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdReferenceInfo*: ptr StdVideoDecodeAV1ReferenceInfo

  VkVideoSessionCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    queueFamilyIndex*: uint32
    flags*: VkVideoSessionCreateFlagsKHR
    pVideoProfile*: ptr VkVideoProfileInfoKHR
    pictureFormat*: VkFormat
    maxCodedExtent*: VkExtent2D
    referencePictureFormat*: VkFormat
    maxDpbSlots*: uint32
    maxActiveReferencePictures*: uint32
    pStdHeaderVersion*: ptr VkExtensionProperties

  VkVideoSessionParametersCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoSessionParametersCreateFlagsKHR
    videoSessionParametersTemplate*: VkVideoSessionParametersKHR
    videoSession*: VkVideoSessionKHR

  VkVideoSessionParametersUpdateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    updateSequenceCount*: uint32

  VkVideoEncodeSessionParametersGetInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoSessionParameters*: VkVideoSessionParametersKHR

  VkVideoEncodeSessionParametersFeedbackInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    hasOverrides*: VkBool32

  VkVideoBeginCodingInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoBeginCodingFlagsKHR
    videoSession*: VkVideoSessionKHR
    videoSessionParameters*: VkVideoSessionParametersKHR
    referenceSlotCount*: uint32
    pReferenceSlots*: ptr VkVideoReferenceSlotInfoKHR

  VkVideoEndCodingInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEndCodingFlagsKHR

  VkVideoCodingControlInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoCodingControlFlagsKHR

  VkVideoEncodeUsageInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoUsageHints*: VkVideoEncodeUsageFlagsKHR
    videoContentHints*: VkVideoEncodeContentFlagsKHR
    tuningMode*: VkVideoEncodeTuningModeKHR

  VkVideoEncodeInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEncodeFlagsKHR
    dstBuffer*: VkBuffer
    dstBufferOffset*: VkDeviceSize
    dstBufferRange*: VkDeviceSize
    srcPictureResource*: VkVideoPictureResourceInfoKHR
    pSetupReferenceSlot*: ptr VkVideoReferenceSlotInfoKHR
    referenceSlotCount*: uint32
    pReferenceSlots*: ptr VkVideoReferenceSlotInfoKHR
    precedingExternallyEncodedBytes*: uint32

  VkVideoEncodeQuantizationMapInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    quantizationMap*: VkImageView
    quantizationMapExtent*: VkExtent2D

  VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    quantizationMapTexelSize*: VkExtent2D

  VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoEncodeQuantizationMap*: VkBool32

  VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    encodeFeedbackFlags*: VkVideoEncodeFeedbackFlagsKHR

  VkVideoEncodeQualityLevelInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    qualityLevel*: uint32

  VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pVideoProfile*: ptr VkVideoProfileInfoKHR
    qualityLevel*: uint32

  VkVideoEncodeQualityLevelPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    preferredRateControlMode*: VkVideoEncodeRateControlModeFlagBitsKHR
    preferredRateControlLayerCount*: uint32

  VkVideoEncodeRateControlInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEncodeRateControlFlagsKHR
    rateControlMode*: VkVideoEncodeRateControlModeFlagBitsKHR
    layerCount*: uint32
    pLayers*: ptr VkVideoEncodeRateControlLayerInfoKHR
    virtualBufferSizeInMs*: uint32
    initialVirtualBufferSizeInMs*: uint32

  VkVideoEncodeRateControlLayerInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    averageBitrate*: uint64
    maxBitrate*: uint64
    frameRateNumerator*: uint32
    frameRateDenominator*: uint32

  VkVideoEncodeCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEncodeCapabilityFlagsKHR
    rateControlModes*: VkVideoEncodeRateControlModeFlagsKHR
    maxRateControlLayers*: uint32
    maxBitrate*: uint64
    maxQualityLevels*: uint32
    encodeInputPictureGranularity*: VkExtent2D
    supportedEncodeFeedbackFlags*: VkVideoEncodeFeedbackFlagsKHR

  VkVideoEncodeH264CapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEncodeH264CapabilityFlagsKHR
    maxLevelIdc*: StdVideoH264LevelIdc
    maxSliceCount*: uint32
    maxPPictureL0ReferenceCount*: uint32
    maxBPictureL0ReferenceCount*: uint32
    maxL1ReferenceCount*: uint32
    maxTemporalLayerCount*: uint32
    expectDyadicTemporalLayerPattern*: VkBool32
    minQp*: int32
    maxQp*: int32
    prefersGopRemainingFrames*: VkBool32
    requiresGopRemainingFrames*: VkBool32
    stdSyntaxFlags*: VkVideoEncodeH264StdFlagsKHR

  VkVideoEncodeH264QualityLevelPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    preferredRateControlFlags*: VkVideoEncodeH264RateControlFlagsKHR
    preferredGopFrameCount*: uint32
    preferredIdrPeriod*: uint32
    preferredConsecutiveBFrameCount*: uint32
    preferredTemporalLayerCount*: uint32
    preferredConstantQp*: VkVideoEncodeH264QpKHR
    preferredMaxL0ReferenceCount*: uint32
    preferredMaxL1ReferenceCount*: uint32
    preferredStdEntropyCodingModeFlag*: VkBool32
  StdVideoEncodeH264SliceHeader* {.nodecl.} = object
  StdVideoEncodeH264PictureInfo* {.nodecl.} = object
  StdVideoEncodeH264ReferenceInfo* {.nodecl.} = object

  VkVideoEncodeH264SessionCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    useMaxLevelIdc*: VkBool32
    maxLevelIdc*: StdVideoH264LevelIdc

  VkVideoEncodeH264SessionParametersAddInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdSPSCount*: uint32
    pStdSPSs*: ptr StdVideoH264SequenceParameterSet
    stdPPSCount*: uint32
    pStdPPSs*: ptr StdVideoH264PictureParameterSet

  VkVideoEncodeH264SessionParametersCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxStdSPSCount*: uint32
    maxStdPPSCount*: uint32
    pParametersAddInfo*: ptr VkVideoEncodeH264SessionParametersAddInfoKHR

  VkVideoEncodeH264SessionParametersGetInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    writeStdSPS*: VkBool32
    writeStdPPS*: VkBool32
    stdSPSId*: uint32
    stdPPSId*: uint32

  VkVideoEncodeH264SessionParametersFeedbackInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    hasStdSPSOverrides*: VkBool32
    hasStdPPSOverrides*: VkBool32

  VkVideoEncodeH264DpbSlotInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdReferenceInfo*: ptr StdVideoEncodeH264ReferenceInfo

  VkVideoEncodeH264PictureInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    naluSliceEntryCount*: uint32
    pNaluSliceEntries*: ptr VkVideoEncodeH264NaluSliceInfoKHR
    pStdPictureInfo*: ptr StdVideoEncodeH264PictureInfo
    generatePrefixNalu*: VkBool32

  VkVideoEncodeH264ProfileInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdProfileIdc*: StdVideoH264ProfileIdc

  VkVideoEncodeH264NaluSliceInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    constantQp*: int32
    pStdSliceHeader*: ptr StdVideoEncodeH264SliceHeader

  VkVideoEncodeH264RateControlInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEncodeH264RateControlFlagsKHR
    gopFrameCount*: uint32
    idrPeriod*: uint32
    consecutiveBFrameCount*: uint32
    temporalLayerCount*: uint32

  VkVideoEncodeH264QpKHR* = object
    qpI*: int32
    qpP*: int32
    qpB*: int32

  VkVideoEncodeH264FrameSizeKHR* = object
    frameISize*: uint32
    framePSize*: uint32
    frameBSize*: uint32

  VkVideoEncodeH264GopRemainingFrameInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    useGopRemainingFrames*: VkBool32
    gopRemainingI*: uint32
    gopRemainingP*: uint32
    gopRemainingB*: uint32

  VkVideoEncodeH264RateControlLayerInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    useMinQp*: VkBool32
    minQp*: VkVideoEncodeH264QpKHR
    useMaxQp*: VkBool32
    maxQp*: VkVideoEncodeH264QpKHR
    useMaxFrameSize*: VkBool32
    maxFrameSize*: VkVideoEncodeH264FrameSizeKHR

  VkVideoEncodeH265CapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEncodeH265CapabilityFlagsKHR
    maxLevelIdc*: StdVideoH265LevelIdc
    maxSliceSegmentCount*: uint32
    maxTiles*: VkExtent2D
    ctbSizes*: VkVideoEncodeH265CtbSizeFlagsKHR
    transformBlockSizes*: VkVideoEncodeH265TransformBlockSizeFlagsKHR
    maxPPictureL0ReferenceCount*: uint32
    maxBPictureL0ReferenceCount*: uint32
    maxL1ReferenceCount*: uint32
    maxSubLayerCount*: uint32
    expectDyadicTemporalSubLayerPattern*: VkBool32
    minQp*: int32
    maxQp*: int32
    prefersGopRemainingFrames*: VkBool32
    requiresGopRemainingFrames*: VkBool32
    stdSyntaxFlags*: VkVideoEncodeH265StdFlagsKHR

  VkVideoEncodeH265QualityLevelPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    preferredRateControlFlags*: VkVideoEncodeH265RateControlFlagsKHR
    preferredGopFrameCount*: uint32
    preferredIdrPeriod*: uint32
    preferredConsecutiveBFrameCount*: uint32
    preferredSubLayerCount*: uint32
    preferredConstantQp*: VkVideoEncodeH265QpKHR
    preferredMaxL0ReferenceCount*: uint32
    preferredMaxL1ReferenceCount*: uint32
  StdVideoEncodeH265PictureInfo* {.nodecl.} = object
  StdVideoEncodeH265SliceSegmentHeader* {.nodecl.} = object
  StdVideoEncodeH265ReferenceInfo* {.nodecl.} = object

  VkVideoEncodeH265SessionCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    useMaxLevelIdc*: VkBool32
    maxLevelIdc*: StdVideoH265LevelIdc

  VkVideoEncodeH265SessionParametersAddInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdVPSCount*: uint32
    pStdVPSs*: ptr StdVideoH265VideoParameterSet
    stdSPSCount*: uint32
    pStdSPSs*: ptr StdVideoH265SequenceParameterSet
    stdPPSCount*: uint32
    pStdPPSs*: ptr StdVideoH265PictureParameterSet

  VkVideoEncodeH265SessionParametersCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    maxStdVPSCount*: uint32
    maxStdSPSCount*: uint32
    maxStdPPSCount*: uint32
    pParametersAddInfo*: ptr VkVideoEncodeH265SessionParametersAddInfoKHR

  VkVideoEncodeH265SessionParametersGetInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    writeStdVPS*: VkBool32
    writeStdSPS*: VkBool32
    writeStdPPS*: VkBool32
    stdVPSId*: uint32
    stdSPSId*: uint32
    stdPPSId*: uint32

  VkVideoEncodeH265SessionParametersFeedbackInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    hasStdVPSOverrides*: VkBool32
    hasStdSPSOverrides*: VkBool32
    hasStdPPSOverrides*: VkBool32

  VkVideoEncodeH265PictureInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    naluSliceSegmentEntryCount*: uint32
    pNaluSliceSegmentEntries*: ptr VkVideoEncodeH265NaluSliceSegmentInfoKHR
    pStdPictureInfo*: ptr StdVideoEncodeH265PictureInfo

  VkVideoEncodeH265NaluSliceSegmentInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    constantQp*: int32
    pStdSliceSegmentHeader*: ptr StdVideoEncodeH265SliceSegmentHeader

  VkVideoEncodeH265RateControlInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEncodeH265RateControlFlagsKHR
    gopFrameCount*: uint32
    idrPeriod*: uint32
    consecutiveBFrameCount*: uint32
    subLayerCount*: uint32

  VkVideoEncodeH265QpKHR* = object
    qpI*: int32
    qpP*: int32
    qpB*: int32

  VkVideoEncodeH265FrameSizeKHR* = object
    frameISize*: uint32
    framePSize*: uint32
    frameBSize*: uint32

  VkVideoEncodeH265GopRemainingFrameInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    useGopRemainingFrames*: VkBool32
    gopRemainingI*: uint32
    gopRemainingP*: uint32
    gopRemainingB*: uint32

  VkVideoEncodeH265RateControlLayerInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    useMinQp*: VkBool32
    minQp*: VkVideoEncodeH265QpKHR
    useMaxQp*: VkBool32
    maxQp*: VkVideoEncodeH265QpKHR
    useMaxFrameSize*: VkBool32
    maxFrameSize*: VkVideoEncodeH265FrameSizeKHR

  VkVideoEncodeH265ProfileInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdProfileIdc*: StdVideoH265ProfileIdc

  VkVideoEncodeH265DpbSlotInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdReferenceInfo*: ptr StdVideoEncodeH265ReferenceInfo

  VkVideoEncodeAV1CapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEncodeAV1CapabilityFlagsKHR
    maxLevel*: StdVideoAV1Level
    codedPictureAlignment*: VkExtent2D
    maxTiles*: VkExtent2D
    minTileSize*: VkExtent2D
    maxTileSize*: VkExtent2D
    superblockSizes*: VkVideoEncodeAV1SuperblockSizeFlagsKHR
    maxSingleReferenceCount*: uint32
    singleReferenceNameMask*: uint32
    maxUnidirectionalCompoundReferenceCount*: uint32
    maxUnidirectionalCompoundGroup1ReferenceCount*: uint32
    unidirectionalCompoundReferenceNameMask*: uint32
    maxBidirectionalCompoundReferenceCount*: uint32
    maxBidirectionalCompoundGroup1ReferenceCount*: uint32
    maxBidirectionalCompoundGroup2ReferenceCount*: uint32
    bidirectionalCompoundReferenceNameMask*: uint32
    maxTemporalLayerCount*: uint32
    maxSpatialLayerCount*: uint32
    maxOperatingPoints*: uint32
    minQIndex*: uint32
    maxQIndex*: uint32
    prefersGopRemainingFrames*: VkBool32
    requiresGopRemainingFrames*: VkBool32
    stdSyntaxFlags*: VkVideoEncodeAV1StdFlagsKHR

  VkVideoEncodeAV1QualityLevelPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    preferredRateControlFlags*: VkVideoEncodeAV1RateControlFlagsKHR
    preferredGopFrameCount*: uint32
    preferredKeyFramePeriod*: uint32
    preferredConsecutiveBipredictiveFrameCount*: uint32
    preferredTemporalLayerCount*: uint32
    preferredConstantQIndex*: VkVideoEncodeAV1QIndexKHR
    preferredMaxSingleReferenceCount*: uint32
    preferredSingleReferenceNameMask*: uint32
    preferredMaxUnidirectionalCompoundReferenceCount*: uint32
    preferredMaxUnidirectionalCompoundGroup1ReferenceCount*: uint32
    preferredUnidirectionalCompoundReferenceNameMask*: uint32
    preferredMaxBidirectionalCompoundReferenceCount*: uint32
    preferredMaxBidirectionalCompoundGroup1ReferenceCount*: uint32
    preferredMaxBidirectionalCompoundGroup2ReferenceCount*: uint32
    preferredBidirectionalCompoundReferenceNameMask*: uint32
  StdVideoEncodeAV1ExtensionHeader* {.nodecl.} = object
  StdVideoEncodeAV1DecoderModelInfo* {.nodecl.} = object
  StdVideoEncodeAV1OperatingPointInfo* {.nodecl.} = object
  StdVideoEncodeAV1PictureInfo* {.nodecl.} = object
  StdVideoEncodeAV1ReferenceInfo* {.nodecl.} = object

  VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoEncodeAV1*: VkBool32

  VkVideoEncodeAV1SessionCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    useMaxLevel*: VkBool32
    maxLevel*: StdVideoAV1Level

  VkVideoEncodeAV1SessionParametersCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdSequenceHeader*: ptr StdVideoAV1SequenceHeader
    pStdDecoderModelInfo*: ptr StdVideoEncodeAV1DecoderModelInfo
    stdOperatingPointCount*: uint32
    pStdOperatingPoints*: ptr StdVideoEncodeAV1OperatingPointInfo

  VkVideoEncodeAV1DpbSlotInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pStdReferenceInfo*: ptr StdVideoEncodeAV1ReferenceInfo

  VkVideoEncodeAV1PictureInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    predictionMode*: VkVideoEncodeAV1PredictionModeKHR
    rateControlGroup*: VkVideoEncodeAV1RateControlGroupKHR
    constantQIndex*: uint32
    pStdPictureInfo*: ptr StdVideoEncodeAV1PictureInfo
    referenceNameSlotIndices*: array[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR, int32]
    primaryReferenceCdfOnly*: VkBool32
    generateObuExtensionHeader*: VkBool32

  VkVideoEncodeAV1ProfileInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    stdProfile*: StdVideoAV1Profile

  VkVideoEncodeAV1RateControlInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkVideoEncodeAV1RateControlFlagsKHR
    gopFrameCount*: uint32
    keyFramePeriod*: uint32
    consecutiveBipredictiveFrameCount*: uint32
    temporalLayerCount*: uint32

  VkVideoEncodeAV1QIndexKHR* = object
    intraQIndex*: uint32
    predictiveQIndex*: uint32
    bipredictiveQIndex*: uint32

  VkVideoEncodeAV1FrameSizeKHR* = object
    intraFrameSize*: uint32
    predictiveFrameSize*: uint32
    bipredictiveFrameSize*: uint32

  VkVideoEncodeAV1GopRemainingFrameInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    useGopRemainingFrames*: VkBool32
    gopRemainingIntra*: uint32
    gopRemainingPredictive*: uint32
    gopRemainingBipredictive*: uint32

  VkVideoEncodeAV1RateControlLayerInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    useMinQIndex*: VkBool32
    minQIndex*: VkVideoEncodeAV1QIndexKHR
    useMaxQIndex*: VkBool32
    maxQIndex*: VkVideoEncodeAV1QIndexKHR
    useMaxFrameSize*: VkBool32
    maxFrameSize*: VkVideoEncodeAV1FrameSizeKHR

  VkPhysicalDeviceInheritedViewportScissorFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    inheritedViewportScissor2D*: VkBool32

  VkCommandBufferInheritanceViewportScissorInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    viewportScissor2D*: VkBool32
    viewportDepthCount*: uint32
    pViewportDepths*: ptr VkViewport

  VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    ycbcr2plane444Formats*: VkBool32

  VkPhysicalDeviceProvokingVertexFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    provokingVertexLast*: VkBool32
    transformFeedbackPreservesProvokingVertex*: VkBool32

  VkPhysicalDeviceProvokingVertexPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    provokingVertexModePerPipeline*: VkBool32
    transformFeedbackPreservesTriangleFanProvokingVertex*: VkBool32

  VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    provokingVertexMode*: VkProvokingVertexModeEXT

  VkVideoEncodeIntraRefreshCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    intraRefreshModes*: VkVideoEncodeIntraRefreshModeFlagsKHR
    maxIntraRefreshCycleDuration*: uint32
    maxIntraRefreshActiveReferencePictures*: uint32
    partitionIndependentIntraRefreshRegions*: VkBool32
    nonRectangularIntraRefreshRegions*: VkBool32

  VkVideoEncodeSessionIntraRefreshCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    intraRefreshMode*: VkVideoEncodeIntraRefreshModeFlagBitsKHR

  VkVideoEncodeIntraRefreshInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    intraRefreshCycleDuration*: uint32
    intraRefreshIndex*: uint32

  VkVideoReferenceIntraRefreshInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    dirtyIntraRefreshRegions*: uint32

  VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    videoEncodeIntraRefresh*: VkBool32

  VkCuModuleCreateInfoNVX* = object
    sType*: VkStructureType
    pNext*: pointer
    dataSize*: uint
    pData*: pointer

  VkCuModuleTexturingModeCreateInfoNVX* = object
    sType*: VkStructureType
    pNext*: pointer
    use64bitTexturing*: VkBool32

  VkCuFunctionCreateInfoNVX* = object
    sType*: VkStructureType
    pNext*: pointer
    module*: VkCuModuleNVX
    pName*: cstring

  VkCuLaunchInfoNVX* = object
    sType*: VkStructureType
    pNext*: pointer
    function*: VkCuFunctionNVX
    gridDimX*: uint32
    gridDimY*: uint32
    gridDimZ*: uint32
    blockDimX*: uint32
    blockDimY*: uint32
    blockDimZ*: uint32
    sharedMemBytes*: uint32
    paramCount*: uint
    pParams*: ptr pointer
    extraCount*: uint
    pExtras*: ptr pointer

  VkPhysicalDeviceDescriptorBufferFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorBuffer*: VkBool32
    descriptorBufferCaptureReplay*: VkBool32
    descriptorBufferImageLayoutIgnored*: VkBool32
    descriptorBufferPushDescriptors*: VkBool32

  VkPhysicalDeviceDescriptorBufferPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    combinedImageSamplerDescriptorSingleArray*: VkBool32
    bufferlessPushDescriptors*: VkBool32
    allowSamplerImageViewPostSubmitCreation*: VkBool32
    descriptorBufferOffsetAlignment*: VkDeviceSize
    maxDescriptorBufferBindings*: uint32
    maxResourceDescriptorBufferBindings*: uint32
    maxSamplerDescriptorBufferBindings*: uint32
    maxEmbeddedImmutableSamplerBindings*: uint32
    maxEmbeddedImmutableSamplers*: uint32
    bufferCaptureReplayDescriptorDataSize*: uint
    imageCaptureReplayDescriptorDataSize*: uint
    imageViewCaptureReplayDescriptorDataSize*: uint
    samplerCaptureReplayDescriptorDataSize*: uint
    accelerationStructureCaptureReplayDescriptorDataSize*: uint
    samplerDescriptorSize*: uint
    combinedImageSamplerDescriptorSize*: uint
    sampledImageDescriptorSize*: uint
    storageImageDescriptorSize*: uint
    uniformTexelBufferDescriptorSize*: uint
    robustUniformTexelBufferDescriptorSize*: uint
    storageTexelBufferDescriptorSize*: uint
    robustStorageTexelBufferDescriptorSize*: uint
    uniformBufferDescriptorSize*: uint
    robustUniformBufferDescriptorSize*: uint
    storageBufferDescriptorSize*: uint
    robustStorageBufferDescriptorSize*: uint
    inputAttachmentDescriptorSize*: uint
    accelerationStructureDescriptorSize*: uint
    maxSamplerDescriptorBufferRange*: VkDeviceSize
    maxResourceDescriptorBufferRange*: VkDeviceSize
    samplerDescriptorBufferAddressSpaceSize*: VkDeviceSize
    resourceDescriptorBufferAddressSpaceSize*: VkDeviceSize
    descriptorBufferAddressSpaceSize*: VkDeviceSize

  VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    combinedImageSamplerDensityMapDescriptorSize*: uint

  VkDescriptorAddressInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    address*: VkDeviceAddress
    range*: VkDeviceSize
    format*: VkFormat

  VkDescriptorBufferBindingInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    address*: VkDeviceAddress
    usage*: VkBufferUsageFlags

  VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    buffer*: VkBuffer

  VkDescriptorDataEXT* {.union.} = object
    pSampler*: ptr VkSampler
    pCombinedImageSampler*: ptr VkDescriptorImageInfo
    pInputAttachmentImage*: ptr VkDescriptorImageInfo
    pSampledImage*: ptr VkDescriptorImageInfo
    pStorageImage*: ptr VkDescriptorImageInfo
    pUniformTexelBuffer*: ptr VkDescriptorAddressInfoEXT
    pStorageTexelBuffer*: ptr VkDescriptorAddressInfoEXT
    pUniformBuffer*: ptr VkDescriptorAddressInfoEXT
    pStorageBuffer*: ptr VkDescriptorAddressInfoEXT
    accelerationStructure*: VkDeviceAddress

  VkDescriptorGetInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkDescriptorType
    data*: VkDescriptorDataEXT

  VkBufferCaptureDescriptorDataInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    buffer*: VkBuffer

  VkImageCaptureDescriptorDataInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    image*: VkImage

  VkImageViewCaptureDescriptorDataInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    imageView*: VkImageView

  VkSamplerCaptureDescriptorDataInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    sampler*: VkSampler

  VkAccelerationStructureCaptureDescriptorDataInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    accelerationStructure*: VkAccelerationStructureKHR
    accelerationStructureNV*: VkAccelerationStructureNV

  VkOpaqueCaptureDescriptorDataCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    opaqueCaptureDescriptorData*: pointer

  VkPhysicalDeviceShaderIntegerDotProductFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderIntegerDotProduct*: VkBool32

  VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR* = VkPhysicalDeviceShaderIntegerDotProductFeatures

  VkPhysicalDeviceShaderIntegerDotProductProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    integerDotProduct8BitUnsignedAccelerated*: VkBool32
    integerDotProduct8BitSignedAccelerated*: VkBool32
    integerDotProduct8BitMixedSignednessAccelerated*: VkBool32
    integerDotProduct4x8BitPackedUnsignedAccelerated*: VkBool32
    integerDotProduct4x8BitPackedSignedAccelerated*: VkBool32
    integerDotProduct4x8BitPackedMixedSignednessAccelerated*: VkBool32
    integerDotProduct16BitUnsignedAccelerated*: VkBool32
    integerDotProduct16BitSignedAccelerated*: VkBool32
    integerDotProduct16BitMixedSignednessAccelerated*: VkBool32
    integerDotProduct32BitUnsignedAccelerated*: VkBool32
    integerDotProduct32BitSignedAccelerated*: VkBool32
    integerDotProduct32BitMixedSignednessAccelerated*: VkBool32
    integerDotProduct64BitUnsignedAccelerated*: VkBool32
    integerDotProduct64BitSignedAccelerated*: VkBool32
    integerDotProduct64BitMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating8BitSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating16BitSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating32BitSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating64BitSignedAccelerated*: VkBool32
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated*: VkBool32

  VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR* = VkPhysicalDeviceShaderIntegerDotProductProperties

  VkPhysicalDeviceDrmPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    hasPrimary*: VkBool32
    hasRender*: VkBool32
    primaryMajor*: int64
    primaryMinor*: int64
    renderMajor*: int64
    renderMinor*: int64

  VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentShaderBarycentric*: VkBool32

  VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    triStripVertexOrderIndependentOfProvokingVertex*: VkBool32

  VkPhysicalDeviceShaderFmaFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderFmaFloat16*: VkBool32
    shaderFmaFloat32*: VkBool32
    shaderFmaFloat64*: VkBool32

  VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    rayTracingMotionBlur*: VkBool32
    rayTracingMotionBlurPipelineTraceRaysIndirect*: VkBool32

  VkPhysicalDeviceRayTracingValidationFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    rayTracingValidation*: VkBool32

  VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    spheres*: VkBool32
    linearSweptSpheres*: VkBool32

  VkAccelerationStructureGeometryMotionTrianglesDataNV* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexData*: VkDeviceOrHostAddressConstKHR

  VkAccelerationStructureMotionInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxInstances*: uint32
    flags*: VkAccelerationStructureMotionInfoFlagsNV

  VkSRTDataNV* = object
    sx*: float32
    a*: float32
    b*: float32
    pvx*: float32
    sy*: float32
    c*: float32
    pvy*: float32
    sz*: float32
    pvz*: float32
    qx*: float32
    qy*: float32
    qz*: float32
    qw*: float32
    tx*: float32
    ty*: float32
    tz*: float32

  VkAccelerationStructureSRTMotionInstanceNV* = object
    transformT0*: VkSRTDataNV
    transformT1*: VkSRTDataNV
    instanceCustomIndex*: uint32
    mask*: uint32
    instanceShaderBindingTableRecordOffset*: uint32
    flags*: VkGeometryInstanceFlagsKHR
    accelerationStructureReference*: uint64

  VkAccelerationStructureMatrixMotionInstanceNV* = object
    transformT0*: VkTransformMatrixKHR
    transformT1*: VkTransformMatrixKHR
    instanceCustomIndex*: uint32
    mask*: uint32
    instanceShaderBindingTableRecordOffset*: uint32
    flags*: VkGeometryInstanceFlagsKHR
    accelerationStructureReference*: uint64

  VkAccelerationStructureMotionInstanceDataNV* {.union.} = object
    staticInstance*: VkAccelerationStructureInstanceKHR
    matrixMotionInstance*: VkAccelerationStructureMatrixMotionInstanceNV
    srtMotionInstance*: VkAccelerationStructureSRTMotionInstanceNV

  VkAccelerationStructureMotionInstanceNV* = object
    `type`*: VkAccelerationStructureMotionInstanceTypeNV
    flags*: VkAccelerationStructureMotionInstanceFlagsNV
    data*: VkAccelerationStructureMotionInstanceDataNV
  VkRemoteAddressNV* = distinct pointer

  VkMemoryGetRemoteAddressInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory
    handleType*: VkExternalMemoryHandleTypeFlagBits

  VkImportMemoryBufferCollectionFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    collection*: VkBufferCollectionFUCHSIA
    index*: uint32

  VkBufferCollectionImageCreateInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    collection*: VkBufferCollectionFUCHSIA
    index*: uint32

  VkBufferCollectionBufferCreateInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    collection*: VkBufferCollectionFUCHSIA
    index*: uint32

  VkBufferCollectionCreateInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    collectionToken*: zx_handle_t

  VkBufferCollectionPropertiesFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryTypeBits*: uint32
    bufferCount*: uint32
    createInfoIndex*: uint32
    sysmemPixelFormat*: uint64
    formatFeatures*: VkFormatFeatureFlags
    sysmemColorSpaceIndex*: VkSysmemColorSpaceFUCHSIA
    samplerYcbcrConversionComponents*: VkComponentMapping
    suggestedYcbcrModel*: VkSamplerYcbcrModelConversion
    suggestedYcbcrRange*: VkSamplerYcbcrRange
    suggestedXChromaOffset*: VkChromaLocation
    suggestedYChromaOffset*: VkChromaLocation

  VkBufferConstraintsInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    createInfo*: VkBufferCreateInfo
    requiredFormatFeatures*: VkFormatFeatureFlags
    bufferCollectionConstraints*: VkBufferCollectionConstraintsInfoFUCHSIA

  VkSysmemColorSpaceFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    colorSpace*: uint32

  VkImageFormatConstraintsInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    imageCreateInfo*: VkImageCreateInfo
    requiredFormatFeatures*: VkFormatFeatureFlags
    flags*: VkImageFormatConstraintsFlagsFUCHSIA
    sysmemPixelFormat*: uint64
    colorSpaceCount*: uint32
    pColorSpaces*: ptr VkSysmemColorSpaceFUCHSIA

  VkImageConstraintsInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    formatConstraintsCount*: uint32
    pFormatConstraints*: ptr VkImageFormatConstraintsInfoFUCHSIA
    bufferCollectionConstraints*: VkBufferCollectionConstraintsInfoFUCHSIA
    flags*: VkImageConstraintsInfoFlagsFUCHSIA

  VkBufferCollectionConstraintsInfoFUCHSIA* = object
    sType*: VkStructureType
    pNext*: pointer
    minBufferCount*: uint32
    maxBufferCount*: uint32
    minBufferCountForCamping*: uint32
    minBufferCountForDedicatedSlack*: uint32
    minBufferCountForSharedSlack*: uint32
  VkCudaModuleNV* = distinct VkNonDispatchableHandle
  VkCudaFunctionNV* = distinct VkNonDispatchableHandle

  VkCudaModuleCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    dataSize*: uint
    pData*: pointer

  VkCudaFunctionCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    module*: VkCudaModuleNV
    pName*: cstring

  VkCudaLaunchInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    function*: VkCudaFunctionNV
    gridDimX*: uint32
    gridDimY*: uint32
    gridDimZ*: uint32
    blockDimX*: uint32
    blockDimY*: uint32
    blockDimZ*: uint32
    sharedMemBytes*: uint32
    paramCount*: uint
    pParams*: ptr pointer
    extraCount*: uint
    pExtras*: ptr pointer

  VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    formatRgba10x6WithoutYCbCrSampler*: VkBool32

  VkFormatProperties3* = object
    sType*: VkStructureType
    pNext*: pointer
    linearTilingFeatures*: VkFormatFeatureFlags2
    optimalTilingFeatures*: VkFormatFeatureFlags2
    bufferFeatures*: VkFormatFeatureFlags2

  VkFormatProperties3KHR* = VkFormatProperties3

  VkDrmFormatModifierPropertiesList2EXT* = object
    sType*: VkStructureType
    pNext*: pointer
    drmFormatModifierCount*: uint32
    pDrmFormatModifierProperties*: ptr VkDrmFormatModifierProperties2EXT

  VkDrmFormatModifierProperties2EXT* = object
    drmFormatModifier*: uint64
    drmFormatModifierPlaneCount*: uint32
    drmFormatModifierTilingFeatures*: VkFormatFeatureFlags2

  VkAndroidHardwareBufferFormatProperties2ANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat
    externalFormat*: uint64
    formatFeatures*: VkFormatFeatureFlags2
    samplerYcbcrConversionComponents*: VkComponentMapping
    suggestedYcbcrModel*: VkSamplerYcbcrModelConversion
    suggestedYcbcrRange*: VkSamplerYcbcrRange
    suggestedXChromaOffset*: VkChromaLocation
    suggestedYChromaOffset*: VkChromaLocation

  VkPipelineRenderingCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    viewMask*: uint32
    colorAttachmentCount*: uint32
    pColorAttachmentFormats*: ptr VkFormat
    depthAttachmentFormat*: VkFormat
    stencilAttachmentFormat*: VkFormat

  VkPipelineRenderingCreateInfoKHR* = VkPipelineRenderingCreateInfo

  VkRenderingInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkRenderingFlags
    renderArea*: VkRect2D
    layerCount*: uint32
    viewMask*: uint32
    colorAttachmentCount*: uint32
    pColorAttachments*: ptr VkRenderingAttachmentInfo
    pDepthAttachment*: ptr VkRenderingAttachmentInfo
    pStencilAttachment*: ptr VkRenderingAttachmentInfo

  VkRenderingInfoKHR* = VkRenderingInfo

  VkRenderingEndInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer

  VkRenderingEndInfoEXT* = VkRenderingEndInfoKHR

  VkRenderingAttachmentInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    imageView*: VkImageView
    imageLayout*: VkImageLayout
    resolveMode*: VkResolveModeFlagBits
    resolveImageView*: VkImageView
    resolveImageLayout*: VkImageLayout
    loadOp*: VkAttachmentLoadOp
    storeOp*: VkAttachmentStoreOp
    clearValue*: VkClearValue

  VkRenderingAttachmentInfoKHR* = VkRenderingAttachmentInfo

  VkRenderingFragmentShadingRateAttachmentInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    imageView*: VkImageView
    imageLayout*: VkImageLayout
    shadingRateAttachmentTexelSize*: VkExtent2D

  VkRenderingFragmentDensityMapAttachmentInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    imageView*: VkImageView
    imageLayout*: VkImageLayout

  VkPhysicalDeviceDynamicRenderingFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    dynamicRendering*: VkBool32

  VkPhysicalDeviceDynamicRenderingFeaturesKHR* = VkPhysicalDeviceDynamicRenderingFeatures

  VkCommandBufferInheritanceRenderingInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkRenderingFlags
    viewMask*: uint32
    colorAttachmentCount*: uint32
    pColorAttachmentFormats*: ptr VkFormat
    depthAttachmentFormat*: VkFormat
    stencilAttachmentFormat*: VkFormat
    rasterizationSamples*: VkSampleCountFlagBits

  VkCommandBufferInheritanceRenderingInfoKHR* = VkCommandBufferInheritanceRenderingInfo

  VkAttachmentSampleCountInfoAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    colorAttachmentCount*: uint32
    pColorAttachmentSamples*: ptr VkSampleCountFlagBits
    depthStencilAttachmentSamples*: VkSampleCountFlagBits

  VkAttachmentSampleCountInfoNV* = VkAttachmentSampleCountInfoAMD

  VkMultiviewPerViewAttributesInfoNVX* = object
    sType*: VkStructureType
    pNext*: pointer
    perViewAttributes*: VkBool32
    perViewAttributesPositionXOnly*: VkBool32

  VkPhysicalDeviceImageViewMinLodFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    minLod*: VkBool32

  VkImageViewMinLodCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    minLod*: float32

  VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    rasterizationOrderColorAttachmentAccess*: VkBool32
    rasterizationOrderDepthAttachmentAccess*: VkBool32
    rasterizationOrderStencilAttachmentAccess*: VkBool32

  VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM* = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT

  VkPhysicalDeviceLinearColorAttachmentFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    linearColorAttachment*: VkBool32

  VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    graphicsPipelineLibrary*: VkBool32

  VkPhysicalDevicePipelineBinaryFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineBinaries*: VkBool32

  VkDevicePipelineBinaryInternalCacheControlKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    disableInternalCache*: VkBool32

  VkPhysicalDevicePipelineBinaryPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineBinaryInternalCache*: VkBool32
    pipelineBinaryInternalCacheControl*: VkBool32
    pipelineBinaryPrefersInternalCache*: VkBool32
    pipelineBinaryPrecompiledInternalCache*: VkBool32
    pipelineBinaryCompressedData*: VkBool32

  VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    graphicsPipelineLibraryFastLinking*: VkBool32
    graphicsPipelineLibraryIndependentInterpolationDecoration*: VkBool32

  VkGraphicsPipelineLibraryCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkGraphicsPipelineLibraryFlagsEXT

  VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorSetHostMapping*: VkBool32

  VkDescriptorSetBindingReferenceVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorSetLayout*: VkDescriptorSetLayout
    binding*: uint32

  VkDescriptorSetLayoutHostMappingInfoVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorOffset*: uint
    descriptorSize*: uint32

  VkPhysicalDeviceNestedCommandBufferFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    nestedCommandBuffer*: VkBool32
    nestedCommandBufferRendering*: VkBool32
    nestedCommandBufferSimultaneousUse*: VkBool32

  VkPhysicalDeviceNestedCommandBufferPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxCommandBufferNestingLevel*: uint32

  VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderModuleIdentifier*: VkBool32

  VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderModuleIdentifierAlgorithmUUID*: array[VK_UUID_SIZE, uint8]

  VkPipelineShaderStageModuleIdentifierCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    identifierSize*: uint32
    pIdentifier*: ptr uint8

  VkShaderModuleIdentifierEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    identifierSize*: uint32
    identifier*: array[VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT, uint8]

  VkImageCompressionControlEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkImageCompressionFlagsEXT
    compressionControlPlaneCount*: uint32
    pFixedRateFlags*: ptr VkImageCompressionFixedRateFlagsEXT

  VkPhysicalDeviceImageCompressionControlFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    imageCompressionControl*: VkBool32

  VkImageCompressionPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    imageCompressionFlags*: VkImageCompressionFlagsEXT
    imageCompressionFixedRateFlags*: VkImageCompressionFixedRateFlagsEXT

  VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    imageCompressionControlSwapchain*: VkBool32

  VkImageSubresource2* = object
    sType*: VkStructureType
    pNext*: pointer
    imageSubresource*: VkImageSubresource

  VkImageSubresource2KHR* = VkImageSubresource2

  VkImageSubresource2EXT* = VkImageSubresource2

  VkSubresourceLayout2* = object
    sType*: VkStructureType
    pNext*: pointer
    subresourceLayout*: VkSubresourceLayout

  VkSubresourceLayout2KHR* = VkSubresourceLayout2

  VkSubresourceLayout2EXT* = VkSubresourceLayout2

  VkRenderPassCreationControlEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    disallowMerging*: VkBool32

  VkRenderPassCreationFeedbackInfoEXT* = object
    postMergeSubpassCount*: uint32

  VkRenderPassCreationFeedbackCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pRenderPassFeedback*: ptr VkRenderPassCreationFeedbackInfoEXT

  VkRenderPassSubpassFeedbackInfoEXT* = object
    subpassMergeStatus*: VkSubpassMergeStatusEXT
    description*: array[VK_MAX_DESCRIPTION_SIZE, char]
    postMergeIndex*: uint32

  VkRenderPassSubpassFeedbackCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pSubpassFeedback*: ptr VkRenderPassSubpassFeedbackInfoEXT

  VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    subpassMergeFeedback*: VkBool32

  VkMicromapBuildInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkMicromapTypeEXT
    flags*: VkBuildMicromapFlagsEXT
    mode*: VkBuildMicromapModeEXT
    dstMicromap*: VkMicromapEXT
    usageCountsCount*: uint32
    pUsageCounts*: ptr VkMicromapUsageEXT
    ppUsageCounts*: ptr ptr VkMicromapUsageEXT
    data*: VkDeviceOrHostAddressConstKHR
    scratchData*: VkDeviceOrHostAddressKHR
    triangleArray*: VkDeviceOrHostAddressConstKHR
    triangleArrayStride*: VkDeviceSize

  VkMicromapCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    createFlags*: VkMicromapCreateFlagsEXT
    buffer*: VkBuffer
    offset*: VkDeviceSize
    size*: VkDeviceSize
    `type`*: VkMicromapTypeEXT
    deviceAddress*: VkDeviceAddress

  VkMicromapVersionInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pVersionData*: ptr uint8

  VkCopyMicromapInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    src*: VkMicromapEXT
    dst*: VkMicromapEXT
    mode*: VkCopyMicromapModeEXT

  VkCopyMicromapToMemoryInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    src*: VkMicromapEXT
    dst*: VkDeviceOrHostAddressKHR
    mode*: VkCopyMicromapModeEXT

  VkCopyMemoryToMicromapInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    src*: VkDeviceOrHostAddressConstKHR
    dst*: VkMicromapEXT
    mode*: VkCopyMicromapModeEXT

  VkMicromapBuildSizesInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    micromapSize*: VkDeviceSize
    buildScratchSize*: VkDeviceSize
    discardable*: VkBool32

  VkMicromapUsageEXT* = object
    count*: uint32
    subdivisionLevel*: uint32
    format*: uint32

  VkMicromapTriangleEXT* = object
    dataOffset*: uint32
    subdivisionLevel*: uint16
    format*: uint16

  VkPhysicalDeviceOpacityMicromapFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    micromap*: VkBool32
    micromapCaptureReplay*: VkBool32
    micromapHostCommands*: VkBool32

  VkPhysicalDeviceOpacityMicromapPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxOpacity2StateSubdivisionLevel*: uint32
    maxOpacity4StateSubdivisionLevel*: uint32

  VkAccelerationStructureTrianglesOpacityMicromapEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    indexType*: VkIndexType
    indexBuffer*: VkDeviceOrHostAddressConstKHR
    indexStride*: VkDeviceSize
    baseTriangle*: uint32
    usageCountsCount*: uint32
    pUsageCounts*: ptr VkMicromapUsageEXT
    ppUsageCounts*: ptr ptr VkMicromapUsageEXT
    micromap*: VkMicromapEXT

  VkPhysicalDeviceDisplacementMicromapFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    displacementMicromap*: VkBool32

  VkPhysicalDeviceDisplacementMicromapPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    maxDisplacementMicromapSubdivisionLevel*: uint32

  VkAccelerationStructureTrianglesDisplacementMicromapNV* = object
    sType*: VkStructureType
    pNext*: pointer
    displacementBiasAndScaleFormat*: VkFormat
    displacementVectorFormat*: VkFormat
    displacementBiasAndScaleBuffer*: VkDeviceOrHostAddressConstKHR
    displacementBiasAndScaleStride*: VkDeviceSize
    displacementVectorBuffer*: VkDeviceOrHostAddressConstKHR
    displacementVectorStride*: VkDeviceSize
    displacedMicromapPrimitiveFlags*: VkDeviceOrHostAddressConstKHR
    displacedMicromapPrimitiveFlagsStride*: VkDeviceSize
    indexType*: VkIndexType
    indexBuffer*: VkDeviceOrHostAddressConstKHR
    indexStride*: VkDeviceSize
    baseTriangle*: uint32
    usageCountsCount*: uint32
    pUsageCounts*: ptr VkMicromapUsageEXT
    ppUsageCounts*: ptr ptr VkMicromapUsageEXT
    micromap*: VkMicromapEXT

  VkPipelinePropertiesIdentifierEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineIdentifier*: array[VK_UUID_SIZE, uint8]

  VkPhysicalDevicePipelinePropertiesFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelinePropertiesIdentifier*: VkBool32

  VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderEarlyAndLateFragmentTests*: VkBool32

  VkExternalMemoryAcquireUnmodifiedEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    acquireUnmodifiedMemory*: VkBool32

  VkExportMetalObjectCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    exportObjectType*: VkExportMetalObjectTypeFlagBitsEXT

  VkExportMetalObjectsInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer

  VkExportMetalDeviceInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    mtlDevice*: MTLDevice_id

  VkExportMetalCommandQueueInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    queue*: VkQueue
    mtlCommandQueue*: MTLCommandQueue_id

  VkExportMetalBufferInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory
    mtlBuffer*: MTLBuffer_id

  VkImportMetalBufferInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    mtlBuffer*: MTLBuffer_id

  VkExportMetalTextureInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    image*: VkImage
    imageView*: VkImageView
    bufferView*: VkBufferView
    plane*: VkImageAspectFlagBits
    mtlTexture*: MTLTexture_id

  VkImportMetalTextureInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    plane*: VkImageAspectFlagBits
    mtlTexture*: MTLTexture_id

  VkExportMetalIOSurfaceInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    image*: VkImage
    ioSurface*: IOSurfaceRef

  VkImportMetalIOSurfaceInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    ioSurface*: IOSurfaceRef

  VkExportMetalSharedEventInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    semaphore*: VkSemaphore
    event*: VkEvent
    mtlSharedEvent*: MTLSharedEvent_id

  VkImportMetalSharedEventInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    mtlSharedEvent*: MTLSharedEvent_id

  VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    nonSeamlessCubeMap*: VkBool32

  VkPhysicalDevicePipelineRobustnessFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineRobustness*: VkBool32

  VkPhysicalDevicePipelineRobustnessFeaturesEXT* = VkPhysicalDevicePipelineRobustnessFeatures

  VkPipelineRobustnessCreateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    storageBuffers*: VkPipelineRobustnessBufferBehavior
    uniformBuffers*: VkPipelineRobustnessBufferBehavior
    vertexInputs*: VkPipelineRobustnessBufferBehavior
    images*: VkPipelineRobustnessImageBehavior

  VkPipelineRobustnessCreateInfoEXT* = VkPipelineRobustnessCreateInfo

  VkPhysicalDevicePipelineRobustnessProperties* = object
    sType*: VkStructureType
    pNext*: pointer
    defaultRobustnessStorageBuffers*: VkPipelineRobustnessBufferBehavior
    defaultRobustnessUniformBuffers*: VkPipelineRobustnessBufferBehavior
    defaultRobustnessVertexInputs*: VkPipelineRobustnessBufferBehavior
    defaultRobustnessImages*: VkPipelineRobustnessImageBehavior

  VkPhysicalDevicePipelineRobustnessPropertiesEXT* = VkPhysicalDevicePipelineRobustnessProperties

  VkImageViewSampleWeightCreateInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    filterCenter*: VkOffset2D
    filterSize*: VkExtent2D
    numPhases*: uint32

  VkPhysicalDeviceImageProcessingFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    textureSampleWeighted*: VkBool32
    textureBoxFilter*: VkBool32
    textureBlockMatch*: VkBool32

  VkPhysicalDeviceImageProcessingPropertiesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    maxWeightFilterPhases*: uint32
    maxWeightFilterDimension*: VkExtent2D
    maxBlockMatchRegion*: VkExtent2D
    maxBoxFilterBlockSize*: VkExtent2D

  VkPhysicalDeviceTilePropertiesFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    tileProperties*: VkBool32

  VkTilePropertiesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    tileSize*: VkExtent3D
    apronSize*: VkExtent2D
    origin*: VkOffset2D

  VkTileMemoryBindInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory

  VkPhysicalDeviceAmigoProfilingFeaturesSEC* = object
    sType*: VkStructureType
    pNext*: pointer
    amigoProfiling*: VkBool32

  VkAmigoProfilingSubmitInfoSEC* = object
    sType*: VkStructureType
    pNext*: pointer
    firstDrawTimestamp*: uint64
    swapBufferTimestamp*: uint64

  VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    attachmentFeedbackLoopLayout*: VkBool32

  VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* = VkPhysicalDeviceDepthClampZeroOneFeaturesKHR

  VkAttachmentFeedbackLoopInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    feedbackLoopEnable*: VkBool32

  VkPhysicalDeviceAddressBindingReportFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    reportAddressBinding*: VkBool32

  VkRenderingAttachmentFlagsInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkRenderingAttachmentFlagsKHR

  VkResolveImageModeInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkResolveImageFlagsKHR
    resolveMode*: VkResolveModeFlagBits
    stencilResolveMode*: VkResolveModeFlagBits

  VkDeviceAddressBindingCallbackDataEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDeviceAddressBindingFlagsEXT
    baseAddress*: VkDeviceAddress
    size*: VkDeviceSize
    bindingType*: VkDeviceAddressBindingTypeEXT

  VkPhysicalDeviceOpticalFlowFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    opticalFlow*: VkBool32

  VkPhysicalDeviceOpticalFlowPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    supportedOutputGridSizes*: VkOpticalFlowGridSizeFlagsNV
    supportedHintGridSizes*: VkOpticalFlowGridSizeFlagsNV
    hintSupported*: VkBool32
    costSupported*: VkBool32
    bidirectionalFlowSupported*: VkBool32
    globalFlowSupported*: VkBool32
    minWidth*: uint32
    minHeight*: uint32
    maxWidth*: uint32
    maxHeight*: uint32
    maxNumRegionsOfInterest*: uint32

  VkOpticalFlowImageFormatInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    usage*: VkOpticalFlowUsageFlagsNV

  VkOpticalFlowImageFormatPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat

  VkOpticalFlowSessionCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    width*: uint32
    height*: uint32
    imageFormat*: VkFormat
    flowVectorFormat*: VkFormat
    costFormat*: VkFormat
    outputGridSize*: VkOpticalFlowGridSizeFlagsNV
    hintGridSize*: VkOpticalFlowGridSizeFlagsNV
    performanceLevel*: VkOpticalFlowPerformanceLevelNV
    flags*: VkOpticalFlowSessionCreateFlagsNV

  VkOpticalFlowSessionCreatePrivateDataInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    id*: uint32
    size*: uint32
    pPrivateData*: pointer

  VkOpticalFlowExecuteInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkOpticalFlowExecuteFlagsNV
    regionCount*: uint32
    pRegions*: ptr VkRect2D

  VkPhysicalDeviceFaultFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceFault*: VkBool32
    deviceFaultVendorBinary*: VkBool32

  VkDeviceFaultAddressInfoEXT* = object
    addressType*: VkDeviceFaultAddressTypeEXT
    reportedAddress*: VkDeviceAddress
    addressPrecision*: VkDeviceSize

  VkDeviceFaultVendorInfoEXT* = object
    description*: array[VK_MAX_DESCRIPTION_SIZE, char]
    vendorFaultCode*: uint64
    vendorFaultData*: uint64

  VkDeviceFaultCountsEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    addressInfoCount*: uint32
    vendorInfoCount*: uint32
    vendorBinarySize*: VkDeviceSize

  VkDeviceFaultInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    description*: array[VK_MAX_DESCRIPTION_SIZE, char]
    pAddressInfos*: ptr VkDeviceFaultAddressInfoEXT
    pVendorInfos*: ptr VkDeviceFaultVendorInfoEXT
    pVendorBinaryData*: pointer

  VkDeviceFaultVendorBinaryHeaderVersionOneEXT* = object
    headerSize*: uint32
    headerVersion*: VkDeviceFaultVendorBinaryHeaderVersionEXT
    vendorID*: uint32
    deviceID*: uint32
    driverVersion*: uint32
    pipelineCacheUUID*: array[VK_UUID_SIZE, uint8]
    applicationNameOffset*: uint32
    applicationVersion*: uint32
    engineNameOffset*: uint32
    engineVersion*: uint32
    apiVersion*: uint32

  VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineLibraryGroupHandles*: VkBool32

  VkDepthBiasInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    depthBiasConstantFactor*: float32
    depthBiasClamp*: float32
    depthBiasSlopeFactor*: float32

  VkDepthBiasRepresentationInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    depthBiasRepresentation*: VkDepthBiasRepresentationEXT
    depthBiasExact*: VkBool32

  VkDecompressMemoryRegionNV* = object
    srcAddress*: VkDeviceAddress
    dstAddress*: VkDeviceAddress
    compressedSize*: VkDeviceSize
    decompressedSize*: VkDeviceSize
    decompressionMethod*: VkMemoryDecompressionMethodFlagsNV

  VkDecompressMemoryRegionEXT* = object
    srcAddress*: VkDeviceAddress
    dstAddress*: VkDeviceAddress
    compressedSize*: VkDeviceSize
    decompressedSize*: VkDeviceSize

  VkDecompressMemoryInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    decompressionMethod*: VkMemoryDecompressionMethodFlagsEXT
    regionCount*: uint32
    pRegions*: ptr VkDecompressMemoryRegionEXT

  VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderCoreMask*: uint64
    shaderCoreCount*: uint32
    shaderWarpsPerCore*: uint32

  VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderCoreBuiltins*: VkBool32

  VkFrameBoundaryEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkFrameBoundaryFlagsEXT
    frameID*: uint64
    imageCount*: uint32
    pImages*: ptr VkImage
    bufferCount*: uint32
    pBuffers*: ptr VkBuffer
    tagName*: uint64
    tagSize*: uint
    pTag*: pointer

  VkPhysicalDeviceFrameBoundaryFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    frameBoundary*: VkBool32

  VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    dynamicRenderingUnusedAttachments*: VkBool32

  VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    internallySynchronizedQueues*: VkBool32

  VkSurfacePresentModeKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentMode*: VkPresentModeKHR

  VkSurfacePresentModeEXT* = VkSurfacePresentModeKHR

  VkSurfacePresentScalingCapabilitiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    supportedPresentScaling*: VkPresentScalingFlagsKHR
    supportedPresentGravityX*: VkPresentGravityFlagsKHR
    supportedPresentGravityY*: VkPresentGravityFlagsKHR
    minScaledImageExtent*: VkExtent2D
    maxScaledImageExtent*: VkExtent2D

  VkSurfacePresentScalingCapabilitiesEXT* = VkSurfacePresentScalingCapabilitiesKHR

  VkSurfacePresentModeCompatibilityKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentModeCount*: uint32
    pPresentModes*: ptr VkPresentModeKHR

  VkSurfacePresentModeCompatibilityEXT* = VkSurfacePresentModeCompatibilityKHR

  VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchainMaintenance1*: VkBool32

  VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* = VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR

  VkSwapchainPresentFenceInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchainCount*: uint32
    pFences*: ptr VkFence

  VkSwapchainPresentFenceInfoEXT* = VkSwapchainPresentFenceInfoKHR

  VkSwapchainPresentModesCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentModeCount*: uint32
    pPresentModes*: ptr VkPresentModeKHR

  VkSwapchainPresentModesCreateInfoEXT* = VkSwapchainPresentModesCreateInfoKHR

  VkSwapchainPresentModeInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchainCount*: uint32
    pPresentModes*: ptr VkPresentModeKHR

  VkSwapchainPresentModeInfoEXT* = VkSwapchainPresentModeInfoKHR

  VkSwapchainPresentScalingCreateInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    scalingBehavior*: VkPresentScalingFlagsKHR
    presentGravityX*: VkPresentGravityFlagsKHR
    presentGravityY*: VkPresentGravityFlagsKHR

  VkSwapchainPresentScalingCreateInfoEXT* = VkSwapchainPresentScalingCreateInfoKHR

  VkReleaseSwapchainImagesInfoKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    swapchain*: VkSwapchainKHR
    imageIndexCount*: uint32
    pImageIndices*: ptr uint32

  VkReleaseSwapchainImagesInfoEXT* = VkReleaseSwapchainImagesInfoKHR

  VkPhysicalDeviceDepthBiasControlFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    depthBiasControl*: VkBool32
    leastRepresentableValueForceUnormRepresentation*: VkBool32
    floatRepresentation*: VkBool32
    depthBiasExact*: VkBool32

  VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    rayTracingInvocationReorder*: VkBool32

  VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    rayTracingInvocationReorder*: VkBool32

  VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    rayTracingInvocationReorderReorderingHint*: VkRayTracingInvocationReorderModeEXT
    maxShaderBindingTableRecordIndex*: uint32

  VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    rayTracingInvocationReorderReorderingHint*: VkRayTracingInvocationReorderModeEXT

  VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    extendedSparseAddressSpace*: VkBool32

  VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    extendedSparseAddressSpaceSize*: VkDeviceSize
    extendedSparseImageUsageFlags*: VkImageUsageFlags
    extendedSparseBufferUsageFlags*: VkBufferUsageFlags

  VkDirectDriverLoadingInfoLUNARG* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDirectDriverLoadingFlagsLUNARG
    pfnGetInstanceProcAddr*: PFN_vkGetInstanceProcAddrLUNARG

  VkDirectDriverLoadingListLUNARG* = object
    sType*: VkStructureType
    pNext*: pointer
    mode*: VkDirectDriverLoadingModeLUNARG
    driverCount*: uint32
    pDrivers*: ptr VkDirectDriverLoadingInfoLUNARG

  VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    multiviewPerViewViewports*: VkBool32

  VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    rayTracingPositionFetch*: VkBool32

  VkDeviceImageSubresourceInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    pCreateInfo*: ptr VkImageCreateInfo
    pSubresource*: ptr VkImageSubresource2

  VkDeviceImageSubresourceInfoKHR* = VkDeviceImageSubresourceInfo

  VkPhysicalDeviceShaderCorePropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    pixelRate*: uint32
    texelRate*: uint32
    fmaRate*: uint32

  VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    multiviewPerViewRenderAreas*: VkBool32

  VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    perViewRenderAreaCount*: uint32
    pPerViewRenderAreas*: ptr VkRect2D

  VkQueryLowLatencySupportNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pQueriedLowLatencyData*: pointer

  VkMemoryMapInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkMemoryMapFlags
    memory*: VkDeviceMemory
    offset*: VkDeviceSize
    size*: VkDeviceSize

  VkMemoryMapInfoKHR* = VkMemoryMapInfo

  VkMemoryUnmapInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkMemoryUnmapFlags
    memory*: VkDeviceMemory

  VkMemoryUnmapInfoKHR* = VkMemoryUnmapInfo

  VkPhysicalDeviceShaderObjectFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderObject*: VkBool32

  VkPhysicalDeviceShaderObjectPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderBinaryUUID*: array[VK_UUID_SIZE, uint8]
    shaderBinaryVersion*: uint32

  VkShaderCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkShaderCreateFlagsEXT
    stage*: VkShaderStageFlagBits
    nextStage*: VkShaderStageFlags
    codeType*: VkShaderCodeTypeEXT
    codeSize*: uint
    pCode*: pointer
    pName*: cstring
    setLayoutCount*: uint32
    pSetLayouts*: ptr VkDescriptorSetLayout
    pushConstantRangeCount*: uint32
    pPushConstantRanges*: ptr VkPushConstantRange
    pSpecializationInfo*: ptr VkSpecializationInfo

  VkPhysicalDeviceShaderTileImageFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderTileImageColorReadAccess*: VkBool32
    shaderTileImageDepthReadAccess*: VkBool32
    shaderTileImageStencilReadAccess*: VkBool32

  VkPhysicalDeviceShaderTileImagePropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderTileImageCoherentReadAccelerated*: VkBool32
    shaderTileImageReadSampleFromPixelRateInvocation*: VkBool32
    shaderTileImageReadFromHelperInvocation*: VkBool32

  VkImportScreenBufferInfoQNX* = object
    sType*: VkStructureType
    pNext*: pointer
    buffer*: ptr screen_buffer

  VkScreenBufferPropertiesQNX* = object
    sType*: VkStructureType
    pNext*: pointer
    allocationSize*: VkDeviceSize
    memoryTypeBits*: uint32

  VkScreenBufferFormatPropertiesQNX* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat
    externalFormat*: uint64
    screenUsage*: uint64
    formatFeatures*: VkFormatFeatureFlags
    samplerYcbcrConversionComponents*: VkComponentMapping
    suggestedYcbcrModel*: VkSamplerYcbcrModelConversion
    suggestedYcbcrRange*: VkSamplerYcbcrRange
    suggestedXChromaOffset*: VkChromaLocation
    suggestedYChromaOffset*: VkChromaLocation

  VkExternalFormatQNX* = object
    sType*: VkStructureType
    pNext*: pointer
    externalFormat*: uint64

  VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX* = object
    sType*: VkStructureType
    pNext*: pointer
    screenBufferImport*: VkBool32

  VkPhysicalDeviceCooperativeMatrixFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    cooperativeMatrix*: VkBool32
    cooperativeMatrixRobustBufferAccess*: VkBool32

  VkCooperativeMatrixPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    MSize*: uint32
    NSize*: uint32
    KSize*: uint32
    AType*: VkComponentTypeKHR
    BType*: VkComponentTypeKHR
    CType*: VkComponentTypeKHR
    ResultType*: VkComponentTypeKHR
    saturatingAccumulation*: VkBool32
    scope*: VkScopeKHR

  VkPhysicalDeviceCooperativeMatrixPropertiesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    cooperativeMatrixSupportedStages*: VkShaderStageFlags

  VkPhysicalDeviceCooperativeMatrixConversionFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    cooperativeMatrixConversion*: VkBool32

  VkPhysicalDeviceShaderEnqueuePropertiesAMDX* = object
    sType*: VkStructureType
    pNext*: pointer
    maxExecutionGraphDepth*: uint32
    maxExecutionGraphShaderOutputNodes*: uint32
    maxExecutionGraphShaderPayloadSize*: uint32
    maxExecutionGraphShaderPayloadCount*: uint32
    executionGraphDispatchAddressAlignment*: uint32
    maxExecutionGraphWorkgroupCount*: array[3, uint32]
    maxExecutionGraphWorkgroups*: uint32

  VkPhysicalDeviceShaderEnqueueFeaturesAMDX* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderEnqueue*: VkBool32
    shaderMeshEnqueue*: VkBool32

  VkExecutionGraphPipelineCreateInfoAMDX* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCreateFlags
    stageCount*: uint32
    pStages*: ptr VkPipelineShaderStageCreateInfo
    pLibraryInfo*: ptr VkPipelineLibraryCreateInfoKHR
    layout*: VkPipelineLayout
    basePipelineHandle*: VkPipeline
    basePipelineIndex*: int32

  VkPipelineShaderStageNodeCreateInfoAMDX* = object
    sType*: VkStructureType
    pNext*: pointer
    pName*: cstring
    index*: uint32

  VkExecutionGraphPipelineScratchSizeAMDX* = object
    sType*: VkStructureType
    pNext*: pointer
    minSize*: VkDeviceSize
    maxSize*: VkDeviceSize
    sizeGranularity*: VkDeviceSize

  VkDispatchGraphInfoAMDX* = object
    nodeIndex*: uint32
    payloadCount*: uint32
    payloads*: VkDeviceOrHostAddressConstAMDX
    payloadStride*: uint64

  VkDispatchGraphCountInfoAMDX* = object
    count*: uint32
    infos*: VkDeviceOrHostAddressConstAMDX
    stride*: uint64

  VkPhysicalDeviceAntiLagFeaturesAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    antiLag*: VkBool32

  VkAntiLagDataAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    mode*: VkAntiLagModeAMD
    maxFPS*: uint32
    pPresentationInfo*: ptr VkAntiLagPresentationInfoAMD

  VkAntiLagPresentationInfoAMD* = object
    sType*: VkStructureType
    pNext*: pointer
    stage*: VkAntiLagStageAMD
    frameIndex*: uint64

  VkBindMemoryStatus* = object
    sType*: VkStructureType
    pNext*: pointer
    pResult*: ptr VkResult

  VkPhysicalDeviceTileMemoryHeapFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    tileMemoryHeap*: VkBool32

  VkPhysicalDeviceTileMemoryHeapPropertiesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    queueSubmitBoundary*: VkBool32
    tileBufferTransfers*: VkBool32

  VkTileMemorySizeInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    size*: VkDeviceSize

  VkTileMemoryRequirementsQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    size*: VkDeviceSize
    alignment*: VkDeviceSize

  VkBindMemoryStatusKHR* = VkBindMemoryStatus

  VkBindDescriptorSetsInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    stageFlags*: VkShaderStageFlags
    layout*: VkPipelineLayout
    firstSet*: uint32
    descriptorSetCount*: uint32
    pDescriptorSets*: ptr VkDescriptorSet
    dynamicOffsetCount*: uint32
    pDynamicOffsets*: ptr uint32

  VkBindDescriptorSetsInfoKHR* = VkBindDescriptorSetsInfo

  VkPushConstantsInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    layout*: VkPipelineLayout
    stageFlags*: VkShaderStageFlags
    offset*: uint32
    size*: uint32
    pValues*: pointer

  VkPushConstantsInfoKHR* = VkPushConstantsInfo

  VkPushDescriptorSetInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    stageFlags*: VkShaderStageFlags
    layout*: VkPipelineLayout
    set*: uint32
    descriptorWriteCount*: uint32
    pDescriptorWrites*: ptr VkWriteDescriptorSet

  VkPushDescriptorSetInfoKHR* = VkPushDescriptorSetInfo

  VkPushDescriptorSetWithTemplateInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorUpdateTemplate*: VkDescriptorUpdateTemplate
    layout*: VkPipelineLayout
    set*: uint32
    pData*: pointer

  VkPushDescriptorSetWithTemplateInfoKHR* = VkPushDescriptorSetWithTemplateInfo

  VkSetDescriptorBufferOffsetsInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    stageFlags*: VkShaderStageFlags
    layout*: VkPipelineLayout
    firstSet*: uint32
    setCount*: uint32
    pBufferIndices*: ptr uint32
    pOffsets*: ptr VkDeviceSize

  VkBindDescriptorBufferEmbeddedSamplersInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    stageFlags*: VkShaderStageFlags
    layout*: VkPipelineLayout
    set*: uint32

  VkPhysicalDeviceCubicClampFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    cubicRangeClamp*: VkBool32

  VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    ycbcrDegamma*: VkBool32

  VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    enableYDegamma*: VkBool32
    enableCbCrDegamma*: VkBool32

  VkPhysicalDeviceCubicWeightsFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    selectableCubicWeights*: VkBool32

  VkSamplerCubicWeightsCreateInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    cubicWeights*: VkCubicFilterWeightsQCOM

  VkBlitImageCubicWeightsInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    cubicWeights*: VkCubicFilterWeightsQCOM

  VkPhysicalDeviceImageProcessing2FeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    textureBlockMatch2*: VkBool32

  VkPhysicalDeviceImageProcessing2PropertiesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    maxBlockMatchWindow*: VkExtent2D

  VkSamplerBlockMatchWindowCreateInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    windowExtent*: VkExtent2D
    windowCompareMode*: VkBlockMatchWindowCompareModeQCOM

  VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorPoolOverallocation*: VkBool32

  VkPhysicalDeviceLayeredDriverPropertiesMSFT* = object
    sType*: VkStructureType
    pNext*: pointer
    underlyingAPI*: VkLayeredDriverUnderlyingApiMSFT

  VkPhysicalDevicePerStageDescriptorSetFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    perStageDescriptorSet*: VkBool32
    dynamicPipelineLayout*: VkBool32

  VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    externalFormatResolve*: VkBool32

  VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    nullColorAttachmentWithExternalFormatResolve*: VkBool32
    externalFormatResolveChromaOffsetX*: VkChromaLocation
    externalFormatResolveChromaOffsetY*: VkChromaLocation

  VkAndroidHardwareBufferFormatResolvePropertiesANDROID* = object
    sType*: VkStructureType
    pNext*: pointer
    colorAttachmentFormat*: VkFormat

  VkLatencySleepModeInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    lowLatencyMode*: VkBool32
    lowLatencyBoost*: VkBool32
    minimumIntervalUs*: uint32

  VkLatencySleepInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    signalSemaphore*: VkSemaphore
    value*: uint64

  VkSetLatencyMarkerInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    presentID*: uint64
    marker*: VkLatencyMarkerNV

  VkGetLatencyMarkerInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    timingCount*: uint32
    pTimings*: ptr VkLatencyTimingsFrameReportNV

  VkLatencyTimingsFrameReportNV* = object
    sType*: VkStructureType
    pNext*: pointer
    presentID*: uint64
    inputSampleTimeUs*: uint64
    simStartTimeUs*: uint64
    simEndTimeUs*: uint64
    renderSubmitStartTimeUs*: uint64
    renderSubmitEndTimeUs*: uint64
    presentStartTimeUs*: uint64
    presentEndTimeUs*: uint64
    driverStartTimeUs*: uint64
    driverEndTimeUs*: uint64
    osRenderQueueStartTimeUs*: uint64
    osRenderQueueEndTimeUs*: uint64
    gpuRenderStartTimeUs*: uint64
    gpuRenderEndTimeUs*: uint64

  VkOutOfBandQueueTypeInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    queueType*: VkOutOfBandQueueTypeNV

  VkLatencySubmissionPresentIdNV* = object
    sType*: VkStructureType
    pNext*: pointer
    presentID*: uint64

  VkSwapchainLatencyCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    latencyModeEnable*: VkBool32

  VkLatencySurfaceCapabilitiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    presentModeCount*: uint32
    pPresentModes*: ptr VkPresentModeKHR

  VkPhysicalDeviceCudaKernelLaunchFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    cudaKernelLaunchFeatures*: VkBool32

  VkPhysicalDeviceCudaKernelLaunchPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    computeCapabilityMinor*: uint32
    computeCapabilityMajor*: uint32

  VkDeviceQueueShaderCoreControlCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderCoreCount*: uint32

  VkPhysicalDeviceSchedulingControlsFeaturesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    schedulingControls*: VkBool32

  VkPhysicalDeviceSchedulingControlsPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    schedulingControlsFlags*: VkPhysicalDeviceSchedulingControlsFlagsARM

  VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* = object
    sType*: VkStructureType
    pNext*: pointer
    relaxedLineRasterization*: VkBool32

  VkPhysicalDeviceRenderPassStripedFeaturesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    renderPassStriped*: VkBool32

  VkPhysicalDeviceRenderPassStripedPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    renderPassStripeGranularity*: VkExtent2D
    maxRenderPassStripes*: uint32

  VkRenderPassStripeInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    stripeArea*: VkRect2D

  VkRenderPassStripeBeginInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    stripeInfoCount*: uint32
    pStripeInfos*: ptr VkRenderPassStripeInfoARM

  VkRenderPassStripeSubmitInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    stripeSemaphoreInfoCount*: uint32
    pStripeSemaphoreInfos*: ptr VkSemaphoreSubmitInfo

  VkPhysicalDevicePipelineOpacityMicromapFeaturesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineOpacityMicromap*: VkBool32

  VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderMaximalReconvergence*: VkBool32

  VkPhysicalDeviceShaderSubgroupRotateFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderSubgroupRotate*: VkBool32
    shaderSubgroupRotateClustered*: VkBool32

  VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR* = VkPhysicalDeviceShaderSubgroupRotateFeatures

  VkPhysicalDeviceShaderExpectAssumeFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderExpectAssume*: VkBool32

  VkPhysicalDeviceShaderExpectAssumeFeaturesKHR* = VkPhysicalDeviceShaderExpectAssumeFeatures

  VkPhysicalDeviceShaderFloatControls2Features* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderFloatControls2*: VkBool32

  VkPhysicalDeviceShaderFloatControls2FeaturesKHR* = VkPhysicalDeviceShaderFloatControls2Features

  VkPhysicalDeviceDynamicRenderingLocalReadFeatures* = object
    sType*: VkStructureType
    pNext*: pointer
    dynamicRenderingLocalRead*: VkBool32

  VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR* = VkPhysicalDeviceDynamicRenderingLocalReadFeatures

  VkRenderingAttachmentLocationInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    colorAttachmentCount*: uint32
    pColorAttachmentLocations*: ptr uint32

  VkRenderingAttachmentLocationInfoKHR* = VkRenderingAttachmentLocationInfo

  VkRenderingInputAttachmentIndexInfo* = object
    sType*: VkStructureType
    pNext*: pointer
    colorAttachmentCount*: uint32
    pColorAttachmentInputIndices*: ptr uint32
    pDepthInputAttachmentIndex*: ptr uint32
    pStencilInputAttachmentIndex*: ptr uint32

  VkRenderingInputAttachmentIndexInfoKHR* = VkRenderingInputAttachmentIndexInfo

  VkPhysicalDeviceShaderQuadControlFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderQuadControl*: VkBool32

  VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderFloat16VectorAtomics*: VkBool32

  VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    memoryMapPlaced*: VkBool32
    memoryMapRangePlaced*: VkBool32
    memoryUnmapReserve*: VkBool32

  VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    minPlacedMemoryMapAlignment*: VkDeviceSize

  VkMemoryMapPlacedInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pPlacedAddress*: pointer

  VkPhysicalDeviceShaderBfloat16FeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderBFloat16Type*: VkBool32
    shaderBFloat16DotProduct*: VkBool32
    shaderBFloat16CooperativeMatrix*: VkBool32

  VkPhysicalDeviceRawAccessChainsFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderRawAccessChains*: VkBool32

  VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    commandBufferInheritance*: VkBool32

  VkPhysicalDeviceImageAlignmentControlFeaturesMESA* = object
    sType*: VkStructureType
    pNext*: pointer
    imageAlignmentControl*: VkBool32

  VkPhysicalDeviceImageAlignmentControlPropertiesMESA* = object
    sType*: VkStructureType
    pNext*: pointer
    supportedImageAlignmentMask*: uint32

  VkImageAlignmentControlCreateInfoMESA* = object
    sType*: VkStructureType
    pNext*: pointer
    maximumRequestedAlignment*: uint32

  VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderReplicatedComposites*: VkBool32

  VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT* = VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR

  VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    presentModeFifoLatestReady*: VkBool32

  VkDepthClampRangeEXT* = object
    minDepthClamp*: float32
    maxDepthClamp*: float32

  VkPhysicalDeviceCooperativeMatrix2FeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    cooperativeMatrixWorkgroupScope*: VkBool32
    cooperativeMatrixFlexibleDimensions*: VkBool32
    cooperativeMatrixReductions*: VkBool32
    cooperativeMatrixConversions*: VkBool32
    cooperativeMatrixPerElementOperations*: VkBool32
    cooperativeMatrixTensorAddressing*: VkBool32
    cooperativeMatrixBlockLoads*: VkBool32

  VkPhysicalDeviceCooperativeMatrix2PropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    cooperativeMatrixWorkgroupScopeMaxWorkgroupSize*: uint32
    cooperativeMatrixFlexibleDimensionsMaxDimension*: uint32
    cooperativeMatrixWorkgroupScopeReservedSharedMemory*: uint32

  VkCooperativeMatrixFlexibleDimensionsPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    MGranularity*: uint32
    NGranularity*: uint32
    KGranularity*: uint32
    AType*: VkComponentTypeKHR
    BType*: VkComponentTypeKHR
    CType*: VkComponentTypeKHR
    ResultType*: VkComponentTypeKHR
    saturatingAccumulation*: VkBool32
    scope*: VkScopeKHR
    workgroupInvocations*: uint32

  VkPhysicalDeviceHdrVividFeaturesHUAWEI* = object
    sType*: VkStructureType
    pNext*: pointer
    hdrVivid*: VkBool32

  VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    vertexAttributeRobustness*: VkBool32

  VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX* = object
    sType*: VkStructureType
    pNext*: pointer
    denseGeometryFormat*: VkBool32

  VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX* = object
    sType*: VkStructureType
    pNext*: pointer
    compressedData*: VkDeviceOrHostAddressConstKHR
    dataSize*: VkDeviceSize
    numTriangles*: uint32
    numVertices*: uint32
    maxPrimitiveIndex*: uint32
    maxGeometryIndex*: uint32
    format*: VkCompressedTriangleFormatAMDX

  VkPhysicalDeviceDepthClampZeroOneFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    depthClampZeroOne*: VkBool32

  VkPhysicalDeviceCooperativeVectorFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    cooperativeVector*: VkBool32
    cooperativeVectorTraining*: VkBool32

  VkCooperativeVectorPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    inputType*: VkComponentTypeKHR
    inputInterpretation*: VkComponentTypeKHR
    matrixInterpretation*: VkComponentTypeKHR
    biasInterpretation*: VkComponentTypeKHR
    resultType*: VkComponentTypeKHR
    transpose*: VkBool32

  VkPhysicalDeviceCooperativeVectorPropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    cooperativeVectorSupportedStages*: VkShaderStageFlags
    cooperativeVectorTrainingFloat16Accumulation*: VkBool32
    cooperativeVectorTrainingFloat32Accumulation*: VkBool32
    maxCooperativeVectorComponents*: uint32

  VkConvertCooperativeVectorMatrixInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    srcSize*: uint
    srcData*: VkDeviceOrHostAddressConstKHR
    pDstSize*: ptr uint
    dstData*: VkDeviceOrHostAddressKHR
    srcComponentType*: VkComponentTypeKHR
    dstComponentType*: VkComponentTypeKHR
    numRows*: uint32
    numColumns*: uint32
    srcLayout*: VkCooperativeVectorMatrixLayoutNV
    srcStride*: uint
    dstLayout*: VkCooperativeVectorMatrixLayoutNV
    dstStride*: uint

  VkPhysicalDeviceTileShadingFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    tileShading*: VkBool32
    tileShadingFragmentStage*: VkBool32
    tileShadingColorAttachments*: VkBool32
    tileShadingDepthAttachments*: VkBool32
    tileShadingStencilAttachments*: VkBool32
    tileShadingInputAttachments*: VkBool32
    tileShadingSampledAttachments*: VkBool32
    tileShadingPerTileDraw*: VkBool32
    tileShadingPerTileDispatch*: VkBool32
    tileShadingDispatchTile*: VkBool32
    tileShadingApron*: VkBool32
    tileShadingAnisotropicApron*: VkBool32
    tileShadingAtomicOps*: VkBool32
    tileShadingImageProcessing*: VkBool32

  VkPhysicalDeviceTileShadingPropertiesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    maxApronSize*: uint32
    preferNonCoherent*: VkBool32
    tileGranularity*: VkExtent2D
    maxTileShadingRate*: VkExtent2D

  VkRenderPassTileShadingCreateInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkTileShadingRenderPassFlagsQCOM
    tileApronSize*: VkExtent2D

  VkPerTileBeginInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer

  VkPerTileEndInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer

  VkDispatchTileInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer

  VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    maxFragmentDensityMapLayers*: uint32

  VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    fragmentDensityMapLayered*: VkBool32

  VkPipelineFragmentDensityMapLayeredCreateInfoVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    maxFragmentDensityMapLayers*: uint32

  VkSetPresentConfigNV* = object
    sType*: VkStructureType
    pNext*: pointer
    numFramesPerBatch*: uint32
    presentConfigFeedback*: uint32

  VkPhysicalDevicePresentMeteringFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    presentMetering*: VkBool32

  VkExternalComputeQueueDeviceCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    reservedExternalQueues*: uint32

  VkExternalComputeQueueCreateInfoNV* = object
    sType*: VkStructureType
    pNext*: pointer
    preferredQueue*: VkQueue

  VkExternalComputeQueueDataParamsNV* = object
    sType*: VkStructureType
    pNext*: pointer
    deviceIndex*: uint32

  VkPhysicalDeviceExternalComputeQueuePropertiesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    externalDataSize*: uint32
    maxExternalQueues*: uint32
  VkExternalComputeQueueNV* = distinct VkHandle

  VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderUniformBufferUnsizedArray*: VkBool32

  VkPhysicalDeviceShaderMixedFloatDotProductFeaturesVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderMixedFloatDotProductFloat16AccFloat32*: VkBool32
    shaderMixedFloatDotProductFloat16AccFloat16*: VkBool32
    shaderMixedFloatDotProductBFloat16Acc*: VkBool32
    shaderMixedFloatDotProductFloat8AccFloat32*: VkBool32

  VkPhysicalDeviceFormatPackFeaturesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    formatPack*: VkBool32

  VkTensorDescriptionARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tiling*: VkTensorTilingARM
    format*: VkFormat
    dimensionCount*: uint32
    pDimensions*: ptr int64
    pStrides*: ptr int64
    usage*: VkTensorUsageFlagsARM

  VkTensorCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkTensorCreateFlagsARM
    pDescription*: ptr VkTensorDescriptionARM
    sharingMode*: VkSharingMode
    queueFamilyIndexCount*: uint32
    pQueueFamilyIndices*: ptr uint32

  VkTensorViewCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkTensorViewCreateFlagsARM
    tensor*: VkTensorARM
    format*: VkFormat

  VkTensorMemoryRequirementsInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensor*: VkTensorARM

  VkBindTensorMemoryInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensor*: VkTensorARM
    memory*: VkDeviceMemory
    memoryOffset*: VkDeviceSize

  VkWriteDescriptorSetTensorARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensorViewCount*: uint32
    pTensorViews*: ptr VkTensorViewARM

  VkTensorFormatPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    optimalTilingTensorFeatures*: VkFormatFeatureFlags2
    linearTilingTensorFeatures*: VkFormatFeatureFlags2

  VkPhysicalDeviceTensorPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    maxTensorDimensionCount*: uint32
    maxTensorElements*: uint64
    maxPerDimensionTensorElements*: uint64
    maxTensorStride*: int64
    maxTensorSize*: uint64
    maxTensorShaderAccessArrayLength*: uint32
    maxTensorShaderAccessSize*: uint32
    maxDescriptorSetStorageTensors*: uint32
    maxPerStageDescriptorSetStorageTensors*: uint32
    maxDescriptorSetUpdateAfterBindStorageTensors*: uint32
    maxPerStageDescriptorUpdateAfterBindStorageTensors*: uint32
    shaderStorageTensorArrayNonUniformIndexingNative*: VkBool32
    shaderTensorSupportedStages*: VkShaderStageFlags

  VkTensorMemoryBarrierARM* = object
    sType*: VkStructureType
    pNext*: pointer
    srcStageMask*: VkPipelineStageFlags2
    srcAccessMask*: VkAccessFlags2
    dstStageMask*: VkPipelineStageFlags2
    dstAccessMask*: VkAccessFlags2
    srcQueueFamilyIndex*: uint32
    dstQueueFamilyIndex*: uint32
    tensor*: VkTensorARM

  VkTensorDependencyInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensorMemoryBarrierCount*: uint32
    pTensorMemoryBarriers*: ptr VkTensorMemoryBarrierARM

  VkPhysicalDeviceTensorFeaturesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensorNonPacked*: VkBool32
    shaderTensorAccess*: VkBool32
    shaderStorageTensorArrayDynamicIndexing*: VkBool32
    shaderStorageTensorArrayNonUniformIndexing*: VkBool32
    descriptorBindingStorageTensorUpdateAfterBind*: VkBool32
    tensors*: VkBool32

  VkDeviceTensorMemoryRequirementsARM* = object
    sType*: VkStructureType
    pNext*: pointer
    pCreateInfo*: ptr VkTensorCreateInfoARM

  VkCopyTensorInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    srcTensor*: VkTensorARM
    dstTensor*: VkTensorARM
    regionCount*: uint32
    pRegions*: ptr VkTensorCopyARM

  VkTensorCopyARM* = object
    sType*: VkStructureType
    pNext*: pointer
    dimensionCount*: uint32
    pSrcOffset*: ptr uint64
    pDstOffset*: ptr uint64
    pExtent*: ptr uint64

  VkMemoryDedicatedAllocateInfoTensorARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensor*: VkTensorARM

  VkPhysicalDeviceDescriptorBufferTensorPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensorCaptureReplayDescriptorDataSize*: uint
    tensorViewCaptureReplayDescriptorDataSize*: uint
    tensorDescriptorSize*: uint

  VkPhysicalDeviceDescriptorBufferTensorFeaturesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorBufferTensorDescriptors*: VkBool32

  VkTensorCaptureDescriptorDataInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensor*: VkTensorARM

  VkTensorViewCaptureDescriptorDataInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensorView*: VkTensorViewARM

  VkDescriptorGetTensorInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensorView*: VkTensorViewARM

  VkFrameBoundaryTensorsARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensorCount*: uint32
    pTensors*: ptr VkTensorARM

  VkPhysicalDeviceExternalTensorInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkTensorCreateFlagsARM
    pDescription*: ptr VkTensorDescriptionARM
    handleType*: VkExternalMemoryHandleTypeFlagBits

  VkExternalTensorPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    externalMemoryProperties*: VkExternalMemoryProperties

  VkExternalMemoryTensorCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    handleTypes*: VkExternalMemoryHandleTypeFlags

  VkPhysicalDeviceShaderFloat8FeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderFloat8*: VkBool32
    shaderFloat8CooperativeMatrix*: VkBool32

  VkSurfaceCreateInfoOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkSurfaceCreateFlagsOHOS
    window*: ptr OHNativeWindow

  VkPhysicalDeviceDataGraphFeaturesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    dataGraph*: VkBool32
    dataGraphUpdateAfterBind*: VkBool32
    dataGraphSpecializationConstants*: VkBool32
    dataGraphDescriptorBuffer*: VkBool32
    dataGraphShaderModule*: VkBool32

  VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    dimension*: uint32
    zeroCount*: uint32
    groupSize*: uint32

  VkDataGraphPipelineConstantARM* = object
    sType*: VkStructureType
    pNext*: pointer
    id*: uint32
    pConstantData*: pointer

  VkDataGraphPipelineResourceInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorSet*: uint32
    binding*: uint32
    arrayElement*: uint32

  VkDataGraphPipelineCompilerControlCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    pVendorOptions*: cstring

  VkDataGraphPipelineCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPipelineCreateFlags2KHR
    layout*: VkPipelineLayout
    resourceInfoCount*: uint32
    pResourceInfos*: ptr VkDataGraphPipelineResourceInfoARM

  VkDataGraphPipelineShaderModuleCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    module*: VkShaderModule
    pName*: cstring
    pSpecializationInfo*: ptr VkSpecializationInfo
    constantCount*: uint32
    pConstants*: ptr VkDataGraphPipelineConstantARM

  VkDataGraphPipelineSessionCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDataGraphPipelineSessionCreateFlagsARM
    dataGraphPipeline*: VkPipeline

  VkDataGraphPipelineSessionBindPointRequirementsInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    session*: VkDataGraphPipelineSessionARM

  VkDataGraphPipelineSessionBindPointRequirementARM* = object
    sType*: VkStructureType
    pNext*: pointer
    bindPoint*: VkDataGraphPipelineSessionBindPointARM
    bindPointType*: VkDataGraphPipelineSessionBindPointTypeARM
    numObjects*: uint32

  VkDataGraphPipelineSessionMemoryRequirementsInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    session*: VkDataGraphPipelineSessionARM
    bindPoint*: VkDataGraphPipelineSessionBindPointARM
    objectIndex*: uint32

  VkBindDataGraphPipelineSessionMemoryInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    session*: VkDataGraphPipelineSessionARM
    bindPoint*: VkDataGraphPipelineSessionBindPointARM
    objectIndex*: uint32
    memory*: VkDeviceMemory
    memoryOffset*: VkDeviceSize

  VkDataGraphPipelineInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    dataGraphPipeline*: VkPipeline

  VkDataGraphPipelinePropertyQueryResultARM* = object
    sType*: VkStructureType
    pNext*: pointer
    property*: VkDataGraphPipelinePropertyARM
    isText*: VkBool32
    dataSize*: uint
    pData*: pointer

  VkDataGraphPipelineIdentifierCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    identifierSize*: uint32
    pIdentifier*: ptr uint8

  VkDataGraphPipelineDispatchInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkDataGraphPipelineDispatchFlagsARM

  VkPhysicalDeviceDataGraphProcessingEngineARM* = object
    `type`*: VkPhysicalDeviceDataGraphProcessingEngineTypeARM
    isForeign*: VkBool32

  VkPhysicalDeviceDataGraphOperationSupportARM* = object
    operationType*: VkPhysicalDeviceDataGraphOperationTypeARM
    name*: array[VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM, char]
    version*: uint32

  VkQueueFamilyDataGraphPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    engine*: VkPhysicalDeviceDataGraphProcessingEngineARM
    operation*: VkPhysicalDeviceDataGraphOperationSupportARM

  VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    queueFamilyIndex*: uint32
    engineType*: VkPhysicalDeviceDataGraphProcessingEngineTypeARM

  VkQueueFamilyDataGraphProcessingEnginePropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    foreignSemaphoreHandleTypes*: VkExternalSemaphoreHandleTypeFlags
    foreignMemoryHandleTypes*: VkExternalMemoryHandleTypeFlags

  VkDataGraphProcessingEngineCreateInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    processingEngineCount*: uint32
    pProcessingEngines*: ptr VkPhysicalDeviceDataGraphProcessingEngineARM

  VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC* = object
    sType*: VkStructureType
    pNext*: pointer
    pipelineCacheIncrementalMode*: VkBool32

  VkDataGraphPipelineBuiltinModelCreateInfoQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    pOperation*: ptr VkPhysicalDeviceDataGraphOperationSupportARM

  VkPhysicalDeviceDataGraphModelFeaturesQCOM* = object
    sType*: VkStructureType
    pNext*: pointer
    dataGraphModel*: VkBool32

  VkPhysicalDeviceShaderUntypedPointersFeaturesKHR* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderUntypedPointers*: VkBool32

  VkNativeBufferOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    handle*: ptr OHBufferHandle

  VkSwapchainImageCreateInfoOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    usage*: VkSwapchainImageUsageFlagsOHOS

  VkPhysicalDevicePresentationPropertiesOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    sharedImage*: VkBool32

  VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    videoEncodeRgbConversion*: VkBool32

  VkVideoEncodeRgbConversionCapabilitiesVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    rgbModels*: VkVideoEncodeRgbModelConversionFlagsVALVE
    rgbRanges*: VkVideoEncodeRgbRangeCompressionFlagsVALVE
    xChromaOffsets*: VkVideoEncodeRgbChromaOffsetFlagsVALVE
    yChromaOffsets*: VkVideoEncodeRgbChromaOffsetFlagsVALVE

  VkVideoEncodeProfileRgbConversionInfoVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    performEncodeRgbConversion*: VkBool32

  VkVideoEncodeSessionRgbConversionCreateInfoVALVE* = object
    sType*: VkStructureType
    pNext*: pointer
    rgbModel*: VkVideoEncodeRgbModelConversionFlagBitsVALVE
    rgbRange*: VkVideoEncodeRgbRangeCompressionFlagBitsVALVE
    xChromaOffset*: VkVideoEncodeRgbChromaOffsetFlagBitsVALVE
    yChromaOffset*: VkVideoEncodeRgbChromaOffsetFlagBitsVALVE

  VkPhysicalDeviceShader64BitIndexingFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shader64BitIndexing*: VkBool32

  VkNativeBufferUsageOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    OHOSNativeBufferUsage*: uint64

  VkNativeBufferPropertiesOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    allocationSize*: VkDeviceSize
    memoryTypeBits*: uint32

  VkNativeBufferFormatPropertiesOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat
    externalFormat*: uint64
    formatFeatures*: VkFormatFeatureFlags
    samplerYcbcrConversionComponents*: VkComponentMapping
    suggestedYcbcrModel*: VkSamplerYcbcrModelConversion
    suggestedYcbcrRange*: VkSamplerYcbcrRange
    suggestedXChromaOffset*: VkChromaLocation
    suggestedYChromaOffset*: VkChromaLocation

  VkImportNativeBufferInfoOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    buffer*: ptr OH_NativeBuffer

  VkMemoryGetNativeBufferInfoOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    memory*: VkDeviceMemory

  VkExternalFormatOHOS* = object
    sType*: VkStructureType
    pNext*: pointer
    externalFormat*: uint64

  VkPhysicalDevicePerformanceCountersByRegionFeaturesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    performanceCountersByRegion*: VkBool32

  VkPhysicalDevicePerformanceCountersByRegionPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    maxPerRegionPerformanceCounters*: uint32
    performanceCounterRegionSize*: VkExtent2D
    rowStrideAlignment*: uint32
    regionAlignment*: uint32
    identityTransformOrder*: VkBool32

  VkPerformanceCounterARM* = object
    sType*: VkStructureType
    pNext*: pointer
    counterID*: uint32

  VkPerformanceCounterDescriptionARM* = object
    sType*: VkStructureType
    pNext*: pointer
    flags*: VkPerformanceCounterDescriptionFlagsARM
    name*: array[VK_MAX_DESCRIPTION_SIZE, char]

  VkRenderPassPerformanceCountersByRegionBeginInfoARM* = object
    sType*: VkStructureType
    pNext*: pointer
    counterAddressCount*: uint32
    pCounterAddresses*: ptr VkDeviceAddress
    serializeRegions*: VkBool32
    counterIndexCount*: uint32
    pCounterIndices*: ptr uint32

  VkComputeOccupancyPriorityParametersNV* = object
    sType*: VkStructureType
    pNext*: pointer
    occupancyPriority*: float32
    occupancyThrottling*: float32

  VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV* = object
    sType*: VkStructureType
    pNext*: pointer
    computeOccupancyPriority*: VkBool32

  VkPhysicalDeviceShaderLongVectorFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    longVector*: VkBool32

  VkPhysicalDeviceShaderLongVectorPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    maxVectorComponents*: uint32

  VkPhysicalDeviceTextureCompressionASTC3DFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    textureCompressionASTC_3D*: VkBool32

  VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    shaderSubgroupPartitioned*: VkBool32

  VkHostAddressRangeEXT* = object
    address*: pointer
    size*: uint

  VkHostAddressRangeConstEXT* = object
    address*: pointer
    size*: uint

  VkDeviceAddressRangeEXT* = object
    address*: VkDeviceAddress
    size*: VkDeviceSize

  VkTexelBufferDescriptorInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    format*: VkFormat
    addressRange*: VkDeviceAddressRangeEXT

  VkImageDescriptorInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pView*: ptr VkImageViewCreateInfo
    layout*: VkImageLayout

  VkResourceDescriptorDataEXT* {.union.} = object
    pImage*: ptr VkImageDescriptorInfoEXT
    pTexelBuffer*: ptr VkTexelBufferDescriptorInfoEXT
    pAddressRange*: ptr VkDeviceAddressRangeEXT
    pTensorARM*: ptr VkTensorViewCreateInfoARM

  VkResourceDescriptorInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    `type`*: VkDescriptorType
    data*: VkResourceDescriptorDataEXT

  VkBindHeapInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    heapRange*: VkDeviceAddressRangeEXT
    reservedRangeOffset*: VkDeviceSize
    reservedRangeSize*: VkDeviceSize

  VkPushDataInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    offset*: uint32
    data*: VkHostAddressRangeConstEXT

  VkDescriptorMappingSourceConstantOffsetEXT* = object
    heapOffset*: uint32
    heapArrayStride*: uint32
    pEmbeddedSampler*: ptr VkSamplerCreateInfo
    samplerHeapOffset*: uint32
    samplerHeapArrayStride*: uint32

  VkDescriptorMappingSourcePushIndexEXT* = object
    heapOffset*: uint32
    pushOffset*: uint32
    heapIndexStride*: uint32
    heapArrayStride*: uint32
    pEmbeddedSampler*: ptr VkSamplerCreateInfo
    useCombinedImageSamplerIndex*: VkBool32
    samplerHeapOffset*: uint32
    samplerPushOffset*: uint32
    samplerHeapIndexStride*: uint32
    samplerHeapArrayStride*: uint32

  VkDescriptorMappingSourceIndirectIndexEXT* = object
    heapOffset*: uint32
    pushOffset*: uint32
    addressOffset*: uint32
    heapIndexStride*: uint32
    heapArrayStride*: uint32
    pEmbeddedSampler*: ptr VkSamplerCreateInfo
    useCombinedImageSamplerIndex*: VkBool32
    samplerHeapOffset*: uint32
    samplerPushOffset*: uint32
    samplerAddressOffset*: uint32
    samplerHeapIndexStride*: uint32
    samplerHeapArrayStride*: uint32

  VkDescriptorMappingSourceIndirectIndexArrayEXT* = object
    heapOffset*: uint32
    pushOffset*: uint32
    addressOffset*: uint32
    heapIndexStride*: uint32
    pEmbeddedSampler*: ptr VkSamplerCreateInfo
    useCombinedImageSamplerIndex*: VkBool32
    samplerHeapOffset*: uint32
    samplerPushOffset*: uint32
    samplerAddressOffset*: uint32
    samplerHeapIndexStride*: uint32

  VkDescriptorMappingSourceHeapDataEXT* = object
    heapOffset*: uint32
    pushOffset*: uint32

  VkDescriptorMappingSourceShaderRecordIndexEXT* = object
    heapOffset*: uint32
    shaderRecordOffset*: uint32
    heapIndexStride*: uint32
    heapArrayStride*: uint32
    pEmbeddedSampler*: ptr VkSamplerCreateInfo
    useCombinedImageSamplerIndex*: VkBool32
    samplerHeapOffset*: uint32
    samplerShaderRecordOffset*: uint32
    samplerHeapIndexStride*: uint32
    samplerHeapArrayStride*: uint32

  VkDescriptorMappingSourceIndirectAddressEXT* = object
    pushOffset*: uint32
    addressOffset*: uint32

  VkDescriptorMappingSourceDataEXT* {.union.} = object
    constantOffset*: VkDescriptorMappingSourceConstantOffsetEXT
    pushIndex*: VkDescriptorMappingSourcePushIndexEXT
    indirectIndex*: VkDescriptorMappingSourceIndirectIndexEXT
    indirectIndexArray*: VkDescriptorMappingSourceIndirectIndexArrayEXT
    heapData*: VkDescriptorMappingSourceHeapDataEXT
    pushDataOffset*: uint32
    pushAddressOffset*: uint32
    indirectAddress*: VkDescriptorMappingSourceIndirectAddressEXT
    shaderRecordIndex*: VkDescriptorMappingSourceShaderRecordIndexEXT
    shaderRecordDataOffset*: uint32
    shaderRecordAddressOffset*: uint32

  VkDescriptorSetAndBindingMappingEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorSet*: uint32
    firstBinding*: uint32
    bindingCount*: uint32
    resourceMask*: VkSpirvResourceTypeFlagsEXT
    source*: VkDescriptorMappingSourceEXT
    sourceData*: VkDescriptorMappingSourceDataEXT

  VkShaderDescriptorSetAndBindingMappingInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    mappingCount*: uint32
    pMappings*: ptr VkDescriptorSetAndBindingMappingEXT

  VkSamplerCustomBorderColorIndexCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    index*: uint32

  VkOpaqueCaptureDataCreateInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pData*: ptr VkHostAddressRangeConstEXT

  VkIndirectCommandsLayoutPushDataTokenNV* = object
    sType*: VkStructureType
    pNext*: pointer
    pushDataOffset*: uint32
    pushDataSize*: uint32

  VkSubsampledImageFormatPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    subsampledImageDescriptorCount*: uint32

  VkPhysicalDeviceDescriptorHeapFeaturesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    descriptorHeap*: VkBool32
    descriptorHeapCaptureReplay*: VkBool32

  VkPhysicalDeviceDescriptorHeapPropertiesEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    samplerHeapAlignment*: VkDeviceSize
    resourceHeapAlignment*: VkDeviceSize
    maxSamplerHeapSize*: VkDeviceSize
    maxResourceHeapSize*: VkDeviceSize
    minSamplerHeapReservedRange*: VkDeviceSize
    minSamplerHeapReservedRangeWithEmbedded*: VkDeviceSize
    minResourceHeapReservedRange*: VkDeviceSize
    samplerDescriptorSize*: VkDeviceSize
    imageDescriptorSize*: VkDeviceSize
    bufferDescriptorSize*: VkDeviceSize
    samplerDescriptorAlignment*: VkDeviceSize
    imageDescriptorAlignment*: VkDeviceSize
    bufferDescriptorAlignment*: VkDeviceSize
    maxPushDataSize*: VkDeviceSize
    imageCaptureReplayOpaqueDataSize*: uint
    maxDescriptorHeapEmbeddedSamplers*: uint32
    samplerYcbcrConversionCount*: uint32
    sparseDescriptorHeaps*: VkBool32
    protectedDescriptorHeaps*: VkBool32

  VkCommandBufferInheritanceDescriptorHeapInfoEXT* = object
    sType*: VkStructureType
    pNext*: pointer
    pSamplerHeapBindInfo*: ptr VkBindHeapInfoEXT
    pResourceHeapBindInfo*: ptr VkBindHeapInfoEXT

  VkPhysicalDeviceDescriptorHeapTensorPropertiesARM* = object
    sType*: VkStructureType
    pNext*: pointer
    tensorDescriptorSize*: VkDeviceSize
    tensorDescriptorAlignment*: VkDeviceSize
    tensorCaptureReplayOpaqueDataSize*: uint

# Constructors

proc newVkBaseOutStructure*(sType: VkStructureType, pNext: ptr VkBaseOutStructure): VkBaseOutStructure =
  result = VkBaseOutStructure(
    sType: sType,
    pNext: pNext,
  )

proc newVkBaseInStructure*(sType: VkStructureType, pNext: ptr VkBaseInStructure): VkBaseInStructure =
  result = VkBaseInStructure(
    sType: sType,
    pNext: pNext,
  )

proc newVkOffset2D*(x: int32, y: int32): VkOffset2D =
  result = VkOffset2D(
    x: x,
    y: y,
  )

proc newVkOffset3D*(x: int32, y: int32, z: int32): VkOffset3D =
  result = VkOffset3D(
    x: x,
    y: y,
    z: z,
  )

proc newVkExtent2D*(width: uint32, height: uint32): VkExtent2D =
  result = VkExtent2D(
    width: width,
    height: height,
  )

proc newVkExtent3D*(width: uint32, height: uint32, depth: uint32): VkExtent3D =
  result = VkExtent3D(
    width: width,
    height: height,
    depth: depth,
  )

proc newVkViewport*(x: float32, y: float32, width: float32, height: float32, minDepth: float32, maxDepth: float32): VkViewport =
  result = VkViewport(
    x: x,
    y: y,
    width: width,
    height: height,
    minDepth: minDepth,
    maxDepth: maxDepth,
  )

proc newVkRect2D*(offset: VkOffset2D, extent: VkExtent2D): VkRect2D =
  result = VkRect2D(
    offset: offset,
    extent: extent,
  )

proc newVkClearRect*(rect: VkRect2D, baseArrayLayer: uint32, layerCount: uint32): VkClearRect =
  result = VkClearRect(
    rect: rect,
    baseArrayLayer: baseArrayLayer,
    layerCount: layerCount,
  )

proc newVkComponentMapping*(r: VkComponentSwizzle, g: VkComponentSwizzle, b: VkComponentSwizzle, a: VkComponentSwizzle): VkComponentMapping =
  result = VkComponentMapping(
    r: r,
    g: g,
    b: b,
    a: a,
  )

proc newVkPhysicalDeviceProperties*(apiVersion: uint32, driverVersion: uint32, vendorID: uint32, deviceID: uint32, deviceType: VkPhysicalDeviceType, deviceName: array[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, char], pipelineCacheUUID: array[VK_UUID_SIZE, uint8], limits: VkPhysicalDeviceLimits, sparseProperties: VkPhysicalDeviceSparseProperties): VkPhysicalDeviceProperties =
  result = VkPhysicalDeviceProperties(
    apiVersion: apiVersion,
    driverVersion: driverVersion,
    vendorID: vendorID,
    deviceID: deviceID,
    deviceType: deviceType,
    deviceName: deviceName,
    pipelineCacheUUID: pipelineCacheUUID,
    limits: limits,
    sparseProperties: sparseProperties,
  )

proc newVkExtensionProperties*(extensionName: array[VK_MAX_EXTENSION_NAME_SIZE, char], specVersion: uint32): VkExtensionProperties =
  result = VkExtensionProperties(
    extensionName: extensionName,
    specVersion: specVersion,
  )

proc newVkLayerProperties*(layerName: array[VK_MAX_EXTENSION_NAME_SIZE, char], specVersion: uint32, implementationVersion: uint32, description: array[VK_MAX_DESCRIPTION_SIZE, char]): VkLayerProperties =
  result = VkLayerProperties(
    layerName: layerName,
    specVersion: specVersion,
    implementationVersion: implementationVersion,
    description: description,
  )

proc newVkApplicationInfo*(sType: VkStructureType = VkStructureType.ApplicationInfo, pNext: pointer = nil, pApplicationName: cstring, applicationVersion: uint32, pEngineName: cstring, engineVersion: uint32, apiVersion: uint32): VkApplicationInfo =
  result = VkApplicationInfo(
    sType: sType,
    pNext: pNext,
    pApplicationName: pApplicationName,
    applicationVersion: applicationVersion,
    pEngineName: pEngineName,
    engineVersion: engineVersion,
    apiVersion: apiVersion,
  )

proc newVkAllocationCallbacks*(pUserData: pointer = nil, pfnAllocation: PFN_vkAllocationFunction, pfnReallocation: PFN_vkReallocationFunction, pfnFree: PFN_vkFreeFunction, pfnInternalAllocation: PFN_vkInternalAllocationNotification, pfnInternalFree: PFN_vkInternalFreeNotification): VkAllocationCallbacks =
  result = VkAllocationCallbacks(
    pUserData: pUserData,
    pfnAllocation: pfnAllocation,
    pfnReallocation: pfnReallocation,
    pfnFree: pfnFree,
    pfnInternalAllocation: pfnInternalAllocation,
    pfnInternalFree: pfnInternalFree,
  )

proc newVkDeviceQueueCreateInfo*(sType: VkStructureType = VkStructureType.DeviceQueueCreateInfo, pNext: pointer = nil, flags: VkDeviceQueueCreateFlags = 0.VkDeviceQueueCreateFlags, queueFamilyIndex: uint32, queuePriorities: openarray[float32]): VkDeviceQueueCreateInfo =
  result = VkDeviceQueueCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    queueFamilyIndex: queueFamilyIndex,
    queueCount: len(queuePriorities).uint32,
    pQueuePriorities: if len(queuePriorities) == 0: nil else: cast[ptr float32](queuePriorities),
  )

proc newVkDeviceCreateInfo*(sType: VkStructureType = VkStructureType.DeviceCreateInfo, pNext: pointer = nil, flags: VkDeviceCreateFlags = 0.VkDeviceCreateFlags, queueCreateInfos: openarray[VkDeviceQueueCreateInfo], pEnabledLayerNames: openarray[cstring], pEnabledExtensionNames: openarray[cstring], enabledFeatures: openarray[VkPhysicalDeviceFeatures]): VkDeviceCreateInfo =
  result = VkDeviceCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    queueCreateInfoCount: len(queueCreateInfos).uint32,
    pQueueCreateInfos: if len(queueCreateInfos) == 0: nil else: cast[ptr VkDeviceQueueCreateInfo](queueCreateInfos),
    enabledLayerCount: len(pEnabledLayerNames).uint32,
    ppEnabledLayerNames: if len(pEnabledLayerNames) == 0: nil else: cast[cstringArray](pEnabledLayerNames),
    enabledExtensionCount: len(pEnabledExtensionNames).uint32,
    ppEnabledExtensionNames: if len(pEnabledExtensionNames) == 0: nil else: cast[cstringArray](pEnabledExtensionNames),
    pEnabledFeatures: if len(enabledFeatures) == 0: nil else: cast[ptr VkPhysicalDeviceFeatures](enabledFeatures),
  )

proc newVkInstanceCreateInfo*(sType: VkStructureType = VkStructureType.InstanceCreateInfo, pNext: pointer = nil, flags: VkInstanceCreateFlags = 0.VkInstanceCreateFlags, pApplicationInfo: ptr VkApplicationInfo, pEnabledLayerNames: openarray[cstring], pEnabledExtensionNames: openarray[cstring]): VkInstanceCreateInfo =
  result = VkInstanceCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pApplicationInfo: pApplicationInfo,
    enabledLayerCount: len(pEnabledLayerNames).uint32,
    ppEnabledLayerNames: if len(pEnabledLayerNames) == 0: nil else: cast[cstringArray](pEnabledLayerNames),
    enabledExtensionCount: len(pEnabledExtensionNames).uint32,
    ppEnabledExtensionNames: if len(pEnabledExtensionNames) == 0: nil else: cast[cstringArray](pEnabledExtensionNames),
  )

proc newVkQueueFamilyProperties*(queueFlags: VkQueueFlags, queueCount: uint32, timestampValidBits: uint32, minImageTransferGranularity: VkExtent3D): VkQueueFamilyProperties =
  result = VkQueueFamilyProperties(
    queueFlags: queueFlags,
    queueCount: queueCount,
    timestampValidBits: timestampValidBits,
    minImageTransferGranularity: minImageTransferGranularity,
  )

proc newVkPhysicalDeviceMemoryProperties*(memoryTypeCount: uint32, memoryTypes: array[VK_MAX_MEMORY_TYPES, VkMemoryType], memoryHeapCount: uint32, memoryHeaps: array[VK_MAX_MEMORY_HEAPS, VkMemoryHeap]): VkPhysicalDeviceMemoryProperties =
  result = VkPhysicalDeviceMemoryProperties(
    memoryTypeCount: memoryTypeCount,
    memoryTypes: memoryTypes,
    memoryHeapCount: memoryHeapCount,
    memoryHeaps: memoryHeaps,
  )

proc newVkMemoryAllocateInfo*(sType: VkStructureType = VkStructureType.MemoryAllocateInfo, pNext: pointer = nil, allocationSize: VkDeviceSize, memoryTypeIndex: uint32): VkMemoryAllocateInfo =
  result = VkMemoryAllocateInfo(
    sType: sType,
    pNext: pNext,
    allocationSize: allocationSize,
    memoryTypeIndex: memoryTypeIndex,
  )

proc newVkMemoryRequirements*(size: VkDeviceSize, alignment: VkDeviceSize, memoryTypeBits: uint32): VkMemoryRequirements =
  result = VkMemoryRequirements(
    size: size,
    alignment: alignment,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkSparseImageFormatProperties*(aspectMask: VkImageAspectFlags, imageGranularity: VkExtent3D, flags: VkSparseImageFormatFlags = 0.VkSparseImageFormatFlags): VkSparseImageFormatProperties =
  result = VkSparseImageFormatProperties(
    aspectMask: aspectMask,
    imageGranularity: imageGranularity,
    flags: flags,
  )

proc newVkSparseImageMemoryRequirements*(formatProperties: VkSparseImageFormatProperties, imageMipTailFirstLod: uint32, imageMipTailSize: VkDeviceSize, imageMipTailOffset: VkDeviceSize, imageMipTailStride: VkDeviceSize): VkSparseImageMemoryRequirements =
  result = VkSparseImageMemoryRequirements(
    formatProperties: formatProperties,
    imageMipTailFirstLod: imageMipTailFirstLod,
    imageMipTailSize: imageMipTailSize,
    imageMipTailOffset: imageMipTailOffset,
    imageMipTailStride: imageMipTailStride,
  )

proc newVkMemoryType*(propertyFlags: VkMemoryPropertyFlags, heapIndex: uint32): VkMemoryType =
  result = VkMemoryType(
    propertyFlags: propertyFlags,
    heapIndex: heapIndex,
  )

proc newVkMemoryHeap*(size: VkDeviceSize, flags: VkMemoryHeapFlags = 0.VkMemoryHeapFlags): VkMemoryHeap =
  result = VkMemoryHeap(
    size: size,
    flags: flags,
  )

proc newVkMappedMemoryRange*(sType: VkStructureType = VkStructureType.MappedMemoryRange, pNext: pointer = nil, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize): VkMappedMemoryRange =
  result = VkMappedMemoryRange(
    sType: sType,
    pNext: pNext,
    memory: memory,
    offset: offset,
    size: size,
  )

proc newVkFormatProperties*(linearTilingFeatures: VkFormatFeatureFlags, optimalTilingFeatures: VkFormatFeatureFlags, bufferFeatures: VkFormatFeatureFlags): VkFormatProperties =
  result = VkFormatProperties(
    linearTilingFeatures: linearTilingFeatures,
    optimalTilingFeatures: optimalTilingFeatures,
    bufferFeatures: bufferFeatures,
  )

proc newVkImageFormatProperties*(maxExtent: VkExtent3D, maxMipLevels: uint32, maxArrayLayers: uint32, sampleCounts: VkSampleCountFlags, maxResourceSize: VkDeviceSize): VkImageFormatProperties =
  result = VkImageFormatProperties(
    maxExtent: maxExtent,
    maxMipLevels: maxMipLevels,
    maxArrayLayers: maxArrayLayers,
    sampleCounts: sampleCounts,
    maxResourceSize: maxResourceSize,
  )

proc newVkDescriptorBufferInfo*(buffer: VkBuffer, offset: VkDeviceSize, range: VkDeviceSize): VkDescriptorBufferInfo =
  result = VkDescriptorBufferInfo(
    buffer: buffer,
    offset: offset,
    range: range,
  )

proc newVkDescriptorImageInfo*(sampler: VkSampler, imageView: VkImageView, imageLayout: VkImageLayout): VkDescriptorImageInfo =
  result = VkDescriptorImageInfo(
    sampler: sampler,
    imageView: imageView,
    imageLayout: imageLayout,
  )

proc newVkWriteDescriptorSet*(sType: VkStructureType = VkStructureType.WriteDescriptorSet, pNext: pointer = nil, dstSet: VkDescriptorSet, dstBinding: uint32, dstArrayElement: uint32, descriptorCount: uint32, descriptorType: VkDescriptorType, pImageInfo: ptr VkDescriptorImageInfo, pBufferInfo: ptr VkDescriptorBufferInfo, pTexelBufferView: ptr VkBufferView): VkWriteDescriptorSet =
  result = VkWriteDescriptorSet(
    sType: sType,
    pNext: pNext,
    dstSet: dstSet,
    dstBinding: dstBinding,
    dstArrayElement: dstArrayElement,
    descriptorCount: descriptorCount,
    descriptorType: descriptorType,
    pImageInfo: pImageInfo,
    pBufferInfo: pBufferInfo,
    pTexelBufferView: pTexelBufferView,
  )

proc newVkCopyDescriptorSet*(sType: VkStructureType = VkStructureType.CopyDescriptorSet, pNext: pointer = nil, srcSet: VkDescriptorSet, srcBinding: uint32, srcArrayElement: uint32, dstSet: VkDescriptorSet, dstBinding: uint32, dstArrayElement: uint32, descriptorCount: uint32): VkCopyDescriptorSet =
  result = VkCopyDescriptorSet(
    sType: sType,
    pNext: pNext,
    srcSet: srcSet,
    srcBinding: srcBinding,
    srcArrayElement: srcArrayElement,
    dstSet: dstSet,
    dstBinding: dstBinding,
    dstArrayElement: dstArrayElement,
    descriptorCount: descriptorCount,
  )

proc newVkBufferUsageFlags2CreateInfo*(sType: VkStructureType = VkStructureType.BufferUsageFlags2CreateInfo, pNext: pointer = nil, usage: VkBufferUsageFlags2): VkBufferUsageFlags2CreateInfo =
  result = VkBufferUsageFlags2CreateInfo(
    sType: sType,
    pNext: pNext,
    usage: usage,
  )

proc newVkBufferCreateInfo*(sType: VkStructureType = VkStructureType.BufferCreateInfo, pNext: pointer = nil, flags: VkBufferCreateFlags = 0.VkBufferCreateFlags, size: VkDeviceSize, usage: VkBufferUsageFlags, sharingMode: VkSharingMode, queueFamilyIndices: openarray[uint32]): VkBufferCreateInfo =
  result = VkBufferCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    size: size,
    usage: usage,
    sharingMode: sharingMode,
    queueFamilyIndexCount: len(queueFamilyIndices).uint32,
    pQueueFamilyIndices: if len(queueFamilyIndices) == 0: nil else: cast[ptr uint32](queueFamilyIndices),
  )

proc newVkBufferViewCreateInfo*(sType: VkStructureType = VkStructureType.BufferViewCreateInfo, pNext: pointer = nil, flags: VkBufferViewCreateFlags = 0.VkBufferViewCreateFlags, buffer: VkBuffer, format: VkFormat, offset: VkDeviceSize, range: VkDeviceSize): VkBufferViewCreateInfo =
  result = VkBufferViewCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    buffer: buffer,
    format: format,
    offset: offset,
    range: range,
  )

proc newVkImageSubresource*(aspectMask: VkImageAspectFlags, mipLevel: uint32, arrayLayer: uint32): VkImageSubresource =
  result = VkImageSubresource(
    aspectMask: aspectMask,
    mipLevel: mipLevel,
    arrayLayer: arrayLayer,
  )

proc newVkImageSubresourceLayers*(aspectMask: VkImageAspectFlags, mipLevel: uint32, baseArrayLayer: uint32, layerCount: uint32): VkImageSubresourceLayers =
  result = VkImageSubresourceLayers(
    aspectMask: aspectMask,
    mipLevel: mipLevel,
    baseArrayLayer: baseArrayLayer,
    layerCount: layerCount,
  )

proc newVkImageSubresourceRange*(aspectMask: VkImageAspectFlags, baseMipLevel: uint32, levelCount: uint32, baseArrayLayer: uint32, layerCount: uint32): VkImageSubresourceRange =
  result = VkImageSubresourceRange(
    aspectMask: aspectMask,
    baseMipLevel: baseMipLevel,
    levelCount: levelCount,
    baseArrayLayer: baseArrayLayer,
    layerCount: layerCount,
  )

proc newVkMemoryBarrier*(sType: VkStructureType = VkStructureType.MemoryBarrier, pNext: pointer = nil, srcAccessMask: VkAccessFlags, dstAccessMask: VkAccessFlags): VkMemoryBarrier =
  result = VkMemoryBarrier(
    sType: sType,
    pNext: pNext,
    srcAccessMask: srcAccessMask,
    dstAccessMask: dstAccessMask,
  )

proc newVkBufferMemoryBarrier*(sType: VkStructureType = VkStructureType.BufferMemoryBarrier, pNext: pointer = nil, srcAccessMask: VkAccessFlags, dstAccessMask: VkAccessFlags, srcQueueFamilyIndex: uint32, dstQueueFamilyIndex: uint32, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize): VkBufferMemoryBarrier =
  result = VkBufferMemoryBarrier(
    sType: sType,
    pNext: pNext,
    srcAccessMask: srcAccessMask,
    dstAccessMask: dstAccessMask,
    srcQueueFamilyIndex: srcQueueFamilyIndex,
    dstQueueFamilyIndex: dstQueueFamilyIndex,
    buffer: buffer,
    offset: offset,
    size: size,
  )

proc newVkImageMemoryBarrier*(sType: VkStructureType = VkStructureType.ImageMemoryBarrier, pNext: pointer = nil, srcAccessMask: VkAccessFlags, dstAccessMask: VkAccessFlags, oldLayout: VkImageLayout, newLayout: VkImageLayout, srcQueueFamilyIndex: uint32, dstQueueFamilyIndex: uint32, image: VkImage, subresourceRange: VkImageSubresourceRange): VkImageMemoryBarrier =
  result = VkImageMemoryBarrier(
    sType: sType,
    pNext: pNext,
    srcAccessMask: srcAccessMask,
    dstAccessMask: dstAccessMask,
    oldLayout: oldLayout,
    newLayout: newLayout,
    srcQueueFamilyIndex: srcQueueFamilyIndex,
    dstQueueFamilyIndex: dstQueueFamilyIndex,
    image: image,
    subresourceRange: subresourceRange,
  )

proc newVkImageCreateInfo*(sType: VkStructureType = VkStructureType.ImageCreateInfo, pNext: pointer = nil, flags: VkImageCreateFlags = 0.VkImageCreateFlags, imageType: VkImageType, format: VkFormat, extent: VkExtent3D, mipLevels: uint32, arrayLayers: uint32, samples: VkSampleCountFlagBits, tiling: VkImageTiling, usage: VkImageUsageFlags, sharingMode: VkSharingMode, queueFamilyIndices: openarray[uint32], initialLayout: VkImageLayout): VkImageCreateInfo =
  result = VkImageCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    imageType: imageType,
    format: format,
    extent: extent,
    mipLevels: mipLevels,
    arrayLayers: arrayLayers,
    samples: samples,
    tiling: tiling,
    usage: usage,
    sharingMode: sharingMode,
    queueFamilyIndexCount: len(queueFamilyIndices).uint32,
    pQueueFamilyIndices: if len(queueFamilyIndices) == 0: nil else: cast[ptr uint32](queueFamilyIndices),
    initialLayout: initialLayout,
  )

proc newVkSubresourceLayout*(offset: VkDeviceSize, size: VkDeviceSize, rowPitch: VkDeviceSize, arrayPitch: VkDeviceSize, depthPitch: VkDeviceSize): VkSubresourceLayout =
  result = VkSubresourceLayout(
    offset: offset,
    size: size,
    rowPitch: rowPitch,
    arrayPitch: arrayPitch,
    depthPitch: depthPitch,
  )

proc newVkImageViewCreateInfo*(sType: VkStructureType = VkStructureType.ImageViewCreateInfo, pNext: pointer = nil, flags: VkImageViewCreateFlags = 0.VkImageViewCreateFlags, image: VkImage, viewType: VkImageViewType, format: VkFormat, components: VkComponentMapping, subresourceRange: VkImageSubresourceRange): VkImageViewCreateInfo =
  result = VkImageViewCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    image: image,
    viewType: viewType,
    format: format,
    components: components,
    subresourceRange: subresourceRange,
  )

proc newVkBufferCopy*(srcOffset: VkDeviceSize, dstOffset: VkDeviceSize, size: VkDeviceSize): VkBufferCopy =
  result = VkBufferCopy(
    srcOffset: srcOffset,
    dstOffset: dstOffset,
    size: size,
  )

proc newVkSparseMemoryBind*(resourceOffset: VkDeviceSize, size: VkDeviceSize, memory: VkDeviceMemory, memoryOffset: VkDeviceSize, flags: VkSparseMemoryBindFlags = 0.VkSparseMemoryBindFlags): VkSparseMemoryBind =
  result = VkSparseMemoryBind(
    resourceOffset: resourceOffset,
    size: size,
    memory: memory,
    memoryOffset: memoryOffset,
    flags: flags,
  )

proc newVkSparseImageMemoryBind*(subresource: VkImageSubresource, offset: VkOffset3D, extent: VkExtent3D, memory: VkDeviceMemory, memoryOffset: VkDeviceSize, flags: VkSparseMemoryBindFlags = 0.VkSparseMemoryBindFlags): VkSparseImageMemoryBind =
  result = VkSparseImageMemoryBind(
    subresource: subresource,
    offset: offset,
    extent: extent,
    memory: memory,
    memoryOffset: memoryOffset,
    flags: flags,
  )

proc newVkSparseBufferMemoryBindInfo*(buffer: VkBuffer, binds: openarray[VkSparseMemoryBind]): VkSparseBufferMemoryBindInfo =
  result = VkSparseBufferMemoryBindInfo(
    buffer: buffer,
    bindCount: len(binds).uint32,
    pBinds: if len(binds) == 0: nil else: cast[ptr VkSparseMemoryBind](binds),
  )

proc newVkSparseImageOpaqueMemoryBindInfo*(image: VkImage, binds: openarray[VkSparseMemoryBind]): VkSparseImageOpaqueMemoryBindInfo =
  result = VkSparseImageOpaqueMemoryBindInfo(
    image: image,
    bindCount: len(binds).uint32,
    pBinds: if len(binds) == 0: nil else: cast[ptr VkSparseMemoryBind](binds),
  )

proc newVkSparseImageMemoryBindInfo*(image: VkImage, binds: openarray[VkSparseImageMemoryBind]): VkSparseImageMemoryBindInfo =
  result = VkSparseImageMemoryBindInfo(
    image: image,
    bindCount: len(binds).uint32,
    pBinds: if len(binds) == 0: nil else: cast[ptr VkSparseImageMemoryBind](binds),
  )

proc newVkBindSparseInfo*(sType: VkStructureType = VkStructureType.BindSparseInfo, pNext: pointer = nil, waitSemaphores: openarray[VkSemaphore], bufferBinds: openarray[VkSparseBufferMemoryBindInfo], imageOpaqueBinds: openarray[VkSparseImageOpaqueMemoryBindInfo], imageBinds: openarray[VkSparseImageMemoryBindInfo], signalSemaphores: openarray[VkSemaphore]): VkBindSparseInfo =
  result = VkBindSparseInfo(
    sType: sType,
    pNext: pNext,
    waitSemaphoreCount: len(waitSemaphores).uint32,
    pWaitSemaphores: if len(waitSemaphores) == 0: nil else: cast[ptr VkSemaphore](waitSemaphores),
    bufferBindCount: len(bufferBinds).uint32,
    pBufferBinds: if len(bufferBinds) == 0: nil else: cast[ptr VkSparseBufferMemoryBindInfo](bufferBinds),
    imageOpaqueBindCount: len(imageOpaqueBinds).uint32,
    pImageOpaqueBinds: if len(imageOpaqueBinds) == 0: nil else: cast[ptr VkSparseImageOpaqueMemoryBindInfo](imageOpaqueBinds),
    imageBindCount: len(imageBinds).uint32,
    pImageBinds: if len(imageBinds) == 0: nil else: cast[ptr VkSparseImageMemoryBindInfo](imageBinds),
    signalSemaphoreCount: len(signalSemaphores).uint32,
    pSignalSemaphores: if len(signalSemaphores) == 0: nil else: cast[ptr VkSemaphore](signalSemaphores),
  )

proc newVkImageCopy*(srcSubresource: VkImageSubresourceLayers, srcOffset: VkOffset3D, dstSubresource: VkImageSubresourceLayers, dstOffset: VkOffset3D, extent: VkExtent3D): VkImageCopy =
  result = VkImageCopy(
    srcSubresource: srcSubresource,
    srcOffset: srcOffset,
    dstSubresource: dstSubresource,
    dstOffset: dstOffset,
    extent: extent,
  )

proc newVkImageBlit*(srcSubresource: VkImageSubresourceLayers, srcOffsets: array[2, VkOffset3D], dstSubresource: VkImageSubresourceLayers, dstOffsets: array[2, VkOffset3D]): VkImageBlit =
  result = VkImageBlit(
    srcSubresource: srcSubresource,
    srcOffsets: srcOffsets,
    dstSubresource: dstSubresource,
    dstOffsets: dstOffsets,
  )

proc newVkBufferImageCopy*(bufferOffset: VkDeviceSize, bufferRowLength: uint32, bufferImageHeight: uint32, imageSubresource: VkImageSubresourceLayers, imageOffset: VkOffset3D, imageExtent: VkExtent3D): VkBufferImageCopy =
  result = VkBufferImageCopy(
    bufferOffset: bufferOffset,
    bufferRowLength: bufferRowLength,
    bufferImageHeight: bufferImageHeight,
    imageSubresource: imageSubresource,
    imageOffset: imageOffset,
    imageExtent: imageExtent,
  )

proc newVkStridedDeviceAddressRangeKHR*(address: VkDeviceAddress, size: VkDeviceSize, stride: VkDeviceSize): VkStridedDeviceAddressRangeKHR =
  result = VkStridedDeviceAddressRangeKHR(
    address: address,
    size: size,
    stride: stride,
  )

proc newVkCopyMemoryIndirectCommandKHR*(srcAddress: VkDeviceAddress, dstAddress: VkDeviceAddress, size: VkDeviceSize): VkCopyMemoryIndirectCommandKHR =
  result = VkCopyMemoryIndirectCommandKHR(
    srcAddress: srcAddress,
    dstAddress: dstAddress,
    size: size,
  )

proc newVkCopyMemoryIndirectInfoKHR*(sType: VkStructureType = VkStructureType.CopyMemoryIndirectInfoKHR, pNext: pointer = nil, srcCopyFlags: VkAddressCopyFlagsKHR, dstCopyFlags: VkAddressCopyFlagsKHR, copyCount: uint32, copyAddressRange: VkStridedDeviceAddressRangeKHR): VkCopyMemoryIndirectInfoKHR =
  result = VkCopyMemoryIndirectInfoKHR(
    sType: sType,
    pNext: pNext,
    srcCopyFlags: srcCopyFlags,
    dstCopyFlags: dstCopyFlags,
    copyCount: copyCount,
    copyAddressRange: copyAddressRange,
  )

proc newVkCopyMemoryToImageIndirectCommandKHR*(srcAddress: VkDeviceAddress, bufferRowLength: uint32, bufferImageHeight: uint32, imageSubresource: VkImageSubresourceLayers, imageOffset: VkOffset3D, imageExtent: VkExtent3D): VkCopyMemoryToImageIndirectCommandKHR =
  result = VkCopyMemoryToImageIndirectCommandKHR(
    srcAddress: srcAddress,
    bufferRowLength: bufferRowLength,
    bufferImageHeight: bufferImageHeight,
    imageSubresource: imageSubresource,
    imageOffset: imageOffset,
    imageExtent: imageExtent,
  )

proc newVkCopyMemoryToImageIndirectInfoKHR*(sType: VkStructureType = VkStructureType.CopyMemoryToImageIndirectInfoKHR, pNext: pointer = nil, srcCopyFlags: VkAddressCopyFlagsKHR, copyCount: uint32, copyAddressRange: VkStridedDeviceAddressRangeKHR, dstImage: VkImage, dstImageLayout: VkImageLayout, pImageSubresources: ptr VkImageSubresourceLayers): VkCopyMemoryToImageIndirectInfoKHR =
  result = VkCopyMemoryToImageIndirectInfoKHR(
    sType: sType,
    pNext: pNext,
    srcCopyFlags: srcCopyFlags,
    copyCount: copyCount,
    copyAddressRange: copyAddressRange,
    dstImage: dstImage,
    dstImageLayout: dstImageLayout,
    pImageSubresources: pImageSubresources,
  )

proc newVkImageResolve*(srcSubresource: VkImageSubresourceLayers, srcOffset: VkOffset3D, dstSubresource: VkImageSubresourceLayers, dstOffset: VkOffset3D, extent: VkExtent3D): VkImageResolve =
  result = VkImageResolve(
    srcSubresource: srcSubresource,
    srcOffset: srcOffset,
    dstSubresource: dstSubresource,
    dstOffset: dstOffset,
    extent: extent,
  )

proc newVkShaderModuleCreateInfo*(sType: VkStructureType = VkStructureType.ShaderModuleCreateInfo, pNext: pointer = nil, flags: VkShaderModuleCreateFlags = 0.VkShaderModuleCreateFlags, code: openarray[char]): VkShaderModuleCreateInfo =
  result = VkShaderModuleCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    codeSize: len(code).uint,
    pCode: if len(code) == 0: nil else: cast[ptr uint32](code),
  )

proc newVkDescriptorSetLayoutBinding*(binding: uint32, descriptorType: VkDescriptorType, descriptorCount: uint32, stageFlags: VkShaderStageFlags, pImmutableSamplers: ptr VkSampler): VkDescriptorSetLayoutBinding =
  result = VkDescriptorSetLayoutBinding(
    binding: binding,
    descriptorType: descriptorType,
    descriptorCount: descriptorCount,
    stageFlags: stageFlags,
    pImmutableSamplers: pImmutableSamplers,
  )

proc newVkDescriptorSetLayoutCreateInfo*(sType: VkStructureType = VkStructureType.DescriptorSetLayoutCreateInfo, pNext: pointer = nil, flags: VkDescriptorSetLayoutCreateFlags = 0.VkDescriptorSetLayoutCreateFlags, bindings: openarray[VkDescriptorSetLayoutBinding]): VkDescriptorSetLayoutCreateInfo =
  result = VkDescriptorSetLayoutCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    bindingCount: len(bindings).uint32,
    pBindings: if len(bindings) == 0: nil else: cast[ptr VkDescriptorSetLayoutBinding](bindings),
  )

proc newVkDescriptorPoolSize*(`type`: VkDescriptorType, descriptorCount: uint32): VkDescriptorPoolSize =
  result = VkDescriptorPoolSize(
    `type`: `type`,
    descriptorCount: descriptorCount,
  )

proc newVkDescriptorPoolCreateInfo*(sType: VkStructureType = VkStructureType.DescriptorPoolCreateInfo, pNext: pointer = nil, flags: VkDescriptorPoolCreateFlags = 0.VkDescriptorPoolCreateFlags, maxSets: uint32, poolSizes: openarray[VkDescriptorPoolSize]): VkDescriptorPoolCreateInfo =
  result = VkDescriptorPoolCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    maxSets: maxSets,
    poolSizeCount: len(poolSizes).uint32,
    pPoolSizes: if len(poolSizes) == 0: nil else: cast[ptr VkDescriptorPoolSize](poolSizes),
  )

proc newVkDescriptorSetAllocateInfo*(sType: VkStructureType = VkStructureType.DescriptorSetAllocateInfo, pNext: pointer = nil, descriptorPool: VkDescriptorPool, setLayouts: openarray[VkDescriptorSetLayout]): VkDescriptorSetAllocateInfo =
  result = VkDescriptorSetAllocateInfo(
    sType: sType,
    pNext: pNext,
    descriptorPool: descriptorPool,
    descriptorSetCount: len(setLayouts).uint32,
    pSetLayouts: if len(setLayouts) == 0: nil else: cast[ptr VkDescriptorSetLayout](setLayouts),
  )

proc newVkSpecializationMapEntry*(constantID: uint32, offset: uint32, size: uint): VkSpecializationMapEntry =
  result = VkSpecializationMapEntry(
    constantID: constantID,
    offset: offset,
    size: size,
  )

proc newVkSpecializationInfo*(mapEntries: openarray[VkSpecializationMapEntry], dataSize: uint, pData: pointer = nil): VkSpecializationInfo =
  result = VkSpecializationInfo(
    mapEntryCount: len(mapEntries).uint32,
    pMapEntries: if len(mapEntries) == 0: nil else: cast[ptr VkSpecializationMapEntry](mapEntries),
    dataSize: dataSize,
    pData: pData,
  )

proc newVkPipelineShaderStageCreateInfo*(sType: VkStructureType = VkStructureType.PipelineShaderStageCreateInfo, pNext: pointer = nil, flags: VkPipelineShaderStageCreateFlags = 0.VkPipelineShaderStageCreateFlags, stage: VkShaderStageFlagBits, module: VkShaderModule, pName: cstring, pSpecializationInfo: ptr VkSpecializationInfo): VkPipelineShaderStageCreateInfo =
  result = VkPipelineShaderStageCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    stage: stage,
    module: module,
    pName: pName,
    pSpecializationInfo: pSpecializationInfo,
  )

proc newVkComputePipelineCreateInfo*(sType: VkStructureType = VkStructureType.ComputePipelineCreateInfo, pNext: pointer = nil, flags: VkPipelineCreateFlags = 0.VkPipelineCreateFlags, stage: VkPipelineShaderStageCreateInfo, layout: VkPipelineLayout, basePipelineHandle: VkPipeline, basePipelineIndex: int32): VkComputePipelineCreateInfo =
  result = VkComputePipelineCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    stage: stage,
    layout: layout,
    basePipelineHandle: basePipelineHandle,
    basePipelineIndex: basePipelineIndex,
  )

proc newVkComputePipelineIndirectBufferInfoNV*(sType: VkStructureType = VkStructureType.ComputePipelineIndirectBufferInfoNV, pNext: pointer = nil, deviceAddress: VkDeviceAddress, size: VkDeviceSize, pipelineDeviceAddressCaptureReplay: VkDeviceAddress): VkComputePipelineIndirectBufferInfoNV =
  result = VkComputePipelineIndirectBufferInfoNV(
    sType: sType,
    pNext: pNext,
    deviceAddress: deviceAddress,
    size: size,
    pipelineDeviceAddressCaptureReplay: pipelineDeviceAddressCaptureReplay,
  )

proc newVkPipelineCreateFlags2CreateInfo*(sType: VkStructureType = VkStructureType.PipelineCreateFlags2CreateInfo, pNext: pointer = nil, flags: VkPipelineCreateFlags2 = 0.VkPipelineCreateFlags2): VkPipelineCreateFlags2CreateInfo =
  result = VkPipelineCreateFlags2CreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkVertexInputBindingDescription*(binding: uint32, stride: uint32, inputRate: VkVertexInputRate): VkVertexInputBindingDescription =
  result = VkVertexInputBindingDescription(
    binding: binding,
    stride: stride,
    inputRate: inputRate,
  )

proc newVkVertexInputAttributeDescription*(location: uint32, binding: uint32, format: VkFormat, offset: uint32): VkVertexInputAttributeDescription =
  result = VkVertexInputAttributeDescription(
    location: location,
    binding: binding,
    format: format,
    offset: offset,
  )

proc newVkPipelineVertexInputStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineVertexInputStateCreateInfo, pNext: pointer = nil, flags: VkPipelineVertexInputStateCreateFlags = 0.VkPipelineVertexInputStateCreateFlags, vertexBindingDescriptions: openarray[VkVertexInputBindingDescription], vertexAttributeDescriptions: openarray[VkVertexInputAttributeDescription]): VkPipelineVertexInputStateCreateInfo =
  result = VkPipelineVertexInputStateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    vertexBindingDescriptionCount: len(vertexBindingDescriptions).uint32,
    pVertexBindingDescriptions: if len(vertexBindingDescriptions) == 0: nil else: cast[ptr VkVertexInputBindingDescription](vertexBindingDescriptions),
    vertexAttributeDescriptionCount: len(vertexAttributeDescriptions).uint32,
    pVertexAttributeDescriptions: if len(vertexAttributeDescriptions) == 0: nil else: cast[ptr VkVertexInputAttributeDescription](vertexAttributeDescriptions),
  )

proc newVkPipelineInputAssemblyStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineInputAssemblyStateCreateInfo, pNext: pointer = nil, flags: VkPipelineInputAssemblyStateCreateFlags = 0.VkPipelineInputAssemblyStateCreateFlags, topology: VkPrimitiveTopology, primitiveRestartEnable: VkBool32): VkPipelineInputAssemblyStateCreateInfo =
  result = VkPipelineInputAssemblyStateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    topology: topology,
    primitiveRestartEnable: primitiveRestartEnable,
  )

proc newVkPipelineTessellationStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineTessellationStateCreateInfo, pNext: pointer = nil, flags: VkPipelineTessellationStateCreateFlags = 0.VkPipelineTessellationStateCreateFlags, patchControlPoints: uint32): VkPipelineTessellationStateCreateInfo =
  result = VkPipelineTessellationStateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    patchControlPoints: patchControlPoints,
  )

proc newVkPipelineViewportStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineViewportStateCreateInfo, pNext: pointer = nil, flags: VkPipelineViewportStateCreateFlags = 0.VkPipelineViewportStateCreateFlags, viewports: openarray[VkViewport], scissors: openarray[VkRect2D]): VkPipelineViewportStateCreateInfo =
  result = VkPipelineViewportStateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    viewportCount: len(viewports).uint32,
    pViewports: if len(viewports) == 0: nil else: cast[ptr VkViewport](viewports),
    scissorCount: len(scissors).uint32,
    pScissors: if len(scissors) == 0: nil else: cast[ptr VkRect2D](scissors),
  )

proc newVkPipelineRasterizationStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineRasterizationStateCreateInfo, pNext: pointer = nil, flags: VkPipelineRasterizationStateCreateFlags = 0.VkPipelineRasterizationStateCreateFlags, depthClampEnable: VkBool32, rasterizerDiscardEnable: VkBool32, polygonMode: VkPolygonMode, cullMode: VkCullModeFlags, frontFace: VkFrontFace, depthBiasEnable: VkBool32, depthBiasConstantFactor: float32, depthBiasClamp: float32, depthBiasSlopeFactor: float32, lineWidth: float32): VkPipelineRasterizationStateCreateInfo =
  result = VkPipelineRasterizationStateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    depthClampEnable: depthClampEnable,
    rasterizerDiscardEnable: rasterizerDiscardEnable,
    polygonMode: polygonMode,
    cullMode: cullMode,
    frontFace: frontFace,
    depthBiasEnable: depthBiasEnable,
    depthBiasConstantFactor: depthBiasConstantFactor,
    depthBiasClamp: depthBiasClamp,
    depthBiasSlopeFactor: depthBiasSlopeFactor,
    lineWidth: lineWidth,
  )

proc newVkPipelineMultisampleStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineMultisampleStateCreateInfo, pNext: pointer = nil, flags: VkPipelineMultisampleStateCreateFlags = 0.VkPipelineMultisampleStateCreateFlags, rasterizationSamples: VkSampleCountFlagBits, sampleShadingEnable: VkBool32, minSampleShading: float32, pSampleMask: ptr VkSampleMask, alphaToCoverageEnable: VkBool32, alphaToOneEnable: VkBool32): VkPipelineMultisampleStateCreateInfo =
  result = VkPipelineMultisampleStateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    rasterizationSamples: rasterizationSamples,
    sampleShadingEnable: sampleShadingEnable,
    minSampleShading: minSampleShading,
    pSampleMask: pSampleMask,
    alphaToCoverageEnable: alphaToCoverageEnable,
    alphaToOneEnable: alphaToOneEnable,
  )

proc newVkPipelineColorBlendAttachmentState*(blendEnable: VkBool32, srcColorBlendFactor: VkBlendFactor, dstColorBlendFactor: VkBlendFactor, colorBlendOp: VkBlendOp, srcAlphaBlendFactor: VkBlendFactor, dstAlphaBlendFactor: VkBlendFactor, alphaBlendOp: VkBlendOp, colorWriteMask: VkColorComponentFlags): VkPipelineColorBlendAttachmentState =
  result = VkPipelineColorBlendAttachmentState(
    blendEnable: blendEnable,
    srcColorBlendFactor: srcColorBlendFactor,
    dstColorBlendFactor: dstColorBlendFactor,
    colorBlendOp: colorBlendOp,
    srcAlphaBlendFactor: srcAlphaBlendFactor,
    dstAlphaBlendFactor: dstAlphaBlendFactor,
    alphaBlendOp: alphaBlendOp,
    colorWriteMask: colorWriteMask,
  )

proc newVkPipelineColorBlendStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineColorBlendStateCreateInfo, pNext: pointer = nil, flags: VkPipelineColorBlendStateCreateFlags = 0.VkPipelineColorBlendStateCreateFlags, logicOpEnable: VkBool32, logicOp: VkLogicOp, attachments: openarray[VkPipelineColorBlendAttachmentState], blendConstants: array[4, float32]): VkPipelineColorBlendStateCreateInfo =
  result = VkPipelineColorBlendStateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    logicOpEnable: logicOpEnable,
    logicOp: logicOp,
    attachmentCount: len(attachments).uint32,
    pAttachments: if len(attachments) == 0: nil else: cast[ptr VkPipelineColorBlendAttachmentState](attachments),
    blendConstants: blendConstants,
  )

proc newVkPipelineDynamicStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineDynamicStateCreateInfo, pNext: pointer = nil, flags: VkPipelineDynamicStateCreateFlags = 0.VkPipelineDynamicStateCreateFlags, dynamicStates: openarray[VkDynamicState]): VkPipelineDynamicStateCreateInfo =
  result = VkPipelineDynamicStateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    dynamicStateCount: len(dynamicStates).uint32,
    pDynamicStates: if len(dynamicStates) == 0: nil else: cast[ptr VkDynamicState](dynamicStates),
  )

proc newVkStencilOpState*(failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp, compareMask: uint32, writeMask: uint32, reference: uint32): VkStencilOpState =
  result = VkStencilOpState(
    failOp: failOp,
    passOp: passOp,
    depthFailOp: depthFailOp,
    compareOp: compareOp,
    compareMask: compareMask,
    writeMask: writeMask,
    reference: reference,
  )

proc newVkPipelineDepthStencilStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineDepthStencilStateCreateInfo, pNext: pointer = nil, flags: VkPipelineDepthStencilStateCreateFlags = 0.VkPipelineDepthStencilStateCreateFlags, depthTestEnable: VkBool32, depthWriteEnable: VkBool32, depthCompareOp: VkCompareOp, depthBoundsTestEnable: VkBool32, stencilTestEnable: VkBool32, front: VkStencilOpState, back: VkStencilOpState, minDepthBounds: float32, maxDepthBounds: float32): VkPipelineDepthStencilStateCreateInfo =
  result = VkPipelineDepthStencilStateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    depthTestEnable: depthTestEnable,
    depthWriteEnable: depthWriteEnable,
    depthCompareOp: depthCompareOp,
    depthBoundsTestEnable: depthBoundsTestEnable,
    stencilTestEnable: stencilTestEnable,
    front: front,
    back: back,
    minDepthBounds: minDepthBounds,
    maxDepthBounds: maxDepthBounds,
  )

proc newVkGraphicsPipelineCreateInfo*(sType: VkStructureType = VkStructureType.GraphicsPipelineCreateInfo, pNext: pointer = nil, flags: VkPipelineCreateFlags = 0.VkPipelineCreateFlags, stages: openarray[VkPipelineShaderStageCreateInfo], pVertexInputState: ptr VkPipelineVertexInputStateCreateInfo, pInputAssemblyState: ptr VkPipelineInputAssemblyStateCreateInfo, pTessellationState: ptr VkPipelineTessellationStateCreateInfo, pViewportState: ptr VkPipelineViewportStateCreateInfo, pRasterizationState: ptr VkPipelineRasterizationStateCreateInfo, pMultisampleState: ptr VkPipelineMultisampleStateCreateInfo, pDepthStencilState: ptr VkPipelineDepthStencilStateCreateInfo, pColorBlendState: ptr VkPipelineColorBlendStateCreateInfo, pDynamicState: ptr VkPipelineDynamicStateCreateInfo, layout: VkPipelineLayout, renderPass: VkRenderPass, subpass: uint32, basePipelineHandle: VkPipeline, basePipelineIndex: int32): VkGraphicsPipelineCreateInfo =
  result = VkGraphicsPipelineCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    stageCount: len(stages).uint32,
    pStages: if len(stages) == 0: nil else: cast[ptr VkPipelineShaderStageCreateInfo](stages),
    pVertexInputState: pVertexInputState,
    pInputAssemblyState: pInputAssemblyState,
    pTessellationState: pTessellationState,
    pViewportState: pViewportState,
    pRasterizationState: pRasterizationState,
    pMultisampleState: pMultisampleState,
    pDepthStencilState: pDepthStencilState,
    pColorBlendState: pColorBlendState,
    pDynamicState: pDynamicState,
    layout: layout,
    renderPass: renderPass,
    subpass: subpass,
    basePipelineHandle: basePipelineHandle,
    basePipelineIndex: basePipelineIndex,
  )

proc newVkPipelineCacheCreateInfo*(sType: VkStructureType = VkStructureType.PipelineCacheCreateInfo, pNext: pointer = nil, flags: VkPipelineCacheCreateFlags = 0.VkPipelineCacheCreateFlags, initialDataSize: uint, pInitialData: pointer = nil): VkPipelineCacheCreateInfo =
  result = VkPipelineCacheCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    initialDataSize: initialDataSize,
    pInitialData: pInitialData,
  )

proc newVkPipelineCacheHeaderVersionOne*(headerSize: uint32, headerVersion: VkPipelineCacheHeaderVersion, vendorID: uint32, deviceID: uint32, pipelineCacheUUID: array[VK_UUID_SIZE, uint8]): VkPipelineCacheHeaderVersionOne =
  result = VkPipelineCacheHeaderVersionOne(
    headerSize: headerSize,
    headerVersion: headerVersion,
    vendorID: vendorID,
    deviceID: deviceID,
    pipelineCacheUUID: pipelineCacheUUID,
  )

proc newVkPipelineCacheStageValidationIndexEntry*(codeSize: uint64, codeOffset: uint64): VkPipelineCacheStageValidationIndexEntry =
  result = VkPipelineCacheStageValidationIndexEntry(
    codeSize: codeSize,
    codeOffset: codeOffset,
  )

proc newVkPipelineCacheSafetyCriticalIndexEntry*(pipelineIdentifier: array[VK_UUID_SIZE, uint8], pipelineMemorySize: uint64, jsonSize: uint64, jsonOffset: uint64, stageIndexCount: uint32, stageIndexStride: uint32, stageIndexOffset: uint64): VkPipelineCacheSafetyCriticalIndexEntry =
  result = VkPipelineCacheSafetyCriticalIndexEntry(
    pipelineIdentifier: pipelineIdentifier,
    pipelineMemorySize: pipelineMemorySize,
    jsonSize: jsonSize,
    jsonOffset: jsonOffset,
    stageIndexCount: stageIndexCount,
    stageIndexStride: stageIndexStride,
    stageIndexOffset: stageIndexOffset,
  )

proc newVkPipelineCacheHeaderVersionSafetyCriticalOne*(headerVersionOne: VkPipelineCacheHeaderVersionOne, validationVersion: VkPipelineCacheValidationVersion, implementationData: uint32, pipelineIndexCount: uint32, pipelineIndexStride: uint32, pipelineIndexOffset: uint64): VkPipelineCacheHeaderVersionSafetyCriticalOne =
  result = VkPipelineCacheHeaderVersionSafetyCriticalOne(
    headerVersionOne: headerVersionOne,
    validationVersion: validationVersion,
    implementationData: implementationData,
    pipelineIndexCount: pipelineIndexCount,
    pipelineIndexStride: pipelineIndexStride,
    pipelineIndexOffset: pipelineIndexOffset,
  )

proc newVkPipelineCacheHeaderVersionDataGraphQCOM*(headerSize: uint32, headerVersion: VkPipelineCacheHeaderVersion, cacheType: VkDataGraphModelCacheTypeQCOM, cacheVersion: uint32, toolchainVersion: array[VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM, uint32]): VkPipelineCacheHeaderVersionDataGraphQCOM =
  result = VkPipelineCacheHeaderVersionDataGraphQCOM(
    headerSize: headerSize,
    headerVersion: headerVersion,
    cacheType: cacheType,
    cacheVersion: cacheVersion,
    toolchainVersion: toolchainVersion,
  )

proc newVkPushConstantRange*(stageFlags: VkShaderStageFlags, offset: uint32, size: uint32): VkPushConstantRange =
  result = VkPushConstantRange(
    stageFlags: stageFlags,
    offset: offset,
    size: size,
  )

proc newVkPipelineBinaryCreateInfoKHR*(sType: VkStructureType = VkStructureType.PipelineBinaryCreateInfoKHR, pNext: pointer = nil, pKeysAndDataInfo: ptr VkPipelineBinaryKeysAndDataKHR, pipeline: VkPipeline, pPipelineCreateInfo: ptr VkPipelineCreateInfoKHR): VkPipelineBinaryCreateInfoKHR =
  result = VkPipelineBinaryCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    pKeysAndDataInfo: pKeysAndDataInfo,
    pipeline: pipeline,
    pPipelineCreateInfo: pPipelineCreateInfo,
  )

proc newVkPipelineBinaryHandlesInfoKHR*(sType: VkStructureType = VkStructureType.PipelineBinaryHandlesInfoKHR, pNext: pointer = nil, pipelineBinaries: openarray[VkPipelineBinaryKHR]): VkPipelineBinaryHandlesInfoKHR =
  result = VkPipelineBinaryHandlesInfoKHR(
    sType: sType,
    pNext: pNext,
    pipelineBinaryCount: len(pipelineBinaries).uint32,
    pPipelineBinaries: if len(pipelineBinaries) == 0: nil else: cast[ptr VkPipelineBinaryKHR](pipelineBinaries),
  )

proc newVkPipelineBinaryDataKHR*(dataSize: uint, pData: pointer = nil): VkPipelineBinaryDataKHR =
  result = VkPipelineBinaryDataKHR(
    dataSize: dataSize,
    pData: pData,
  )

proc newVkPipelineBinaryKeysAndDataKHR*(pipelineBinaryKeys: openarray[VkPipelineBinaryKeyKHR], pipelineBinaryData: openarray[VkPipelineBinaryDataKHR]): VkPipelineBinaryKeysAndDataKHR =
  result = VkPipelineBinaryKeysAndDataKHR(
    binaryCount: len(pipelineBinaryKeys).uint32,
    pPipelineBinaryKeys: if len(pipelineBinaryKeys) == 0: nil else: cast[ptr VkPipelineBinaryKeyKHR](pipelineBinaryKeys),
    pPipelineBinaryData: if len(pipelineBinaryData) == 0: nil else: cast[ptr VkPipelineBinaryDataKHR](pipelineBinaryData),
  )

proc newVkPipelineBinaryKeyKHR*(sType: VkStructureType = VkStructureType.PipelineBinaryKeyKHR, pNext: pointer = nil, keySize: uint32, key: array[VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR, uint8]): VkPipelineBinaryKeyKHR =
  result = VkPipelineBinaryKeyKHR(
    sType: sType,
    pNext: pNext,
    keySize: keySize,
    key: key,
  )

proc newVkPipelineBinaryInfoKHR*(sType: VkStructureType = VkStructureType.PipelineBinaryInfoKHR, pNext: pointer = nil, pipelineBinaries: openarray[VkPipelineBinaryKHR]): VkPipelineBinaryInfoKHR =
  result = VkPipelineBinaryInfoKHR(
    sType: sType,
    pNext: pNext,
    binaryCount: len(pipelineBinaries).uint32,
    pPipelineBinaries: if len(pipelineBinaries) == 0: nil else: cast[ptr VkPipelineBinaryKHR](pipelineBinaries),
  )

proc newVkReleaseCapturedPipelineDataInfoKHR*(sType: VkStructureType = VkStructureType.ReleaseCapturedPipelineDataInfoKHR, pNext: pointer = nil, pipeline: VkPipeline): VkReleaseCapturedPipelineDataInfoKHR =
  result = VkReleaseCapturedPipelineDataInfoKHR(
    sType: sType,
    pNext: pNext,
    pipeline: pipeline,
  )

proc newVkPipelineBinaryDataInfoKHR*(sType: VkStructureType = VkStructureType.PipelineBinaryDataInfoKHR, pNext: pointer = nil, pipelineBinary: VkPipelineBinaryKHR): VkPipelineBinaryDataInfoKHR =
  result = VkPipelineBinaryDataInfoKHR(
    sType: sType,
    pNext: pNext,
    pipelineBinary: pipelineBinary,
  )

proc newVkPipelineCreateInfoKHR*(sType: VkStructureType = VkStructureType.PipelineCreateInfoKHR, pNext: pointer = nil): VkPipelineCreateInfoKHR =
  result = VkPipelineCreateInfoKHR(
    sType: sType,
    pNext: pNext,
  )

proc newVkPipelineLayoutCreateInfo*(sType: VkStructureType = VkStructureType.PipelineLayoutCreateInfo, pNext: pointer = nil, flags: VkPipelineLayoutCreateFlags = 0.VkPipelineLayoutCreateFlags, setLayouts: openarray[VkDescriptorSetLayout], pushConstantRanges: openarray[VkPushConstantRange]): VkPipelineLayoutCreateInfo =
  result = VkPipelineLayoutCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    setLayoutCount: len(setLayouts).uint32,
    pSetLayouts: if len(setLayouts) == 0: nil else: cast[ptr VkDescriptorSetLayout](setLayouts),
    pushConstantRangeCount: len(pushConstantRanges).uint32,
    pPushConstantRanges: if len(pushConstantRanges) == 0: nil else: cast[ptr VkPushConstantRange](pushConstantRanges),
  )

proc newVkSamplerCreateInfo*(sType: VkStructureType = VkStructureType.SamplerCreateInfo, pNext: pointer = nil, flags: VkSamplerCreateFlags = 0.VkSamplerCreateFlags, magFilter: VkFilter, minFilter: VkFilter, mipmapMode: VkSamplerMipmapMode, addressModeU: VkSamplerAddressMode, addressModeV: VkSamplerAddressMode, addressModeW: VkSamplerAddressMode, mipLodBias: float32, anisotropyEnable: VkBool32, maxAnisotropy: float32, compareEnable: VkBool32, compareOp: VkCompareOp, minLod: float32, maxLod: float32, borderColor: VkBorderColor, unnormalizedCoordinates: VkBool32): VkSamplerCreateInfo =
  result = VkSamplerCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    magFilter: magFilter,
    minFilter: minFilter,
    mipmapMode: mipmapMode,
    addressModeU: addressModeU,
    addressModeV: addressModeV,
    addressModeW: addressModeW,
    mipLodBias: mipLodBias,
    anisotropyEnable: anisotropyEnable,
    maxAnisotropy: maxAnisotropy,
    compareEnable: compareEnable,
    compareOp: compareOp,
    minLod: minLod,
    maxLod: maxLod,
    borderColor: borderColor,
    unnormalizedCoordinates: unnormalizedCoordinates,
  )

proc newVkCommandPoolCreateInfo*(sType: VkStructureType = VkStructureType.CommandPoolCreateInfo, pNext: pointer = nil, flags: VkCommandPoolCreateFlags = 0.VkCommandPoolCreateFlags, queueFamilyIndex: uint32): VkCommandPoolCreateInfo =
  result = VkCommandPoolCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    queueFamilyIndex: queueFamilyIndex,
  )

proc newVkCommandBufferAllocateInfo*(sType: VkStructureType = VkStructureType.CommandBufferAllocateInfo, pNext: pointer = nil, commandPool: VkCommandPool, level: VkCommandBufferLevel, commandBufferCount: uint32): VkCommandBufferAllocateInfo =
  result = VkCommandBufferAllocateInfo(
    sType: sType,
    pNext: pNext,
    commandPool: commandPool,
    level: level,
    commandBufferCount: commandBufferCount,
  )

proc newVkCommandBufferInheritanceInfo*(sType: VkStructureType = VkStructureType.CommandBufferInheritanceInfo, pNext: pointer = nil, renderPass: VkRenderPass, subpass: uint32, framebuffer: VkFramebuffer, occlusionQueryEnable: VkBool32, queryFlags: VkQueryControlFlags, pipelineStatistics: VkQueryPipelineStatisticFlags): VkCommandBufferInheritanceInfo =
  result = VkCommandBufferInheritanceInfo(
    sType: sType,
    pNext: pNext,
    renderPass: renderPass,
    subpass: subpass,
    framebuffer: framebuffer,
    occlusionQueryEnable: occlusionQueryEnable,
    queryFlags: queryFlags,
    pipelineStatistics: pipelineStatistics,
  )

proc newVkCommandBufferBeginInfo*(sType: VkStructureType = VkStructureType.CommandBufferBeginInfo, pNext: pointer = nil, flags: VkCommandBufferUsageFlags = 0.VkCommandBufferUsageFlags, pInheritanceInfo: ptr VkCommandBufferInheritanceInfo): VkCommandBufferBeginInfo =
  result = VkCommandBufferBeginInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pInheritanceInfo: pInheritanceInfo,
  )

proc newVkRenderPassBeginInfo*(sType: VkStructureType = VkStructureType.RenderPassBeginInfo, pNext: pointer = nil, renderPass: VkRenderPass, framebuffer: VkFramebuffer, renderArea: VkRect2D, clearValues: openarray[VkClearValue]): VkRenderPassBeginInfo =
  result = VkRenderPassBeginInfo(
    sType: sType,
    pNext: pNext,
    renderPass: renderPass,
    framebuffer: framebuffer,
    renderArea: renderArea,
    clearValueCount: len(clearValues).uint32,
    pClearValues: if len(clearValues) == 0: nil else: cast[ptr VkClearValue](clearValues),
  )

proc newVkClearDepthStencilValue*(depth: float32, stencil: uint32): VkClearDepthStencilValue =
  result = VkClearDepthStencilValue(
    depth: depth,
    stencil: stencil,
  )

proc newVkClearAttachment*(aspectMask: VkImageAspectFlags, colorAttachment: uint32, clearValue: VkClearValue): VkClearAttachment =
  result = VkClearAttachment(
    aspectMask: aspectMask,
    colorAttachment: colorAttachment,
    clearValue: clearValue,
  )

proc newVkAttachmentDescription*(flags: VkAttachmentDescriptionFlags = 0.VkAttachmentDescriptionFlags, format: VkFormat, samples: VkSampleCountFlagBits, loadOp: VkAttachmentLoadOp, storeOp: VkAttachmentStoreOp, stencilLoadOp: VkAttachmentLoadOp, stencilStoreOp: VkAttachmentStoreOp, initialLayout: VkImageLayout, finalLayout: VkImageLayout): VkAttachmentDescription =
  result = VkAttachmentDescription(
    flags: flags,
    format: format,
    samples: samples,
    loadOp: loadOp,
    storeOp: storeOp,
    stencilLoadOp: stencilLoadOp,
    stencilStoreOp: stencilStoreOp,
    initialLayout: initialLayout,
    finalLayout: finalLayout,
  )

proc newVkAttachmentReference*(attachment: uint32, layout: VkImageLayout): VkAttachmentReference =
  result = VkAttachmentReference(
    attachment: attachment,
    layout: layout,
  )

proc newVkSubpassDescription*(flags: VkSubpassDescriptionFlags = 0.VkSubpassDescriptionFlags, pipelineBindPoint: VkPipelineBindPoint, inputAttachments: openarray[VkAttachmentReference], colorAttachments: openarray[VkAttachmentReference], resolveAttachments: openarray[VkAttachmentReference], pDepthStencilAttachment: ptr VkAttachmentReference, preserveAttachments: openarray[uint32]): VkSubpassDescription =
  result = VkSubpassDescription(
    flags: flags,
    pipelineBindPoint: pipelineBindPoint,
    inputAttachmentCount: len(inputAttachments).uint32,
    pInputAttachments: if len(inputAttachments) == 0: nil else: cast[ptr VkAttachmentReference](inputAttachments),
    colorAttachmentCount: len(colorAttachments).uint32,
    pColorAttachments: if len(colorAttachments) == 0: nil else: cast[ptr VkAttachmentReference](colorAttachments),
    pResolveAttachments: if len(resolveAttachments) == 0: nil else: cast[ptr VkAttachmentReference](resolveAttachments),
    pDepthStencilAttachment: pDepthStencilAttachment,
    preserveAttachmentCount: len(preserveAttachments).uint32,
    pPreserveAttachments: if len(preserveAttachments) == 0: nil else: cast[ptr uint32](preserveAttachments),
  )

proc newVkSubpassDependency*(srcSubpass: uint32, dstSubpass: uint32, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, srcAccessMask: VkAccessFlags, dstAccessMask: VkAccessFlags, dependencyFlags: VkDependencyFlags): VkSubpassDependency =
  result = VkSubpassDependency(
    srcSubpass: srcSubpass,
    dstSubpass: dstSubpass,
    srcStageMask: srcStageMask,
    dstStageMask: dstStageMask,
    srcAccessMask: srcAccessMask,
    dstAccessMask: dstAccessMask,
    dependencyFlags: dependencyFlags,
  )

proc newVkRenderPassCreateInfo*(sType: VkStructureType = VkStructureType.RenderPassCreateInfo, pNext: pointer = nil, flags: VkRenderPassCreateFlags = 0.VkRenderPassCreateFlags, attachments: openarray[VkAttachmentDescription], subpasses: openarray[VkSubpassDescription], dependencies: openarray[VkSubpassDependency]): VkRenderPassCreateInfo =
  result = VkRenderPassCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    attachmentCount: len(attachments).uint32,
    pAttachments: if len(attachments) == 0: nil else: cast[ptr VkAttachmentDescription](attachments),
    subpassCount: len(subpasses).uint32,
    pSubpasses: if len(subpasses) == 0: nil else: cast[ptr VkSubpassDescription](subpasses),
    dependencyCount: len(dependencies).uint32,
    pDependencies: if len(dependencies) == 0: nil else: cast[ptr VkSubpassDependency](dependencies),
  )

proc newVkEventCreateInfo*(sType: VkStructureType = VkStructureType.EventCreateInfo, pNext: pointer = nil, flags: VkEventCreateFlags = 0.VkEventCreateFlags): VkEventCreateInfo =
  result = VkEventCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkFenceCreateInfo*(sType: VkStructureType = VkStructureType.FenceCreateInfo, pNext: pointer = nil, flags: VkFenceCreateFlags = 0.VkFenceCreateFlags): VkFenceCreateInfo =
  result = VkFenceCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkPhysicalDeviceFeatures*(robustBufferAccess: VkBool32, fullDrawIndexUint32: VkBool32, imageCubeArray: VkBool32, independentBlend: VkBool32, geometryShader: VkBool32, tessellationShader: VkBool32, sampleRateShading: VkBool32, dualSrcBlend: VkBool32, logicOp: VkBool32, multiDrawIndirect: VkBool32, drawIndirectFirstInstance: VkBool32, depthClamp: VkBool32, depthBiasClamp: VkBool32, fillModeNonSolid: VkBool32, depthBounds: VkBool32, wideLines: VkBool32, largePoints: VkBool32, alphaToOne: VkBool32, multiViewport: VkBool32, samplerAnisotropy: VkBool32, textureCompressionETC2: VkBool32, textureCompressionASTC_LDR: VkBool32, textureCompressionBC: VkBool32, occlusionQueryPrecise: VkBool32, pipelineStatisticsQuery: VkBool32, vertexPipelineStoresAndAtomics: VkBool32, fragmentStoresAndAtomics: VkBool32, shaderTessellationAndGeometryPointSize: VkBool32, shaderImageGatherExtended: VkBool32, shaderStorageImageExtendedFormats: VkBool32, shaderStorageImageMultisample: VkBool32, shaderStorageImageReadWithoutFormat: VkBool32, shaderStorageImageWriteWithoutFormat: VkBool32, shaderUniformBufferArrayDynamicIndexing: VkBool32, shaderSampledImageArrayDynamicIndexing: VkBool32, shaderStorageBufferArrayDynamicIndexing: VkBool32, shaderStorageImageArrayDynamicIndexing: VkBool32, shaderClipDistance: VkBool32, shaderCullDistance: VkBool32, shaderFloat64: VkBool32, shaderInt64: VkBool32, shaderInt16: VkBool32, shaderResourceResidency: VkBool32, shaderResourceMinLod: VkBool32, sparseBinding: VkBool32, sparseResidencyBuffer: VkBool32, sparseResidencyImage2D: VkBool32, sparseResidencyImage3D: VkBool32, sparseResidency2Samples: VkBool32, sparseResidency4Samples: VkBool32, sparseResidency8Samples: VkBool32, sparseResidency16Samples: VkBool32, sparseResidencyAliased: VkBool32, variableMultisampleRate: VkBool32, inheritedQueries: VkBool32): VkPhysicalDeviceFeatures =
  result = VkPhysicalDeviceFeatures(
    robustBufferAccess: robustBufferAccess,
    fullDrawIndexUint32: fullDrawIndexUint32,
    imageCubeArray: imageCubeArray,
    independentBlend: independentBlend,
    geometryShader: geometryShader,
    tessellationShader: tessellationShader,
    sampleRateShading: sampleRateShading,
    dualSrcBlend: dualSrcBlend,
    logicOp: logicOp,
    multiDrawIndirect: multiDrawIndirect,
    drawIndirectFirstInstance: drawIndirectFirstInstance,
    depthClamp: depthClamp,
    depthBiasClamp: depthBiasClamp,
    fillModeNonSolid: fillModeNonSolid,
    depthBounds: depthBounds,
    wideLines: wideLines,
    largePoints: largePoints,
    alphaToOne: alphaToOne,
    multiViewport: multiViewport,
    samplerAnisotropy: samplerAnisotropy,
    textureCompressionETC2: textureCompressionETC2,
    textureCompressionASTC_LDR: textureCompressionASTC_LDR,
    textureCompressionBC: textureCompressionBC,
    occlusionQueryPrecise: occlusionQueryPrecise,
    pipelineStatisticsQuery: pipelineStatisticsQuery,
    vertexPipelineStoresAndAtomics: vertexPipelineStoresAndAtomics,
    fragmentStoresAndAtomics: fragmentStoresAndAtomics,
    shaderTessellationAndGeometryPointSize: shaderTessellationAndGeometryPointSize,
    shaderImageGatherExtended: shaderImageGatherExtended,
    shaderStorageImageExtendedFormats: shaderStorageImageExtendedFormats,
    shaderStorageImageMultisample: shaderStorageImageMultisample,
    shaderStorageImageReadWithoutFormat: shaderStorageImageReadWithoutFormat,
    shaderStorageImageWriteWithoutFormat: shaderStorageImageWriteWithoutFormat,
    shaderUniformBufferArrayDynamicIndexing: shaderUniformBufferArrayDynamicIndexing,
    shaderSampledImageArrayDynamicIndexing: shaderSampledImageArrayDynamicIndexing,
    shaderStorageBufferArrayDynamicIndexing: shaderStorageBufferArrayDynamicIndexing,
    shaderStorageImageArrayDynamicIndexing: shaderStorageImageArrayDynamicIndexing,
    shaderClipDistance: shaderClipDistance,
    shaderCullDistance: shaderCullDistance,
    shaderFloat64: shaderFloat64,
    shaderInt64: shaderInt64,
    shaderInt16: shaderInt16,
    shaderResourceResidency: shaderResourceResidency,
    shaderResourceMinLod: shaderResourceMinLod,
    sparseBinding: sparseBinding,
    sparseResidencyBuffer: sparseResidencyBuffer,
    sparseResidencyImage2D: sparseResidencyImage2D,
    sparseResidencyImage3D: sparseResidencyImage3D,
    sparseResidency2Samples: sparseResidency2Samples,
    sparseResidency4Samples: sparseResidency4Samples,
    sparseResidency8Samples: sparseResidency8Samples,
    sparseResidency16Samples: sparseResidency16Samples,
    sparseResidencyAliased: sparseResidencyAliased,
    variableMultisampleRate: variableMultisampleRate,
    inheritedQueries: inheritedQueries,
  )

proc newVkPhysicalDeviceSparseProperties*(residencyStandard2DBlockShape: VkBool32, residencyStandard2DMultisampleBlockShape: VkBool32, residencyStandard3DBlockShape: VkBool32, residencyAlignedMipSize: VkBool32, residencyNonResidentStrict: VkBool32): VkPhysicalDeviceSparseProperties =
  result = VkPhysicalDeviceSparseProperties(
    residencyStandard2DBlockShape: residencyStandard2DBlockShape,
    residencyStandard2DMultisampleBlockShape: residencyStandard2DMultisampleBlockShape,
    residencyStandard3DBlockShape: residencyStandard3DBlockShape,
    residencyAlignedMipSize: residencyAlignedMipSize,
    residencyNonResidentStrict: residencyNonResidentStrict,
  )

proc newVkPhysicalDeviceLimits*(maxImageDimension1D: uint32, maxImageDimension2D: uint32, maxImageDimension3D: uint32, maxImageDimensionCube: uint32, maxImageArrayLayers: uint32, maxTexelBufferElements: uint32, maxUniformBufferRange: uint32, maxStorageBufferRange: uint32, maxPushConstantsSize: uint32, maxMemoryAllocationCount: uint32, maxSamplerAllocationCount: uint32, bufferImageGranularity: VkDeviceSize, sparseAddressSpaceSize: VkDeviceSize, maxBoundDescriptorSets: uint32, maxPerStageDescriptorSamplers: uint32, maxPerStageDescriptorUniformBuffers: uint32, maxPerStageDescriptorStorageBuffers: uint32, maxPerStageDescriptorSampledImages: uint32, maxPerStageDescriptorStorageImages: uint32, maxPerStageDescriptorInputAttachments: uint32, maxPerStageResources: uint32, maxDescriptorSetSamplers: uint32, maxDescriptorSetUniformBuffers: uint32, maxDescriptorSetUniformBuffersDynamic: uint32, maxDescriptorSetStorageBuffers: uint32, maxDescriptorSetStorageBuffersDynamic: uint32, maxDescriptorSetSampledImages: uint32, maxDescriptorSetStorageImages: uint32, maxDescriptorSetInputAttachments: uint32, maxVertexInputAttributes: uint32, maxVertexInputBindings: uint32, maxVertexInputAttributeOffset: uint32, maxVertexInputBindingStride: uint32, maxVertexOutputComponents: uint32, maxTessellationGenerationLevel: uint32, maxTessellationPatchSize: uint32, maxTessellationControlPerVertexInputComponents: uint32, maxTessellationControlPerVertexOutputComponents: uint32, maxTessellationControlPerPatchOutputComponents: uint32, maxTessellationControlTotalOutputComponents: uint32, maxTessellationEvaluationInputComponents: uint32, maxTessellationEvaluationOutputComponents: uint32, maxGeometryShaderInvocations: uint32, maxGeometryInputComponents: uint32, maxGeometryOutputComponents: uint32, maxGeometryOutputVertices: uint32, maxGeometryTotalOutputComponents: uint32, maxFragmentInputComponents: uint32, maxFragmentOutputAttachments: uint32, maxFragmentDualSrcAttachments: uint32, maxFragmentCombinedOutputResources: uint32, maxComputeSharedMemorySize: uint32, maxComputeWorkGroupCount: array[3, uint32], maxComputeWorkGroupInvocations: uint32, maxComputeWorkGroupSize: array[3, uint32], subPixelPrecisionBits: uint32, subTexelPrecisionBits: uint32, mipmapPrecisionBits: uint32, maxDrawIndexedIndexValue: uint32, maxDrawIndirectCount: uint32, maxSamplerLodBias: float32, maxSamplerAnisotropy: float32, maxViewports: uint32, maxViewportDimensions: array[2, uint32], viewportBoundsRange: array[2, float32], viewportSubPixelBits: uint32, minMemoryMapAlignment: uint, minTexelBufferOffsetAlignment: VkDeviceSize, minUniformBufferOffsetAlignment: VkDeviceSize, minStorageBufferOffsetAlignment: VkDeviceSize, minTexelOffset: int32, maxTexelOffset: uint32, minTexelGatherOffset: int32, maxTexelGatherOffset: uint32, minInterpolationOffset: float32, maxInterpolationOffset: float32, subPixelInterpolationOffsetBits: uint32, maxFramebufferWidth: uint32, maxFramebufferHeight: uint32, maxFramebufferLayers: uint32, framebufferColorSampleCounts: VkSampleCountFlags, framebufferDepthSampleCounts: VkSampleCountFlags, framebufferStencilSampleCounts: VkSampleCountFlags, framebufferNoAttachmentsSampleCounts: VkSampleCountFlags, maxColorAttachments: uint32, sampledImageColorSampleCounts: VkSampleCountFlags, sampledImageIntegerSampleCounts: VkSampleCountFlags, sampledImageDepthSampleCounts: VkSampleCountFlags, sampledImageStencilSampleCounts: VkSampleCountFlags, storageImageSampleCounts: VkSampleCountFlags, maxSampleMaskWords: uint32, timestampComputeAndGraphics: VkBool32, timestampPeriod: float32, maxClipDistances: uint32, maxCullDistances: uint32, maxCombinedClipAndCullDistances: uint32, discreteQueuePriorities: uint32, pointSizeRange: array[2, float32], lineWidthRange: array[2, float32], pointSizeGranularity: float32, lineWidthGranularity: float32, strictLines: VkBool32, standardSampleLocations: VkBool32, optimalBufferCopyOffsetAlignment: VkDeviceSize, optimalBufferCopyRowPitchAlignment: VkDeviceSize, nonCoherentAtomSize: VkDeviceSize): VkPhysicalDeviceLimits =
  result = VkPhysicalDeviceLimits(
    maxImageDimension1D: maxImageDimension1D,
    maxImageDimension2D: maxImageDimension2D,
    maxImageDimension3D: maxImageDimension3D,
    maxImageDimensionCube: maxImageDimensionCube,
    maxImageArrayLayers: maxImageArrayLayers,
    maxTexelBufferElements: maxTexelBufferElements,
    maxUniformBufferRange: maxUniformBufferRange,
    maxStorageBufferRange: maxStorageBufferRange,
    maxPushConstantsSize: maxPushConstantsSize,
    maxMemoryAllocationCount: maxMemoryAllocationCount,
    maxSamplerAllocationCount: maxSamplerAllocationCount,
    bufferImageGranularity: bufferImageGranularity,
    sparseAddressSpaceSize: sparseAddressSpaceSize,
    maxBoundDescriptorSets: maxBoundDescriptorSets,
    maxPerStageDescriptorSamplers: maxPerStageDescriptorSamplers,
    maxPerStageDescriptorUniformBuffers: maxPerStageDescriptorUniformBuffers,
    maxPerStageDescriptorStorageBuffers: maxPerStageDescriptorStorageBuffers,
    maxPerStageDescriptorSampledImages: maxPerStageDescriptorSampledImages,
    maxPerStageDescriptorStorageImages: maxPerStageDescriptorStorageImages,
    maxPerStageDescriptorInputAttachments: maxPerStageDescriptorInputAttachments,
    maxPerStageResources: maxPerStageResources,
    maxDescriptorSetSamplers: maxDescriptorSetSamplers,
    maxDescriptorSetUniformBuffers: maxDescriptorSetUniformBuffers,
    maxDescriptorSetUniformBuffersDynamic: maxDescriptorSetUniformBuffersDynamic,
    maxDescriptorSetStorageBuffers: maxDescriptorSetStorageBuffers,
    maxDescriptorSetStorageBuffersDynamic: maxDescriptorSetStorageBuffersDynamic,
    maxDescriptorSetSampledImages: maxDescriptorSetSampledImages,
    maxDescriptorSetStorageImages: maxDescriptorSetStorageImages,
    maxDescriptorSetInputAttachments: maxDescriptorSetInputAttachments,
    maxVertexInputAttributes: maxVertexInputAttributes,
    maxVertexInputBindings: maxVertexInputBindings,
    maxVertexInputAttributeOffset: maxVertexInputAttributeOffset,
    maxVertexInputBindingStride: maxVertexInputBindingStride,
    maxVertexOutputComponents: maxVertexOutputComponents,
    maxTessellationGenerationLevel: maxTessellationGenerationLevel,
    maxTessellationPatchSize: maxTessellationPatchSize,
    maxTessellationControlPerVertexInputComponents: maxTessellationControlPerVertexInputComponents,
    maxTessellationControlPerVertexOutputComponents: maxTessellationControlPerVertexOutputComponents,
    maxTessellationControlPerPatchOutputComponents: maxTessellationControlPerPatchOutputComponents,
    maxTessellationControlTotalOutputComponents: maxTessellationControlTotalOutputComponents,
    maxTessellationEvaluationInputComponents: maxTessellationEvaluationInputComponents,
    maxTessellationEvaluationOutputComponents: maxTessellationEvaluationOutputComponents,
    maxGeometryShaderInvocations: maxGeometryShaderInvocations,
    maxGeometryInputComponents: maxGeometryInputComponents,
    maxGeometryOutputComponents: maxGeometryOutputComponents,
    maxGeometryOutputVertices: maxGeometryOutputVertices,
    maxGeometryTotalOutputComponents: maxGeometryTotalOutputComponents,
    maxFragmentInputComponents: maxFragmentInputComponents,
    maxFragmentOutputAttachments: maxFragmentOutputAttachments,
    maxFragmentDualSrcAttachments: maxFragmentDualSrcAttachments,
    maxFragmentCombinedOutputResources: maxFragmentCombinedOutputResources,
    maxComputeSharedMemorySize: maxComputeSharedMemorySize,
    maxComputeWorkGroupCount: maxComputeWorkGroupCount,
    maxComputeWorkGroupInvocations: maxComputeWorkGroupInvocations,
    maxComputeWorkGroupSize: maxComputeWorkGroupSize,
    subPixelPrecisionBits: subPixelPrecisionBits,
    subTexelPrecisionBits: subTexelPrecisionBits,
    mipmapPrecisionBits: mipmapPrecisionBits,
    maxDrawIndexedIndexValue: maxDrawIndexedIndexValue,
    maxDrawIndirectCount: maxDrawIndirectCount,
    maxSamplerLodBias: maxSamplerLodBias,
    maxSamplerAnisotropy: maxSamplerAnisotropy,
    maxViewports: maxViewports,
    maxViewportDimensions: maxViewportDimensions,
    viewportBoundsRange: viewportBoundsRange,
    viewportSubPixelBits: viewportSubPixelBits,
    minMemoryMapAlignment: minMemoryMapAlignment,
    minTexelBufferOffsetAlignment: minTexelBufferOffsetAlignment,
    minUniformBufferOffsetAlignment: minUniformBufferOffsetAlignment,
    minStorageBufferOffsetAlignment: minStorageBufferOffsetAlignment,
    minTexelOffset: minTexelOffset,
    maxTexelOffset: maxTexelOffset,
    minTexelGatherOffset: minTexelGatherOffset,
    maxTexelGatherOffset: maxTexelGatherOffset,
    minInterpolationOffset: minInterpolationOffset,
    maxInterpolationOffset: maxInterpolationOffset,
    subPixelInterpolationOffsetBits: subPixelInterpolationOffsetBits,
    maxFramebufferWidth: maxFramebufferWidth,
    maxFramebufferHeight: maxFramebufferHeight,
    maxFramebufferLayers: maxFramebufferLayers,
    framebufferColorSampleCounts: framebufferColorSampleCounts,
    framebufferDepthSampleCounts: framebufferDepthSampleCounts,
    framebufferStencilSampleCounts: framebufferStencilSampleCounts,
    framebufferNoAttachmentsSampleCounts: framebufferNoAttachmentsSampleCounts,
    maxColorAttachments: maxColorAttachments,
    sampledImageColorSampleCounts: sampledImageColorSampleCounts,
    sampledImageIntegerSampleCounts: sampledImageIntegerSampleCounts,
    sampledImageDepthSampleCounts: sampledImageDepthSampleCounts,
    sampledImageStencilSampleCounts: sampledImageStencilSampleCounts,
    storageImageSampleCounts: storageImageSampleCounts,
    maxSampleMaskWords: maxSampleMaskWords,
    timestampComputeAndGraphics: timestampComputeAndGraphics,
    timestampPeriod: timestampPeriod,
    maxClipDistances: maxClipDistances,
    maxCullDistances: maxCullDistances,
    maxCombinedClipAndCullDistances: maxCombinedClipAndCullDistances,
    discreteQueuePriorities: discreteQueuePriorities,
    pointSizeRange: pointSizeRange,
    lineWidthRange: lineWidthRange,
    pointSizeGranularity: pointSizeGranularity,
    lineWidthGranularity: lineWidthGranularity,
    strictLines: strictLines,
    standardSampleLocations: standardSampleLocations,
    optimalBufferCopyOffsetAlignment: optimalBufferCopyOffsetAlignment,
    optimalBufferCopyRowPitchAlignment: optimalBufferCopyRowPitchAlignment,
    nonCoherentAtomSize: nonCoherentAtomSize,
  )

proc newVkSemaphoreCreateInfo*(sType: VkStructureType = VkStructureType.SemaphoreCreateInfo, pNext: pointer = nil, flags: VkSemaphoreCreateFlags = 0.VkSemaphoreCreateFlags): VkSemaphoreCreateInfo =
  result = VkSemaphoreCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkQueryPoolCreateInfo*(sType: VkStructureType = VkStructureType.QueryPoolCreateInfo, pNext: pointer = nil, flags: VkQueryPoolCreateFlags = 0.VkQueryPoolCreateFlags, queryType: VkQueryType, queryCount: uint32, pipelineStatistics: VkQueryPipelineStatisticFlags): VkQueryPoolCreateInfo =
  result = VkQueryPoolCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    queryType: queryType,
    queryCount: queryCount,
    pipelineStatistics: pipelineStatistics,
  )

proc newVkFramebufferCreateInfo*(sType: VkStructureType = VkStructureType.FramebufferCreateInfo, pNext: pointer = nil, flags: VkFramebufferCreateFlags = 0.VkFramebufferCreateFlags, renderPass: VkRenderPass, attachments: openarray[VkImageView], width: uint32, height: uint32, layers: uint32): VkFramebufferCreateInfo =
  result = VkFramebufferCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    renderPass: renderPass,
    attachmentCount: len(attachments).uint32,
    pAttachments: if len(attachments) == 0: nil else: cast[ptr VkImageView](attachments),
    width: width,
    height: height,
    layers: layers,
  )

proc newVkDrawIndirectCommand*(vertexCount: uint32, instanceCount: uint32, firstVertex: uint32, firstInstance: uint32): VkDrawIndirectCommand =
  result = VkDrawIndirectCommand(
    vertexCount: vertexCount,
    instanceCount: instanceCount,
    firstVertex: firstVertex,
    firstInstance: firstInstance,
  )

proc newVkDrawIndexedIndirectCommand*(indexCount: uint32, instanceCount: uint32, firstIndex: uint32, vertexOffset: int32, firstInstance: uint32): VkDrawIndexedIndirectCommand =
  result = VkDrawIndexedIndirectCommand(
    indexCount: indexCount,
    instanceCount: instanceCount,
    firstIndex: firstIndex,
    vertexOffset: vertexOffset,
    firstInstance: firstInstance,
  )

proc newVkDispatchIndirectCommand*(x: uint32, y: uint32, z: uint32): VkDispatchIndirectCommand =
  result = VkDispatchIndirectCommand(
    x: x,
    y: y,
    z: z,
  )

proc newVkMultiDrawInfoEXT*(firstVertex: uint32, vertexCount: uint32): VkMultiDrawInfoEXT =
  result = VkMultiDrawInfoEXT(
    firstVertex: firstVertex,
    vertexCount: vertexCount,
  )

proc newVkMultiDrawIndexedInfoEXT*(firstIndex: uint32, indexCount: uint32, vertexOffset: int32): VkMultiDrawIndexedInfoEXT =
  result = VkMultiDrawIndexedInfoEXT(
    firstIndex: firstIndex,
    indexCount: indexCount,
    vertexOffset: vertexOffset,
  )

proc newVkSubmitInfo*(sType: VkStructureType = VkStructureType.SubmitInfo, pNext: pointer = nil, waitSemaphores: openarray[VkSemaphore], waitDstStageMask: openarray[VkPipelineStageFlags], commandBuffers: openarray[VkCommandBuffer], signalSemaphores: openarray[VkSemaphore]): VkSubmitInfo =
  result = VkSubmitInfo(
    sType: sType,
    pNext: pNext,
    waitSemaphoreCount: len(waitSemaphores).uint32,
    pWaitSemaphores: if len(waitSemaphores) == 0: nil else: cast[ptr VkSemaphore](waitSemaphores),
    pWaitDstStageMask: if len(waitDstStageMask) == 0: nil else: cast[ptr VkPipelineStageFlags](waitDstStageMask),
    commandBufferCount: len(commandBuffers).uint32,
    pCommandBuffers: if len(commandBuffers) == 0: nil else: cast[ptr VkCommandBuffer](commandBuffers),
    signalSemaphoreCount: len(signalSemaphores).uint32,
    pSignalSemaphores: if len(signalSemaphores) == 0: nil else: cast[ptr VkSemaphore](signalSemaphores),
  )

proc newVkDisplayPropertiesKHR*(display: VkDisplayKHR, displayName: cstring, physicalDimensions: VkExtent2D, physicalResolution: VkExtent2D, supportedTransforms: VkSurfaceTransformFlagsKHR, planeReorderPossible: VkBool32, persistentContent: VkBool32): VkDisplayPropertiesKHR =
  result = VkDisplayPropertiesKHR(
    display: display,
    displayName: displayName,
    physicalDimensions: physicalDimensions,
    physicalResolution: physicalResolution,
    supportedTransforms: supportedTransforms,
    planeReorderPossible: planeReorderPossible,
    persistentContent: persistentContent,
  )

proc newVkDisplayPlanePropertiesKHR*(currentDisplay: VkDisplayKHR, currentStackIndex: uint32): VkDisplayPlanePropertiesKHR =
  result = VkDisplayPlanePropertiesKHR(
    currentDisplay: currentDisplay,
    currentStackIndex: currentStackIndex,
  )

proc newVkDisplayModeParametersKHR*(visibleRegion: VkExtent2D, refreshRate: uint32): VkDisplayModeParametersKHR =
  result = VkDisplayModeParametersKHR(
    visibleRegion: visibleRegion,
    refreshRate: refreshRate,
  )

proc newVkDisplayModePropertiesKHR*(displayMode: VkDisplayModeKHR, parameters: VkDisplayModeParametersKHR): VkDisplayModePropertiesKHR =
  result = VkDisplayModePropertiesKHR(
    displayMode: displayMode,
    parameters: parameters,
  )

proc newVkDisplayModeCreateInfoKHR*(sType: VkStructureType = VkStructureType.DisplayModeCreateInfoKHR, pNext: pointer = nil, flags: VkDisplayModeCreateFlagsKHR = 0.VkDisplayModeCreateFlagsKHR, parameters: VkDisplayModeParametersKHR): VkDisplayModeCreateInfoKHR =
  result = VkDisplayModeCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    parameters: parameters,
  )

proc newVkDisplayPlaneCapabilitiesKHR*(supportedAlpha: VkDisplayPlaneAlphaFlagsKHR, minSrcPosition: VkOffset2D, maxSrcPosition: VkOffset2D, minSrcExtent: VkExtent2D, maxSrcExtent: VkExtent2D, minDstPosition: VkOffset2D, maxDstPosition: VkOffset2D, minDstExtent: VkExtent2D, maxDstExtent: VkExtent2D): VkDisplayPlaneCapabilitiesKHR =
  result = VkDisplayPlaneCapabilitiesKHR(
    supportedAlpha: supportedAlpha,
    minSrcPosition: minSrcPosition,
    maxSrcPosition: maxSrcPosition,
    minSrcExtent: minSrcExtent,
    maxSrcExtent: maxSrcExtent,
    minDstPosition: minDstPosition,
    maxDstPosition: maxDstPosition,
    minDstExtent: minDstExtent,
    maxDstExtent: maxDstExtent,
  )

proc newVkDisplaySurfaceCreateInfoKHR*(sType: VkStructureType = VkStructureType.DisplaySurfaceCreateInfoKHR, pNext: pointer = nil, flags: VkDisplaySurfaceCreateFlagsKHR = 0.VkDisplaySurfaceCreateFlagsKHR, displayMode: VkDisplayModeKHR, planeIndex: uint32, planeStackIndex: uint32, transform: VkSurfaceTransformFlagBitsKHR, globalAlpha: float32, alphaMode: VkDisplayPlaneAlphaFlagBitsKHR, imageExtent: VkExtent2D): VkDisplaySurfaceCreateInfoKHR =
  result = VkDisplaySurfaceCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    displayMode: displayMode,
    planeIndex: planeIndex,
    planeStackIndex: planeStackIndex,
    transform: transform,
    globalAlpha: globalAlpha,
    alphaMode: alphaMode,
    imageExtent: imageExtent,
  )

proc newVkDisplaySurfaceStereoCreateInfoNV*(sType: VkStructureType = VkStructureType.DisplaySurfaceStereoCreateInfoNV, pNext: pointer = nil, stereoType: VkDisplaySurfaceStereoTypeNV): VkDisplaySurfaceStereoCreateInfoNV =
  result = VkDisplaySurfaceStereoCreateInfoNV(
    sType: sType,
    pNext: pNext,
    stereoType: stereoType,
  )

proc newVkDisplayPresentInfoKHR*(sType: VkStructureType = VkStructureType.DisplayPresentInfoKHR, pNext: pointer = nil, srcRect: VkRect2D, dstRect: VkRect2D, persistent: VkBool32): VkDisplayPresentInfoKHR =
  result = VkDisplayPresentInfoKHR(
    sType: sType,
    pNext: pNext,
    srcRect: srcRect,
    dstRect: dstRect,
    persistent: persistent,
  )

proc newVkSurfaceCapabilitiesKHR*(minImageCount: uint32, maxImageCount: uint32, currentExtent: VkExtent2D, minImageExtent: VkExtent2D, maxImageExtent: VkExtent2D, maxImageArrayLayers: uint32, supportedTransforms: VkSurfaceTransformFlagsKHR, currentTransform: VkSurfaceTransformFlagBitsKHR, supportedCompositeAlpha: VkCompositeAlphaFlagsKHR, supportedUsageFlags: VkImageUsageFlags): VkSurfaceCapabilitiesKHR =
  result = VkSurfaceCapabilitiesKHR(
    minImageCount: minImageCount,
    maxImageCount: maxImageCount,
    currentExtent: currentExtent,
    minImageExtent: minImageExtent,
    maxImageExtent: maxImageExtent,
    maxImageArrayLayers: maxImageArrayLayers,
    supportedTransforms: supportedTransforms,
    currentTransform: currentTransform,
    supportedCompositeAlpha: supportedCompositeAlpha,
    supportedUsageFlags: supportedUsageFlags,
  )

proc newVkAndroidSurfaceCreateInfoKHR*(sType: VkStructureType = VkStructureType.AndroidSurfaceCreateInfoKHR, pNext: pointer = nil, flags: VkAndroidSurfaceCreateFlagsKHR = 0.VkAndroidSurfaceCreateFlagsKHR, window: ptr ANativeWindow): VkAndroidSurfaceCreateInfoKHR =
  result = VkAndroidSurfaceCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    window: window,
  )

proc newVkViSurfaceCreateInfoNN*(sType: VkStructureType = VkStructureType.ViSurfaceCreateInfoNN, pNext: pointer = nil, flags: VkViSurfaceCreateFlagsNN = 0.VkViSurfaceCreateFlagsNN, window: pointer = nil): VkViSurfaceCreateInfoNN =
  result = VkViSurfaceCreateInfoNN(
    sType: sType,
    pNext: pNext,
    flags: flags,
    window: window,
  )

proc newVkWaylandSurfaceCreateInfoKHR*(sType: VkStructureType = VkStructureType.WaylandSurfaceCreateInfoKHR, pNext: pointer = nil, flags: VkWaylandSurfaceCreateFlagsKHR = 0.VkWaylandSurfaceCreateFlagsKHR, display: ptr wl_display, surface: ptr wl_surface): VkWaylandSurfaceCreateInfoKHR =
  result = VkWaylandSurfaceCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    display: display,
    surface: surface,
  )

proc newVkUbmSurfaceCreateInfoSEC*(sType: VkStructureType = VkStructureType.UbmSurfaceCreateInfoSEC, pNext: pointer = nil, flags: VkUbmSurfaceCreateFlagsSEC = 0.VkUbmSurfaceCreateFlagsSEC, device: ptr ubm_device, surface: ptr ubm_surface): VkUbmSurfaceCreateInfoSEC =
  result = VkUbmSurfaceCreateInfoSEC(
    sType: sType,
    pNext: pNext,
    flags: flags,
    device: device,
    surface: surface,
  )

proc newVkWin32SurfaceCreateInfoKHR*(sType: VkStructureType = VkStructureType.Win32SurfaceCreateInfoKHR, pNext: pointer = nil, flags: VkWin32SurfaceCreateFlagsKHR = 0.VkWin32SurfaceCreateFlagsKHR, hinstance: HINSTANCE, hwnd: HWND): VkWin32SurfaceCreateInfoKHR =
  result = VkWin32SurfaceCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    hinstance: hinstance,
    hwnd: hwnd,
  )

proc newVkXlibSurfaceCreateInfoKHR*(sType: VkStructureType = VkStructureType.XlibSurfaceCreateInfoKHR, pNext: pointer = nil, flags: VkXlibSurfaceCreateFlagsKHR = 0.VkXlibSurfaceCreateFlagsKHR, dpy: ptr Display, window: Window): VkXlibSurfaceCreateInfoKHR =
  result = VkXlibSurfaceCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    dpy: dpy,
    window: window,
  )

proc newVkXcbSurfaceCreateInfoKHR*(sType: VkStructureType = VkStructureType.XcbSurfaceCreateInfoKHR, pNext: pointer = nil, flags: VkXcbSurfaceCreateFlagsKHR = 0.VkXcbSurfaceCreateFlagsKHR, connection: ptr xcb_connection_t, window: xcb_window_t): VkXcbSurfaceCreateInfoKHR =
  result = VkXcbSurfaceCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    connection: connection,
    window: window,
  )

proc newVkDirectFBSurfaceCreateInfoEXT*(sType: VkStructureType = VkStructureType.DirectFBSurfaceCreateInfoEXT, pNext: pointer = nil, flags: VkDirectFBSurfaceCreateFlagsEXT = 0.VkDirectFBSurfaceCreateFlagsEXT, dfb: ptr IDirectFB, surface: ptr IDirectFBSurface): VkDirectFBSurfaceCreateInfoEXT =
  result = VkDirectFBSurfaceCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    dfb: dfb,
    surface: surface,
  )

proc newVkImagePipeSurfaceCreateInfoFUCHSIA*(sType: VkStructureType = VkStructureType.ImagePipeSurfaceCreateInfoFUCHSIA, pNext: pointer = nil, flags: VkImagePipeSurfaceCreateFlagsFUCHSIA = 0.VkImagePipeSurfaceCreateFlagsFUCHSIA, imagePipeHandle: zx_handle_t): VkImagePipeSurfaceCreateInfoFUCHSIA =
  result = VkImagePipeSurfaceCreateInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    flags: flags,
    imagePipeHandle: imagePipeHandle,
  )

proc newVkStreamDescriptorSurfaceCreateInfoGGP*(sType: VkStructureType = VkStructureType.StreamDescriptorSurfaceCreateInfoGGP, pNext: pointer = nil, flags: VkStreamDescriptorSurfaceCreateFlagsGGP = 0.VkStreamDescriptorSurfaceCreateFlagsGGP, streamDescriptor: GgpStreamDescriptor): VkStreamDescriptorSurfaceCreateInfoGGP =
  result = VkStreamDescriptorSurfaceCreateInfoGGP(
    sType: sType,
    pNext: pNext,
    flags: flags,
    streamDescriptor: streamDescriptor,
  )

proc newVkScreenSurfaceCreateInfoQNX*(sType: VkStructureType = VkStructureType.ScreenSurfaceCreateInfoQNX, pNext: pointer = nil, flags: VkScreenSurfaceCreateFlagsQNX = 0.VkScreenSurfaceCreateFlagsQNX, context: ptr screen_context, window: ptr screen_window): VkScreenSurfaceCreateInfoQNX =
  result = VkScreenSurfaceCreateInfoQNX(
    sType: sType,
    pNext: pNext,
    flags: flags,
    context: context,
    window: window,
  )

proc newVkSurfaceFormatKHR*(format: VkFormat, colorSpace: VkColorSpaceKHR): VkSurfaceFormatKHR =
  result = VkSurfaceFormatKHR(
    format: format,
    colorSpace: colorSpace,
  )

proc newVkSwapchainCreateInfoKHR*(sType: VkStructureType = VkStructureType.SwapchainCreateInfoKHR, pNext: pointer = nil, flags: VkSwapchainCreateFlagsKHR = 0.VkSwapchainCreateFlagsKHR, surface: VkSurfaceKHR, minImageCount: uint32, imageFormat: VkFormat, imageColorSpace: VkColorSpaceKHR, imageExtent: VkExtent2D, imageArrayLayers: uint32, imageUsage: VkImageUsageFlags, imageSharingMode: VkSharingMode, queueFamilyIndices: openarray[uint32], preTransform: VkSurfaceTransformFlagBitsKHR, compositeAlpha: VkCompositeAlphaFlagBitsKHR, presentMode: VkPresentModeKHR, clipped: VkBool32, oldSwapchain: VkSwapchainKHR): VkSwapchainCreateInfoKHR =
  result = VkSwapchainCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    surface: surface,
    minImageCount: minImageCount,
    imageFormat: imageFormat,
    imageColorSpace: imageColorSpace,
    imageExtent: imageExtent,
    imageArrayLayers: imageArrayLayers,
    imageUsage: imageUsage,
    imageSharingMode: imageSharingMode,
    queueFamilyIndexCount: len(queueFamilyIndices).uint32,
    pQueueFamilyIndices: if len(queueFamilyIndices) == 0: nil else: cast[ptr uint32](queueFamilyIndices),
    preTransform: preTransform,
    compositeAlpha: compositeAlpha,
    presentMode: presentMode,
    clipped: clipped,
    oldSwapchain: oldSwapchain,
  )

proc newVkPresentInfoKHR*(sType: VkStructureType = VkStructureType.PresentInfoKHR, pNext: pointer = nil, waitSemaphores: openarray[VkSemaphore], swapchains: openarray[VkSwapchainKHR], imageIndices: openarray[uint32], results: openarray[VkResult]): VkPresentInfoKHR =
  result = VkPresentInfoKHR(
    sType: sType,
    pNext: pNext,
    waitSemaphoreCount: len(waitSemaphores).uint32,
    pWaitSemaphores: if len(waitSemaphores) == 0: nil else: cast[ptr VkSemaphore](waitSemaphores),
    swapchainCount: len(swapchains).uint32,
    pSwapchains: if len(swapchains) == 0: nil else: cast[ptr VkSwapchainKHR](swapchains),
    pImageIndices: if len(imageIndices) == 0: nil else: cast[ptr uint32](imageIndices),
    pResults: if len(results) == 0: nil else: cast[ptr VkResult](results),
  )

proc newVkDebugReportCallbackCreateInfoEXT*(sType: VkStructureType = VkStructureType.DebugReportCallbackCreateInfoEXT, pNext: pointer = nil, flags: VkDebugReportFlagsEXT = 0.VkDebugReportFlagsEXT, pfnCallback: PFN_vkDebugReportCallbackEXT, pUserData: pointer = nil): VkDebugReportCallbackCreateInfoEXT =
  result = VkDebugReportCallbackCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pfnCallback: pfnCallback,
    pUserData: pUserData,
  )

proc newVkValidationFlagsEXT*(sType: VkStructureType = VkStructureType.ValidationFlagsEXT, pNext: pointer = nil, disabledValidationChecks: openarray[VkValidationCheckEXT]): VkValidationFlagsEXT =
  result = VkValidationFlagsEXT(
    sType: sType,
    pNext: pNext,
    disabledValidationCheckCount: len(disabledValidationChecks).uint32,
    pDisabledValidationChecks: if len(disabledValidationChecks) == 0: nil else: cast[ptr VkValidationCheckEXT](disabledValidationChecks),
  )

proc newVkValidationFeaturesEXT*(sType: VkStructureType = VkStructureType.ValidationFeaturesEXT, pNext: pointer = nil, enabledValidationFeatures: openarray[VkValidationFeatureEnableEXT], disabledValidationFeatures: openarray[VkValidationFeatureDisableEXT]): VkValidationFeaturesEXT =
  result = VkValidationFeaturesEXT(
    sType: sType,
    pNext: pNext,
    enabledValidationFeatureCount: len(enabledValidationFeatures).uint32,
    pEnabledValidationFeatures: if len(enabledValidationFeatures) == 0: nil else: cast[ptr VkValidationFeatureEnableEXT](enabledValidationFeatures),
    disabledValidationFeatureCount: len(disabledValidationFeatures).uint32,
    pDisabledValidationFeatures: if len(disabledValidationFeatures) == 0: nil else: cast[ptr VkValidationFeatureDisableEXT](disabledValidationFeatures),
  )

proc newVkLayerSettingsCreateInfoEXT*(sType: VkStructureType = VkStructureType.LayerSettingsCreateInfoEXT, pNext: pointer = nil, settings: openarray[VkLayerSettingEXT]): VkLayerSettingsCreateInfoEXT =
  result = VkLayerSettingsCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    settingCount: len(settings).uint32,
    pSettings: if len(settings) == 0: nil else: cast[ptr VkLayerSettingEXT](settings),
  )

proc newVkLayerSettingEXT*(pLayerName: cstring, pSettingName: cstring, `type`: VkLayerSettingTypeEXT, valueCount: uint32, pValues: pointer = nil): VkLayerSettingEXT =
  result = VkLayerSettingEXT(
    pLayerName: pLayerName,
    pSettingName: pSettingName,
    `type`: `type`,
    valueCount: valueCount,
    pValues: pValues,
  )

proc newVkApplicationParametersEXT*(sType: VkStructureType = VkStructureType.ApplicationParametersEXT, pNext: pointer = nil, vendorID: uint32, deviceID: uint32, key: uint32, value: uint64): VkApplicationParametersEXT =
  result = VkApplicationParametersEXT(
    sType: sType,
    pNext: pNext,
    vendorID: vendorID,
    deviceID: deviceID,
    key: key,
    value: value,
  )

proc newVkPipelineRasterizationStateRasterizationOrderAMD*(sType: VkStructureType = VkStructureType.PipelineRasterizationStateRasterizationOrderAMD, pNext: pointer = nil, rasterizationOrder: VkRasterizationOrderAMD): VkPipelineRasterizationStateRasterizationOrderAMD =
  result = VkPipelineRasterizationStateRasterizationOrderAMD(
    sType: sType,
    pNext: pNext,
    rasterizationOrder: rasterizationOrder,
  )

proc newVkDebugMarkerObjectNameInfoEXT*(sType: VkStructureType = VkStructureType.DebugMarkerObjectNameInfoEXT, pNext: pointer = nil, objectType: VkDebugReportObjectTypeEXT, `object`: uint64, pObjectName: cstring): VkDebugMarkerObjectNameInfoEXT =
  result = VkDebugMarkerObjectNameInfoEXT(
    sType: sType,
    pNext: pNext,
    objectType: objectType,
    `object`: `object`,
    pObjectName: pObjectName,
  )

proc newVkDebugMarkerObjectTagInfoEXT*(sType: VkStructureType = VkStructureType.DebugMarkerObjectTagInfoEXT, pNext: pointer = nil, objectType: VkDebugReportObjectTypeEXT, `object`: uint64, tagName: uint64, tagSize: uint, pTag: pointer = nil): VkDebugMarkerObjectTagInfoEXT =
  result = VkDebugMarkerObjectTagInfoEXT(
    sType: sType,
    pNext: pNext,
    objectType: objectType,
    `object`: `object`,
    tagName: tagName,
    tagSize: tagSize,
    pTag: pTag,
  )

proc newVkDebugMarkerMarkerInfoEXT*(sType: VkStructureType = VkStructureType.DebugMarkerMarkerInfoEXT, pNext: pointer = nil, pMarkerName: cstring, color: array[4, float32]): VkDebugMarkerMarkerInfoEXT =
  result = VkDebugMarkerMarkerInfoEXT(
    sType: sType,
    pNext: pNext,
    pMarkerName: pMarkerName,
    color: color,
  )

proc newVkDedicatedAllocationImageCreateInfoNV*(sType: VkStructureType = VkStructureType.DedicatedAllocationImageCreateInfoNV, pNext: pointer = nil, dedicatedAllocation: VkBool32): VkDedicatedAllocationImageCreateInfoNV =
  result = VkDedicatedAllocationImageCreateInfoNV(
    sType: sType,
    pNext: pNext,
    dedicatedAllocation: dedicatedAllocation,
  )

proc newVkDedicatedAllocationBufferCreateInfoNV*(sType: VkStructureType = VkStructureType.DedicatedAllocationBufferCreateInfoNV, pNext: pointer = nil, dedicatedAllocation: VkBool32): VkDedicatedAllocationBufferCreateInfoNV =
  result = VkDedicatedAllocationBufferCreateInfoNV(
    sType: sType,
    pNext: pNext,
    dedicatedAllocation: dedicatedAllocation,
  )

proc newVkDedicatedAllocationMemoryAllocateInfoNV*(sType: VkStructureType = VkStructureType.DedicatedAllocationMemoryAllocateInfoNV, pNext: pointer = nil, image: VkImage, buffer: VkBuffer): VkDedicatedAllocationMemoryAllocateInfoNV =
  result = VkDedicatedAllocationMemoryAllocateInfoNV(
    sType: sType,
    pNext: pNext,
    image: image,
    buffer: buffer,
  )

proc newVkExternalImageFormatPropertiesNV*(imageFormatProperties: VkImageFormatProperties, externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV, exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV, compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV): VkExternalImageFormatPropertiesNV =
  result = VkExternalImageFormatPropertiesNV(
    imageFormatProperties: imageFormatProperties,
    externalMemoryFeatures: externalMemoryFeatures,
    exportFromImportedHandleTypes: exportFromImportedHandleTypes,
    compatibleHandleTypes: compatibleHandleTypes,
  )

proc newVkExternalMemoryImageCreateInfoNV*(sType: VkStructureType = VkStructureType.ExternalMemoryImageCreateInfoNV, pNext: pointer = nil, handleTypes: VkExternalMemoryHandleTypeFlagsNV): VkExternalMemoryImageCreateInfoNV =
  result = VkExternalMemoryImageCreateInfoNV(
    sType: sType,
    pNext: pNext,
    handleTypes: handleTypes,
  )

proc newVkExportMemoryAllocateInfoNV*(sType: VkStructureType = VkStructureType.ExportMemoryAllocateInfoNV, pNext: pointer = nil, handleTypes: VkExternalMemoryHandleTypeFlagsNV): VkExportMemoryAllocateInfoNV =
  result = VkExportMemoryAllocateInfoNV(
    sType: sType,
    pNext: pNext,
    handleTypes: handleTypes,
  )

proc newVkImportMemoryWin32HandleInfoNV*(sType: VkStructureType = VkStructureType.ImportMemoryWin32HandleInfoNV, pNext: pointer = nil, handleType: VkExternalMemoryHandleTypeFlagsNV, handle: HANDLE): VkImportMemoryWin32HandleInfoNV =
  result = VkImportMemoryWin32HandleInfoNV(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
    handle: handle,
  )

proc newVkExportMemoryWin32HandleInfoNV*(sType: VkStructureType = VkStructureType.ExportMemoryWin32HandleInfoNV, pNext: pointer = nil, pAttributes: ptr SECURITY_ATTRIBUTES, dwAccess: DWORD): VkExportMemoryWin32HandleInfoNV =
  result = VkExportMemoryWin32HandleInfoNV(
    sType: sType,
    pNext: pNext,
    pAttributes: pAttributes,
    dwAccess: dwAccess,
  )

proc newVkExportMemorySciBufInfoNV*(sType: VkStructureType = VkStructureType.ExportMemorySciBufInfoNV, pNext: pointer = nil, pAttributes: NvSciBufAttrList): VkExportMemorySciBufInfoNV =
  result = VkExportMemorySciBufInfoNV(
    sType: sType,
    pNext: pNext,
    pAttributes: pAttributes,
  )

proc newVkImportMemorySciBufInfoNV*(sType: VkStructureType = VkStructureType.ImportMemorySciBufInfoNV, pNext: pointer = nil, handleType: VkExternalMemoryHandleTypeFlagBits, handle: NvSciBufObj): VkImportMemorySciBufInfoNV =
  result = VkImportMemorySciBufInfoNV(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
    handle: handle,
  )

proc newVkMemoryGetSciBufInfoNV*(sType: VkStructureType = VkStructureType.MemoryGetSciBufInfoNV, pNext: pointer = nil, memory: VkDeviceMemory, handleType: VkExternalMemoryHandleTypeFlagBits): VkMemoryGetSciBufInfoNV =
  result = VkMemoryGetSciBufInfoNV(
    sType: sType,
    pNext: pNext,
    memory: memory,
    handleType: handleType,
  )

proc newVkMemorySciBufPropertiesNV*(sType: VkStructureType = VkStructureType.MemorySciBufPropertiesNV, pNext: pointer = nil, memoryTypeBits: uint32): VkMemorySciBufPropertiesNV =
  result = VkMemorySciBufPropertiesNV(
    sType: sType,
    pNext: pNext,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkPhysicalDeviceExternalMemorySciBufFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalMemorySciBufFeaturesNV, pNext: pointer = nil, sciBufImport: VkBool32, sciBufExport: VkBool32): VkPhysicalDeviceExternalMemorySciBufFeaturesNV =
  result = VkPhysicalDeviceExternalMemorySciBufFeaturesNV(
    sType: sType,
    pNext: pNext,
    sciBufImport: sciBufImport,
    sciBufExport: sciBufExport,
  )

proc newVkWin32KeyedMutexAcquireReleaseInfoNV*(sType: VkStructureType = VkStructureType.Win32KeyedMutexAcquireReleaseInfoNV, pNext: pointer = nil, acquireSyncs: openarray[VkDeviceMemory], acquireKeys: openarray[uint64], acquireTimeoutMilliseconds: openarray[uint32], releaseSyncs: openarray[VkDeviceMemory], releaseKeys: openarray[uint64]): VkWin32KeyedMutexAcquireReleaseInfoNV =
  result = VkWin32KeyedMutexAcquireReleaseInfoNV(
    sType: sType,
    pNext: pNext,
    acquireCount: len(acquireSyncs).uint32,
    pAcquireSyncs: if len(acquireSyncs) == 0: nil else: cast[ptr VkDeviceMemory](acquireSyncs),
    pAcquireKeys: if len(acquireKeys) == 0: nil else: cast[ptr uint64](acquireKeys),
    pAcquireTimeoutMilliseconds: if len(acquireTimeoutMilliseconds) == 0: nil else: cast[ptr uint32](acquireTimeoutMilliseconds),
    releaseCount: len(releaseSyncs).uint32,
    pReleaseSyncs: if len(releaseSyncs) == 0: nil else: cast[ptr VkDeviceMemory](releaseSyncs),
    pReleaseKeys: if len(releaseKeys) == 0: nil else: cast[ptr uint64](releaseKeys),
  )

proc newVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceDeviceGeneratedCommandsFeaturesNV, pNext: pointer = nil, deviceGeneratedCommands: VkBool32): VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV =
  result = VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(
    sType: sType,
    pNext: pNext,
    deviceGeneratedCommands: deviceGeneratedCommands,
  )

proc newVkPushConstantBankInfoNV*(sType: VkStructureType = VkStructureType.PushConstantBankInfoNV, pNext: pointer = nil, bank: uint32): VkPushConstantBankInfoNV =
  result = VkPushConstantBankInfoNV(
    sType: sType,
    pNext: pNext,
    bank: bank,
  )

proc newVkPhysicalDevicePushConstantBankFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDevicePushConstantBankFeaturesNV, pNext: pointer = nil, pushConstantBank: VkBool32): VkPhysicalDevicePushConstantBankFeaturesNV =
  result = VkPhysicalDevicePushConstantBankFeaturesNV(
    sType: sType,
    pNext: pNext,
    pushConstantBank: pushConstantBank,
  )

proc newVkPhysicalDevicePushConstantBankPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDevicePushConstantBankPropertiesNV, pNext: pointer = nil, maxGraphicsPushConstantBanks: uint32, maxComputePushConstantBanks: uint32, maxGraphicsPushDataBanks: uint32, maxComputePushDataBanks: uint32): VkPhysicalDevicePushConstantBankPropertiesNV =
  result = VkPhysicalDevicePushConstantBankPropertiesNV(
    sType: sType,
    pNext: pNext,
    maxGraphicsPushConstantBanks: maxGraphicsPushConstantBanks,
    maxComputePushConstantBanks: maxComputePushConstantBanks,
    maxGraphicsPushDataBanks: maxGraphicsPushDataBanks,
    maxComputePushDataBanks: maxComputePushDataBanks,
  )

proc newVkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV, pNext: pointer = nil, deviceGeneratedCompute: VkBool32, deviceGeneratedComputePipelines: VkBool32, deviceGeneratedComputeCaptureReplay: VkBool32): VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV =
  result = VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(
    sType: sType,
    pNext: pNext,
    deviceGeneratedCompute: deviceGeneratedCompute,
    deviceGeneratedComputePipelines: deviceGeneratedComputePipelines,
    deviceGeneratedComputeCaptureReplay: deviceGeneratedComputeCaptureReplay,
  )

proc newVkDevicePrivateDataCreateInfo*(sType: VkStructureType = VkStructureType.DevicePrivateDataCreateInfo, pNext: pointer = nil, privateDataSlotRequestCount: uint32): VkDevicePrivateDataCreateInfo =
  result = VkDevicePrivateDataCreateInfo(
    sType: sType,
    pNext: pNext,
    privateDataSlotRequestCount: privateDataSlotRequestCount,
  )

proc newVkPrivateDataSlotCreateInfo*(sType: VkStructureType = VkStructureType.PrivateDataSlotCreateInfo, pNext: pointer = nil, flags: VkPrivateDataSlotCreateFlags = 0.VkPrivateDataSlotCreateFlags): VkPrivateDataSlotCreateInfo =
  result = VkPrivateDataSlotCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkPhysicalDevicePrivateDataFeatures*(sType: VkStructureType = VkStructureType.PhysicalDevicePrivateDataFeatures, pNext: pointer = nil, privateData: VkBool32): VkPhysicalDevicePrivateDataFeatures =
  result = VkPhysicalDevicePrivateDataFeatures(
    sType: sType,
    pNext: pNext,
    privateData: privateData,
  )

proc newVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceDeviceGeneratedCommandsPropertiesNV, pNext: pointer = nil, maxGraphicsShaderGroupCount: uint32, maxIndirectSequenceCount: uint32, maxIndirectCommandsTokenCount: uint32, maxIndirectCommandsStreamCount: uint32, maxIndirectCommandsTokenOffset: uint32, maxIndirectCommandsStreamStride: uint32, minSequencesCountBufferOffsetAlignment: uint32, minSequencesIndexBufferOffsetAlignment: uint32, minIndirectCommandsBufferOffsetAlignment: uint32): VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV =
  result = VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(
    sType: sType,
    pNext: pNext,
    maxGraphicsShaderGroupCount: maxGraphicsShaderGroupCount,
    maxIndirectSequenceCount: maxIndirectSequenceCount,
    maxIndirectCommandsTokenCount: maxIndirectCommandsTokenCount,
    maxIndirectCommandsStreamCount: maxIndirectCommandsStreamCount,
    maxIndirectCommandsTokenOffset: maxIndirectCommandsTokenOffset,
    maxIndirectCommandsStreamStride: maxIndirectCommandsStreamStride,
    minSequencesCountBufferOffsetAlignment: minSequencesCountBufferOffsetAlignment,
    minSequencesIndexBufferOffsetAlignment: minSequencesIndexBufferOffsetAlignment,
    minIndirectCommandsBufferOffsetAlignment: minIndirectCommandsBufferOffsetAlignment,
  )

proc newVkPhysicalDeviceClusterAccelerationStructureFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceClusterAccelerationStructureFeaturesNV, pNext: pointer = nil, clusterAccelerationStructure: VkBool32): VkPhysicalDeviceClusterAccelerationStructureFeaturesNV =
  result = VkPhysicalDeviceClusterAccelerationStructureFeaturesNV(
    sType: sType,
    pNext: pNext,
    clusterAccelerationStructure: clusterAccelerationStructure,
  )

proc newVkPhysicalDeviceClusterAccelerationStructurePropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceClusterAccelerationStructurePropertiesNV, pNext: pointer = nil, maxVerticesPerCluster: uint32, maxTrianglesPerCluster: uint32, clusterScratchByteAlignment: uint32, clusterByteAlignment: uint32, clusterTemplateByteAlignment: uint32, clusterBottomLevelByteAlignment: uint32, clusterTemplateBoundsByteAlignment: uint32, maxClusterGeometryIndex: uint32): VkPhysicalDeviceClusterAccelerationStructurePropertiesNV =
  result = VkPhysicalDeviceClusterAccelerationStructurePropertiesNV(
    sType: sType,
    pNext: pNext,
    maxVerticesPerCluster: maxVerticesPerCluster,
    maxTrianglesPerCluster: maxTrianglesPerCluster,
    clusterScratchByteAlignment: clusterScratchByteAlignment,
    clusterByteAlignment: clusterByteAlignment,
    clusterTemplateByteAlignment: clusterTemplateByteAlignment,
    clusterBottomLevelByteAlignment: clusterBottomLevelByteAlignment,
    clusterTemplateBoundsByteAlignment: clusterTemplateBoundsByteAlignment,
    maxClusterGeometryIndex: maxClusterGeometryIndex,
  )

proc newVkStridedDeviceAddressNV*(startAddress: VkDeviceAddress, strideInBytes: VkDeviceSize): VkStridedDeviceAddressNV =
  result = VkStridedDeviceAddressNV(
    startAddress: startAddress,
    strideInBytes: strideInBytes,
  )

proc newVkRayTracingPipelineClusterAccelerationStructureCreateInfoNV*(sType: VkStructureType = VkStructureType.RayTracingPipelineClusterAccelerationStructureCreateInfoNV, pNext: pointer = nil, allowClusterAccelerationStructure: VkBool32): VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV =
  result = VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV(
    sType: sType,
    pNext: pNext,
    allowClusterAccelerationStructure: allowClusterAccelerationStructure,
  )

proc newVkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV*(geometryIndex: uint32, reserved: uint32, geometryFlags: uint32): VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV =
  result = VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(
    geometryIndex: geometryIndex,
    reserved: reserved,
    geometryFlags: geometryFlags,
  )

proc newVkClusterAccelerationStructureMoveObjectsInfoNV*(srcAccelerationStructure: VkDeviceAddress): VkClusterAccelerationStructureMoveObjectsInfoNV =
  result = VkClusterAccelerationStructureMoveObjectsInfoNV(
    srcAccelerationStructure: srcAccelerationStructure,
  )

proc newVkClusterAccelerationStructureBuildClustersBottomLevelInfoNV*(clusterReferencesCount: uint32, clusterReferencesStride: uint32, clusterReferences: VkDeviceAddress): VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV =
  result = VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV(
    clusterReferencesCount: clusterReferencesCount,
    clusterReferencesStride: clusterReferencesStride,
    clusterReferences: clusterReferences,
  )

proc newVkClusterAccelerationStructureGetTemplateIndicesInfoNV*(clusterTemplateAddress: VkDeviceAddress): VkClusterAccelerationStructureGetTemplateIndicesInfoNV =
  result = VkClusterAccelerationStructureGetTemplateIndicesInfoNV(
    clusterTemplateAddress: clusterTemplateAddress,
  )

proc newVkClusterAccelerationStructureBuildTriangleClusterInfoNV*(clusterID: uint32, clusterFlags: VkClusterAccelerationStructureClusterFlagsNV, triangleCount: uint32, vertexCount: uint32, positionTruncateBitCount: uint32, indexType: uint32, opacityMicromapIndexType: uint32, baseGeometryIndexAndGeometryFlags: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV, indexBufferStride: uint16, vertexBufferStride: uint16, geometryIndexAndFlagsBufferStride: uint16, opacityMicromapIndexBufferStride: uint16, indexBuffer: VkDeviceAddress, vertexBuffer: VkDeviceAddress, geometryIndexAndFlagsBuffer: VkDeviceAddress, opacityMicromapArray: VkDeviceAddress, opacityMicromapIndexBuffer: VkDeviceAddress): VkClusterAccelerationStructureBuildTriangleClusterInfoNV =
  result = VkClusterAccelerationStructureBuildTriangleClusterInfoNV(
    clusterID: clusterID,
    clusterFlags: clusterFlags,
    triangleCount: triangleCount,
    vertexCount: vertexCount,
    positionTruncateBitCount: positionTruncateBitCount,
    indexType: indexType,
    opacityMicromapIndexType: opacityMicromapIndexType,
    baseGeometryIndexAndGeometryFlags: baseGeometryIndexAndGeometryFlags,
    indexBufferStride: indexBufferStride,
    vertexBufferStride: vertexBufferStride,
    geometryIndexAndFlagsBufferStride: geometryIndexAndFlagsBufferStride,
    opacityMicromapIndexBufferStride: opacityMicromapIndexBufferStride,
    indexBuffer: indexBuffer,
    vertexBuffer: vertexBuffer,
    geometryIndexAndFlagsBuffer: geometryIndexAndFlagsBuffer,
    opacityMicromapArray: opacityMicromapArray,
    opacityMicromapIndexBuffer: opacityMicromapIndexBuffer,
  )

proc newVkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV*(clusterID: uint32, clusterFlags: VkClusterAccelerationStructureClusterFlagsNV, triangleCount: uint32, vertexCount: uint32, positionTruncateBitCount: uint32, indexType: uint32, opacityMicromapIndexType: uint32, baseGeometryIndexAndGeometryFlags: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV, indexBufferStride: uint16, vertexBufferStride: uint16, geometryIndexAndFlagsBufferStride: uint16, opacityMicromapIndexBufferStride: uint16, indexBuffer: VkDeviceAddress, vertexBuffer: VkDeviceAddress, geometryIndexAndFlagsBuffer: VkDeviceAddress, opacityMicromapArray: VkDeviceAddress, opacityMicromapIndexBuffer: VkDeviceAddress, instantiationBoundingBoxLimit: VkDeviceAddress): VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV =
  result = VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV(
    clusterID: clusterID,
    clusterFlags: clusterFlags,
    triangleCount: triangleCount,
    vertexCount: vertexCount,
    positionTruncateBitCount: positionTruncateBitCount,
    indexType: indexType,
    opacityMicromapIndexType: opacityMicromapIndexType,
    baseGeometryIndexAndGeometryFlags: baseGeometryIndexAndGeometryFlags,
    indexBufferStride: indexBufferStride,
    vertexBufferStride: vertexBufferStride,
    geometryIndexAndFlagsBufferStride: geometryIndexAndFlagsBufferStride,
    opacityMicromapIndexBufferStride: opacityMicromapIndexBufferStride,
    indexBuffer: indexBuffer,
    vertexBuffer: vertexBuffer,
    geometryIndexAndFlagsBuffer: geometryIndexAndFlagsBuffer,
    opacityMicromapArray: opacityMicromapArray,
    opacityMicromapIndexBuffer: opacityMicromapIndexBuffer,
    instantiationBoundingBoxLimit: instantiationBoundingBoxLimit,
  )

proc newVkClusterAccelerationStructureInstantiateClusterInfoNV*(clusterIdOffset: uint32, geometryIndexOffset: uint32, reserved: uint32, clusterTemplateAddress: VkDeviceAddress, vertexBuffer: VkStridedDeviceAddressNV): VkClusterAccelerationStructureInstantiateClusterInfoNV =
  result = VkClusterAccelerationStructureInstantiateClusterInfoNV(
    clusterIdOffset: clusterIdOffset,
    geometryIndexOffset: geometryIndexOffset,
    reserved: reserved,
    clusterTemplateAddress: clusterTemplateAddress,
    vertexBuffer: vertexBuffer,
  )

proc newVkClusterAccelerationStructureClustersBottomLevelInputNV*(sType: VkStructureType = VkStructureType.ClusterAccelerationStructureClustersBottomLevelInputNV, pNext: pointer = nil, maxTotalClusterCount: uint32, maxClusterCountPerAccelerationStructure: uint32): VkClusterAccelerationStructureClustersBottomLevelInputNV =
  result = VkClusterAccelerationStructureClustersBottomLevelInputNV(
    sType: sType,
    pNext: pNext,
    maxTotalClusterCount: maxTotalClusterCount,
    maxClusterCountPerAccelerationStructure: maxClusterCountPerAccelerationStructure,
  )

proc newVkClusterAccelerationStructureTriangleClusterInputNV*(sType: VkStructureType = VkStructureType.ClusterAccelerationStructureTriangleClusterInputNV, pNext: pointer = nil, vertexFormat: VkFormat, maxGeometryIndexValue: uint32, maxClusterUniqueGeometryCount: uint32, maxClusterTriangleCount: uint32, maxClusterVertexCount: uint32, maxTotalTriangleCount: uint32, maxTotalVertexCount: uint32, minPositionTruncateBitCount: uint32): VkClusterAccelerationStructureTriangleClusterInputNV =
  result = VkClusterAccelerationStructureTriangleClusterInputNV(
    sType: sType,
    pNext: pNext,
    vertexFormat: vertexFormat,
    maxGeometryIndexValue: maxGeometryIndexValue,
    maxClusterUniqueGeometryCount: maxClusterUniqueGeometryCount,
    maxClusterTriangleCount: maxClusterTriangleCount,
    maxClusterVertexCount: maxClusterVertexCount,
    maxTotalTriangleCount: maxTotalTriangleCount,
    maxTotalVertexCount: maxTotalVertexCount,
    minPositionTruncateBitCount: minPositionTruncateBitCount,
  )

proc newVkClusterAccelerationStructureMoveObjectsInputNV*(sType: VkStructureType = VkStructureType.ClusterAccelerationStructureMoveObjectsInputNV, pNext: pointer = nil, `type`: VkClusterAccelerationStructureTypeNV, noMoveOverlap: VkBool32, maxMovedBytes: VkDeviceSize): VkClusterAccelerationStructureMoveObjectsInputNV =
  result = VkClusterAccelerationStructureMoveObjectsInputNV(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    noMoveOverlap: noMoveOverlap,
    maxMovedBytes: maxMovedBytes,
  )

proc newVkClusterAccelerationStructureInputInfoNV*(sType: VkStructureType = VkStructureType.ClusterAccelerationStructureInputInfoNV, pNext: pointer = nil, maxAccelerationStructureCount: uint32, flags: VkBuildAccelerationStructureFlagsKHR = 0.VkBuildAccelerationStructureFlagsKHR, opType: VkClusterAccelerationStructureOpTypeNV, opMode: VkClusterAccelerationStructureOpModeNV, opInput: VkClusterAccelerationStructureOpInputNV): VkClusterAccelerationStructureInputInfoNV =
  result = VkClusterAccelerationStructureInputInfoNV(
    sType: sType,
    pNext: pNext,
    maxAccelerationStructureCount: maxAccelerationStructureCount,
    flags: flags,
    opType: opType,
    opMode: opMode,
    opInput: opInput,
  )

proc newVkClusterAccelerationStructureCommandsInfoNV*(sType: VkStructureType = VkStructureType.ClusterAccelerationStructureCommandsInfoNV, pNext: pointer = nil, input: VkClusterAccelerationStructureInputInfoNV, dstImplicitData: VkDeviceAddress, scratchData: VkDeviceAddress, dstAddressesArray: VkStridedDeviceAddressRegionKHR, dstSizesArray: VkStridedDeviceAddressRegionKHR, srcInfosArray: VkStridedDeviceAddressRegionKHR, srcInfosCount: VkDeviceAddress, addressResolutionFlags: VkClusterAccelerationStructureAddressResolutionFlagsNV): VkClusterAccelerationStructureCommandsInfoNV =
  result = VkClusterAccelerationStructureCommandsInfoNV(
    sType: sType,
    pNext: pNext,
    input: input,
    dstImplicitData: dstImplicitData,
    scratchData: scratchData,
    dstAddressesArray: dstAddressesArray,
    dstSizesArray: dstSizesArray,
    srcInfosArray: srcInfosArray,
    srcInfosCount: srcInfosCount,
    addressResolutionFlags: addressResolutionFlags,
  )

proc newVkPhysicalDeviceMultiDrawPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMultiDrawPropertiesEXT, pNext: pointer = nil, maxMultiDrawCount: uint32): VkPhysicalDeviceMultiDrawPropertiesEXT =
  result = VkPhysicalDeviceMultiDrawPropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxMultiDrawCount: maxMultiDrawCount,
  )

proc newVkGraphicsShaderGroupCreateInfoNV*(sType: VkStructureType = VkStructureType.GraphicsShaderGroupCreateInfoNV, pNext: pointer = nil, stages: openarray[VkPipelineShaderStageCreateInfo], pVertexInputState: ptr VkPipelineVertexInputStateCreateInfo, pTessellationState: ptr VkPipelineTessellationStateCreateInfo): VkGraphicsShaderGroupCreateInfoNV =
  result = VkGraphicsShaderGroupCreateInfoNV(
    sType: sType,
    pNext: pNext,
    stageCount: len(stages).uint32,
    pStages: if len(stages) == 0: nil else: cast[ptr VkPipelineShaderStageCreateInfo](stages),
    pVertexInputState: pVertexInputState,
    pTessellationState: pTessellationState,
  )

proc newVkGraphicsPipelineShaderGroupsCreateInfoNV*(sType: VkStructureType = VkStructureType.GraphicsPipelineShaderGroupsCreateInfoNV, pNext: pointer = nil, groups: openarray[VkGraphicsShaderGroupCreateInfoNV], pipelines: openarray[VkPipeline]): VkGraphicsPipelineShaderGroupsCreateInfoNV =
  result = VkGraphicsPipelineShaderGroupsCreateInfoNV(
    sType: sType,
    pNext: pNext,
    groupCount: len(groups).uint32,
    pGroups: if len(groups) == 0: nil else: cast[ptr VkGraphicsShaderGroupCreateInfoNV](groups),
    pipelineCount: len(pipelines).uint32,
    pPipelines: if len(pipelines) == 0: nil else: cast[ptr VkPipeline](pipelines),
  )

proc newVkBindShaderGroupIndirectCommandNV*(groupIndex: uint32): VkBindShaderGroupIndirectCommandNV =
  result = VkBindShaderGroupIndirectCommandNV(
    groupIndex: groupIndex,
  )

proc newVkBindIndexBufferIndirectCommandNV*(bufferAddress: VkDeviceAddress, size: uint32, indexType: VkIndexType): VkBindIndexBufferIndirectCommandNV =
  result = VkBindIndexBufferIndirectCommandNV(
    bufferAddress: bufferAddress,
    size: size,
    indexType: indexType,
  )

proc newVkBindVertexBufferIndirectCommandNV*(bufferAddress: VkDeviceAddress, size: uint32, stride: uint32): VkBindVertexBufferIndirectCommandNV =
  result = VkBindVertexBufferIndirectCommandNV(
    bufferAddress: bufferAddress,
    size: size,
    stride: stride,
  )

proc newVkSetStateFlagsIndirectCommandNV*(data: uint32): VkSetStateFlagsIndirectCommandNV =
  result = VkSetStateFlagsIndirectCommandNV(
    data: data,
  )

proc newVkIndirectCommandsStreamNV*(buffer: VkBuffer, offset: VkDeviceSize): VkIndirectCommandsStreamNV =
  result = VkIndirectCommandsStreamNV(
    buffer: buffer,
    offset: offset,
  )

proc newVkIndirectCommandsLayoutTokenNV*(sType: VkStructureType = VkStructureType.IndirectCommandsLayoutTokenNV, pNext: pointer = nil, tokenType: VkIndirectCommandsTokenTypeNV, stream: uint32, offset: uint32, vertexBindingUnit: uint32, vertexDynamicStride: VkBool32, pushconstantPipelineLayout: VkPipelineLayout, pushconstantShaderStageFlags: VkShaderStageFlags, pushconstantOffset: uint32, pushconstantSize: uint32, indirectStateFlags: VkIndirectStateFlagsNV, indexTypes: openarray[VkIndexType], indexTypeValues: openarray[uint32]): VkIndirectCommandsLayoutTokenNV =
  result = VkIndirectCommandsLayoutTokenNV(
    sType: sType,
    pNext: pNext,
    tokenType: tokenType,
    stream: stream,
    offset: offset,
    vertexBindingUnit: vertexBindingUnit,
    vertexDynamicStride: vertexDynamicStride,
    pushconstantPipelineLayout: pushconstantPipelineLayout,
    pushconstantShaderStageFlags: pushconstantShaderStageFlags,
    pushconstantOffset: pushconstantOffset,
    pushconstantSize: pushconstantSize,
    indirectStateFlags: indirectStateFlags,
    indexTypeCount: len(indexTypes).uint32,
    pIndexTypes: if len(indexTypes) == 0: nil else: cast[ptr VkIndexType](indexTypes),
    pIndexTypeValues: if len(indexTypeValues) == 0: nil else: cast[ptr uint32](indexTypeValues),
  )

proc newVkIndirectCommandsLayoutCreateInfoNV*(sType: VkStructureType = VkStructureType.IndirectCommandsLayoutCreateInfoNV, pNext: pointer = nil, flags: VkIndirectCommandsLayoutUsageFlagsNV = 0.VkIndirectCommandsLayoutUsageFlagsNV, pipelineBindPoint: VkPipelineBindPoint, tokens: openarray[VkIndirectCommandsLayoutTokenNV], streamStrides: openarray[uint32]): VkIndirectCommandsLayoutCreateInfoNV =
  result = VkIndirectCommandsLayoutCreateInfoNV(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pipelineBindPoint: pipelineBindPoint,
    tokenCount: len(tokens).uint32,
    pTokens: if len(tokens) == 0: nil else: cast[ptr VkIndirectCommandsLayoutTokenNV](tokens),
    streamCount: len(streamStrides).uint32,
    pStreamStrides: if len(streamStrides) == 0: nil else: cast[ptr uint32](streamStrides),
  )

proc newVkGeneratedCommandsInfoNV*(sType: VkStructureType = VkStructureType.GeneratedCommandsInfoNV, pNext: pointer = nil, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline, indirectCommandsLayout: VkIndirectCommandsLayoutNV, streams: openarray[VkIndirectCommandsStreamNV], sequencesCount: uint32, preprocessBuffer: VkBuffer, preprocessOffset: VkDeviceSize, preprocessSize: VkDeviceSize, sequencesCountBuffer: VkBuffer, sequencesCountOffset: VkDeviceSize, sequencesIndexBuffer: VkBuffer, sequencesIndexOffset: VkDeviceSize): VkGeneratedCommandsInfoNV =
  result = VkGeneratedCommandsInfoNV(
    sType: sType,
    pNext: pNext,
    pipelineBindPoint: pipelineBindPoint,
    pipeline: pipeline,
    indirectCommandsLayout: indirectCommandsLayout,
    streamCount: len(streams).uint32,
    pStreams: if len(streams) == 0: nil else: cast[ptr VkIndirectCommandsStreamNV](streams),
    sequencesCount: sequencesCount,
    preprocessBuffer: preprocessBuffer,
    preprocessOffset: preprocessOffset,
    preprocessSize: preprocessSize,
    sequencesCountBuffer: sequencesCountBuffer,
    sequencesCountOffset: sequencesCountOffset,
    sequencesIndexBuffer: sequencesIndexBuffer,
    sequencesIndexOffset: sequencesIndexOffset,
  )

proc newVkGeneratedCommandsMemoryRequirementsInfoNV*(sType: VkStructureType = VkStructureType.GeneratedCommandsMemoryRequirementsInfoNV, pNext: pointer = nil, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline, indirectCommandsLayout: VkIndirectCommandsLayoutNV, maxSequencesCount: uint32): VkGeneratedCommandsMemoryRequirementsInfoNV =
  result = VkGeneratedCommandsMemoryRequirementsInfoNV(
    sType: sType,
    pNext: pNext,
    pipelineBindPoint: pipelineBindPoint,
    pipeline: pipeline,
    indirectCommandsLayout: indirectCommandsLayout,
    maxSequencesCount: maxSequencesCount,
  )

proc newVkPipelineIndirectDeviceAddressInfoNV*(sType: VkStructureType = VkStructureType.PipelineIndirectDeviceAddressInfoNV, pNext: pointer = nil, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline): VkPipelineIndirectDeviceAddressInfoNV =
  result = VkPipelineIndirectDeviceAddressInfoNV(
    sType: sType,
    pNext: pNext,
    pipelineBindPoint: pipelineBindPoint,
    pipeline: pipeline,
  )

proc newVkBindPipelineIndirectCommandNV*(pipelineAddress: VkDeviceAddress): VkBindPipelineIndirectCommandNV =
  result = VkBindPipelineIndirectCommandNV(
    pipelineAddress: pipelineAddress,
  )

proc newVkPhysicalDeviceFeatures2*(sType: VkStructureType = VkStructureType.PhysicalDeviceFeatures2, pNext: pointer = nil, features: VkPhysicalDeviceFeatures): VkPhysicalDeviceFeatures2 =
  result = VkPhysicalDeviceFeatures2(
    sType: sType,
    pNext: pNext,
    features: features,
  )

proc newVkPhysicalDeviceProperties2*(sType: VkStructureType = VkStructureType.PhysicalDeviceProperties2, pNext: pointer = nil, properties: VkPhysicalDeviceProperties): VkPhysicalDeviceProperties2 =
  result = VkPhysicalDeviceProperties2(
    sType: sType,
    pNext: pNext,
    properties: properties,
  )

proc newVkFormatProperties2*(sType: VkStructureType = VkStructureType.FormatProperties2, pNext: pointer = nil, formatProperties: VkFormatProperties): VkFormatProperties2 =
  result = VkFormatProperties2(
    sType: sType,
    pNext: pNext,
    formatProperties: formatProperties,
  )

proc newVkImageFormatProperties2*(sType: VkStructureType = VkStructureType.ImageFormatProperties2, pNext: pointer = nil, imageFormatProperties: VkImageFormatProperties): VkImageFormatProperties2 =
  result = VkImageFormatProperties2(
    sType: sType,
    pNext: pNext,
    imageFormatProperties: imageFormatProperties,
  )

proc newVkPhysicalDeviceImageFormatInfo2*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageFormatInfo2, pNext: pointer = nil, format: VkFormat, `type`: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags = 0.VkImageCreateFlags): VkPhysicalDeviceImageFormatInfo2 =
  result = VkPhysicalDeviceImageFormatInfo2(
    sType: sType,
    pNext: pNext,
    format: format,
    `type`: `type`,
    tiling: tiling,
    usage: usage,
    flags: flags,
  )

proc newVkQueueFamilyProperties2*(sType: VkStructureType = VkStructureType.QueueFamilyProperties2, pNext: pointer = nil, queueFamilyProperties: VkQueueFamilyProperties): VkQueueFamilyProperties2 =
  result = VkQueueFamilyProperties2(
    sType: sType,
    pNext: pNext,
    queueFamilyProperties: queueFamilyProperties,
  )

proc newVkPhysicalDeviceMemoryProperties2*(sType: VkStructureType = VkStructureType.PhysicalDeviceMemoryProperties2, pNext: pointer = nil, memoryProperties: VkPhysicalDeviceMemoryProperties): VkPhysicalDeviceMemoryProperties2 =
  result = VkPhysicalDeviceMemoryProperties2(
    sType: sType,
    pNext: pNext,
    memoryProperties: memoryProperties,
  )

proc newVkSparseImageFormatProperties2*(sType: VkStructureType = VkStructureType.SparseImageFormatProperties2, pNext: pointer = nil, properties: VkSparseImageFormatProperties): VkSparseImageFormatProperties2 =
  result = VkSparseImageFormatProperties2(
    sType: sType,
    pNext: pNext,
    properties: properties,
  )

proc newVkPhysicalDeviceSparseImageFormatInfo2*(sType: VkStructureType = VkStructureType.PhysicalDeviceSparseImageFormatInfo2, pNext: pointer = nil, format: VkFormat, `type`: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling): VkPhysicalDeviceSparseImageFormatInfo2 =
  result = VkPhysicalDeviceSparseImageFormatInfo2(
    sType: sType,
    pNext: pNext,
    format: format,
    `type`: `type`,
    samples: samples,
    usage: usage,
    tiling: tiling,
  )

proc newVkPhysicalDevicePushDescriptorProperties*(sType: VkStructureType = VkStructureType.PhysicalDevicePushDescriptorProperties, pNext: pointer = nil, maxPushDescriptors: uint32): VkPhysicalDevicePushDescriptorProperties =
  result = VkPhysicalDevicePushDescriptorProperties(
    sType: sType,
    pNext: pNext,
    maxPushDescriptors: maxPushDescriptors,
  )

proc newVkConformanceVersion*(major: uint8, minor: uint8, subminor: uint8, patch: uint8): VkConformanceVersion =
  result = VkConformanceVersion(
    major: major,
    minor: minor,
    subminor: subminor,
    patch: patch,
  )

proc newVkPhysicalDeviceDriverProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceDriverProperties, pNext: pointer = nil, driverID: VkDriverId, driverName: array[VK_MAX_DRIVER_NAME_SIZE, char], driverInfo: array[VK_MAX_DRIVER_INFO_SIZE, char], conformanceVersion: VkConformanceVersion): VkPhysicalDeviceDriverProperties =
  result = VkPhysicalDeviceDriverProperties(
    sType: sType,
    pNext: pNext,
    driverID: driverID,
    driverName: driverName,
    driverInfo: driverInfo,
    conformanceVersion: conformanceVersion,
  )

proc newVkPresentRegionsKHR*(sType: VkStructureType = VkStructureType.PresentRegionsKHR, pNext: pointer = nil, regions: openarray[VkPresentRegionKHR]): VkPresentRegionsKHR =
  result = VkPresentRegionsKHR(
    sType: sType,
    pNext: pNext,
    swapchainCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkPresentRegionKHR](regions),
  )

proc newVkPresentRegionKHR*(rectangles: openarray[VkRectLayerKHR]): VkPresentRegionKHR =
  result = VkPresentRegionKHR(
    rectangleCount: len(rectangles).uint32,
    pRectangles: if len(rectangles) == 0: nil else: cast[ptr VkRectLayerKHR](rectangles),
  )

proc newVkRectLayerKHR*(offset: VkOffset2D, extent: VkExtent2D, layer: uint32): VkRectLayerKHR =
  result = VkRectLayerKHR(
    offset: offset,
    extent: extent,
    layer: layer,
  )

proc newVkPhysicalDeviceVariablePointersFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceVariablePointersFeatures, pNext: pointer = nil, variablePointersStorageBuffer: VkBool32, variablePointers: VkBool32): VkPhysicalDeviceVariablePointersFeatures =
  result = VkPhysicalDeviceVariablePointersFeatures(
    sType: sType,
    pNext: pNext,
    variablePointersStorageBuffer: variablePointersStorageBuffer,
    variablePointers: variablePointers,
  )

proc newVkExternalMemoryProperties*(externalMemoryFeatures: VkExternalMemoryFeatureFlags, exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags, compatibleHandleTypes: VkExternalMemoryHandleTypeFlags): VkExternalMemoryProperties =
  result = VkExternalMemoryProperties(
    externalMemoryFeatures: externalMemoryFeatures,
    exportFromImportedHandleTypes: exportFromImportedHandleTypes,
    compatibleHandleTypes: compatibleHandleTypes,
  )

proc newVkPhysicalDeviceExternalImageFormatInfo*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalImageFormatInfo, pNext: pointer = nil, handleType: VkExternalMemoryHandleTypeFlagBits): VkPhysicalDeviceExternalImageFormatInfo =
  result = VkPhysicalDeviceExternalImageFormatInfo(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
  )

proc newVkExternalImageFormatProperties*(sType: VkStructureType = VkStructureType.ExternalImageFormatProperties, pNext: pointer = nil, externalMemoryProperties: VkExternalMemoryProperties): VkExternalImageFormatProperties =
  result = VkExternalImageFormatProperties(
    sType: sType,
    pNext: pNext,
    externalMemoryProperties: externalMemoryProperties,
  )

proc newVkPhysicalDeviceExternalBufferInfo*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalBufferInfo, pNext: pointer = nil, flags: VkBufferCreateFlags = 0.VkBufferCreateFlags, usage: VkBufferUsageFlags, handleType: VkExternalMemoryHandleTypeFlagBits): VkPhysicalDeviceExternalBufferInfo =
  result = VkPhysicalDeviceExternalBufferInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    usage: usage,
    handleType: handleType,
  )

proc newVkExternalBufferProperties*(sType: VkStructureType = VkStructureType.ExternalBufferProperties, pNext: pointer = nil, externalMemoryProperties: VkExternalMemoryProperties): VkExternalBufferProperties =
  result = VkExternalBufferProperties(
    sType: sType,
    pNext: pNext,
    externalMemoryProperties: externalMemoryProperties,
  )

proc newVkPhysicalDeviceIDProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceIDProperties, pNext: pointer = nil, deviceUUID: array[VK_UUID_SIZE, uint8], driverUUID: array[VK_UUID_SIZE, uint8], deviceLUID: array[VK_LUID_SIZE, uint8], deviceNodeMask: uint32, deviceLUIDValid: VkBool32): VkPhysicalDeviceIDProperties =
  result = VkPhysicalDeviceIDProperties(
    sType: sType,
    pNext: pNext,
    deviceUUID: deviceUUID,
    driverUUID: driverUUID,
    deviceLUID: deviceLUID,
    deviceNodeMask: deviceNodeMask,
    deviceLUIDValid: deviceLUIDValid,
  )

proc newVkExternalMemoryImageCreateInfo*(sType: VkStructureType = VkStructureType.ExternalMemoryImageCreateInfo, pNext: pointer = nil, handleTypes: VkExternalMemoryHandleTypeFlags): VkExternalMemoryImageCreateInfo =
  result = VkExternalMemoryImageCreateInfo(
    sType: sType,
    pNext: pNext,
    handleTypes: handleTypes,
  )

proc newVkExternalMemoryBufferCreateInfo*(sType: VkStructureType = VkStructureType.ExternalMemoryBufferCreateInfo, pNext: pointer = nil, handleTypes: VkExternalMemoryHandleTypeFlags): VkExternalMemoryBufferCreateInfo =
  result = VkExternalMemoryBufferCreateInfo(
    sType: sType,
    pNext: pNext,
    handleTypes: handleTypes,
  )

proc newVkExportMemoryAllocateInfo*(sType: VkStructureType = VkStructureType.ExportMemoryAllocateInfo, pNext: pointer = nil, handleTypes: VkExternalMemoryHandleTypeFlags): VkExportMemoryAllocateInfo =
  result = VkExportMemoryAllocateInfo(
    sType: sType,
    pNext: pNext,
    handleTypes: handleTypes,
  )

proc newVkImportMemoryWin32HandleInfoKHR*(sType: VkStructureType = VkStructureType.ImportMemoryWin32HandleInfoKHR, pNext: pointer = nil, handleType: VkExternalMemoryHandleTypeFlagBits, handle: HANDLE, name: LPCWSTR): VkImportMemoryWin32HandleInfoKHR =
  result = VkImportMemoryWin32HandleInfoKHR(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
    handle: handle,
    name: name,
  )

proc newVkExportMemoryWin32HandleInfoKHR*(sType: VkStructureType = VkStructureType.ExportMemoryWin32HandleInfoKHR, pNext: pointer = nil, pAttributes: ptr SECURITY_ATTRIBUTES, dwAccess: DWORD, name: LPCWSTR): VkExportMemoryWin32HandleInfoKHR =
  result = VkExportMemoryWin32HandleInfoKHR(
    sType: sType,
    pNext: pNext,
    pAttributes: pAttributes,
    dwAccess: dwAccess,
    name: name,
  )

proc newVkImportMemoryZirconHandleInfoFUCHSIA*(sType: VkStructureType = VkStructureType.ImportMemoryZirconHandleInfoFUCHSIA, pNext: pointer = nil, handleType: VkExternalMemoryHandleTypeFlagBits, handle: zx_handle_t): VkImportMemoryZirconHandleInfoFUCHSIA =
  result = VkImportMemoryZirconHandleInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
    handle: handle,
  )

proc newVkMemoryZirconHandlePropertiesFUCHSIA*(sType: VkStructureType = VkStructureType.MemoryZirconHandlePropertiesFUCHSIA, pNext: pointer = nil, memoryTypeBits: uint32): VkMemoryZirconHandlePropertiesFUCHSIA =
  result = VkMemoryZirconHandlePropertiesFUCHSIA(
    sType: sType,
    pNext: pNext,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkMemoryGetZirconHandleInfoFUCHSIA*(sType: VkStructureType = VkStructureType.MemoryGetZirconHandleInfoFUCHSIA, pNext: pointer = nil, memory: VkDeviceMemory, handleType: VkExternalMemoryHandleTypeFlagBits): VkMemoryGetZirconHandleInfoFUCHSIA =
  result = VkMemoryGetZirconHandleInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    memory: memory,
    handleType: handleType,
  )

proc newVkMemoryWin32HandlePropertiesKHR*(sType: VkStructureType = VkStructureType.MemoryWin32HandlePropertiesKHR, pNext: pointer = nil, memoryTypeBits: uint32): VkMemoryWin32HandlePropertiesKHR =
  result = VkMemoryWin32HandlePropertiesKHR(
    sType: sType,
    pNext: pNext,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkMemoryGetWin32HandleInfoKHR*(sType: VkStructureType = VkStructureType.MemoryGetWin32HandleInfoKHR, pNext: pointer = nil, memory: VkDeviceMemory, handleType: VkExternalMemoryHandleTypeFlagBits): VkMemoryGetWin32HandleInfoKHR =
  result = VkMemoryGetWin32HandleInfoKHR(
    sType: sType,
    pNext: pNext,
    memory: memory,
    handleType: handleType,
  )

proc newVkImportMemoryFdInfoKHR*(sType: VkStructureType = VkStructureType.ImportMemoryFdInfoKHR, pNext: pointer = nil, handleType: VkExternalMemoryHandleTypeFlagBits, fd: int): VkImportMemoryFdInfoKHR =
  result = VkImportMemoryFdInfoKHR(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
    fd: fd,
  )

proc newVkMemoryFdPropertiesKHR*(sType: VkStructureType = VkStructureType.MemoryFdPropertiesKHR, pNext: pointer = nil, memoryTypeBits: uint32): VkMemoryFdPropertiesKHR =
  result = VkMemoryFdPropertiesKHR(
    sType: sType,
    pNext: pNext,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkMemoryGetFdInfoKHR*(sType: VkStructureType = VkStructureType.MemoryGetFdInfoKHR, pNext: pointer = nil, memory: VkDeviceMemory, handleType: VkExternalMemoryHandleTypeFlagBits): VkMemoryGetFdInfoKHR =
  result = VkMemoryGetFdInfoKHR(
    sType: sType,
    pNext: pNext,
    memory: memory,
    handleType: handleType,
  )

proc newVkWin32KeyedMutexAcquireReleaseInfoKHR*(sType: VkStructureType = VkStructureType.Win32KeyedMutexAcquireReleaseInfoKHR, pNext: pointer = nil, acquireSyncs: openarray[VkDeviceMemory], acquireKeys: openarray[uint64], acquireTimeouts: openarray[uint32], releaseSyncs: openarray[VkDeviceMemory], releaseKeys: openarray[uint64]): VkWin32KeyedMutexAcquireReleaseInfoKHR =
  result = VkWin32KeyedMutexAcquireReleaseInfoKHR(
    sType: sType,
    pNext: pNext,
    acquireCount: len(acquireSyncs).uint32,
    pAcquireSyncs: if len(acquireSyncs) == 0: nil else: cast[ptr VkDeviceMemory](acquireSyncs),
    pAcquireKeys: if len(acquireKeys) == 0: nil else: cast[ptr uint64](acquireKeys),
    pAcquireTimeouts: if len(acquireTimeouts) == 0: nil else: cast[ptr uint32](acquireTimeouts),
    releaseCount: len(releaseSyncs).uint32,
    pReleaseSyncs: if len(releaseSyncs) == 0: nil else: cast[ptr VkDeviceMemory](releaseSyncs),
    pReleaseKeys: if len(releaseKeys) == 0: nil else: cast[ptr uint64](releaseKeys),
  )

proc newVkImportMemoryMetalHandleInfoEXT*(sType: VkStructureType = VkStructureType.ImportMemoryMetalHandleInfoEXT, pNext: pointer = nil, handleType: VkExternalMemoryHandleTypeFlagBits, handle: pointer = nil): VkImportMemoryMetalHandleInfoEXT =
  result = VkImportMemoryMetalHandleInfoEXT(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
    handle: handle,
  )

proc newVkMemoryMetalHandlePropertiesEXT*(sType: VkStructureType = VkStructureType.MemoryMetalHandlePropertiesEXT, pNext: pointer = nil, memoryTypeBits: uint32): VkMemoryMetalHandlePropertiesEXT =
  result = VkMemoryMetalHandlePropertiesEXT(
    sType: sType,
    pNext: pNext,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkMemoryGetMetalHandleInfoEXT*(sType: VkStructureType = VkStructureType.MemoryGetMetalHandleInfoEXT, pNext: pointer = nil, memory: VkDeviceMemory, handleType: VkExternalMemoryHandleTypeFlagBits): VkMemoryGetMetalHandleInfoEXT =
  result = VkMemoryGetMetalHandleInfoEXT(
    sType: sType,
    pNext: pNext,
    memory: memory,
    handleType: handleType,
  )

proc newVkPhysicalDeviceExternalSemaphoreInfo*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalSemaphoreInfo, pNext: pointer = nil, handleType: VkExternalSemaphoreHandleTypeFlagBits): VkPhysicalDeviceExternalSemaphoreInfo =
  result = VkPhysicalDeviceExternalSemaphoreInfo(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
  )

proc newVkExternalSemaphoreProperties*(sType: VkStructureType = VkStructureType.ExternalSemaphoreProperties, pNext: pointer = nil, exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags, compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags, externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags): VkExternalSemaphoreProperties =
  result = VkExternalSemaphoreProperties(
    sType: sType,
    pNext: pNext,
    exportFromImportedHandleTypes: exportFromImportedHandleTypes,
    compatibleHandleTypes: compatibleHandleTypes,
    externalSemaphoreFeatures: externalSemaphoreFeatures,
  )

proc newVkExportSemaphoreCreateInfo*(sType: VkStructureType = VkStructureType.ExportSemaphoreCreateInfo, pNext: pointer = nil, handleTypes: VkExternalSemaphoreHandleTypeFlags): VkExportSemaphoreCreateInfo =
  result = VkExportSemaphoreCreateInfo(
    sType: sType,
    pNext: pNext,
    handleTypes: handleTypes,
  )

proc newVkImportSemaphoreWin32HandleInfoKHR*(sType: VkStructureType = VkStructureType.ImportSemaphoreWin32HandleInfoKHR, pNext: pointer = nil, semaphore: VkSemaphore, flags: VkSemaphoreImportFlags = 0.VkSemaphoreImportFlags, handleType: VkExternalSemaphoreHandleTypeFlagBits, handle: HANDLE, name: LPCWSTR): VkImportSemaphoreWin32HandleInfoKHR =
  result = VkImportSemaphoreWin32HandleInfoKHR(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    flags: flags,
    handleType: handleType,
    handle: handle,
    name: name,
  )

proc newVkExportSemaphoreWin32HandleInfoKHR*(sType: VkStructureType = VkStructureType.ExportSemaphoreWin32HandleInfoKHR, pNext: pointer = nil, pAttributes: ptr SECURITY_ATTRIBUTES, dwAccess: DWORD, name: LPCWSTR): VkExportSemaphoreWin32HandleInfoKHR =
  result = VkExportSemaphoreWin32HandleInfoKHR(
    sType: sType,
    pNext: pNext,
    pAttributes: pAttributes,
    dwAccess: dwAccess,
    name: name,
  )

proc newVkD3D12FenceSubmitInfoKHR*(sType: VkStructureType = VkStructureType.D3D12FenceSubmitInfoKHR, pNext: pointer = nil, waitSemaphoreValues: openarray[uint64], signalSemaphoreValues: openarray[uint64]): VkD3D12FenceSubmitInfoKHR =
  result = VkD3D12FenceSubmitInfoKHR(
    sType: sType,
    pNext: pNext,
    waitSemaphoreValuesCount: len(waitSemaphoreValues).uint32,
    pWaitSemaphoreValues: if len(waitSemaphoreValues) == 0: nil else: cast[ptr uint64](waitSemaphoreValues),
    signalSemaphoreValuesCount: len(signalSemaphoreValues).uint32,
    pSignalSemaphoreValues: if len(signalSemaphoreValues) == 0: nil else: cast[ptr uint64](signalSemaphoreValues),
  )

proc newVkSemaphoreGetWin32HandleInfoKHR*(sType: VkStructureType = VkStructureType.SemaphoreGetWin32HandleInfoKHR, pNext: pointer = nil, semaphore: VkSemaphore, handleType: VkExternalSemaphoreHandleTypeFlagBits): VkSemaphoreGetWin32HandleInfoKHR =
  result = VkSemaphoreGetWin32HandleInfoKHR(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    handleType: handleType,
  )

proc newVkImportSemaphoreFdInfoKHR*(sType: VkStructureType = VkStructureType.ImportSemaphoreFdInfoKHR, pNext: pointer = nil, semaphore: VkSemaphore, flags: VkSemaphoreImportFlags = 0.VkSemaphoreImportFlags, handleType: VkExternalSemaphoreHandleTypeFlagBits, fd: int): VkImportSemaphoreFdInfoKHR =
  result = VkImportSemaphoreFdInfoKHR(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    flags: flags,
    handleType: handleType,
    fd: fd,
  )

proc newVkSemaphoreGetFdInfoKHR*(sType: VkStructureType = VkStructureType.SemaphoreGetFdInfoKHR, pNext: pointer = nil, semaphore: VkSemaphore, handleType: VkExternalSemaphoreHandleTypeFlagBits): VkSemaphoreGetFdInfoKHR =
  result = VkSemaphoreGetFdInfoKHR(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    handleType: handleType,
  )

proc newVkImportSemaphoreZirconHandleInfoFUCHSIA*(sType: VkStructureType = VkStructureType.ImportSemaphoreZirconHandleInfoFUCHSIA, pNext: pointer = nil, semaphore: VkSemaphore, flags: VkSemaphoreImportFlags = 0.VkSemaphoreImportFlags, handleType: VkExternalSemaphoreHandleTypeFlagBits, zirconHandle: zx_handle_t): VkImportSemaphoreZirconHandleInfoFUCHSIA =
  result = VkImportSemaphoreZirconHandleInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    flags: flags,
    handleType: handleType,
    zirconHandle: zirconHandle,
  )

proc newVkSemaphoreGetZirconHandleInfoFUCHSIA*(sType: VkStructureType = VkStructureType.SemaphoreGetZirconHandleInfoFUCHSIA, pNext: pointer = nil, semaphore: VkSemaphore, handleType: VkExternalSemaphoreHandleTypeFlagBits): VkSemaphoreGetZirconHandleInfoFUCHSIA =
  result = VkSemaphoreGetZirconHandleInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    handleType: handleType,
  )

proc newVkPhysicalDeviceExternalFenceInfo*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalFenceInfo, pNext: pointer = nil, handleType: VkExternalFenceHandleTypeFlagBits): VkPhysicalDeviceExternalFenceInfo =
  result = VkPhysicalDeviceExternalFenceInfo(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
  )

proc newVkExternalFenceProperties*(sType: VkStructureType = VkStructureType.ExternalFenceProperties, pNext: pointer = nil, exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags, compatibleHandleTypes: VkExternalFenceHandleTypeFlags, externalFenceFeatures: VkExternalFenceFeatureFlags): VkExternalFenceProperties =
  result = VkExternalFenceProperties(
    sType: sType,
    pNext: pNext,
    exportFromImportedHandleTypes: exportFromImportedHandleTypes,
    compatibleHandleTypes: compatibleHandleTypes,
    externalFenceFeatures: externalFenceFeatures,
  )

proc newVkExportFenceCreateInfo*(sType: VkStructureType = VkStructureType.ExportFenceCreateInfo, pNext: pointer = nil, handleTypes: VkExternalFenceHandleTypeFlags): VkExportFenceCreateInfo =
  result = VkExportFenceCreateInfo(
    sType: sType,
    pNext: pNext,
    handleTypes: handleTypes,
  )

proc newVkImportFenceWin32HandleInfoKHR*(sType: VkStructureType = VkStructureType.ImportFenceWin32HandleInfoKHR, pNext: pointer = nil, fence: VkFence, flags: VkFenceImportFlags = 0.VkFenceImportFlags, handleType: VkExternalFenceHandleTypeFlagBits, handle: HANDLE, name: LPCWSTR): VkImportFenceWin32HandleInfoKHR =
  result = VkImportFenceWin32HandleInfoKHR(
    sType: sType,
    pNext: pNext,
    fence: fence,
    flags: flags,
    handleType: handleType,
    handle: handle,
    name: name,
  )

proc newVkExportFenceWin32HandleInfoKHR*(sType: VkStructureType = VkStructureType.ExportFenceWin32HandleInfoKHR, pNext: pointer = nil, pAttributes: ptr SECURITY_ATTRIBUTES, dwAccess: DWORD, name: LPCWSTR): VkExportFenceWin32HandleInfoKHR =
  result = VkExportFenceWin32HandleInfoKHR(
    sType: sType,
    pNext: pNext,
    pAttributes: pAttributes,
    dwAccess: dwAccess,
    name: name,
  )

proc newVkFenceGetWin32HandleInfoKHR*(sType: VkStructureType = VkStructureType.FenceGetWin32HandleInfoKHR, pNext: pointer = nil, fence: VkFence, handleType: VkExternalFenceHandleTypeFlagBits): VkFenceGetWin32HandleInfoKHR =
  result = VkFenceGetWin32HandleInfoKHR(
    sType: sType,
    pNext: pNext,
    fence: fence,
    handleType: handleType,
  )

proc newVkImportFenceFdInfoKHR*(sType: VkStructureType = VkStructureType.ImportFenceFdInfoKHR, pNext: pointer = nil, fence: VkFence, flags: VkFenceImportFlags = 0.VkFenceImportFlags, handleType: VkExternalFenceHandleTypeFlagBits, fd: int): VkImportFenceFdInfoKHR =
  result = VkImportFenceFdInfoKHR(
    sType: sType,
    pNext: pNext,
    fence: fence,
    flags: flags,
    handleType: handleType,
    fd: fd,
  )

proc newVkFenceGetFdInfoKHR*(sType: VkStructureType = VkStructureType.FenceGetFdInfoKHR, pNext: pointer = nil, fence: VkFence, handleType: VkExternalFenceHandleTypeFlagBits): VkFenceGetFdInfoKHR =
  result = VkFenceGetFdInfoKHR(
    sType: sType,
    pNext: pNext,
    fence: fence,
    handleType: handleType,
  )

proc newVkExportFenceSciSyncInfoNV*(sType: VkStructureType = VkStructureType.ExportFenceSciSyncInfoNV, pNext: pointer = nil, pAttributes: NvSciSyncAttrList): VkExportFenceSciSyncInfoNV =
  result = VkExportFenceSciSyncInfoNV(
    sType: sType,
    pNext: pNext,
    pAttributes: pAttributes,
  )

proc newVkImportFenceSciSyncInfoNV*(sType: VkStructureType = VkStructureType.ImportFenceSciSyncInfoNV, pNext: pointer = nil, fence: VkFence, handleType: VkExternalFenceHandleTypeFlagBits, handle: pointer = nil): VkImportFenceSciSyncInfoNV =
  result = VkImportFenceSciSyncInfoNV(
    sType: sType,
    pNext: pNext,
    fence: fence,
    handleType: handleType,
    handle: handle,
  )

proc newVkFenceGetSciSyncInfoNV*(sType: VkStructureType = VkStructureType.FenceGetSciSyncInfoNV, pNext: pointer = nil, fence: VkFence, handleType: VkExternalFenceHandleTypeFlagBits): VkFenceGetSciSyncInfoNV =
  result = VkFenceGetSciSyncInfoNV(
    sType: sType,
    pNext: pNext,
    fence: fence,
    handleType: handleType,
  )

proc newVkExportSemaphoreSciSyncInfoNV*(sType: VkStructureType = VkStructureType.ExportSemaphoreSciSyncInfoNV, pNext: pointer = nil, pAttributes: NvSciSyncAttrList): VkExportSemaphoreSciSyncInfoNV =
  result = VkExportSemaphoreSciSyncInfoNV(
    sType: sType,
    pNext: pNext,
    pAttributes: pAttributes,
  )

proc newVkImportSemaphoreSciSyncInfoNV*(sType: VkStructureType = VkStructureType.ImportSemaphoreSciSyncInfoNV, pNext: pointer = nil, semaphore: VkSemaphore, handleType: VkExternalSemaphoreHandleTypeFlagBits, handle: pointer = nil): VkImportSemaphoreSciSyncInfoNV =
  result = VkImportSemaphoreSciSyncInfoNV(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    handleType: handleType,
    handle: handle,
  )

proc newVkSemaphoreGetSciSyncInfoNV*(sType: VkStructureType = VkStructureType.SemaphoreGetSciSyncInfoNV, pNext: pointer = nil, semaphore: VkSemaphore, handleType: VkExternalSemaphoreHandleTypeFlagBits): VkSemaphoreGetSciSyncInfoNV =
  result = VkSemaphoreGetSciSyncInfoNV(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    handleType: handleType,
  )

proc newVkSciSyncAttributesInfoNV*(sType: VkStructureType = VkStructureType.SciSyncAttributesInfoNV, pNext: pointer = nil, clientType: VkSciSyncClientTypeNV, primitiveType: VkSciSyncPrimitiveTypeNV): VkSciSyncAttributesInfoNV =
  result = VkSciSyncAttributesInfoNV(
    sType: sType,
    pNext: pNext,
    clientType: clientType,
    primitiveType: primitiveType,
  )

proc newVkPhysicalDeviceExternalSciSyncFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalSciSyncFeaturesNV, pNext: pointer = nil, sciSyncFence: VkBool32, sciSyncSemaphore: VkBool32, sciSyncImport: VkBool32, sciSyncExport: VkBool32): VkPhysicalDeviceExternalSciSyncFeaturesNV =
  result = VkPhysicalDeviceExternalSciSyncFeaturesNV(
    sType: sType,
    pNext: pNext,
    sciSyncFence: sciSyncFence,
    sciSyncSemaphore: sciSyncSemaphore,
    sciSyncImport: sciSyncImport,
    sciSyncExport: sciSyncExport,
  )

proc newVkPhysicalDeviceExternalSciSync2FeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalSciSync2FeaturesNV, pNext: pointer = nil, sciSyncFence: VkBool32, sciSyncSemaphore2: VkBool32, sciSyncImport: VkBool32, sciSyncExport: VkBool32): VkPhysicalDeviceExternalSciSync2FeaturesNV =
  result = VkPhysicalDeviceExternalSciSync2FeaturesNV(
    sType: sType,
    pNext: pNext,
    sciSyncFence: sciSyncFence,
    sciSyncSemaphore2: sciSyncSemaphore2,
    sciSyncImport: sciSyncImport,
    sciSyncExport: sciSyncExport,
  )

proc newVkSemaphoreSciSyncPoolCreateInfoNV*(sType: VkStructureType = VkStructureType.SemaphoreSciSyncPoolCreateInfoNV, pNext: pointer = nil, handle: NvSciSyncObj): VkSemaphoreSciSyncPoolCreateInfoNV =
  result = VkSemaphoreSciSyncPoolCreateInfoNV(
    sType: sType,
    pNext: pNext,
    handle: handle,
  )

proc newVkSemaphoreSciSyncCreateInfoNV*(sType: VkStructureType = VkStructureType.SemaphoreSciSyncCreateInfoNV, pNext: pointer = nil, semaphorePool: VkSemaphoreSciSyncPoolNV, pFence: ptr NvSciSyncFence): VkSemaphoreSciSyncCreateInfoNV =
  result = VkSemaphoreSciSyncCreateInfoNV(
    sType: sType,
    pNext: pNext,
    semaphorePool: semaphorePool,
    pFence: pFence,
  )

proc newVkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV*(sType: VkStructureType = VkStructureType.DeviceSemaphoreSciSyncPoolReservationCreateInfoNV, pNext: pointer = nil, semaphoreSciSyncPoolRequestCount: uint32): VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV =
  result = VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV(
    sType: sType,
    pNext: pNext,
    semaphoreSciSyncPoolRequestCount: semaphoreSciSyncPoolRequestCount,
  )

proc newVkPhysicalDeviceMultiviewFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceMultiviewFeatures, pNext: pointer = nil, multiview: VkBool32, multiviewGeometryShader: VkBool32, multiviewTessellationShader: VkBool32): VkPhysicalDeviceMultiviewFeatures =
  result = VkPhysicalDeviceMultiviewFeatures(
    sType: sType,
    pNext: pNext,
    multiview: multiview,
    multiviewGeometryShader: multiviewGeometryShader,
    multiviewTessellationShader: multiviewTessellationShader,
  )

proc newVkPhysicalDeviceMultiviewProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceMultiviewProperties, pNext: pointer = nil, maxMultiviewViewCount: uint32, maxMultiviewInstanceIndex: uint32): VkPhysicalDeviceMultiviewProperties =
  result = VkPhysicalDeviceMultiviewProperties(
    sType: sType,
    pNext: pNext,
    maxMultiviewViewCount: maxMultiviewViewCount,
    maxMultiviewInstanceIndex: maxMultiviewInstanceIndex,
  )

proc newVkRenderPassMultiviewCreateInfo*(sType: VkStructureType = VkStructureType.RenderPassMultiviewCreateInfo, pNext: pointer = nil, viewMasks: openarray[uint32], viewOffsets: openarray[int32], correlationMasks: openarray[uint32]): VkRenderPassMultiviewCreateInfo =
  result = VkRenderPassMultiviewCreateInfo(
    sType: sType,
    pNext: pNext,
    subpassCount: len(viewMasks).uint32,
    pViewMasks: if len(viewMasks) == 0: nil else: cast[ptr uint32](viewMasks),
    dependencyCount: len(viewOffsets).uint32,
    pViewOffsets: if len(viewOffsets) == 0: nil else: cast[ptr int32](viewOffsets),
    correlationMaskCount: len(correlationMasks).uint32,
    pCorrelationMasks: if len(correlationMasks) == 0: nil else: cast[ptr uint32](correlationMasks),
  )

proc newVkSurfaceCapabilities2EXT*(sType: VkStructureType = VkStructureType.SurfaceCapabilities2EXT, pNext: pointer = nil, minImageCount: uint32, maxImageCount: uint32, currentExtent: VkExtent2D, minImageExtent: VkExtent2D, maxImageExtent: VkExtent2D, maxImageArrayLayers: uint32, supportedTransforms: VkSurfaceTransformFlagsKHR, currentTransform: VkSurfaceTransformFlagBitsKHR, supportedCompositeAlpha: VkCompositeAlphaFlagsKHR, supportedUsageFlags: VkImageUsageFlags, supportedSurfaceCounters: VkSurfaceCounterFlagsEXT): VkSurfaceCapabilities2EXT =
  result = VkSurfaceCapabilities2EXT(
    sType: sType,
    pNext: pNext,
    minImageCount: minImageCount,
    maxImageCount: maxImageCount,
    currentExtent: currentExtent,
    minImageExtent: minImageExtent,
    maxImageExtent: maxImageExtent,
    maxImageArrayLayers: maxImageArrayLayers,
    supportedTransforms: supportedTransforms,
    currentTransform: currentTransform,
    supportedCompositeAlpha: supportedCompositeAlpha,
    supportedUsageFlags: supportedUsageFlags,
    supportedSurfaceCounters: supportedSurfaceCounters,
  )

proc newVkDisplayPowerInfoEXT*(sType: VkStructureType = VkStructureType.DisplayPowerInfoEXT, pNext: pointer = nil, powerState: VkDisplayPowerStateEXT): VkDisplayPowerInfoEXT =
  result = VkDisplayPowerInfoEXT(
    sType: sType,
    pNext: pNext,
    powerState: powerState,
  )

proc newVkDeviceEventInfoEXT*(sType: VkStructureType = VkStructureType.DeviceEventInfoEXT, pNext: pointer = nil, deviceEvent: VkDeviceEventTypeEXT): VkDeviceEventInfoEXT =
  result = VkDeviceEventInfoEXT(
    sType: sType,
    pNext: pNext,
    deviceEvent: deviceEvent,
  )

proc newVkDisplayEventInfoEXT*(sType: VkStructureType = VkStructureType.DisplayEventInfoEXT, pNext: pointer = nil, displayEvent: VkDisplayEventTypeEXT): VkDisplayEventInfoEXT =
  result = VkDisplayEventInfoEXT(
    sType: sType,
    pNext: pNext,
    displayEvent: displayEvent,
  )

proc newVkSwapchainCounterCreateInfoEXT*(sType: VkStructureType = VkStructureType.SwapchainCounterCreateInfoEXT, pNext: pointer = nil, surfaceCounters: VkSurfaceCounterFlagsEXT): VkSwapchainCounterCreateInfoEXT =
  result = VkSwapchainCounterCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    surfaceCounters: surfaceCounters,
  )

proc newVkPhysicalDeviceGroupProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceGroupProperties, pNext: pointer = nil, physicalDeviceCount: uint32, physicalDevices: array[VK_MAX_DEVICE_GROUP_SIZE, VkPhysicalDevice], subsetAllocation: VkBool32): VkPhysicalDeviceGroupProperties =
  result = VkPhysicalDeviceGroupProperties(
    sType: sType,
    pNext: pNext,
    physicalDeviceCount: physicalDeviceCount,
    physicalDevices: physicalDevices,
    subsetAllocation: subsetAllocation,
  )

proc newVkMemoryAllocateFlagsInfo*(sType: VkStructureType = VkStructureType.MemoryAllocateFlagsInfo, pNext: pointer = nil, flags: VkMemoryAllocateFlags = 0.VkMemoryAllocateFlags, deviceMask: uint32): VkMemoryAllocateFlagsInfo =
  result = VkMemoryAllocateFlagsInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    deviceMask: deviceMask,
  )

proc newVkBindBufferMemoryInfo*(sType: VkStructureType = VkStructureType.BindBufferMemoryInfo, pNext: pointer = nil, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize): VkBindBufferMemoryInfo =
  result = VkBindBufferMemoryInfo(
    sType: sType,
    pNext: pNext,
    buffer: buffer,
    memory: memory,
    memoryOffset: memoryOffset,
  )

proc newVkBindBufferMemoryDeviceGroupInfo*(sType: VkStructureType = VkStructureType.BindBufferMemoryDeviceGroupInfo, pNext: pointer = nil, deviceIndices: openarray[uint32]): VkBindBufferMemoryDeviceGroupInfo =
  result = VkBindBufferMemoryDeviceGroupInfo(
    sType: sType,
    pNext: pNext,
    deviceIndexCount: len(deviceIndices).uint32,
    pDeviceIndices: if len(deviceIndices) == 0: nil else: cast[ptr uint32](deviceIndices),
  )

proc newVkBindImageMemoryInfo*(sType: VkStructureType = VkStructureType.BindImageMemoryInfo, pNext: pointer = nil, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize): VkBindImageMemoryInfo =
  result = VkBindImageMemoryInfo(
    sType: sType,
    pNext: pNext,
    image: image,
    memory: memory,
    memoryOffset: memoryOffset,
  )

proc newVkBindImageMemoryDeviceGroupInfo*(sType: VkStructureType = VkStructureType.BindImageMemoryDeviceGroupInfo, pNext: pointer = nil, deviceIndices: openarray[uint32], splitInstanceBindRegions: openarray[VkRect2D]): VkBindImageMemoryDeviceGroupInfo =
  result = VkBindImageMemoryDeviceGroupInfo(
    sType: sType,
    pNext: pNext,
    deviceIndexCount: len(deviceIndices).uint32,
    pDeviceIndices: if len(deviceIndices) == 0: nil else: cast[ptr uint32](deviceIndices),
    splitInstanceBindRegionCount: len(splitInstanceBindRegions).uint32,
    pSplitInstanceBindRegions: if len(splitInstanceBindRegions) == 0: nil else: cast[ptr VkRect2D](splitInstanceBindRegions),
  )

proc newVkDeviceGroupRenderPassBeginInfo*(sType: VkStructureType = VkStructureType.DeviceGroupRenderPassBeginInfo, pNext: pointer = nil, deviceMask: uint32, deviceRenderAreas: openarray[VkRect2D]): VkDeviceGroupRenderPassBeginInfo =
  result = VkDeviceGroupRenderPassBeginInfo(
    sType: sType,
    pNext: pNext,
    deviceMask: deviceMask,
    deviceRenderAreaCount: len(deviceRenderAreas).uint32,
    pDeviceRenderAreas: if len(deviceRenderAreas) == 0: nil else: cast[ptr VkRect2D](deviceRenderAreas),
  )

proc newVkDeviceGroupCommandBufferBeginInfo*(sType: VkStructureType = VkStructureType.DeviceGroupCommandBufferBeginInfo, pNext: pointer = nil, deviceMask: uint32): VkDeviceGroupCommandBufferBeginInfo =
  result = VkDeviceGroupCommandBufferBeginInfo(
    sType: sType,
    pNext: pNext,
    deviceMask: deviceMask,
  )

proc newVkDeviceGroupSubmitInfo*(sType: VkStructureType = VkStructureType.DeviceGroupSubmitInfo, pNext: pointer = nil, waitSemaphoreDeviceIndices: openarray[uint32], commandBufferDeviceMasks: openarray[uint32], signalSemaphoreDeviceIndices: openarray[uint32]): VkDeviceGroupSubmitInfo =
  result = VkDeviceGroupSubmitInfo(
    sType: sType,
    pNext: pNext,
    waitSemaphoreCount: len(waitSemaphoreDeviceIndices).uint32,
    pWaitSemaphoreDeviceIndices: if len(waitSemaphoreDeviceIndices) == 0: nil else: cast[ptr uint32](waitSemaphoreDeviceIndices),
    commandBufferCount: len(commandBufferDeviceMasks).uint32,
    pCommandBufferDeviceMasks: if len(commandBufferDeviceMasks) == 0: nil else: cast[ptr uint32](commandBufferDeviceMasks),
    signalSemaphoreCount: len(signalSemaphoreDeviceIndices).uint32,
    pSignalSemaphoreDeviceIndices: if len(signalSemaphoreDeviceIndices) == 0: nil else: cast[ptr uint32](signalSemaphoreDeviceIndices),
  )

proc newVkDeviceGroupBindSparseInfo*(sType: VkStructureType = VkStructureType.DeviceGroupBindSparseInfo, pNext: pointer = nil, resourceDeviceIndex: uint32, memoryDeviceIndex: uint32): VkDeviceGroupBindSparseInfo =
  result = VkDeviceGroupBindSparseInfo(
    sType: sType,
    pNext: pNext,
    resourceDeviceIndex: resourceDeviceIndex,
    memoryDeviceIndex: memoryDeviceIndex,
  )

proc newVkDeviceGroupPresentCapabilitiesKHR*(sType: VkStructureType = VkStructureType.DeviceGroupPresentCapabilitiesKHR, pNext: pointer = nil, presentMask: array[VK_MAX_DEVICE_GROUP_SIZE, uint32], modes: VkDeviceGroupPresentModeFlagsKHR): VkDeviceGroupPresentCapabilitiesKHR =
  result = VkDeviceGroupPresentCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    presentMask: presentMask,
    modes: modes,
  )

proc newVkImageSwapchainCreateInfoKHR*(sType: VkStructureType = VkStructureType.ImageSwapchainCreateInfoKHR, pNext: pointer = nil, swapchain: VkSwapchainKHR): VkImageSwapchainCreateInfoKHR =
  result = VkImageSwapchainCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    swapchain: swapchain,
  )

proc newVkBindImageMemorySwapchainInfoKHR*(sType: VkStructureType = VkStructureType.BindImageMemorySwapchainInfoKHR, pNext: pointer = nil, swapchain: VkSwapchainKHR, imageIndex: uint32): VkBindImageMemorySwapchainInfoKHR =
  result = VkBindImageMemorySwapchainInfoKHR(
    sType: sType,
    pNext: pNext,
    swapchain: swapchain,
    imageIndex: imageIndex,
  )

proc newVkAcquireNextImageInfoKHR*(sType: VkStructureType = VkStructureType.AcquireNextImageInfoKHR, pNext: pointer = nil, swapchain: VkSwapchainKHR, timeout: uint64, semaphore: VkSemaphore, fence: VkFence, deviceMask: uint32): VkAcquireNextImageInfoKHR =
  result = VkAcquireNextImageInfoKHR(
    sType: sType,
    pNext: pNext,
    swapchain: swapchain,
    timeout: timeout,
    semaphore: semaphore,
    fence: fence,
    deviceMask: deviceMask,
  )

proc newVkDeviceGroupPresentInfoKHR*(sType: VkStructureType = VkStructureType.DeviceGroupPresentInfoKHR, pNext: pointer = nil, deviceMasks: openarray[uint32], mode: VkDeviceGroupPresentModeFlagBitsKHR): VkDeviceGroupPresentInfoKHR =
  result = VkDeviceGroupPresentInfoKHR(
    sType: sType,
    pNext: pNext,
    swapchainCount: len(deviceMasks).uint32,
    pDeviceMasks: if len(deviceMasks) == 0: nil else: cast[ptr uint32](deviceMasks),
    mode: mode,
  )

proc newVkDeviceGroupDeviceCreateInfo*(sType: VkStructureType = VkStructureType.DeviceGroupDeviceCreateInfo, pNext: pointer = nil, physicalDevices: openarray[VkPhysicalDevice]): VkDeviceGroupDeviceCreateInfo =
  result = VkDeviceGroupDeviceCreateInfo(
    sType: sType,
    pNext: pNext,
    physicalDeviceCount: len(physicalDevices).uint32,
    pPhysicalDevices: if len(physicalDevices) == 0: nil else: cast[ptr VkPhysicalDevice](physicalDevices),
  )

proc newVkDeviceGroupSwapchainCreateInfoKHR*(sType: VkStructureType = VkStructureType.DeviceGroupSwapchainCreateInfoKHR, pNext: pointer = nil, modes: VkDeviceGroupPresentModeFlagsKHR): VkDeviceGroupSwapchainCreateInfoKHR =
  result = VkDeviceGroupSwapchainCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    modes: modes,
  )

proc newVkDescriptorUpdateTemplateEntry*(dstBinding: uint32, dstArrayElement: uint32, descriptorCount: uint32, descriptorType: VkDescriptorType, offset: uint, stride: uint): VkDescriptorUpdateTemplateEntry =
  result = VkDescriptorUpdateTemplateEntry(
    dstBinding: dstBinding,
    dstArrayElement: dstArrayElement,
    descriptorCount: descriptorCount,
    descriptorType: descriptorType,
    offset: offset,
    stride: stride,
  )

proc newVkDescriptorUpdateTemplateCreateInfo*(sType: VkStructureType = VkStructureType.DescriptorUpdateTemplateCreateInfo, pNext: pointer = nil, flags: VkDescriptorUpdateTemplateCreateFlags = 0.VkDescriptorUpdateTemplateCreateFlags, descriptorUpdateEntries: openarray[VkDescriptorUpdateTemplateEntry], templateType: VkDescriptorUpdateTemplateType, descriptorSetLayout: VkDescriptorSetLayout, pipelineBindPoint: VkPipelineBindPoint, pipelineLayout: VkPipelineLayout, set: uint32): VkDescriptorUpdateTemplateCreateInfo =
  result = VkDescriptorUpdateTemplateCreateInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    descriptorUpdateEntryCount: len(descriptorUpdateEntries).uint32,
    pDescriptorUpdateEntries: if len(descriptorUpdateEntries) == 0: nil else: cast[ptr VkDescriptorUpdateTemplateEntry](descriptorUpdateEntries),
    templateType: templateType,
    descriptorSetLayout: descriptorSetLayout,
    pipelineBindPoint: pipelineBindPoint,
    pipelineLayout: pipelineLayout,
    set: set,
  )

proc newVkXYColorEXT*(x: float32, y: float32): VkXYColorEXT =
  result = VkXYColorEXT(
    x: x,
    y: y,
  )

proc newVkPhysicalDevicePresentIdFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePresentIdFeaturesKHR, pNext: pointer = nil, presentId: VkBool32): VkPhysicalDevicePresentIdFeaturesKHR =
  result = VkPhysicalDevicePresentIdFeaturesKHR(
    sType: sType,
    pNext: pNext,
    presentId: presentId,
  )

proc newVkPresentIdKHR*(sType: VkStructureType = VkStructureType.PresentIdKHR, pNext: pointer = nil, presentIds: openarray[uint64]): VkPresentIdKHR =
  result = VkPresentIdKHR(
    sType: sType,
    pNext: pNext,
    swapchainCount: len(presentIds).uint32,
    pPresentIds: if len(presentIds) == 0: nil else: cast[ptr uint64](presentIds),
  )

proc newVkPhysicalDevicePresentId2FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePresentId2FeaturesKHR, pNext: pointer = nil, presentId2: VkBool32): VkPhysicalDevicePresentId2FeaturesKHR =
  result = VkPhysicalDevicePresentId2FeaturesKHR(
    sType: sType,
    pNext: pNext,
    presentId2: presentId2,
  )

proc newVkPresentId2KHR*(sType: VkStructureType = VkStructureType.PresentId2KHR, pNext: pointer = nil, presentIds: openarray[uint64]): VkPresentId2KHR =
  result = VkPresentId2KHR(
    sType: sType,
    pNext: pNext,
    swapchainCount: len(presentIds).uint32,
    pPresentIds: if len(presentIds) == 0: nil else: cast[ptr uint64](presentIds),
  )

proc newVkPresentWait2InfoKHR*(sType: VkStructureType = VkStructureType.PresentWait2InfoKHR, pNext: pointer = nil, presentId: uint64, timeout: uint64): VkPresentWait2InfoKHR =
  result = VkPresentWait2InfoKHR(
    sType: sType,
    pNext: pNext,
    presentId: presentId,
    timeout: timeout,
  )

proc newVkPhysicalDevicePresentWaitFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePresentWaitFeaturesKHR, pNext: pointer = nil, presentWait: VkBool32): VkPhysicalDevicePresentWaitFeaturesKHR =
  result = VkPhysicalDevicePresentWaitFeaturesKHR(
    sType: sType,
    pNext: pNext,
    presentWait: presentWait,
  )

proc newVkPhysicalDevicePresentWait2FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePresentWait2FeaturesKHR, pNext: pointer = nil, presentWait2: VkBool32): VkPhysicalDevicePresentWait2FeaturesKHR =
  result = VkPhysicalDevicePresentWait2FeaturesKHR(
    sType: sType,
    pNext: pNext,
    presentWait2: presentWait2,
  )

proc newVkPhysicalDevicePresentTimingFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDevicePresentTimingFeaturesEXT, pNext: pointer = nil, presentTiming: VkBool32, presentAtAbsoluteTime: VkBool32, presentAtRelativeTime: VkBool32): VkPhysicalDevicePresentTimingFeaturesEXT =
  result = VkPhysicalDevicePresentTimingFeaturesEXT(
    sType: sType,
    pNext: pNext,
    presentTiming: presentTiming,
    presentAtAbsoluteTime: presentAtAbsoluteTime,
    presentAtRelativeTime: presentAtRelativeTime,
  )

proc newVkPresentTimingSurfaceCapabilitiesEXT*(sType: VkStructureType = VkStructureType.PresentTimingSurfaceCapabilitiesEXT, pNext: pointer = nil, presentTimingSupported: VkBool32, presentAtAbsoluteTimeSupported: VkBool32, presentAtRelativeTimeSupported: VkBool32, presentStageQueries: VkPresentStageFlagsEXT): VkPresentTimingSurfaceCapabilitiesEXT =
  result = VkPresentTimingSurfaceCapabilitiesEXT(
    sType: sType,
    pNext: pNext,
    presentTimingSupported: presentTimingSupported,
    presentAtAbsoluteTimeSupported: presentAtAbsoluteTimeSupported,
    presentAtRelativeTimeSupported: presentAtRelativeTimeSupported,
    presentStageQueries: presentStageQueries,
  )

proc newVkSwapchainTimingPropertiesEXT*(sType: VkStructureType = VkStructureType.SwapchainTimingPropertiesEXT, pNext: pointer = nil, refreshDuration: uint64, refreshInterval: uint64): VkSwapchainTimingPropertiesEXT =
  result = VkSwapchainTimingPropertiesEXT(
    sType: sType,
    pNext: pNext,
    refreshDuration: refreshDuration,
    refreshInterval: refreshInterval,
  )

proc newVkSwapchainTimeDomainPropertiesEXT*(sType: VkStructureType = VkStructureType.SwapchainTimeDomainPropertiesEXT, pNext: pointer = nil, timeDomains: openarray[VkTimeDomainKHR], timeDomainIds: openarray[uint64]): VkSwapchainTimeDomainPropertiesEXT =
  result = VkSwapchainTimeDomainPropertiesEXT(
    sType: sType,
    pNext: pNext,
    timeDomainCount: len(timeDomains).uint32,
    pTimeDomains: if len(timeDomains) == 0: nil else: cast[ptr VkTimeDomainKHR](timeDomains),
    pTimeDomainIds: if len(timeDomainIds) == 0: nil else: cast[ptr uint64](timeDomainIds),
  )

proc newVkPresentStageTimeEXT*(stage: VkPresentStageFlagsEXT, time: uint64): VkPresentStageTimeEXT =
  result = VkPresentStageTimeEXT(
    stage: stage,
    time: time,
  )

proc newVkPastPresentationTimingInfoEXT*(sType: VkStructureType = VkStructureType.PastPresentationTimingInfoEXT, pNext: pointer = nil, flags: VkPastPresentationTimingFlagsEXT = 0.VkPastPresentationTimingFlagsEXT, swapchain: VkSwapchainKHR): VkPastPresentationTimingInfoEXT =
  result = VkPastPresentationTimingInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    swapchain: swapchain,
  )

proc newVkPastPresentationTimingPropertiesEXT*(sType: VkStructureType = VkStructureType.PastPresentationTimingPropertiesEXT, pNext: pointer = nil, timingPropertiesCounter: uint64, timeDomainsCounter: uint64, presentationTimings: openarray[VkPastPresentationTimingEXT]): VkPastPresentationTimingPropertiesEXT =
  result = VkPastPresentationTimingPropertiesEXT(
    sType: sType,
    pNext: pNext,
    timingPropertiesCounter: timingPropertiesCounter,
    timeDomainsCounter: timeDomainsCounter,
    presentationTimingCount: len(presentationTimings).uint32,
    pPresentationTimings: if len(presentationTimings) == 0: nil else: cast[ptr VkPastPresentationTimingEXT](presentationTimings),
  )

proc newVkPastPresentationTimingEXT*(sType: VkStructureType = VkStructureType.PastPresentationTimingEXT, pNext: pointer = nil, presentId: uint64, targetTime: uint64, presentStages: openarray[VkPresentStageTimeEXT], timeDomain: VkTimeDomainKHR, timeDomainId: uint64, reportComplete: VkBool32): VkPastPresentationTimingEXT =
  result = VkPastPresentationTimingEXT(
    sType: sType,
    pNext: pNext,
    presentId: presentId,
    targetTime: targetTime,
    presentStageCount: len(presentStages).uint32,
    pPresentStages: if len(presentStages) == 0: nil else: cast[ptr VkPresentStageTimeEXT](presentStages),
    timeDomain: timeDomain,
    timeDomainId: timeDomainId,
    reportComplete: reportComplete,
  )

proc newVkPresentTimingsInfoEXT*(sType: VkStructureType = VkStructureType.PresentTimingsInfoEXT, pNext: pointer = nil, timingInfos: openarray[VkPresentTimingInfoEXT]): VkPresentTimingsInfoEXT =
  result = VkPresentTimingsInfoEXT(
    sType: sType,
    pNext: pNext,
    swapchainCount: len(timingInfos).uint32,
    pTimingInfos: if len(timingInfos) == 0: nil else: cast[ptr VkPresentTimingInfoEXT](timingInfos),
  )

proc newVkPresentTimingInfoEXT*(sType: VkStructureType = VkStructureType.PresentTimingInfoEXT, pNext: pointer = nil, flags: VkPresentTimingInfoFlagsEXT = 0.VkPresentTimingInfoFlagsEXT, targetTime: uint64, timeDomainId: uint64, presentStageQueries: VkPresentStageFlagsEXT, targetTimeDomainPresentStage: VkPresentStageFlagsEXT): VkPresentTimingInfoEXT =
  result = VkPresentTimingInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    targetTime: targetTime,
    timeDomainId: timeDomainId,
    presentStageQueries: presentStageQueries,
    targetTimeDomainPresentStage: targetTimeDomainPresentStage,
  )

proc newVkSwapchainCalibratedTimestampInfoEXT*(sType: VkStructureType = VkStructureType.SwapchainCalibratedTimestampInfoEXT, pNext: pointer = nil, swapchain: VkSwapchainKHR, presentStage: VkPresentStageFlagsEXT, timeDomainId: uint64): VkSwapchainCalibratedTimestampInfoEXT =
  result = VkSwapchainCalibratedTimestampInfoEXT(
    sType: sType,
    pNext: pNext,
    swapchain: swapchain,
    presentStage: presentStage,
    timeDomainId: timeDomainId,
  )

proc newVkHdrMetadataEXT*(sType: VkStructureType = VkStructureType.HdrMetadataEXT, pNext: pointer = nil, displayPrimaryRed: VkXYColorEXT, displayPrimaryGreen: VkXYColorEXT, displayPrimaryBlue: VkXYColorEXT, whitePoint: VkXYColorEXT, maxLuminance: float32, minLuminance: float32, maxContentLightLevel: float32, maxFrameAverageLightLevel: float32): VkHdrMetadataEXT =
  result = VkHdrMetadataEXT(
    sType: sType,
    pNext: pNext,
    displayPrimaryRed: displayPrimaryRed,
    displayPrimaryGreen: displayPrimaryGreen,
    displayPrimaryBlue: displayPrimaryBlue,
    whitePoint: whitePoint,
    maxLuminance: maxLuminance,
    minLuminance: minLuminance,
    maxContentLightLevel: maxContentLightLevel,
    maxFrameAverageLightLevel: maxFrameAverageLightLevel,
  )

proc newVkHdrVividDynamicMetadataHUAWEI*(sType: VkStructureType = VkStructureType.HdrVividDynamicMetadataHUAWEI, pNext: pointer = nil, dynamicMetadataSize: uint, pDynamicMetadata: pointer = nil): VkHdrVividDynamicMetadataHUAWEI =
  result = VkHdrVividDynamicMetadataHUAWEI(
    sType: sType,
    pNext: pNext,
    dynamicMetadataSize: dynamicMetadataSize,
    pDynamicMetadata: pDynamicMetadata,
  )

proc newVkDisplayNativeHdrSurfaceCapabilitiesAMD*(sType: VkStructureType = VkStructureType.DisplayNativeHdrSurfaceCapabilitiesAMD, pNext: pointer = nil, localDimmingSupport: VkBool32): VkDisplayNativeHdrSurfaceCapabilitiesAMD =
  result = VkDisplayNativeHdrSurfaceCapabilitiesAMD(
    sType: sType,
    pNext: pNext,
    localDimmingSupport: localDimmingSupport,
  )

proc newVkSwapchainDisplayNativeHdrCreateInfoAMD*(sType: VkStructureType = VkStructureType.SwapchainDisplayNativeHdrCreateInfoAMD, pNext: pointer = nil, localDimmingEnable: VkBool32): VkSwapchainDisplayNativeHdrCreateInfoAMD =
  result = VkSwapchainDisplayNativeHdrCreateInfoAMD(
    sType: sType,
    pNext: pNext,
    localDimmingEnable: localDimmingEnable,
  )

proc newVkRefreshCycleDurationGOOGLE*(refreshDuration: uint64): VkRefreshCycleDurationGOOGLE =
  result = VkRefreshCycleDurationGOOGLE(
    refreshDuration: refreshDuration,
  )

proc newVkPastPresentationTimingGOOGLE*(presentID: uint32, desiredPresentTime: uint64, actualPresentTime: uint64, earliestPresentTime: uint64, presentMargin: uint64): VkPastPresentationTimingGOOGLE =
  result = VkPastPresentationTimingGOOGLE(
    presentID: presentID,
    desiredPresentTime: desiredPresentTime,
    actualPresentTime: actualPresentTime,
    earliestPresentTime: earliestPresentTime,
    presentMargin: presentMargin,
  )

proc newVkPresentTimesInfoGOOGLE*(sType: VkStructureType = VkStructureType.PresentTimesInfoGOOGLE, pNext: pointer = nil, times: openarray[VkPresentTimeGOOGLE]): VkPresentTimesInfoGOOGLE =
  result = VkPresentTimesInfoGOOGLE(
    sType: sType,
    pNext: pNext,
    swapchainCount: len(times).uint32,
    pTimes: if len(times) == 0: nil else: cast[ptr VkPresentTimeGOOGLE](times),
  )

proc newVkPresentTimeGOOGLE*(presentID: uint32, desiredPresentTime: uint64): VkPresentTimeGOOGLE =
  result = VkPresentTimeGOOGLE(
    presentID: presentID,
    desiredPresentTime: desiredPresentTime,
  )

proc newVkIOSSurfaceCreateInfoMVK*(sType: VkStructureType = VkStructureType.IOSSurfaceCreateInfoMVK, pNext: pointer = nil, flags: VkIOSSurfaceCreateFlagsMVK = 0.VkIOSSurfaceCreateFlagsMVK, pView: pointer = nil): VkIOSSurfaceCreateInfoMVK =
  result = VkIOSSurfaceCreateInfoMVK(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pView: pView,
  )

proc newVkMacOSSurfaceCreateInfoMVK*(sType: VkStructureType = VkStructureType.MacOSSurfaceCreateInfoMVK, pNext: pointer = nil, flags: VkMacOSSurfaceCreateFlagsMVK = 0.VkMacOSSurfaceCreateFlagsMVK, pView: pointer = nil): VkMacOSSurfaceCreateInfoMVK =
  result = VkMacOSSurfaceCreateInfoMVK(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pView: pView,
  )

proc newVkMetalSurfaceCreateInfoEXT*(sType: VkStructureType = VkStructureType.MetalSurfaceCreateInfoEXT, pNext: pointer = nil, flags: VkMetalSurfaceCreateFlagsEXT = 0.VkMetalSurfaceCreateFlagsEXT, pLayer: ptr CAMetalLayer): VkMetalSurfaceCreateInfoEXT =
  result = VkMetalSurfaceCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pLayer: pLayer,
  )

proc newVkViewportWScalingNV*(xcoeff: float32, ycoeff: float32): VkViewportWScalingNV =
  result = VkViewportWScalingNV(
    xcoeff: xcoeff,
    ycoeff: ycoeff,
  )

proc newVkPipelineViewportWScalingStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineViewportWScalingStateCreateInfoNV, pNext: pointer = nil, viewportWScalingEnable: VkBool32, viewportWScalings: openarray[VkViewportWScalingNV]): VkPipelineViewportWScalingStateCreateInfoNV =
  result = VkPipelineViewportWScalingStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    viewportWScalingEnable: viewportWScalingEnable,
    viewportCount: len(viewportWScalings).uint32,
    pViewportWScalings: if len(viewportWScalings) == 0: nil else: cast[ptr VkViewportWScalingNV](viewportWScalings),
  )

proc newVkViewportSwizzleNV*(x: VkViewportCoordinateSwizzleNV, y: VkViewportCoordinateSwizzleNV, z: VkViewportCoordinateSwizzleNV, w: VkViewportCoordinateSwizzleNV): VkViewportSwizzleNV =
  result = VkViewportSwizzleNV(
    x: x,
    y: y,
    z: z,
    w: w,
  )

proc newVkPipelineViewportSwizzleStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineViewportSwizzleStateCreateInfoNV, pNext: pointer = nil, flags: VkPipelineViewportSwizzleStateCreateFlagsNV = 0.VkPipelineViewportSwizzleStateCreateFlagsNV, viewportSwizzles: openarray[VkViewportSwizzleNV]): VkPipelineViewportSwizzleStateCreateInfoNV =
  result = VkPipelineViewportSwizzleStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    flags: flags,
    viewportCount: len(viewportSwizzles).uint32,
    pViewportSwizzles: if len(viewportSwizzles) == 0: nil else: cast[ptr VkViewportSwizzleNV](viewportSwizzles),
  )

proc newVkPhysicalDeviceDiscardRectanglePropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDiscardRectanglePropertiesEXT, pNext: pointer = nil, maxDiscardRectangles: uint32): VkPhysicalDeviceDiscardRectanglePropertiesEXT =
  result = VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxDiscardRectangles: maxDiscardRectangles,
  )

proc newVkPipelineDiscardRectangleStateCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineDiscardRectangleStateCreateInfoEXT, pNext: pointer = nil, flags: VkPipelineDiscardRectangleStateCreateFlagsEXT = 0.VkPipelineDiscardRectangleStateCreateFlagsEXT, discardRectangleMode: VkDiscardRectangleModeEXT, discardRectangles: openarray[VkRect2D]): VkPipelineDiscardRectangleStateCreateInfoEXT =
  result = VkPipelineDiscardRectangleStateCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    discardRectangleMode: discardRectangleMode,
    discardRectangleCount: len(discardRectangles).uint32,
    pDiscardRectangles: if len(discardRectangles) == 0: nil else: cast[ptr VkRect2D](discardRectangles),
  )

proc newVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*(sType: VkStructureType = VkStructureType.PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, pNext: pointer = nil, perViewPositionAllComponents: VkBool32): VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX =
  result = VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    sType: sType,
    pNext: pNext,
    perViewPositionAllComponents: perViewPositionAllComponents,
  )

proc newVkInputAttachmentAspectReference*(subpass: uint32, inputAttachmentIndex: uint32, aspectMask: VkImageAspectFlags): VkInputAttachmentAspectReference =
  result = VkInputAttachmentAspectReference(
    subpass: subpass,
    inputAttachmentIndex: inputAttachmentIndex,
    aspectMask: aspectMask,
  )

proc newVkRenderPassInputAttachmentAspectCreateInfo*(sType: VkStructureType = VkStructureType.RenderPassInputAttachmentAspectCreateInfo, pNext: pointer = nil, aspectReferences: openarray[VkInputAttachmentAspectReference]): VkRenderPassInputAttachmentAspectCreateInfo =
  result = VkRenderPassInputAttachmentAspectCreateInfo(
    sType: sType,
    pNext: pNext,
    aspectReferenceCount: len(aspectReferences).uint32,
    pAspectReferences: if len(aspectReferences) == 0: nil else: cast[ptr VkInputAttachmentAspectReference](aspectReferences),
  )

proc newVkPhysicalDeviceSurfaceInfo2KHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceSurfaceInfo2KHR, pNext: pointer = nil, surface: VkSurfaceKHR): VkPhysicalDeviceSurfaceInfo2KHR =
  result = VkPhysicalDeviceSurfaceInfo2KHR(
    sType: sType,
    pNext: pNext,
    surface: surface,
  )

proc newVkSurfaceCapabilities2KHR*(sType: VkStructureType = VkStructureType.SurfaceCapabilities2KHR, pNext: pointer = nil, surfaceCapabilities: VkSurfaceCapabilitiesKHR): VkSurfaceCapabilities2KHR =
  result = VkSurfaceCapabilities2KHR(
    sType: sType,
    pNext: pNext,
    surfaceCapabilities: surfaceCapabilities,
  )

proc newVkSurfaceFormat2KHR*(sType: VkStructureType = VkStructureType.SurfaceFormat2KHR, pNext: pointer = nil, surfaceFormat: VkSurfaceFormatKHR): VkSurfaceFormat2KHR =
  result = VkSurfaceFormat2KHR(
    sType: sType,
    pNext: pNext,
    surfaceFormat: surfaceFormat,
  )

proc newVkDisplayProperties2KHR*(sType: VkStructureType = VkStructureType.DisplayProperties2KHR, pNext: pointer = nil, displayProperties: VkDisplayPropertiesKHR): VkDisplayProperties2KHR =
  result = VkDisplayProperties2KHR(
    sType: sType,
    pNext: pNext,
    displayProperties: displayProperties,
  )

proc newVkDisplayPlaneProperties2KHR*(sType: VkStructureType = VkStructureType.DisplayPlaneProperties2KHR, pNext: pointer = nil, displayPlaneProperties: VkDisplayPlanePropertiesKHR): VkDisplayPlaneProperties2KHR =
  result = VkDisplayPlaneProperties2KHR(
    sType: sType,
    pNext: pNext,
    displayPlaneProperties: displayPlaneProperties,
  )

proc newVkDisplayModeProperties2KHR*(sType: VkStructureType = VkStructureType.DisplayModeProperties2KHR, pNext: pointer = nil, displayModeProperties: VkDisplayModePropertiesKHR): VkDisplayModeProperties2KHR =
  result = VkDisplayModeProperties2KHR(
    sType: sType,
    pNext: pNext,
    displayModeProperties: displayModeProperties,
  )

proc newVkDisplayModeStereoPropertiesNV*(sType: VkStructureType = VkStructureType.DisplayModeStereoPropertiesNV, pNext: pointer = nil, hdmi3DSupported: VkBool32): VkDisplayModeStereoPropertiesNV =
  result = VkDisplayModeStereoPropertiesNV(
    sType: sType,
    pNext: pNext,
    hdmi3DSupported: hdmi3DSupported,
  )

proc newVkDisplayPlaneInfo2KHR*(sType: VkStructureType = VkStructureType.DisplayPlaneInfo2KHR, pNext: pointer = nil, mode: VkDisplayModeKHR, planeIndex: uint32): VkDisplayPlaneInfo2KHR =
  result = VkDisplayPlaneInfo2KHR(
    sType: sType,
    pNext: pNext,
    mode: mode,
    planeIndex: planeIndex,
  )

proc newVkDisplayPlaneCapabilities2KHR*(sType: VkStructureType = VkStructureType.DisplayPlaneCapabilities2KHR, pNext: pointer = nil, capabilities: VkDisplayPlaneCapabilitiesKHR): VkDisplayPlaneCapabilities2KHR =
  result = VkDisplayPlaneCapabilities2KHR(
    sType: sType,
    pNext: pNext,
    capabilities: capabilities,
  )

proc newVkSharedPresentSurfaceCapabilitiesKHR*(sType: VkStructureType = VkStructureType.SharedPresentSurfaceCapabilitiesKHR, pNext: pointer = nil, sharedPresentSupportedUsageFlags: VkImageUsageFlags): VkSharedPresentSurfaceCapabilitiesKHR =
  result = VkSharedPresentSurfaceCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    sharedPresentSupportedUsageFlags: sharedPresentSupportedUsageFlags,
  )

proc newVkPhysicalDevice16BitStorageFeatures*(sType: VkStructureType = VkStructureType.PhysicalDevice16BitStorageFeatures, pNext: pointer = nil, storageBuffer16BitAccess: VkBool32, uniformAndStorageBuffer16BitAccess: VkBool32, storagePushConstant16: VkBool32, storageInputOutput16: VkBool32): VkPhysicalDevice16BitStorageFeatures =
  result = VkPhysicalDevice16BitStorageFeatures(
    sType: sType,
    pNext: pNext,
    storageBuffer16BitAccess: storageBuffer16BitAccess,
    uniformAndStorageBuffer16BitAccess: uniformAndStorageBuffer16BitAccess,
    storagePushConstant16: storagePushConstant16,
    storageInputOutput16: storageInputOutput16,
  )

proc newVkPhysicalDeviceSubgroupProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceSubgroupProperties, pNext: pointer = nil, subgroupSize: uint32, supportedStages: VkShaderStageFlags, supportedOperations: VkSubgroupFeatureFlags, quadOperationsInAllStages: VkBool32): VkPhysicalDeviceSubgroupProperties =
  result = VkPhysicalDeviceSubgroupProperties(
    sType: sType,
    pNext: pNext,
    subgroupSize: subgroupSize,
    supportedStages: supportedStages,
    supportedOperations: supportedOperations,
    quadOperationsInAllStages: quadOperationsInAllStages,
  )

proc newVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderSubgroupExtendedTypesFeatures, pNext: pointer = nil, shaderSubgroupExtendedTypes: VkBool32): VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures =
  result = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(
    sType: sType,
    pNext: pNext,
    shaderSubgroupExtendedTypes: shaderSubgroupExtendedTypes,
  )

proc newVkBufferMemoryRequirementsInfo2*(sType: VkStructureType = VkStructureType.BufferMemoryRequirementsInfo2, pNext: pointer = nil, buffer: VkBuffer): VkBufferMemoryRequirementsInfo2 =
  result = VkBufferMemoryRequirementsInfo2(
    sType: sType,
    pNext: pNext,
    buffer: buffer,
  )

proc newVkDeviceBufferMemoryRequirements*(sType: VkStructureType = VkStructureType.DeviceBufferMemoryRequirements, pNext: pointer = nil, pCreateInfo: ptr VkBufferCreateInfo): VkDeviceBufferMemoryRequirements =
  result = VkDeviceBufferMemoryRequirements(
    sType: sType,
    pNext: pNext,
    pCreateInfo: pCreateInfo,
  )

proc newVkImageMemoryRequirementsInfo2*(sType: VkStructureType = VkStructureType.ImageMemoryRequirementsInfo2, pNext: pointer = nil, image: VkImage): VkImageMemoryRequirementsInfo2 =
  result = VkImageMemoryRequirementsInfo2(
    sType: sType,
    pNext: pNext,
    image: image,
  )

proc newVkImageSparseMemoryRequirementsInfo2*(sType: VkStructureType = VkStructureType.ImageSparseMemoryRequirementsInfo2, pNext: pointer = nil, image: VkImage): VkImageSparseMemoryRequirementsInfo2 =
  result = VkImageSparseMemoryRequirementsInfo2(
    sType: sType,
    pNext: pNext,
    image: image,
  )

proc newVkDeviceImageMemoryRequirements*(sType: VkStructureType = VkStructureType.DeviceImageMemoryRequirements, pNext: pointer = nil, pCreateInfo: ptr VkImageCreateInfo, planeAspect: VkImageAspectFlagBits): VkDeviceImageMemoryRequirements =
  result = VkDeviceImageMemoryRequirements(
    sType: sType,
    pNext: pNext,
    pCreateInfo: pCreateInfo,
    planeAspect: planeAspect,
  )

proc newVkMemoryRequirements2*(sType: VkStructureType = VkStructureType.MemoryRequirements2, pNext: pointer = nil, memoryRequirements: VkMemoryRequirements): VkMemoryRequirements2 =
  result = VkMemoryRequirements2(
    sType: sType,
    pNext: pNext,
    memoryRequirements: memoryRequirements,
  )

proc newVkSparseImageMemoryRequirements2*(sType: VkStructureType = VkStructureType.SparseImageMemoryRequirements2, pNext: pointer = nil, memoryRequirements: VkSparseImageMemoryRequirements): VkSparseImageMemoryRequirements2 =
  result = VkSparseImageMemoryRequirements2(
    sType: sType,
    pNext: pNext,
    memoryRequirements: memoryRequirements,
  )

proc newVkPhysicalDevicePointClippingProperties*(sType: VkStructureType = VkStructureType.PhysicalDevicePointClippingProperties, pNext: pointer = nil, pointClippingBehavior: VkPointClippingBehavior): VkPhysicalDevicePointClippingProperties =
  result = VkPhysicalDevicePointClippingProperties(
    sType: sType,
    pNext: pNext,
    pointClippingBehavior: pointClippingBehavior,
  )

proc newVkMemoryDedicatedRequirements*(sType: VkStructureType = VkStructureType.MemoryDedicatedRequirements, pNext: pointer = nil, prefersDedicatedAllocation: VkBool32, requiresDedicatedAllocation: VkBool32): VkMemoryDedicatedRequirements =
  result = VkMemoryDedicatedRequirements(
    sType: sType,
    pNext: pNext,
    prefersDedicatedAllocation: prefersDedicatedAllocation,
    requiresDedicatedAllocation: requiresDedicatedAllocation,
  )

proc newVkMemoryDedicatedAllocateInfo*(sType: VkStructureType = VkStructureType.MemoryDedicatedAllocateInfo, pNext: pointer = nil, image: VkImage, buffer: VkBuffer): VkMemoryDedicatedAllocateInfo =
  result = VkMemoryDedicatedAllocateInfo(
    sType: sType,
    pNext: pNext,
    image: image,
    buffer: buffer,
  )

proc newVkImageViewUsageCreateInfo*(sType: VkStructureType = VkStructureType.ImageViewUsageCreateInfo, pNext: pointer = nil, usage: VkImageUsageFlags): VkImageViewUsageCreateInfo =
  result = VkImageViewUsageCreateInfo(
    sType: sType,
    pNext: pNext,
    usage: usage,
  )

proc newVkImageViewSlicedCreateInfoEXT*(sType: VkStructureType = VkStructureType.ImageViewSlicedCreateInfoEXT, pNext: pointer = nil, sliceOffset: uint32, sliceCount: uint32): VkImageViewSlicedCreateInfoEXT =
  result = VkImageViewSlicedCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    sliceOffset: sliceOffset,
    sliceCount: sliceCount,
  )

proc newVkPipelineTessellationDomainOriginStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineTessellationDomainOriginStateCreateInfo, pNext: pointer = nil, domainOrigin: VkTessellationDomainOrigin): VkPipelineTessellationDomainOriginStateCreateInfo =
  result = VkPipelineTessellationDomainOriginStateCreateInfo(
    sType: sType,
    pNext: pNext,
    domainOrigin: domainOrigin,
  )

proc newVkSamplerYcbcrConversionInfo*(sType: VkStructureType = VkStructureType.SamplerYcbcrConversionInfo, pNext: pointer = nil, conversion: VkSamplerYcbcrConversion): VkSamplerYcbcrConversionInfo =
  result = VkSamplerYcbcrConversionInfo(
    sType: sType,
    pNext: pNext,
    conversion: conversion,
  )

proc newVkSamplerYcbcrConversionCreateInfo*(sType: VkStructureType = VkStructureType.SamplerYcbcrConversionCreateInfo, pNext: pointer = nil, format: VkFormat, ycbcrModel: VkSamplerYcbcrModelConversion, ycbcrRange: VkSamplerYcbcrRange, components: VkComponentMapping, xChromaOffset: VkChromaLocation, yChromaOffset: VkChromaLocation, chromaFilter: VkFilter, forceExplicitReconstruction: VkBool32): VkSamplerYcbcrConversionCreateInfo =
  result = VkSamplerYcbcrConversionCreateInfo(
    sType: sType,
    pNext: pNext,
    format: format,
    ycbcrModel: ycbcrModel,
    ycbcrRange: ycbcrRange,
    components: components,
    xChromaOffset: xChromaOffset,
    yChromaOffset: yChromaOffset,
    chromaFilter: chromaFilter,
    forceExplicitReconstruction: forceExplicitReconstruction,
  )

proc newVkBindImagePlaneMemoryInfo*(sType: VkStructureType = VkStructureType.BindImagePlaneMemoryInfo, pNext: pointer = nil, planeAspect: VkImageAspectFlagBits): VkBindImagePlaneMemoryInfo =
  result = VkBindImagePlaneMemoryInfo(
    sType: sType,
    pNext: pNext,
    planeAspect: planeAspect,
  )

proc newVkImagePlaneMemoryRequirementsInfo*(sType: VkStructureType = VkStructureType.ImagePlaneMemoryRequirementsInfo, pNext: pointer = nil, planeAspect: VkImageAspectFlagBits): VkImagePlaneMemoryRequirementsInfo =
  result = VkImagePlaneMemoryRequirementsInfo(
    sType: sType,
    pNext: pNext,
    planeAspect: planeAspect,
  )

proc newVkPhysicalDeviceSamplerYcbcrConversionFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceSamplerYcbcrConversionFeatures, pNext: pointer = nil, samplerYcbcrConversion: VkBool32): VkPhysicalDeviceSamplerYcbcrConversionFeatures =
  result = VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    sType: sType,
    pNext: pNext,
    samplerYcbcrConversion: samplerYcbcrConversion,
  )

proc newVkSamplerYcbcrConversionImageFormatProperties*(sType: VkStructureType = VkStructureType.SamplerYcbcrConversionImageFormatProperties, pNext: pointer = nil, combinedImageSamplerDescriptorCount: uint32): VkSamplerYcbcrConversionImageFormatProperties =
  result = VkSamplerYcbcrConversionImageFormatProperties(
    sType: sType,
    pNext: pNext,
    combinedImageSamplerDescriptorCount: combinedImageSamplerDescriptorCount,
  )

proc newVkTextureLODGatherFormatPropertiesAMD*(sType: VkStructureType = VkStructureType.TextureLODGatherFormatPropertiesAMD, pNext: pointer = nil, supportsTextureGatherLODBiasAMD: VkBool32): VkTextureLODGatherFormatPropertiesAMD =
  result = VkTextureLODGatherFormatPropertiesAMD(
    sType: sType,
    pNext: pNext,
    supportsTextureGatherLODBiasAMD: supportsTextureGatherLODBiasAMD,
  )

proc newVkConditionalRenderingBeginInfoEXT*(sType: VkStructureType = VkStructureType.ConditionalRenderingBeginInfoEXT, pNext: pointer = nil, buffer: VkBuffer, offset: VkDeviceSize, flags: VkConditionalRenderingFlagsEXT = 0.VkConditionalRenderingFlagsEXT): VkConditionalRenderingBeginInfoEXT =
  result = VkConditionalRenderingBeginInfoEXT(
    sType: sType,
    pNext: pNext,
    buffer: buffer,
    offset: offset,
    flags: flags,
  )

proc newVkProtectedSubmitInfo*(sType: VkStructureType = VkStructureType.ProtectedSubmitInfo, pNext: pointer = nil, protectedSubmit: VkBool32): VkProtectedSubmitInfo =
  result = VkProtectedSubmitInfo(
    sType: sType,
    pNext: pNext,
    protectedSubmit: protectedSubmit,
  )

proc newVkPhysicalDeviceProtectedMemoryFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceProtectedMemoryFeatures, pNext: pointer = nil, protectedMemory: VkBool32): VkPhysicalDeviceProtectedMemoryFeatures =
  result = VkPhysicalDeviceProtectedMemoryFeatures(
    sType: sType,
    pNext: pNext,
    protectedMemory: protectedMemory,
  )

proc newVkPhysicalDeviceProtectedMemoryProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceProtectedMemoryProperties, pNext: pointer = nil, protectedNoFault: VkBool32): VkPhysicalDeviceProtectedMemoryProperties =
  result = VkPhysicalDeviceProtectedMemoryProperties(
    sType: sType,
    pNext: pNext,
    protectedNoFault: protectedNoFault,
  )

proc newVkDeviceQueueInfo2*(sType: VkStructureType = VkStructureType.DeviceQueueInfo2, pNext: pointer = nil, flags: VkDeviceQueueCreateFlags = 0.VkDeviceQueueCreateFlags, queueFamilyIndex: uint32, queueIndex: uint32): VkDeviceQueueInfo2 =
  result = VkDeviceQueueInfo2(
    sType: sType,
    pNext: pNext,
    flags: flags,
    queueFamilyIndex: queueFamilyIndex,
    queueIndex: queueIndex,
  )

proc newVkPipelineCoverageToColorStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineCoverageToColorStateCreateInfoNV, pNext: pointer = nil, flags: VkPipelineCoverageToColorStateCreateFlagsNV = 0.VkPipelineCoverageToColorStateCreateFlagsNV, coverageToColorEnable: VkBool32, coverageToColorLocation: uint32): VkPipelineCoverageToColorStateCreateInfoNV =
  result = VkPipelineCoverageToColorStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    flags: flags,
    coverageToColorEnable: coverageToColorEnable,
    coverageToColorLocation: coverageToColorLocation,
  )

proc newVkPhysicalDeviceSamplerFilterMinmaxProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceSamplerFilterMinmaxProperties, pNext: pointer = nil, filterMinmaxSingleComponentFormats: VkBool32, filterMinmaxImageComponentMapping: VkBool32): VkPhysicalDeviceSamplerFilterMinmaxProperties =
  result = VkPhysicalDeviceSamplerFilterMinmaxProperties(
    sType: sType,
    pNext: pNext,
    filterMinmaxSingleComponentFormats: filterMinmaxSingleComponentFormats,
    filterMinmaxImageComponentMapping: filterMinmaxImageComponentMapping,
  )

proc newVkSampleLocationEXT*(x: float32, y: float32): VkSampleLocationEXT =
  result = VkSampleLocationEXT(
    x: x,
    y: y,
  )

proc newVkSampleLocationsInfoEXT*(sType: VkStructureType = VkStructureType.SampleLocationsInfoEXT, pNext: pointer = nil, sampleLocationsPerPixel: VkSampleCountFlagBits, sampleLocationGridSize: VkExtent2D, sampleLocations: openarray[VkSampleLocationEXT]): VkSampleLocationsInfoEXT =
  result = VkSampleLocationsInfoEXT(
    sType: sType,
    pNext: pNext,
    sampleLocationsPerPixel: sampleLocationsPerPixel,
    sampleLocationGridSize: sampleLocationGridSize,
    sampleLocationsCount: len(sampleLocations).uint32,
    pSampleLocations: if len(sampleLocations) == 0: nil else: cast[ptr VkSampleLocationEXT](sampleLocations),
  )

proc newVkAttachmentSampleLocationsEXT*(attachmentIndex: uint32, sampleLocationsInfo: VkSampleLocationsInfoEXT): VkAttachmentSampleLocationsEXT =
  result = VkAttachmentSampleLocationsEXT(
    attachmentIndex: attachmentIndex,
    sampleLocationsInfo: sampleLocationsInfo,
  )

proc newVkSubpassSampleLocationsEXT*(subpassIndex: uint32, sampleLocationsInfo: VkSampleLocationsInfoEXT): VkSubpassSampleLocationsEXT =
  result = VkSubpassSampleLocationsEXT(
    subpassIndex: subpassIndex,
    sampleLocationsInfo: sampleLocationsInfo,
  )

proc newVkRenderPassSampleLocationsBeginInfoEXT*(sType: VkStructureType = VkStructureType.RenderPassSampleLocationsBeginInfoEXT, pNext: pointer = nil, attachmentInitialSampleLocations: openarray[VkAttachmentSampleLocationsEXT], postSubpassSampleLocations: openarray[VkSubpassSampleLocationsEXT]): VkRenderPassSampleLocationsBeginInfoEXT =
  result = VkRenderPassSampleLocationsBeginInfoEXT(
    sType: sType,
    pNext: pNext,
    attachmentInitialSampleLocationsCount: len(attachmentInitialSampleLocations).uint32,
    pAttachmentInitialSampleLocations: if len(attachmentInitialSampleLocations) == 0: nil else: cast[ptr VkAttachmentSampleLocationsEXT](attachmentInitialSampleLocations),
    postSubpassSampleLocationsCount: len(postSubpassSampleLocations).uint32,
    pPostSubpassSampleLocations: if len(postSubpassSampleLocations) == 0: nil else: cast[ptr VkSubpassSampleLocationsEXT](postSubpassSampleLocations),
  )

proc newVkPipelineSampleLocationsStateCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineSampleLocationsStateCreateInfoEXT, pNext: pointer = nil, sampleLocationsEnable: VkBool32, sampleLocationsInfo: VkSampleLocationsInfoEXT): VkPipelineSampleLocationsStateCreateInfoEXT =
  result = VkPipelineSampleLocationsStateCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    sampleLocationsEnable: sampleLocationsEnable,
    sampleLocationsInfo: sampleLocationsInfo,
  )

proc newVkPhysicalDeviceSampleLocationsPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceSampleLocationsPropertiesEXT, pNext: pointer = nil, sampleLocationSampleCounts: VkSampleCountFlags, maxSampleLocationGridSize: VkExtent2D, sampleLocationCoordinateRange: array[2, float32], sampleLocationSubPixelBits: uint32, variableSampleLocations: VkBool32): VkPhysicalDeviceSampleLocationsPropertiesEXT =
  result = VkPhysicalDeviceSampleLocationsPropertiesEXT(
    sType: sType,
    pNext: pNext,
    sampleLocationSampleCounts: sampleLocationSampleCounts,
    maxSampleLocationGridSize: maxSampleLocationGridSize,
    sampleLocationCoordinateRange: sampleLocationCoordinateRange,
    sampleLocationSubPixelBits: sampleLocationSubPixelBits,
    variableSampleLocations: variableSampleLocations,
  )

proc newVkMultisamplePropertiesEXT*(sType: VkStructureType = VkStructureType.MultisamplePropertiesEXT, pNext: pointer = nil, maxSampleLocationGridSize: VkExtent2D): VkMultisamplePropertiesEXT =
  result = VkMultisamplePropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxSampleLocationGridSize: maxSampleLocationGridSize,
  )

proc newVkSamplerReductionModeCreateInfo*(sType: VkStructureType = VkStructureType.SamplerReductionModeCreateInfo, pNext: pointer = nil, reductionMode: VkSamplerReductionMode): VkSamplerReductionModeCreateInfo =
  result = VkSamplerReductionModeCreateInfo(
    sType: sType,
    pNext: pNext,
    reductionMode: reductionMode,
  )

proc newVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceBlendOperationAdvancedFeaturesEXT, pNext: pointer = nil, advancedBlendCoherentOperations: VkBool32): VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT =
  result = VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    sType: sType,
    pNext: pNext,
    advancedBlendCoherentOperations: advancedBlendCoherentOperations,
  )

proc newVkPhysicalDeviceMultiDrawFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMultiDrawFeaturesEXT, pNext: pointer = nil, multiDraw: VkBool32): VkPhysicalDeviceMultiDrawFeaturesEXT =
  result = VkPhysicalDeviceMultiDrawFeaturesEXT(
    sType: sType,
    pNext: pNext,
    multiDraw: multiDraw,
  )

proc newVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceBlendOperationAdvancedPropertiesEXT, pNext: pointer = nil, advancedBlendMaxColorAttachments: uint32, advancedBlendIndependentBlend: VkBool32, advancedBlendNonPremultipliedSrcColor: VkBool32, advancedBlendNonPremultipliedDstColor: VkBool32, advancedBlendCorrelatedOverlap: VkBool32, advancedBlendAllOperations: VkBool32): VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT =
  result = VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    sType: sType,
    pNext: pNext,
    advancedBlendMaxColorAttachments: advancedBlendMaxColorAttachments,
    advancedBlendIndependentBlend: advancedBlendIndependentBlend,
    advancedBlendNonPremultipliedSrcColor: advancedBlendNonPremultipliedSrcColor,
    advancedBlendNonPremultipliedDstColor: advancedBlendNonPremultipliedDstColor,
    advancedBlendCorrelatedOverlap: advancedBlendCorrelatedOverlap,
    advancedBlendAllOperations: advancedBlendAllOperations,
  )

proc newVkPipelineColorBlendAdvancedStateCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineColorBlendAdvancedStateCreateInfoEXT, pNext: pointer = nil, srcPremultiplied: VkBool32, dstPremultiplied: VkBool32, blendOverlap: VkBlendOverlapEXT): VkPipelineColorBlendAdvancedStateCreateInfoEXT =
  result = VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    srcPremultiplied: srcPremultiplied,
    dstPremultiplied: dstPremultiplied,
    blendOverlap: blendOverlap,
  )

proc newVkPhysicalDeviceInlineUniformBlockFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceInlineUniformBlockFeatures, pNext: pointer = nil, inlineUniformBlock: VkBool32, descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32): VkPhysicalDeviceInlineUniformBlockFeatures =
  result = VkPhysicalDeviceInlineUniformBlockFeatures(
    sType: sType,
    pNext: pNext,
    inlineUniformBlock: inlineUniformBlock,
    descriptorBindingInlineUniformBlockUpdateAfterBind: descriptorBindingInlineUniformBlockUpdateAfterBind,
  )

proc newVkPhysicalDeviceInlineUniformBlockProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceInlineUniformBlockProperties, pNext: pointer = nil, maxInlineUniformBlockSize: uint32, maxPerStageDescriptorInlineUniformBlocks: uint32, maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: uint32, maxDescriptorSetInlineUniformBlocks: uint32, maxDescriptorSetUpdateAfterBindInlineUniformBlocks: uint32): VkPhysicalDeviceInlineUniformBlockProperties =
  result = VkPhysicalDeviceInlineUniformBlockProperties(
    sType: sType,
    pNext: pNext,
    maxInlineUniformBlockSize: maxInlineUniformBlockSize,
    maxPerStageDescriptorInlineUniformBlocks: maxPerStageDescriptorInlineUniformBlocks,
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks,
    maxDescriptorSetInlineUniformBlocks: maxDescriptorSetInlineUniformBlocks,
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: maxDescriptorSetUpdateAfterBindInlineUniformBlocks,
  )

proc newVkWriteDescriptorSetInlineUniformBlock*(sType: VkStructureType = VkStructureType.WriteDescriptorSetInlineUniformBlock, pNext: pointer = nil, dataSize: uint32, pData: pointer = nil): VkWriteDescriptorSetInlineUniformBlock =
  result = VkWriteDescriptorSetInlineUniformBlock(
    sType: sType,
    pNext: pNext,
    dataSize: dataSize,
    pData: pData,
  )

proc newVkDescriptorPoolInlineUniformBlockCreateInfo*(sType: VkStructureType = VkStructureType.DescriptorPoolInlineUniformBlockCreateInfo, pNext: pointer = nil, maxInlineUniformBlockBindings: uint32): VkDescriptorPoolInlineUniformBlockCreateInfo =
  result = VkDescriptorPoolInlineUniformBlockCreateInfo(
    sType: sType,
    pNext: pNext,
    maxInlineUniformBlockBindings: maxInlineUniformBlockBindings,
  )

proc newVkPipelineCoverageModulationStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineCoverageModulationStateCreateInfoNV, pNext: pointer = nil, flags: VkPipelineCoverageModulationStateCreateFlagsNV = 0.VkPipelineCoverageModulationStateCreateFlagsNV, coverageModulationMode: VkCoverageModulationModeNV, coverageModulationTableEnable: VkBool32, coverageModulationTableCount: uint32, pCoverageModulationTable: ptr float32): VkPipelineCoverageModulationStateCreateInfoNV =
  result = VkPipelineCoverageModulationStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    flags: flags,
    coverageModulationMode: coverageModulationMode,
    coverageModulationTableEnable: coverageModulationTableEnable,
    coverageModulationTableCount: coverageModulationTableCount,
    pCoverageModulationTable: pCoverageModulationTable,
  )

proc newVkImageFormatListCreateInfo*(sType: VkStructureType = VkStructureType.ImageFormatListCreateInfo, pNext: pointer = nil, viewFormats: openarray[VkFormat]): VkImageFormatListCreateInfo =
  result = VkImageFormatListCreateInfo(
    sType: sType,
    pNext: pNext,
    viewFormatCount: len(viewFormats).uint32,
    pViewFormats: if len(viewFormats) == 0: nil else: cast[ptr VkFormat](viewFormats),
  )

proc newVkValidationCacheCreateInfoEXT*(sType: VkStructureType = VkStructureType.ValidationCacheCreateInfoEXT, pNext: pointer = nil, flags: VkValidationCacheCreateFlagsEXT = 0.VkValidationCacheCreateFlagsEXT, initialDataSize: uint, pInitialData: pointer = nil): VkValidationCacheCreateInfoEXT =
  result = VkValidationCacheCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    initialDataSize: initialDataSize,
    pInitialData: pInitialData,
  )

proc newVkShaderModuleValidationCacheCreateInfoEXT*(sType: VkStructureType = VkStructureType.ShaderModuleValidationCacheCreateInfoEXT, pNext: pointer = nil, validationCache: VkValidationCacheEXT): VkShaderModuleValidationCacheCreateInfoEXT =
  result = VkShaderModuleValidationCacheCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    validationCache: validationCache,
  )

proc newVkPhysicalDeviceMaintenance3Properties*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance3Properties, pNext: pointer = nil, maxPerSetDescriptors: uint32, maxMemoryAllocationSize: VkDeviceSize): VkPhysicalDeviceMaintenance3Properties =
  result = VkPhysicalDeviceMaintenance3Properties(
    sType: sType,
    pNext: pNext,
    maxPerSetDescriptors: maxPerSetDescriptors,
    maxMemoryAllocationSize: maxMemoryAllocationSize,
  )

proc newVkPhysicalDeviceMaintenance4Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance4Features, pNext: pointer = nil, maintenance4: VkBool32): VkPhysicalDeviceMaintenance4Features =
  result = VkPhysicalDeviceMaintenance4Features(
    sType: sType,
    pNext: pNext,
    maintenance4: maintenance4,
  )

proc newVkPhysicalDeviceMaintenance4Properties*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance4Properties, pNext: pointer = nil, maxBufferSize: VkDeviceSize): VkPhysicalDeviceMaintenance4Properties =
  result = VkPhysicalDeviceMaintenance4Properties(
    sType: sType,
    pNext: pNext,
    maxBufferSize: maxBufferSize,
  )

proc newVkPhysicalDeviceMaintenance5Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance5Features, pNext: pointer = nil, maintenance5: VkBool32): VkPhysicalDeviceMaintenance5Features =
  result = VkPhysicalDeviceMaintenance5Features(
    sType: sType,
    pNext: pNext,
    maintenance5: maintenance5,
  )

proc newVkPhysicalDeviceMaintenance5Properties*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance5Properties, pNext: pointer = nil, earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32, earlyFragmentSampleMaskTestBeforeSampleCounting: VkBool32, depthStencilSwizzleOneSupport: VkBool32, polygonModePointSize: VkBool32, nonStrictSinglePixelWideLinesUseParallelogram: VkBool32, nonStrictWideLinesUseParallelogram: VkBool32): VkPhysicalDeviceMaintenance5Properties =
  result = VkPhysicalDeviceMaintenance5Properties(
    sType: sType,
    pNext: pNext,
    earlyFragmentMultisampleCoverageAfterSampleCounting: earlyFragmentMultisampleCoverageAfterSampleCounting,
    earlyFragmentSampleMaskTestBeforeSampleCounting: earlyFragmentSampleMaskTestBeforeSampleCounting,
    depthStencilSwizzleOneSupport: depthStencilSwizzleOneSupport,
    polygonModePointSize: polygonModePointSize,
    nonStrictSinglePixelWideLinesUseParallelogram: nonStrictSinglePixelWideLinesUseParallelogram,
    nonStrictWideLinesUseParallelogram: nonStrictWideLinesUseParallelogram,
  )

proc newVkPhysicalDeviceMaintenance6Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance6Features, pNext: pointer = nil, maintenance6: VkBool32): VkPhysicalDeviceMaintenance6Features =
  result = VkPhysicalDeviceMaintenance6Features(
    sType: sType,
    pNext: pNext,
    maintenance6: maintenance6,
  )

proc newVkPhysicalDeviceMaintenance6Properties*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance6Properties, pNext: pointer = nil, blockTexelViewCompatibleMultipleLayers: VkBool32, maxCombinedImageSamplerDescriptorCount: uint32, fragmentShadingRateClampCombinerInputs: VkBool32): VkPhysicalDeviceMaintenance6Properties =
  result = VkPhysicalDeviceMaintenance6Properties(
    sType: sType,
    pNext: pNext,
    blockTexelViewCompatibleMultipleLayers: blockTexelViewCompatibleMultipleLayers,
    maxCombinedImageSamplerDescriptorCount: maxCombinedImageSamplerDescriptorCount,
    fragmentShadingRateClampCombinerInputs: fragmentShadingRateClampCombinerInputs,
  )

proc newVkPhysicalDeviceMaintenance7FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance7FeaturesKHR, pNext: pointer = nil, maintenance7: VkBool32): VkPhysicalDeviceMaintenance7FeaturesKHR =
  result = VkPhysicalDeviceMaintenance7FeaturesKHR(
    sType: sType,
    pNext: pNext,
    maintenance7: maintenance7,
  )

proc newVkPhysicalDeviceMaintenance7PropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance7PropertiesKHR, pNext: pointer = nil, robustFragmentShadingRateAttachmentAccess: VkBool32, separateDepthStencilAttachmentAccess: VkBool32, maxDescriptorSetTotalUniformBuffersDynamic: uint32, maxDescriptorSetTotalStorageBuffersDynamic: uint32, maxDescriptorSetTotalBuffersDynamic: uint32, maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic: uint32, maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic: uint32, maxDescriptorSetUpdateAfterBindTotalBuffersDynamic: uint32): VkPhysicalDeviceMaintenance7PropertiesKHR =
  result = VkPhysicalDeviceMaintenance7PropertiesKHR(
    sType: sType,
    pNext: pNext,
    robustFragmentShadingRateAttachmentAccess: robustFragmentShadingRateAttachmentAccess,
    separateDepthStencilAttachmentAccess: separateDepthStencilAttachmentAccess,
    maxDescriptorSetTotalUniformBuffersDynamic: maxDescriptorSetTotalUniformBuffersDynamic,
    maxDescriptorSetTotalStorageBuffersDynamic: maxDescriptorSetTotalStorageBuffersDynamic,
    maxDescriptorSetTotalBuffersDynamic: maxDescriptorSetTotalBuffersDynamic,
    maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic: maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic,
    maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic: maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic,
    maxDescriptorSetUpdateAfterBindTotalBuffersDynamic: maxDescriptorSetUpdateAfterBindTotalBuffersDynamic,
  )

proc newVkPhysicalDeviceLayeredApiPropertiesListKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceLayeredApiPropertiesListKHR, pNext: pointer = nil, layeredApis: openarray[VkPhysicalDeviceLayeredApiPropertiesKHR]): VkPhysicalDeviceLayeredApiPropertiesListKHR =
  result = VkPhysicalDeviceLayeredApiPropertiesListKHR(
    sType: sType,
    pNext: pNext,
    layeredApiCount: len(layeredApis).uint32,
    pLayeredApis: if len(layeredApis) == 0: nil else: cast[ptr VkPhysicalDeviceLayeredApiPropertiesKHR](layeredApis),
  )

proc newVkPhysicalDeviceLayeredApiPropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceLayeredApiPropertiesKHR, pNext: pointer = nil, vendorID: uint32, deviceID: uint32, layeredAPI: VkPhysicalDeviceLayeredApiKHR, deviceName: array[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE, char]): VkPhysicalDeviceLayeredApiPropertiesKHR =
  result = VkPhysicalDeviceLayeredApiPropertiesKHR(
    sType: sType,
    pNext: pNext,
    vendorID: vendorID,
    deviceID: deviceID,
    layeredAPI: layeredAPI,
    deviceName: deviceName,
  )

proc newVkPhysicalDeviceLayeredApiVulkanPropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceLayeredApiVulkanPropertiesKHR, pNext: pointer = nil, properties: VkPhysicalDeviceProperties2): VkPhysicalDeviceLayeredApiVulkanPropertiesKHR =
  result = VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(
    sType: sType,
    pNext: pNext,
    properties: properties,
  )

proc newVkPhysicalDeviceMaintenance8FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance8FeaturesKHR, pNext: pointer = nil, maintenance8: VkBool32): VkPhysicalDeviceMaintenance8FeaturesKHR =
  result = VkPhysicalDeviceMaintenance8FeaturesKHR(
    sType: sType,
    pNext: pNext,
    maintenance8: maintenance8,
  )

proc newVkPhysicalDeviceMaintenance9FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance9FeaturesKHR, pNext: pointer = nil, maintenance9: VkBool32): VkPhysicalDeviceMaintenance9FeaturesKHR =
  result = VkPhysicalDeviceMaintenance9FeaturesKHR(
    sType: sType,
    pNext: pNext,
    maintenance9: maintenance9,
  )

proc newVkPhysicalDeviceMaintenance9PropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance9PropertiesKHR, pNext: pointer = nil, image2DViewOf3DSparse: VkBool32, defaultVertexAttributeValue: VkDefaultVertexAttributeValueKHR): VkPhysicalDeviceMaintenance9PropertiesKHR =
  result = VkPhysicalDeviceMaintenance9PropertiesKHR(
    sType: sType,
    pNext: pNext,
    image2DViewOf3DSparse: image2DViewOf3DSparse,
    defaultVertexAttributeValue: defaultVertexAttributeValue,
  )

proc newVkPhysicalDeviceMaintenance10PropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance10PropertiesKHR, pNext: pointer = nil, rgba4OpaqueBlackSwizzled: VkBool32, resolveSrgbFormatAppliesTransferFunction: VkBool32, resolveSrgbFormatSupportsTransferFunctionControl: VkBool32): VkPhysicalDeviceMaintenance10PropertiesKHR =
  result = VkPhysicalDeviceMaintenance10PropertiesKHR(
    sType: sType,
    pNext: pNext,
    rgba4OpaqueBlackSwizzled: rgba4OpaqueBlackSwizzled,
    resolveSrgbFormatAppliesTransferFunction: resolveSrgbFormatAppliesTransferFunction,
    resolveSrgbFormatSupportsTransferFunctionControl: resolveSrgbFormatSupportsTransferFunctionControl,
  )

proc newVkPhysicalDeviceMaintenance10FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceMaintenance10FeaturesKHR, pNext: pointer = nil, maintenance10: VkBool32): VkPhysicalDeviceMaintenance10FeaturesKHR =
  result = VkPhysicalDeviceMaintenance10FeaturesKHR(
    sType: sType,
    pNext: pNext,
    maintenance10: maintenance10,
  )

proc newVkQueueFamilyOwnershipTransferPropertiesKHR*(sType: VkStructureType = VkStructureType.QueueFamilyOwnershipTransferPropertiesKHR, pNext: pointer = nil, optimalImageTransferToQueueFamilies: uint32): VkQueueFamilyOwnershipTransferPropertiesKHR =
  result = VkQueueFamilyOwnershipTransferPropertiesKHR(
    sType: sType,
    pNext: pNext,
    optimalImageTransferToQueueFamilies: optimalImageTransferToQueueFamilies,
  )

proc newVkRenderingAreaInfo*(sType: VkStructureType = VkStructureType.RenderingAreaInfo, pNext: pointer = nil, viewMask: uint32, colorAttachmentFormats: openarray[VkFormat], depthAttachmentFormat: VkFormat, stencilAttachmentFormat: VkFormat): VkRenderingAreaInfo =
  result = VkRenderingAreaInfo(
    sType: sType,
    pNext: pNext,
    viewMask: viewMask,
    colorAttachmentCount: len(colorAttachmentFormats).uint32,
    pColorAttachmentFormats: if len(colorAttachmentFormats) == 0: nil else: cast[ptr VkFormat](colorAttachmentFormats),
    depthAttachmentFormat: depthAttachmentFormat,
    stencilAttachmentFormat: stencilAttachmentFormat,
  )

proc newVkDescriptorSetLayoutSupport*(sType: VkStructureType = VkStructureType.DescriptorSetLayoutSupport, pNext: pointer = nil, supported: VkBool32): VkDescriptorSetLayoutSupport =
  result = VkDescriptorSetLayoutSupport(
    sType: sType,
    pNext: pNext,
    supported: supported,
  )

proc newVkPhysicalDeviceShaderDrawParametersFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderDrawParametersFeatures, pNext: pointer = nil, shaderDrawParameters: VkBool32): VkPhysicalDeviceShaderDrawParametersFeatures =
  result = VkPhysicalDeviceShaderDrawParametersFeatures(
    sType: sType,
    pNext: pNext,
    shaderDrawParameters: shaderDrawParameters,
  )

proc newVkPhysicalDeviceShaderFloat16Int8Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderFloat16Int8Features, pNext: pointer = nil, shaderFloat16: VkBool32, shaderInt8: VkBool32): VkPhysicalDeviceShaderFloat16Int8Features =
  result = VkPhysicalDeviceShaderFloat16Int8Features(
    sType: sType,
    pNext: pNext,
    shaderFloat16: shaderFloat16,
    shaderInt8: shaderInt8,
  )

proc newVkPhysicalDeviceFloatControlsProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceFloatControlsProperties, pNext: pointer = nil, denormBehaviorIndependence: VkShaderFloatControlsIndependence, roundingModeIndependence: VkShaderFloatControlsIndependence, shaderSignedZeroInfNanPreserveFloat16: VkBool32, shaderSignedZeroInfNanPreserveFloat32: VkBool32, shaderSignedZeroInfNanPreserveFloat64: VkBool32, shaderDenormPreserveFloat16: VkBool32, shaderDenormPreserveFloat32: VkBool32, shaderDenormPreserveFloat64: VkBool32, shaderDenormFlushToZeroFloat16: VkBool32, shaderDenormFlushToZeroFloat32: VkBool32, shaderDenormFlushToZeroFloat64: VkBool32, shaderRoundingModeRTEFloat16: VkBool32, shaderRoundingModeRTEFloat32: VkBool32, shaderRoundingModeRTEFloat64: VkBool32, shaderRoundingModeRTZFloat16: VkBool32, shaderRoundingModeRTZFloat32: VkBool32, shaderRoundingModeRTZFloat64: VkBool32): VkPhysicalDeviceFloatControlsProperties =
  result = VkPhysicalDeviceFloatControlsProperties(
    sType: sType,
    pNext: pNext,
    denormBehaviorIndependence: denormBehaviorIndependence,
    roundingModeIndependence: roundingModeIndependence,
    shaderSignedZeroInfNanPreserveFloat16: shaderSignedZeroInfNanPreserveFloat16,
    shaderSignedZeroInfNanPreserveFloat32: shaderSignedZeroInfNanPreserveFloat32,
    shaderSignedZeroInfNanPreserveFloat64: shaderSignedZeroInfNanPreserveFloat64,
    shaderDenormPreserveFloat16: shaderDenormPreserveFloat16,
    shaderDenormPreserveFloat32: shaderDenormPreserveFloat32,
    shaderDenormPreserveFloat64: shaderDenormPreserveFloat64,
    shaderDenormFlushToZeroFloat16: shaderDenormFlushToZeroFloat16,
    shaderDenormFlushToZeroFloat32: shaderDenormFlushToZeroFloat32,
    shaderDenormFlushToZeroFloat64: shaderDenormFlushToZeroFloat64,
    shaderRoundingModeRTEFloat16: shaderRoundingModeRTEFloat16,
    shaderRoundingModeRTEFloat32: shaderRoundingModeRTEFloat32,
    shaderRoundingModeRTEFloat64: shaderRoundingModeRTEFloat64,
    shaderRoundingModeRTZFloat16: shaderRoundingModeRTZFloat16,
    shaderRoundingModeRTZFloat32: shaderRoundingModeRTZFloat32,
    shaderRoundingModeRTZFloat64: shaderRoundingModeRTZFloat64,
  )

proc newVkPhysicalDeviceHostQueryResetFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceHostQueryResetFeatures, pNext: pointer = nil, hostQueryReset: VkBool32): VkPhysicalDeviceHostQueryResetFeatures =
  result = VkPhysicalDeviceHostQueryResetFeatures(
    sType: sType,
    pNext: pNext,
    hostQueryReset: hostQueryReset,
  )

proc newVkNativeBufferUsage2ANDROID*(consumer: uint64, producer: uint64): VkNativeBufferUsage2ANDROID =
  result = VkNativeBufferUsage2ANDROID(
    consumer: consumer,
    producer: producer,
  )

proc newVkNativeBufferANDROID*(sType: VkStructureType, pNext: pointer = nil, handle: pointer = nil, stride: int, format: int, usage: int, usage2: VkNativeBufferUsage2ANDROID): VkNativeBufferANDROID =
  result = VkNativeBufferANDROID(
    sType: sType,
    pNext: pNext,
    handle: handle,
    stride: stride,
    format: format,
    usage: usage,
    usage2: usage2,
  )

proc newVkSwapchainImageCreateInfoANDROID*(sType: VkStructureType, pNext: pointer = nil, usage: VkSwapchainImageUsageFlagsANDROID): VkSwapchainImageCreateInfoANDROID =
  result = VkSwapchainImageCreateInfoANDROID(
    sType: sType,
    pNext: pNext,
    usage: usage,
  )

proc newVkPhysicalDevicePresentationPropertiesANDROID*(sType: VkStructureType, pNext: pointer = nil, sharedImage: VkBool32): VkPhysicalDevicePresentationPropertiesANDROID =
  result = VkPhysicalDevicePresentationPropertiesANDROID(
    sType: sType,
    pNext: pNext,
    sharedImage: sharedImage,
  )

proc newVkShaderResourceUsageAMD*(numUsedVgprs: uint32, numUsedSgprs: uint32, ldsSizePerLocalWorkGroup: uint32, ldsUsageSizeInBytes: uint, scratchMemUsageInBytes: uint): VkShaderResourceUsageAMD =
  result = VkShaderResourceUsageAMD(
    numUsedVgprs: numUsedVgprs,
    numUsedSgprs: numUsedSgprs,
    ldsSizePerLocalWorkGroup: ldsSizePerLocalWorkGroup,
    ldsUsageSizeInBytes: ldsUsageSizeInBytes,
    scratchMemUsageInBytes: scratchMemUsageInBytes,
  )

proc newVkShaderStatisticsInfoAMD*(shaderStageMask: VkShaderStageFlags, resourceUsage: VkShaderResourceUsageAMD, numPhysicalVgprs: uint32, numPhysicalSgprs: uint32, numAvailableVgprs: uint32, numAvailableSgprs: uint32, computeWorkGroupSize: array[3, uint32]): VkShaderStatisticsInfoAMD =
  result = VkShaderStatisticsInfoAMD(
    shaderStageMask: shaderStageMask,
    resourceUsage: resourceUsage,
    numPhysicalVgprs: numPhysicalVgprs,
    numPhysicalSgprs: numPhysicalSgprs,
    numAvailableVgprs: numAvailableVgprs,
    numAvailableSgprs: numAvailableSgprs,
    computeWorkGroupSize: computeWorkGroupSize,
  )

proc newVkDeviceQueueGlobalPriorityCreateInfo*(sType: VkStructureType = VkStructureType.DeviceQueueGlobalPriorityCreateInfo, pNext: pointer = nil, globalPriority: VkQueueGlobalPriority): VkDeviceQueueGlobalPriorityCreateInfo =
  result = VkDeviceQueueGlobalPriorityCreateInfo(
    sType: sType,
    pNext: pNext,
    globalPriority: globalPriority,
  )

proc newVkPhysicalDeviceGlobalPriorityQueryFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceGlobalPriorityQueryFeatures, pNext: pointer = nil, globalPriorityQuery: VkBool32): VkPhysicalDeviceGlobalPriorityQueryFeatures =
  result = VkPhysicalDeviceGlobalPriorityQueryFeatures(
    sType: sType,
    pNext: pNext,
    globalPriorityQuery: globalPriorityQuery,
  )

proc newVkQueueFamilyGlobalPriorityProperties*(sType: VkStructureType = VkStructureType.QueueFamilyGlobalPriorityProperties, pNext: pointer = nil, priorityCount: uint32, priorities: array[VK_MAX_GLOBAL_PRIORITY_SIZE, VkQueueGlobalPriority]): VkQueueFamilyGlobalPriorityProperties =
  result = VkQueueFamilyGlobalPriorityProperties(
    sType: sType,
    pNext: pNext,
    priorityCount: priorityCount,
    priorities: priorities,
  )

proc newVkDebugUtilsObjectNameInfoEXT*(sType: VkStructureType = VkStructureType.DebugUtilsObjectNameInfoEXT, pNext: pointer = nil, objectType: VkObjectType, objectHandle: uint64, pObjectName: cstring): VkDebugUtilsObjectNameInfoEXT =
  result = VkDebugUtilsObjectNameInfoEXT(
    sType: sType,
    pNext: pNext,
    objectType: objectType,
    objectHandle: objectHandle,
    pObjectName: pObjectName,
  )

proc newVkDebugUtilsObjectTagInfoEXT*(sType: VkStructureType = VkStructureType.DebugUtilsObjectTagInfoEXT, pNext: pointer = nil, objectType: VkObjectType, objectHandle: uint64, tagName: uint64, tagSize: uint, pTag: pointer = nil): VkDebugUtilsObjectTagInfoEXT =
  result = VkDebugUtilsObjectTagInfoEXT(
    sType: sType,
    pNext: pNext,
    objectType: objectType,
    objectHandle: objectHandle,
    tagName: tagName,
    tagSize: tagSize,
    pTag: pTag,
  )

proc newVkDebugUtilsLabelEXT*(sType: VkStructureType = VkStructureType.DebugUtilsLabelEXT, pNext: pointer = nil, pLabelName: cstring, color: array[4, float32]): VkDebugUtilsLabelEXT =
  result = VkDebugUtilsLabelEXT(
    sType: sType,
    pNext: pNext,
    pLabelName: pLabelName,
    color: color,
  )

proc newVkDebugUtilsMessengerCreateInfoEXT*(sType: VkStructureType = VkStructureType.DebugUtilsMessengerCreateInfoEXT, pNext: pointer = nil, flags: VkDebugUtilsMessengerCreateFlagsEXT = 0.VkDebugUtilsMessengerCreateFlagsEXT, messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT, messageType: VkDebugUtilsMessageTypeFlagsEXT, pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT, pUserData: pointer = nil): VkDebugUtilsMessengerCreateInfoEXT =
  result = VkDebugUtilsMessengerCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    messageSeverity: messageSeverity,
    messageType: messageType,
    pfnUserCallback: pfnUserCallback,
    pUserData: pUserData,
  )

proc newVkDebugUtilsMessengerCallbackDataEXT*(sType: VkStructureType = VkStructureType.DebugUtilsMessengerCallbackDataEXT, pNext: pointer = nil, flags: VkDebugUtilsMessengerCallbackDataFlagsEXT = 0.VkDebugUtilsMessengerCallbackDataFlagsEXT, pMessageIdName: cstring, messageIdNumber: int32, pMessage: cstring, queueLabels: openarray[VkDebugUtilsLabelEXT], cmdBufLabels: openarray[VkDebugUtilsLabelEXT], objects: openarray[VkDebugUtilsObjectNameInfoEXT]): VkDebugUtilsMessengerCallbackDataEXT =
  result = VkDebugUtilsMessengerCallbackDataEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pMessageIdName: pMessageIdName,
    messageIdNumber: messageIdNumber,
    pMessage: pMessage,
    queueLabelCount: len(queueLabels).uint32,
    pQueueLabels: if len(queueLabels) == 0: nil else: cast[ptr VkDebugUtilsLabelEXT](queueLabels),
    cmdBufLabelCount: len(cmdBufLabels).uint32,
    pCmdBufLabels: if len(cmdBufLabels) == 0: nil else: cast[ptr VkDebugUtilsLabelEXT](cmdBufLabels),
    objectCount: len(objects).uint32,
    pObjects: if len(objects) == 0: nil else: cast[ptr VkDebugUtilsObjectNameInfoEXT](objects),
  )

proc newVkPhysicalDeviceDeviceMemoryReportFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDeviceMemoryReportFeaturesEXT, pNext: pointer = nil, deviceMemoryReport: VkBool32): VkPhysicalDeviceDeviceMemoryReportFeaturesEXT =
  result = VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(
    sType: sType,
    pNext: pNext,
    deviceMemoryReport: deviceMemoryReport,
  )

proc newVkDeviceDeviceMemoryReportCreateInfoEXT*(sType: VkStructureType = VkStructureType.DeviceDeviceMemoryReportCreateInfoEXT, pNext: pointer = nil, flags: VkDeviceMemoryReportFlagsEXT = 0.VkDeviceMemoryReportFlagsEXT, pfnUserCallback: PFN_vkDeviceMemoryReportCallbackEXT, pUserData: pointer = nil): VkDeviceDeviceMemoryReportCreateInfoEXT =
  result = VkDeviceDeviceMemoryReportCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pfnUserCallback: pfnUserCallback,
    pUserData: pUserData,
  )

proc newVkDeviceMemoryReportCallbackDataEXT*(sType: VkStructureType = VkStructureType.DeviceMemoryReportCallbackDataEXT, pNext: pointer = nil, flags: VkDeviceMemoryReportFlagsEXT = 0.VkDeviceMemoryReportFlagsEXT, `type`: VkDeviceMemoryReportEventTypeEXT, memoryObjectId: uint64, size: VkDeviceSize, objectType: VkObjectType, objectHandle: uint64, heapIndex: uint32): VkDeviceMemoryReportCallbackDataEXT =
  result = VkDeviceMemoryReportCallbackDataEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    `type`: `type`,
    memoryObjectId: memoryObjectId,
    size: size,
    objectType: objectType,
    objectHandle: objectHandle,
    heapIndex: heapIndex,
  )

proc newVkImportMemoryHostPointerInfoEXT*(sType: VkStructureType = VkStructureType.ImportMemoryHostPointerInfoEXT, pNext: pointer = nil, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: pointer = nil): VkImportMemoryHostPointerInfoEXT =
  result = VkImportMemoryHostPointerInfoEXT(
    sType: sType,
    pNext: pNext,
    handleType: handleType,
    pHostPointer: pHostPointer,
  )

proc newVkMemoryHostPointerPropertiesEXT*(sType: VkStructureType = VkStructureType.MemoryHostPointerPropertiesEXT, pNext: pointer = nil, memoryTypeBits: uint32): VkMemoryHostPointerPropertiesEXT =
  result = VkMemoryHostPointerPropertiesEXT(
    sType: sType,
    pNext: pNext,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkPhysicalDeviceExternalMemoryHostPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalMemoryHostPropertiesEXT, pNext: pointer = nil, minImportedHostPointerAlignment: VkDeviceSize): VkPhysicalDeviceExternalMemoryHostPropertiesEXT =
  result = VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    sType: sType,
    pNext: pNext,
    minImportedHostPointerAlignment: minImportedHostPointerAlignment,
  )

proc newVkPhysicalDeviceConservativeRasterizationPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceConservativeRasterizationPropertiesEXT, pNext: pointer = nil, primitiveOverestimationSize: float32, maxExtraPrimitiveOverestimationSize: float32, extraPrimitiveOverestimationSizeGranularity: float32, primitiveUnderestimation: VkBool32, conservativePointAndLineRasterization: VkBool32, degenerateTrianglesRasterized: VkBool32, degenerateLinesRasterized: VkBool32, fullyCoveredFragmentShaderInputVariable: VkBool32, conservativeRasterizationPostDepthCoverage: VkBool32): VkPhysicalDeviceConservativeRasterizationPropertiesEXT =
  result = VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    sType: sType,
    pNext: pNext,
    primitiveOverestimationSize: primitiveOverestimationSize,
    maxExtraPrimitiveOverestimationSize: maxExtraPrimitiveOverestimationSize,
    extraPrimitiveOverestimationSizeGranularity: extraPrimitiveOverestimationSizeGranularity,
    primitiveUnderestimation: primitiveUnderestimation,
    conservativePointAndLineRasterization: conservativePointAndLineRasterization,
    degenerateTrianglesRasterized: degenerateTrianglesRasterized,
    degenerateLinesRasterized: degenerateLinesRasterized,
    fullyCoveredFragmentShaderInputVariable: fullyCoveredFragmentShaderInputVariable,
    conservativeRasterizationPostDepthCoverage: conservativeRasterizationPostDepthCoverage,
  )

proc newVkCalibratedTimestampInfoKHR*(sType: VkStructureType = VkStructureType.CalibratedTimestampInfoKHR, pNext: pointer = nil, timeDomain: VkTimeDomainKHR): VkCalibratedTimestampInfoKHR =
  result = VkCalibratedTimestampInfoKHR(
    sType: sType,
    pNext: pNext,
    timeDomain: timeDomain,
  )

proc newVkPhysicalDeviceShaderCorePropertiesAMD*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderCorePropertiesAMD, pNext: pointer = nil, shaderEngineCount: uint32, shaderArraysPerEngineCount: uint32, computeUnitsPerShaderArray: uint32, simdPerComputeUnit: uint32, wavefrontsPerSimd: uint32, wavefrontSize: uint32, sgprsPerSimd: uint32, minSgprAllocation: uint32, maxSgprAllocation: uint32, sgprAllocationGranularity: uint32, vgprsPerSimd: uint32, minVgprAllocation: uint32, maxVgprAllocation: uint32, vgprAllocationGranularity: uint32): VkPhysicalDeviceShaderCorePropertiesAMD =
  result = VkPhysicalDeviceShaderCorePropertiesAMD(
    sType: sType,
    pNext: pNext,
    shaderEngineCount: shaderEngineCount,
    shaderArraysPerEngineCount: shaderArraysPerEngineCount,
    computeUnitsPerShaderArray: computeUnitsPerShaderArray,
    simdPerComputeUnit: simdPerComputeUnit,
    wavefrontsPerSimd: wavefrontsPerSimd,
    wavefrontSize: wavefrontSize,
    sgprsPerSimd: sgprsPerSimd,
    minSgprAllocation: minSgprAllocation,
    maxSgprAllocation: maxSgprAllocation,
    sgprAllocationGranularity: sgprAllocationGranularity,
    vgprsPerSimd: vgprsPerSimd,
    minVgprAllocation: minVgprAllocation,
    maxVgprAllocation: maxVgprAllocation,
    vgprAllocationGranularity: vgprAllocationGranularity,
  )

proc newVkPhysicalDeviceShaderCoreProperties2AMD*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderCoreProperties2AMD, pNext: pointer = nil, shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD, activeComputeUnitCount: uint32): VkPhysicalDeviceShaderCoreProperties2AMD =
  result = VkPhysicalDeviceShaderCoreProperties2AMD(
    sType: sType,
    pNext: pNext,
    shaderCoreFeatures: shaderCoreFeatures,
    activeComputeUnitCount: activeComputeUnitCount,
  )

proc newVkPipelineRasterizationConservativeStateCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineRasterizationConservativeStateCreateInfoEXT, pNext: pointer = nil, flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT = 0.VkPipelineRasterizationConservativeStateCreateFlagsEXT, conservativeRasterizationMode: VkConservativeRasterizationModeEXT, extraPrimitiveOverestimationSize: float32): VkPipelineRasterizationConservativeStateCreateInfoEXT =
  result = VkPipelineRasterizationConservativeStateCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    conservativeRasterizationMode: conservativeRasterizationMode,
    extraPrimitiveOverestimationSize: extraPrimitiveOverestimationSize,
  )

proc newVkPhysicalDeviceDescriptorIndexingFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorIndexingFeatures, pNext: pointer = nil, shaderInputAttachmentArrayDynamicIndexing: VkBool32, shaderUniformTexelBufferArrayDynamicIndexing: VkBool32, shaderStorageTexelBufferArrayDynamicIndexing: VkBool32, shaderUniformBufferArrayNonUniformIndexing: VkBool32, shaderSampledImageArrayNonUniformIndexing: VkBool32, shaderStorageBufferArrayNonUniformIndexing: VkBool32, shaderStorageImageArrayNonUniformIndexing: VkBool32, shaderInputAttachmentArrayNonUniformIndexing: VkBool32, shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32, shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32, descriptorBindingUniformBufferUpdateAfterBind: VkBool32, descriptorBindingSampledImageUpdateAfterBind: VkBool32, descriptorBindingStorageImageUpdateAfterBind: VkBool32, descriptorBindingStorageBufferUpdateAfterBind: VkBool32, descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32, descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32, descriptorBindingUpdateUnusedWhilePending: VkBool32, descriptorBindingPartiallyBound: VkBool32, descriptorBindingVariableDescriptorCount: VkBool32, runtimeDescriptorArray: VkBool32): VkPhysicalDeviceDescriptorIndexingFeatures =
  result = VkPhysicalDeviceDescriptorIndexingFeatures(
    sType: sType,
    pNext: pNext,
    shaderInputAttachmentArrayDynamicIndexing: shaderInputAttachmentArrayDynamicIndexing,
    shaderUniformTexelBufferArrayDynamicIndexing: shaderUniformTexelBufferArrayDynamicIndexing,
    shaderStorageTexelBufferArrayDynamicIndexing: shaderStorageTexelBufferArrayDynamicIndexing,
    shaderUniformBufferArrayNonUniformIndexing: shaderUniformBufferArrayNonUniformIndexing,
    shaderSampledImageArrayNonUniformIndexing: shaderSampledImageArrayNonUniformIndexing,
    shaderStorageBufferArrayNonUniformIndexing: shaderStorageBufferArrayNonUniformIndexing,
    shaderStorageImageArrayNonUniformIndexing: shaderStorageImageArrayNonUniformIndexing,
    shaderInputAttachmentArrayNonUniformIndexing: shaderInputAttachmentArrayNonUniformIndexing,
    shaderUniformTexelBufferArrayNonUniformIndexing: shaderUniformTexelBufferArrayNonUniformIndexing,
    shaderStorageTexelBufferArrayNonUniformIndexing: shaderStorageTexelBufferArrayNonUniformIndexing,
    descriptorBindingUniformBufferUpdateAfterBind: descriptorBindingUniformBufferUpdateAfterBind,
    descriptorBindingSampledImageUpdateAfterBind: descriptorBindingSampledImageUpdateAfterBind,
    descriptorBindingStorageImageUpdateAfterBind: descriptorBindingStorageImageUpdateAfterBind,
    descriptorBindingStorageBufferUpdateAfterBind: descriptorBindingStorageBufferUpdateAfterBind,
    descriptorBindingUniformTexelBufferUpdateAfterBind: descriptorBindingUniformTexelBufferUpdateAfterBind,
    descriptorBindingStorageTexelBufferUpdateAfterBind: descriptorBindingStorageTexelBufferUpdateAfterBind,
    descriptorBindingUpdateUnusedWhilePending: descriptorBindingUpdateUnusedWhilePending,
    descriptorBindingPartiallyBound: descriptorBindingPartiallyBound,
    descriptorBindingVariableDescriptorCount: descriptorBindingVariableDescriptorCount,
    runtimeDescriptorArray: runtimeDescriptorArray,
  )

proc newVkPhysicalDeviceDescriptorIndexingProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorIndexingProperties, pNext: pointer = nil, maxUpdateAfterBindDescriptorsInAllPools: uint32, shaderUniformBufferArrayNonUniformIndexingNative: VkBool32, shaderSampledImageArrayNonUniformIndexingNative: VkBool32, shaderStorageBufferArrayNonUniformIndexingNative: VkBool32, shaderStorageImageArrayNonUniformIndexingNative: VkBool32, shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32, robustBufferAccessUpdateAfterBind: VkBool32, quadDivergentImplicitLod: VkBool32, maxPerStageDescriptorUpdateAfterBindSamplers: uint32, maxPerStageDescriptorUpdateAfterBindUniformBuffers: uint32, maxPerStageDescriptorUpdateAfterBindStorageBuffers: uint32, maxPerStageDescriptorUpdateAfterBindSampledImages: uint32, maxPerStageDescriptorUpdateAfterBindStorageImages: uint32, maxPerStageDescriptorUpdateAfterBindInputAttachments: uint32, maxPerStageUpdateAfterBindResources: uint32, maxDescriptorSetUpdateAfterBindSamplers: uint32, maxDescriptorSetUpdateAfterBindUniformBuffers: uint32, maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: uint32, maxDescriptorSetUpdateAfterBindStorageBuffers: uint32, maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: uint32, maxDescriptorSetUpdateAfterBindSampledImages: uint32, maxDescriptorSetUpdateAfterBindStorageImages: uint32, maxDescriptorSetUpdateAfterBindInputAttachments: uint32): VkPhysicalDeviceDescriptorIndexingProperties =
  result = VkPhysicalDeviceDescriptorIndexingProperties(
    sType: sType,
    pNext: pNext,
    maxUpdateAfterBindDescriptorsInAllPools: maxUpdateAfterBindDescriptorsInAllPools,
    shaderUniformBufferArrayNonUniformIndexingNative: shaderUniformBufferArrayNonUniformIndexingNative,
    shaderSampledImageArrayNonUniformIndexingNative: shaderSampledImageArrayNonUniformIndexingNative,
    shaderStorageBufferArrayNonUniformIndexingNative: shaderStorageBufferArrayNonUniformIndexingNative,
    shaderStorageImageArrayNonUniformIndexingNative: shaderStorageImageArrayNonUniformIndexingNative,
    shaderInputAttachmentArrayNonUniformIndexingNative: shaderInputAttachmentArrayNonUniformIndexingNative,
    robustBufferAccessUpdateAfterBind: robustBufferAccessUpdateAfterBind,
    quadDivergentImplicitLod: quadDivergentImplicitLod,
    maxPerStageDescriptorUpdateAfterBindSamplers: maxPerStageDescriptorUpdateAfterBindSamplers,
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: maxPerStageDescriptorUpdateAfterBindUniformBuffers,
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: maxPerStageDescriptorUpdateAfterBindStorageBuffers,
    maxPerStageDescriptorUpdateAfterBindSampledImages: maxPerStageDescriptorUpdateAfterBindSampledImages,
    maxPerStageDescriptorUpdateAfterBindStorageImages: maxPerStageDescriptorUpdateAfterBindStorageImages,
    maxPerStageDescriptorUpdateAfterBindInputAttachments: maxPerStageDescriptorUpdateAfterBindInputAttachments,
    maxPerStageUpdateAfterBindResources: maxPerStageUpdateAfterBindResources,
    maxDescriptorSetUpdateAfterBindSamplers: maxDescriptorSetUpdateAfterBindSamplers,
    maxDescriptorSetUpdateAfterBindUniformBuffers: maxDescriptorSetUpdateAfterBindUniformBuffers,
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: maxDescriptorSetUpdateAfterBindUniformBuffersDynamic,
    maxDescriptorSetUpdateAfterBindStorageBuffers: maxDescriptorSetUpdateAfterBindStorageBuffers,
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: maxDescriptorSetUpdateAfterBindStorageBuffersDynamic,
    maxDescriptorSetUpdateAfterBindSampledImages: maxDescriptorSetUpdateAfterBindSampledImages,
    maxDescriptorSetUpdateAfterBindStorageImages: maxDescriptorSetUpdateAfterBindStorageImages,
    maxDescriptorSetUpdateAfterBindInputAttachments: maxDescriptorSetUpdateAfterBindInputAttachments,
  )

proc newVkDescriptorSetLayoutBindingFlagsCreateInfo*(sType: VkStructureType = VkStructureType.DescriptorSetLayoutBindingFlagsCreateInfo, pNext: pointer = nil, bindingFlags: openarray[VkDescriptorBindingFlags]): VkDescriptorSetLayoutBindingFlagsCreateInfo =
  result = VkDescriptorSetLayoutBindingFlagsCreateInfo(
    sType: sType,
    pNext: pNext,
    bindingCount: len(bindingFlags).uint32,
    pBindingFlags: if len(bindingFlags) == 0: nil else: cast[ptr VkDescriptorBindingFlags](bindingFlags),
  )

proc newVkDescriptorSetVariableDescriptorCountAllocateInfo*(sType: VkStructureType = VkStructureType.DescriptorSetVariableDescriptorCountAllocateInfo, pNext: pointer = nil, descriptorCounts: openarray[uint32]): VkDescriptorSetVariableDescriptorCountAllocateInfo =
  result = VkDescriptorSetVariableDescriptorCountAllocateInfo(
    sType: sType,
    pNext: pNext,
    descriptorSetCount: len(descriptorCounts).uint32,
    pDescriptorCounts: if len(descriptorCounts) == 0: nil else: cast[ptr uint32](descriptorCounts),
  )

proc newVkDescriptorSetVariableDescriptorCountLayoutSupport*(sType: VkStructureType = VkStructureType.DescriptorSetVariableDescriptorCountLayoutSupport, pNext: pointer = nil, maxVariableDescriptorCount: uint32): VkDescriptorSetVariableDescriptorCountLayoutSupport =
  result = VkDescriptorSetVariableDescriptorCountLayoutSupport(
    sType: sType,
    pNext: pNext,
    maxVariableDescriptorCount: maxVariableDescriptorCount,
  )

proc newVkAttachmentDescription2*(sType: VkStructureType = VkStructureType.AttachmentDescription2, pNext: pointer = nil, flags: VkAttachmentDescriptionFlags = 0.VkAttachmentDescriptionFlags, format: VkFormat, samples: VkSampleCountFlagBits, loadOp: VkAttachmentLoadOp, storeOp: VkAttachmentStoreOp, stencilLoadOp: VkAttachmentLoadOp, stencilStoreOp: VkAttachmentStoreOp, initialLayout: VkImageLayout, finalLayout: VkImageLayout): VkAttachmentDescription2 =
  result = VkAttachmentDescription2(
    sType: sType,
    pNext: pNext,
    flags: flags,
    format: format,
    samples: samples,
    loadOp: loadOp,
    storeOp: storeOp,
    stencilLoadOp: stencilLoadOp,
    stencilStoreOp: stencilStoreOp,
    initialLayout: initialLayout,
    finalLayout: finalLayout,
  )

proc newVkAttachmentReference2*(sType: VkStructureType = VkStructureType.AttachmentReference2, pNext: pointer = nil, attachment: uint32, layout: VkImageLayout, aspectMask: VkImageAspectFlags): VkAttachmentReference2 =
  result = VkAttachmentReference2(
    sType: sType,
    pNext: pNext,
    attachment: attachment,
    layout: layout,
    aspectMask: aspectMask,
  )

proc newVkSubpassDescription2*(sType: VkStructureType = VkStructureType.SubpassDescription2, pNext: pointer = nil, flags: VkSubpassDescriptionFlags = 0.VkSubpassDescriptionFlags, pipelineBindPoint: VkPipelineBindPoint, viewMask: uint32, inputAttachments: openarray[VkAttachmentReference2], colorAttachments: openarray[VkAttachmentReference2], resolveAttachments: openarray[VkAttachmentReference2], pDepthStencilAttachment: ptr VkAttachmentReference2, preserveAttachments: openarray[uint32]): VkSubpassDescription2 =
  result = VkSubpassDescription2(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pipelineBindPoint: pipelineBindPoint,
    viewMask: viewMask,
    inputAttachmentCount: len(inputAttachments).uint32,
    pInputAttachments: if len(inputAttachments) == 0: nil else: cast[ptr VkAttachmentReference2](inputAttachments),
    colorAttachmentCount: len(colorAttachments).uint32,
    pColorAttachments: if len(colorAttachments) == 0: nil else: cast[ptr VkAttachmentReference2](colorAttachments),
    pResolveAttachments: if len(resolveAttachments) == 0: nil else: cast[ptr VkAttachmentReference2](resolveAttachments),
    pDepthStencilAttachment: pDepthStencilAttachment,
    preserveAttachmentCount: len(preserveAttachments).uint32,
    pPreserveAttachments: if len(preserveAttachments) == 0: nil else: cast[ptr uint32](preserveAttachments),
  )

proc newVkSubpassDependency2*(sType: VkStructureType = VkStructureType.SubpassDependency2, pNext: pointer = nil, srcSubpass: uint32, dstSubpass: uint32, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, srcAccessMask: VkAccessFlags, dstAccessMask: VkAccessFlags, dependencyFlags: VkDependencyFlags, viewOffset: int32): VkSubpassDependency2 =
  result = VkSubpassDependency2(
    sType: sType,
    pNext: pNext,
    srcSubpass: srcSubpass,
    dstSubpass: dstSubpass,
    srcStageMask: srcStageMask,
    dstStageMask: dstStageMask,
    srcAccessMask: srcAccessMask,
    dstAccessMask: dstAccessMask,
    dependencyFlags: dependencyFlags,
    viewOffset: viewOffset,
  )

proc newVkRenderPassCreateInfo2*(sType: VkStructureType = VkStructureType.RenderPassCreateInfo2, pNext: pointer = nil, flags: VkRenderPassCreateFlags = 0.VkRenderPassCreateFlags, attachments: openarray[VkAttachmentDescription2], subpasses: openarray[VkSubpassDescription2], dependencies: openarray[VkSubpassDependency2], correlatedViewMasks: openarray[uint32]): VkRenderPassCreateInfo2 =
  result = VkRenderPassCreateInfo2(
    sType: sType,
    pNext: pNext,
    flags: flags,
    attachmentCount: len(attachments).uint32,
    pAttachments: if len(attachments) == 0: nil else: cast[ptr VkAttachmentDescription2](attachments),
    subpassCount: len(subpasses).uint32,
    pSubpasses: if len(subpasses) == 0: nil else: cast[ptr VkSubpassDescription2](subpasses),
    dependencyCount: len(dependencies).uint32,
    pDependencies: if len(dependencies) == 0: nil else: cast[ptr VkSubpassDependency2](dependencies),
    correlatedViewMaskCount: len(correlatedViewMasks).uint32,
    pCorrelatedViewMasks: if len(correlatedViewMasks) == 0: nil else: cast[ptr uint32](correlatedViewMasks),
  )

proc newVkSubpassBeginInfo*(sType: VkStructureType = VkStructureType.SubpassBeginInfo, pNext: pointer = nil, contents: VkSubpassContents): VkSubpassBeginInfo =
  result = VkSubpassBeginInfo(
    sType: sType,
    pNext: pNext,
    contents: contents,
  )

proc newVkSubpassEndInfo*(sType: VkStructureType = VkStructureType.SubpassEndInfo, pNext: pointer = nil): VkSubpassEndInfo =
  result = VkSubpassEndInfo(
    sType: sType,
    pNext: pNext,
  )

proc newVkPhysicalDeviceTimelineSemaphoreFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceTimelineSemaphoreFeatures, pNext: pointer = nil, timelineSemaphore: VkBool32): VkPhysicalDeviceTimelineSemaphoreFeatures =
  result = VkPhysicalDeviceTimelineSemaphoreFeatures(
    sType: sType,
    pNext: pNext,
    timelineSemaphore: timelineSemaphore,
  )

proc newVkPhysicalDeviceTimelineSemaphoreProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceTimelineSemaphoreProperties, pNext: pointer = nil, maxTimelineSemaphoreValueDifference: uint64): VkPhysicalDeviceTimelineSemaphoreProperties =
  result = VkPhysicalDeviceTimelineSemaphoreProperties(
    sType: sType,
    pNext: pNext,
    maxTimelineSemaphoreValueDifference: maxTimelineSemaphoreValueDifference,
  )

proc newVkSemaphoreTypeCreateInfo*(sType: VkStructureType = VkStructureType.SemaphoreTypeCreateInfo, pNext: pointer = nil, semaphoreType: VkSemaphoreType, initialValue: uint64): VkSemaphoreTypeCreateInfo =
  result = VkSemaphoreTypeCreateInfo(
    sType: sType,
    pNext: pNext,
    semaphoreType: semaphoreType,
    initialValue: initialValue,
  )

proc newVkTimelineSemaphoreSubmitInfo*(sType: VkStructureType = VkStructureType.TimelineSemaphoreSubmitInfo, pNext: pointer = nil, waitSemaphoreValues: openarray[uint64], signalSemaphoreValues: openarray[uint64]): VkTimelineSemaphoreSubmitInfo =
  result = VkTimelineSemaphoreSubmitInfo(
    sType: sType,
    pNext: pNext,
    waitSemaphoreValueCount: len(waitSemaphoreValues).uint32,
    pWaitSemaphoreValues: if len(waitSemaphoreValues) == 0: nil else: cast[ptr uint64](waitSemaphoreValues),
    signalSemaphoreValueCount: len(signalSemaphoreValues).uint32,
    pSignalSemaphoreValues: if len(signalSemaphoreValues) == 0: nil else: cast[ptr uint64](signalSemaphoreValues),
  )

proc newVkSemaphoreWaitInfo*(sType: VkStructureType = VkStructureType.SemaphoreWaitInfo, pNext: pointer = nil, flags: VkSemaphoreWaitFlags = 0.VkSemaphoreWaitFlags, semaphores: openarray[VkSemaphore], values: openarray[uint64]): VkSemaphoreWaitInfo =
  result = VkSemaphoreWaitInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    semaphoreCount: len(semaphores).uint32,
    pSemaphores: if len(semaphores) == 0: nil else: cast[ptr VkSemaphore](semaphores),
    pValues: if len(values) == 0: nil else: cast[ptr uint64](values),
  )

proc newVkSemaphoreSignalInfo*(sType: VkStructureType = VkStructureType.SemaphoreSignalInfo, pNext: pointer = nil, semaphore: VkSemaphore, value: uint64): VkSemaphoreSignalInfo =
  result = VkSemaphoreSignalInfo(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    value: value,
  )

proc newVkVertexInputBindingDivisorDescription*(binding: uint32, divisor: uint32): VkVertexInputBindingDivisorDescription =
  result = VkVertexInputBindingDivisorDescription(
    binding: binding,
    divisor: divisor,
  )

proc newVkPipelineVertexInputDivisorStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineVertexInputDivisorStateCreateInfo, pNext: pointer = nil, vertexBindingDivisors: openarray[VkVertexInputBindingDivisorDescription]): VkPipelineVertexInputDivisorStateCreateInfo =
  result = VkPipelineVertexInputDivisorStateCreateInfo(
    sType: sType,
    pNext: pNext,
    vertexBindingDivisorCount: len(vertexBindingDivisors).uint32,
    pVertexBindingDivisors: if len(vertexBindingDivisors) == 0: nil else: cast[ptr VkVertexInputBindingDivisorDescription](vertexBindingDivisors),
  )

proc newVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceVertexAttributeDivisorPropertiesEXT, pNext: pointer = nil, maxVertexAttribDivisor: uint32): VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT =
  result = VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxVertexAttribDivisor: maxVertexAttribDivisor,
  )

proc newVkPhysicalDeviceVertexAttributeDivisorProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceVertexAttributeDivisorProperties, pNext: pointer = nil, maxVertexAttribDivisor: uint32, supportsNonZeroFirstInstance: VkBool32): VkPhysicalDeviceVertexAttributeDivisorProperties =
  result = VkPhysicalDeviceVertexAttributeDivisorProperties(
    sType: sType,
    pNext: pNext,
    maxVertexAttribDivisor: maxVertexAttribDivisor,
    supportsNonZeroFirstInstance: supportsNonZeroFirstInstance,
  )

proc newVkPhysicalDevicePCIBusInfoPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDevicePCIBusInfoPropertiesEXT, pNext: pointer = nil, pciDomain: uint32, pciBus: uint32, pciDevice: uint32, pciFunction: uint32): VkPhysicalDevicePCIBusInfoPropertiesEXT =
  result = VkPhysicalDevicePCIBusInfoPropertiesEXT(
    sType: sType,
    pNext: pNext,
    pciDomain: pciDomain,
    pciBus: pciBus,
    pciDevice: pciDevice,
    pciFunction: pciFunction,
  )

proc newVkImportAndroidHardwareBufferInfoANDROID*(sType: VkStructureType = VkStructureType.ImportAndroidHardwareBufferInfoANDROID, pNext: pointer = nil, buffer: ptr AHardwareBuffer): VkImportAndroidHardwareBufferInfoANDROID =
  result = VkImportAndroidHardwareBufferInfoANDROID(
    sType: sType,
    pNext: pNext,
    buffer: buffer,
  )

proc newVkAndroidHardwareBufferUsageANDROID*(sType: VkStructureType = VkStructureType.AndroidHardwareBufferUsageANDROID, pNext: pointer = nil, androidHardwareBufferUsage: uint64): VkAndroidHardwareBufferUsageANDROID =
  result = VkAndroidHardwareBufferUsageANDROID(
    sType: sType,
    pNext: pNext,
    androidHardwareBufferUsage: androidHardwareBufferUsage,
  )

proc newVkAndroidHardwareBufferPropertiesANDROID*(sType: VkStructureType = VkStructureType.AndroidHardwareBufferPropertiesANDROID, pNext: pointer = nil, allocationSize: VkDeviceSize, memoryTypeBits: uint32): VkAndroidHardwareBufferPropertiesANDROID =
  result = VkAndroidHardwareBufferPropertiesANDROID(
    sType: sType,
    pNext: pNext,
    allocationSize: allocationSize,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkMemoryGetAndroidHardwareBufferInfoANDROID*(sType: VkStructureType = VkStructureType.MemoryGetAndroidHardwareBufferInfoANDROID, pNext: pointer = nil, memory: VkDeviceMemory): VkMemoryGetAndroidHardwareBufferInfoANDROID =
  result = VkMemoryGetAndroidHardwareBufferInfoANDROID(
    sType: sType,
    pNext: pNext,
    memory: memory,
  )

proc newVkAndroidHardwareBufferFormatPropertiesANDROID*(sType: VkStructureType = VkStructureType.AndroidHardwareBufferFormatPropertiesANDROID, pNext: pointer = nil, format: VkFormat, externalFormat: uint64, formatFeatures: VkFormatFeatureFlags, samplerYcbcrConversionComponents: VkComponentMapping, suggestedYcbcrModel: VkSamplerYcbcrModelConversion, suggestedYcbcrRange: VkSamplerYcbcrRange, suggestedXChromaOffset: VkChromaLocation, suggestedYChromaOffset: VkChromaLocation): VkAndroidHardwareBufferFormatPropertiesANDROID =
  result = VkAndroidHardwareBufferFormatPropertiesANDROID(
    sType: sType,
    pNext: pNext,
    format: format,
    externalFormat: externalFormat,
    formatFeatures: formatFeatures,
    samplerYcbcrConversionComponents: samplerYcbcrConversionComponents,
    suggestedYcbcrModel: suggestedYcbcrModel,
    suggestedYcbcrRange: suggestedYcbcrRange,
    suggestedXChromaOffset: suggestedXChromaOffset,
    suggestedYChromaOffset: suggestedYChromaOffset,
  )

proc newVkCommandBufferInheritanceConditionalRenderingInfoEXT*(sType: VkStructureType = VkStructureType.CommandBufferInheritanceConditionalRenderingInfoEXT, pNext: pointer = nil, conditionalRenderingEnable: VkBool32): VkCommandBufferInheritanceConditionalRenderingInfoEXT =
  result = VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    sType: sType,
    pNext: pNext,
    conditionalRenderingEnable: conditionalRenderingEnable,
  )

proc newVkExternalFormatANDROID*(sType: VkStructureType = VkStructureType.ExternalFormatANDROID, pNext: pointer = nil, externalFormat: uint64): VkExternalFormatANDROID =
  result = VkExternalFormatANDROID(
    sType: sType,
    pNext: pNext,
    externalFormat: externalFormat,
  )

proc newVkPhysicalDevice8BitStorageFeatures*(sType: VkStructureType = VkStructureType.PhysicalDevice8BitStorageFeatures, pNext: pointer = nil, storageBuffer8BitAccess: VkBool32, uniformAndStorageBuffer8BitAccess: VkBool32, storagePushConstant8: VkBool32): VkPhysicalDevice8BitStorageFeatures =
  result = VkPhysicalDevice8BitStorageFeatures(
    sType: sType,
    pNext: pNext,
    storageBuffer8BitAccess: storageBuffer8BitAccess,
    uniformAndStorageBuffer8BitAccess: uniformAndStorageBuffer8BitAccess,
    storagePushConstant8: storagePushConstant8,
  )

proc newVkPhysicalDeviceConditionalRenderingFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceConditionalRenderingFeaturesEXT, pNext: pointer = nil, conditionalRendering: VkBool32, inheritedConditionalRendering: VkBool32): VkPhysicalDeviceConditionalRenderingFeaturesEXT =
  result = VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    sType: sType,
    pNext: pNext,
    conditionalRendering: conditionalRendering,
    inheritedConditionalRendering: inheritedConditionalRendering,
  )

proc newVkPhysicalDeviceVulkanMemoryModelFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkanMemoryModelFeatures, pNext: pointer = nil, vulkanMemoryModel: VkBool32, vulkanMemoryModelDeviceScope: VkBool32, vulkanMemoryModelAvailabilityVisibilityChains: VkBool32): VkPhysicalDeviceVulkanMemoryModelFeatures =
  result = VkPhysicalDeviceVulkanMemoryModelFeatures(
    sType: sType,
    pNext: pNext,
    vulkanMemoryModel: vulkanMemoryModel,
    vulkanMemoryModelDeviceScope: vulkanMemoryModelDeviceScope,
    vulkanMemoryModelAvailabilityVisibilityChains: vulkanMemoryModelAvailabilityVisibilityChains,
  )

proc newVkPhysicalDeviceShaderAtomicInt64Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderAtomicInt64Features, pNext: pointer = nil, shaderBufferInt64Atomics: VkBool32, shaderSharedInt64Atomics: VkBool32): VkPhysicalDeviceShaderAtomicInt64Features =
  result = VkPhysicalDeviceShaderAtomicInt64Features(
    sType: sType,
    pNext: pNext,
    shaderBufferInt64Atomics: shaderBufferInt64Atomics,
    shaderSharedInt64Atomics: shaderSharedInt64Atomics,
  )

proc newVkPhysicalDeviceShaderAtomicFloatFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderAtomicFloatFeaturesEXT, pNext: pointer = nil, shaderBufferFloat32Atomics: VkBool32, shaderBufferFloat32AtomicAdd: VkBool32, shaderBufferFloat64Atomics: VkBool32, shaderBufferFloat64AtomicAdd: VkBool32, shaderSharedFloat32Atomics: VkBool32, shaderSharedFloat32AtomicAdd: VkBool32, shaderSharedFloat64Atomics: VkBool32, shaderSharedFloat64AtomicAdd: VkBool32, shaderImageFloat32Atomics: VkBool32, shaderImageFloat32AtomicAdd: VkBool32, sparseImageFloat32Atomics: VkBool32, sparseImageFloat32AtomicAdd: VkBool32): VkPhysicalDeviceShaderAtomicFloatFeaturesEXT =
  result = VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderBufferFloat32Atomics: shaderBufferFloat32Atomics,
    shaderBufferFloat32AtomicAdd: shaderBufferFloat32AtomicAdd,
    shaderBufferFloat64Atomics: shaderBufferFloat64Atomics,
    shaderBufferFloat64AtomicAdd: shaderBufferFloat64AtomicAdd,
    shaderSharedFloat32Atomics: shaderSharedFloat32Atomics,
    shaderSharedFloat32AtomicAdd: shaderSharedFloat32AtomicAdd,
    shaderSharedFloat64Atomics: shaderSharedFloat64Atomics,
    shaderSharedFloat64AtomicAdd: shaderSharedFloat64AtomicAdd,
    shaderImageFloat32Atomics: shaderImageFloat32Atomics,
    shaderImageFloat32AtomicAdd: shaderImageFloat32AtomicAdd,
    sparseImageFloat32Atomics: sparseImageFloat32Atomics,
    sparseImageFloat32AtomicAdd: sparseImageFloat32AtomicAdd,
  )

proc newVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderAtomicFloat2FeaturesEXT, pNext: pointer = nil, shaderBufferFloat16Atomics: VkBool32, shaderBufferFloat16AtomicAdd: VkBool32, shaderBufferFloat16AtomicMinMax: VkBool32, shaderBufferFloat32AtomicMinMax: VkBool32, shaderBufferFloat64AtomicMinMax: VkBool32, shaderSharedFloat16Atomics: VkBool32, shaderSharedFloat16AtomicAdd: VkBool32, shaderSharedFloat16AtomicMinMax: VkBool32, shaderSharedFloat32AtomicMinMax: VkBool32, shaderSharedFloat64AtomicMinMax: VkBool32, shaderImageFloat32AtomicMinMax: VkBool32, sparseImageFloat32AtomicMinMax: VkBool32): VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT =
  result = VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderBufferFloat16Atomics: shaderBufferFloat16Atomics,
    shaderBufferFloat16AtomicAdd: shaderBufferFloat16AtomicAdd,
    shaderBufferFloat16AtomicMinMax: shaderBufferFloat16AtomicMinMax,
    shaderBufferFloat32AtomicMinMax: shaderBufferFloat32AtomicMinMax,
    shaderBufferFloat64AtomicMinMax: shaderBufferFloat64AtomicMinMax,
    shaderSharedFloat16Atomics: shaderSharedFloat16Atomics,
    shaderSharedFloat16AtomicAdd: shaderSharedFloat16AtomicAdd,
    shaderSharedFloat16AtomicMinMax: shaderSharedFloat16AtomicMinMax,
    shaderSharedFloat32AtomicMinMax: shaderSharedFloat32AtomicMinMax,
    shaderSharedFloat64AtomicMinMax: shaderSharedFloat64AtomicMinMax,
    shaderImageFloat32AtomicMinMax: shaderImageFloat32AtomicMinMax,
    sparseImageFloat32AtomicMinMax: sparseImageFloat32AtomicMinMax,
  )

proc newVkPhysicalDeviceVertexAttributeDivisorFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceVertexAttributeDivisorFeatures, pNext: pointer = nil, vertexAttributeInstanceRateDivisor: VkBool32, vertexAttributeInstanceRateZeroDivisor: VkBool32): VkPhysicalDeviceVertexAttributeDivisorFeatures =
  result = VkPhysicalDeviceVertexAttributeDivisorFeatures(
    sType: sType,
    pNext: pNext,
    vertexAttributeInstanceRateDivisor: vertexAttributeInstanceRateDivisor,
    vertexAttributeInstanceRateZeroDivisor: vertexAttributeInstanceRateZeroDivisor,
  )

proc newVkQueueFamilyCheckpointPropertiesNV*(sType: VkStructureType = VkStructureType.QueueFamilyCheckpointPropertiesNV, pNext: pointer = nil, checkpointExecutionStageMask: VkPipelineStageFlags): VkQueueFamilyCheckpointPropertiesNV =
  result = VkQueueFamilyCheckpointPropertiesNV(
    sType: sType,
    pNext: pNext,
    checkpointExecutionStageMask: checkpointExecutionStageMask,
  )

proc newVkCheckpointDataNV*(sType: VkStructureType = VkStructureType.CheckpointDataNV, pNext: pointer = nil, stage: VkPipelineStageFlagBits, pCheckpointMarker: pointer = nil): VkCheckpointDataNV =
  result = VkCheckpointDataNV(
    sType: sType,
    pNext: pNext,
    stage: stage,
    pCheckpointMarker: pCheckpointMarker,
  )

proc newVkPhysicalDeviceDepthStencilResolveProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceDepthStencilResolveProperties, pNext: pointer = nil, supportedDepthResolveModes: VkResolveModeFlags, supportedStencilResolveModes: VkResolveModeFlags, independentResolveNone: VkBool32, independentResolve: VkBool32): VkPhysicalDeviceDepthStencilResolveProperties =
  result = VkPhysicalDeviceDepthStencilResolveProperties(
    sType: sType,
    pNext: pNext,
    supportedDepthResolveModes: supportedDepthResolveModes,
    supportedStencilResolveModes: supportedStencilResolveModes,
    independentResolveNone: independentResolveNone,
    independentResolve: independentResolve,
  )

proc newVkSubpassDescriptionDepthStencilResolve*(sType: VkStructureType = VkStructureType.SubpassDescriptionDepthStencilResolve, pNext: pointer = nil, depthResolveMode: VkResolveModeFlagBits, stencilResolveMode: VkResolveModeFlagBits, pDepthStencilResolveAttachment: ptr VkAttachmentReference2): VkSubpassDescriptionDepthStencilResolve =
  result = VkSubpassDescriptionDepthStencilResolve(
    sType: sType,
    pNext: pNext,
    depthResolveMode: depthResolveMode,
    stencilResolveMode: stencilResolveMode,
    pDepthStencilResolveAttachment: pDepthStencilResolveAttachment,
  )

proc newVkImageViewASTCDecodeModeEXT*(sType: VkStructureType = VkStructureType.ImageViewASTCDecodeModeEXT, pNext: pointer = nil, decodeMode: VkFormat): VkImageViewASTCDecodeModeEXT =
  result = VkImageViewASTCDecodeModeEXT(
    sType: sType,
    pNext: pNext,
    decodeMode: decodeMode,
  )

proc newVkPhysicalDeviceASTCDecodeFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceASTCDecodeFeaturesEXT, pNext: pointer = nil, decodeModeSharedExponent: VkBool32): VkPhysicalDeviceASTCDecodeFeaturesEXT =
  result = VkPhysicalDeviceASTCDecodeFeaturesEXT(
    sType: sType,
    pNext: pNext,
    decodeModeSharedExponent: decodeModeSharedExponent,
  )

proc newVkPhysicalDeviceTransformFeedbackFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceTransformFeedbackFeaturesEXT, pNext: pointer = nil, transformFeedback: VkBool32, geometryStreams: VkBool32): VkPhysicalDeviceTransformFeedbackFeaturesEXT =
  result = VkPhysicalDeviceTransformFeedbackFeaturesEXT(
    sType: sType,
    pNext: pNext,
    transformFeedback: transformFeedback,
    geometryStreams: geometryStreams,
  )

proc newVkPhysicalDeviceTransformFeedbackPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceTransformFeedbackPropertiesEXT, pNext: pointer = nil, maxTransformFeedbackStreams: uint32, maxTransformFeedbackBuffers: uint32, maxTransformFeedbackBufferSize: VkDeviceSize, maxTransformFeedbackStreamDataSize: uint32, maxTransformFeedbackBufferDataSize: uint32, maxTransformFeedbackBufferDataStride: uint32, transformFeedbackQueries: VkBool32, transformFeedbackStreamsLinesTriangles: VkBool32, transformFeedbackRasterizationStreamSelect: VkBool32, transformFeedbackDraw: VkBool32): VkPhysicalDeviceTransformFeedbackPropertiesEXT =
  result = VkPhysicalDeviceTransformFeedbackPropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxTransformFeedbackStreams: maxTransformFeedbackStreams,
    maxTransformFeedbackBuffers: maxTransformFeedbackBuffers,
    maxTransformFeedbackBufferSize: maxTransformFeedbackBufferSize,
    maxTransformFeedbackStreamDataSize: maxTransformFeedbackStreamDataSize,
    maxTransformFeedbackBufferDataSize: maxTransformFeedbackBufferDataSize,
    maxTransformFeedbackBufferDataStride: maxTransformFeedbackBufferDataStride,
    transformFeedbackQueries: transformFeedbackQueries,
    transformFeedbackStreamsLinesTriangles: transformFeedbackStreamsLinesTriangles,
    transformFeedbackRasterizationStreamSelect: transformFeedbackRasterizationStreamSelect,
    transformFeedbackDraw: transformFeedbackDraw,
  )

proc newVkPipelineRasterizationStateStreamCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineRasterizationStateStreamCreateInfoEXT, pNext: pointer = nil, flags: VkPipelineRasterizationStateStreamCreateFlagsEXT = 0.VkPipelineRasterizationStateStreamCreateFlagsEXT, rasterizationStream: uint32): VkPipelineRasterizationStateStreamCreateInfoEXT =
  result = VkPipelineRasterizationStateStreamCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    rasterizationStream: rasterizationStream,
  )

proc newVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceRepresentativeFragmentTestFeaturesNV, pNext: pointer = nil, representativeFragmentTest: VkBool32): VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV =
  result = VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(
    sType: sType,
    pNext: pNext,
    representativeFragmentTest: representativeFragmentTest,
  )

proc newVkPipelineRepresentativeFragmentTestStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineRepresentativeFragmentTestStateCreateInfoNV, pNext: pointer = nil, representativeFragmentTestEnable: VkBool32): VkPipelineRepresentativeFragmentTestStateCreateInfoNV =
  result = VkPipelineRepresentativeFragmentTestStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    representativeFragmentTestEnable: representativeFragmentTestEnable,
  )

proc newVkPhysicalDeviceExclusiveScissorFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceExclusiveScissorFeaturesNV, pNext: pointer = nil, exclusiveScissor: VkBool32): VkPhysicalDeviceExclusiveScissorFeaturesNV =
  result = VkPhysicalDeviceExclusiveScissorFeaturesNV(
    sType: sType,
    pNext: pNext,
    exclusiveScissor: exclusiveScissor,
  )

proc newVkPipelineViewportExclusiveScissorStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineViewportExclusiveScissorStateCreateInfoNV, pNext: pointer = nil, exclusiveScissors: openarray[VkRect2D]): VkPipelineViewportExclusiveScissorStateCreateInfoNV =
  result = VkPipelineViewportExclusiveScissorStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    exclusiveScissorCount: len(exclusiveScissors).uint32,
    pExclusiveScissors: if len(exclusiveScissors) == 0: nil else: cast[ptr VkRect2D](exclusiveScissors),
  )

proc newVkPhysicalDeviceCornerSampledImageFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCornerSampledImageFeaturesNV, pNext: pointer = nil, cornerSampledImage: VkBool32): VkPhysicalDeviceCornerSampledImageFeaturesNV =
  result = VkPhysicalDeviceCornerSampledImageFeaturesNV(
    sType: sType,
    pNext: pNext,
    cornerSampledImage: cornerSampledImage,
  )

proc newVkPhysicalDeviceComputeShaderDerivativesFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceComputeShaderDerivativesFeaturesKHR, pNext: pointer = nil, computeDerivativeGroupQuads: VkBool32, computeDerivativeGroupLinear: VkBool32): VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR =
  result = VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(
    sType: sType,
    pNext: pNext,
    computeDerivativeGroupQuads: computeDerivativeGroupQuads,
    computeDerivativeGroupLinear: computeDerivativeGroupLinear,
  )

proc newVkPhysicalDeviceComputeShaderDerivativesPropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceComputeShaderDerivativesPropertiesKHR, pNext: pointer = nil, meshAndTaskShaderDerivatives: VkBool32): VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR =
  result = VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(
    sType: sType,
    pNext: pNext,
    meshAndTaskShaderDerivatives: meshAndTaskShaderDerivatives,
  )

proc newVkPhysicalDeviceShaderImageFootprintFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderImageFootprintFeaturesNV, pNext: pointer = nil, imageFootprint: VkBool32): VkPhysicalDeviceShaderImageFootprintFeaturesNV =
  result = VkPhysicalDeviceShaderImageFootprintFeaturesNV(
    sType: sType,
    pNext: pNext,
    imageFootprint: imageFootprint,
  )

proc newVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, pNext: pointer = nil, dedicatedAllocationImageAliasing: VkBool32): VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV =
  result = VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
    sType: sType,
    pNext: pNext,
    dedicatedAllocationImageAliasing: dedicatedAllocationImageAliasing,
  )

proc newVkPhysicalDeviceCopyMemoryIndirectFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceCopyMemoryIndirectFeaturesKHR, pNext: pointer = nil, indirectMemoryCopy: VkBool32, indirectMemoryToImageCopy: VkBool32): VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR =
  result = VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR(
    sType: sType,
    pNext: pNext,
    indirectMemoryCopy: indirectMemoryCopy,
    indirectMemoryToImageCopy: indirectMemoryToImageCopy,
  )

proc newVkPhysicalDeviceCopyMemoryIndirectFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCopyMemoryIndirectFeaturesNV, pNext: pointer = nil, indirectCopy: VkBool32): VkPhysicalDeviceCopyMemoryIndirectFeaturesNV =
  result = VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(
    sType: sType,
    pNext: pNext,
    indirectCopy: indirectCopy,
  )

proc newVkPhysicalDeviceCopyMemoryIndirectPropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceCopyMemoryIndirectPropertiesKHR, pNext: pointer = nil, supportedQueues: VkQueueFlags): VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR =
  result = VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR(
    sType: sType,
    pNext: pNext,
    supportedQueues: supportedQueues,
  )

proc newVkPhysicalDeviceMemoryDecompressionFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMemoryDecompressionFeaturesEXT, pNext: pointer = nil, memoryDecompression: VkBool32): VkPhysicalDeviceMemoryDecompressionFeaturesEXT =
  result = VkPhysicalDeviceMemoryDecompressionFeaturesEXT(
    sType: sType,
    pNext: pNext,
    memoryDecompression: memoryDecompression,
  )

proc newVkPhysicalDeviceMemoryDecompressionPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMemoryDecompressionPropertiesEXT, pNext: pointer = nil, decompressionMethods: VkMemoryDecompressionMethodFlagsEXT, maxDecompressionIndirectCount: uint64): VkPhysicalDeviceMemoryDecompressionPropertiesEXT =
  result = VkPhysicalDeviceMemoryDecompressionPropertiesEXT(
    sType: sType,
    pNext: pNext,
    decompressionMethods: decompressionMethods,
    maxDecompressionIndirectCount: maxDecompressionIndirectCount,
  )

proc newVkShadingRatePaletteNV*(shadingRatePaletteEntries: openarray[VkShadingRatePaletteEntryNV]): VkShadingRatePaletteNV =
  result = VkShadingRatePaletteNV(
    shadingRatePaletteEntryCount: len(shadingRatePaletteEntries).uint32,
    pShadingRatePaletteEntries: if len(shadingRatePaletteEntries) == 0: nil else: cast[ptr VkShadingRatePaletteEntryNV](shadingRatePaletteEntries),
  )

proc newVkPipelineViewportShadingRateImageStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineViewportShadingRateImageStateCreateInfoNV, pNext: pointer = nil, shadingRateImageEnable: VkBool32, shadingRatePalettes: openarray[VkShadingRatePaletteNV]): VkPipelineViewportShadingRateImageStateCreateInfoNV =
  result = VkPipelineViewportShadingRateImageStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    shadingRateImageEnable: shadingRateImageEnable,
    viewportCount: len(shadingRatePalettes).uint32,
    pShadingRatePalettes: if len(shadingRatePalettes) == 0: nil else: cast[ptr VkShadingRatePaletteNV](shadingRatePalettes),
  )

proc newVkPhysicalDeviceShadingRateImageFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceShadingRateImageFeaturesNV, pNext: pointer = nil, shadingRateImage: VkBool32, shadingRateCoarseSampleOrder: VkBool32): VkPhysicalDeviceShadingRateImageFeaturesNV =
  result = VkPhysicalDeviceShadingRateImageFeaturesNV(
    sType: sType,
    pNext: pNext,
    shadingRateImage: shadingRateImage,
    shadingRateCoarseSampleOrder: shadingRateCoarseSampleOrder,
  )

proc newVkPhysicalDeviceShadingRateImagePropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceShadingRateImagePropertiesNV, pNext: pointer = nil, shadingRateTexelSize: VkExtent2D, shadingRatePaletteSize: uint32, shadingRateMaxCoarseSamples: uint32): VkPhysicalDeviceShadingRateImagePropertiesNV =
  result = VkPhysicalDeviceShadingRateImagePropertiesNV(
    sType: sType,
    pNext: pNext,
    shadingRateTexelSize: shadingRateTexelSize,
    shadingRatePaletteSize: shadingRatePaletteSize,
    shadingRateMaxCoarseSamples: shadingRateMaxCoarseSamples,
  )

proc newVkPhysicalDeviceInvocationMaskFeaturesHUAWEI*(sType: VkStructureType = VkStructureType.PhysicalDeviceInvocationMaskFeaturesHUAWEI, pNext: pointer = nil, invocationMask: VkBool32): VkPhysicalDeviceInvocationMaskFeaturesHUAWEI =
  result = VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(
    sType: sType,
    pNext: pNext,
    invocationMask: invocationMask,
  )

proc newVkCoarseSampleLocationNV*(pixelX: uint32, pixelY: uint32, sample: uint32): VkCoarseSampleLocationNV =
  result = VkCoarseSampleLocationNV(
    pixelX: pixelX,
    pixelY: pixelY,
    sample: sample,
  )

proc newVkCoarseSampleOrderCustomNV*(shadingRate: VkShadingRatePaletteEntryNV, sampleCount: uint32, sampleLocations: openarray[VkCoarseSampleLocationNV]): VkCoarseSampleOrderCustomNV =
  result = VkCoarseSampleOrderCustomNV(
    shadingRate: shadingRate,
    sampleCount: sampleCount,
    sampleLocationCount: len(sampleLocations).uint32,
    pSampleLocations: if len(sampleLocations) == 0: nil else: cast[ptr VkCoarseSampleLocationNV](sampleLocations),
  )

proc newVkPipelineViewportCoarseSampleOrderStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineViewportCoarseSampleOrderStateCreateInfoNV, pNext: pointer = nil, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrders: openarray[VkCoarseSampleOrderCustomNV]): VkPipelineViewportCoarseSampleOrderStateCreateInfoNV =
  result = VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    sampleOrderType: sampleOrderType,
    customSampleOrderCount: len(customSampleOrders).uint32,
    pCustomSampleOrders: if len(customSampleOrders) == 0: nil else: cast[ptr VkCoarseSampleOrderCustomNV](customSampleOrders),
  )

proc newVkPhysicalDeviceMeshShaderFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceMeshShaderFeaturesNV, pNext: pointer = nil, taskShader: VkBool32, meshShader: VkBool32): VkPhysicalDeviceMeshShaderFeaturesNV =
  result = VkPhysicalDeviceMeshShaderFeaturesNV(
    sType: sType,
    pNext: pNext,
    taskShader: taskShader,
    meshShader: meshShader,
  )

proc newVkPhysicalDeviceMeshShaderPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceMeshShaderPropertiesNV, pNext: pointer = nil, maxDrawMeshTasksCount: uint32, maxTaskWorkGroupInvocations: uint32, maxTaskWorkGroupSize: array[3, uint32], maxTaskTotalMemorySize: uint32, maxTaskOutputCount: uint32, maxMeshWorkGroupInvocations: uint32, maxMeshWorkGroupSize: array[3, uint32], maxMeshTotalMemorySize: uint32, maxMeshOutputVertices: uint32, maxMeshOutputPrimitives: uint32, maxMeshMultiviewViewCount: uint32, meshOutputPerVertexGranularity: uint32, meshOutputPerPrimitiveGranularity: uint32): VkPhysicalDeviceMeshShaderPropertiesNV =
  result = VkPhysicalDeviceMeshShaderPropertiesNV(
    sType: sType,
    pNext: pNext,
    maxDrawMeshTasksCount: maxDrawMeshTasksCount,
    maxTaskWorkGroupInvocations: maxTaskWorkGroupInvocations,
    maxTaskWorkGroupSize: maxTaskWorkGroupSize,
    maxTaskTotalMemorySize: maxTaskTotalMemorySize,
    maxTaskOutputCount: maxTaskOutputCount,
    maxMeshWorkGroupInvocations: maxMeshWorkGroupInvocations,
    maxMeshWorkGroupSize: maxMeshWorkGroupSize,
    maxMeshTotalMemorySize: maxMeshTotalMemorySize,
    maxMeshOutputVertices: maxMeshOutputVertices,
    maxMeshOutputPrimitives: maxMeshOutputPrimitives,
    maxMeshMultiviewViewCount: maxMeshMultiviewViewCount,
    meshOutputPerVertexGranularity: meshOutputPerVertexGranularity,
    meshOutputPerPrimitiveGranularity: meshOutputPerPrimitiveGranularity,
  )

proc newVkDrawMeshTasksIndirectCommandNV*(taskCount: uint32, firstTask: uint32): VkDrawMeshTasksIndirectCommandNV =
  result = VkDrawMeshTasksIndirectCommandNV(
    taskCount: taskCount,
    firstTask: firstTask,
  )

proc newVkPhysicalDeviceMeshShaderFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMeshShaderFeaturesEXT, pNext: pointer = nil, taskShader: VkBool32, meshShader: VkBool32, multiviewMeshShader: VkBool32, primitiveFragmentShadingRateMeshShader: VkBool32, meshShaderQueries: VkBool32): VkPhysicalDeviceMeshShaderFeaturesEXT =
  result = VkPhysicalDeviceMeshShaderFeaturesEXT(
    sType: sType,
    pNext: pNext,
    taskShader: taskShader,
    meshShader: meshShader,
    multiviewMeshShader: multiviewMeshShader,
    primitiveFragmentShadingRateMeshShader: primitiveFragmentShadingRateMeshShader,
    meshShaderQueries: meshShaderQueries,
  )

proc newVkPhysicalDeviceMeshShaderPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMeshShaderPropertiesEXT, pNext: pointer = nil, maxTaskWorkGroupTotalCount: uint32, maxTaskWorkGroupCount: array[3, uint32], maxTaskWorkGroupInvocations: uint32, maxTaskWorkGroupSize: array[3, uint32], maxTaskPayloadSize: uint32, maxTaskSharedMemorySize: uint32, maxTaskPayloadAndSharedMemorySize: uint32, maxMeshWorkGroupTotalCount: uint32, maxMeshWorkGroupCount: array[3, uint32], maxMeshWorkGroupInvocations: uint32, maxMeshWorkGroupSize: array[3, uint32], maxMeshSharedMemorySize: uint32, maxMeshPayloadAndSharedMemorySize: uint32, maxMeshOutputMemorySize: uint32, maxMeshPayloadAndOutputMemorySize: uint32, maxMeshOutputComponents: uint32, maxMeshOutputVertices: uint32, maxMeshOutputPrimitives: uint32, maxMeshOutputLayers: uint32, maxMeshMultiviewViewCount: uint32, meshOutputPerVertexGranularity: uint32, meshOutputPerPrimitiveGranularity: uint32, maxPreferredTaskWorkGroupInvocations: uint32, maxPreferredMeshWorkGroupInvocations: uint32, prefersLocalInvocationVertexOutput: VkBool32, prefersLocalInvocationPrimitiveOutput: VkBool32, prefersCompactVertexOutput: VkBool32, prefersCompactPrimitiveOutput: VkBool32): VkPhysicalDeviceMeshShaderPropertiesEXT =
  result = VkPhysicalDeviceMeshShaderPropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxTaskWorkGroupTotalCount: maxTaskWorkGroupTotalCount,
    maxTaskWorkGroupCount: maxTaskWorkGroupCount,
    maxTaskWorkGroupInvocations: maxTaskWorkGroupInvocations,
    maxTaskWorkGroupSize: maxTaskWorkGroupSize,
    maxTaskPayloadSize: maxTaskPayloadSize,
    maxTaskSharedMemorySize: maxTaskSharedMemorySize,
    maxTaskPayloadAndSharedMemorySize: maxTaskPayloadAndSharedMemorySize,
    maxMeshWorkGroupTotalCount: maxMeshWorkGroupTotalCount,
    maxMeshWorkGroupCount: maxMeshWorkGroupCount,
    maxMeshWorkGroupInvocations: maxMeshWorkGroupInvocations,
    maxMeshWorkGroupSize: maxMeshWorkGroupSize,
    maxMeshSharedMemorySize: maxMeshSharedMemorySize,
    maxMeshPayloadAndSharedMemorySize: maxMeshPayloadAndSharedMemorySize,
    maxMeshOutputMemorySize: maxMeshOutputMemorySize,
    maxMeshPayloadAndOutputMemorySize: maxMeshPayloadAndOutputMemorySize,
    maxMeshOutputComponents: maxMeshOutputComponents,
    maxMeshOutputVertices: maxMeshOutputVertices,
    maxMeshOutputPrimitives: maxMeshOutputPrimitives,
    maxMeshOutputLayers: maxMeshOutputLayers,
    maxMeshMultiviewViewCount: maxMeshMultiviewViewCount,
    meshOutputPerVertexGranularity: meshOutputPerVertexGranularity,
    meshOutputPerPrimitiveGranularity: meshOutputPerPrimitiveGranularity,
    maxPreferredTaskWorkGroupInvocations: maxPreferredTaskWorkGroupInvocations,
    maxPreferredMeshWorkGroupInvocations: maxPreferredMeshWorkGroupInvocations,
    prefersLocalInvocationVertexOutput: prefersLocalInvocationVertexOutput,
    prefersLocalInvocationPrimitiveOutput: prefersLocalInvocationPrimitiveOutput,
    prefersCompactVertexOutput: prefersCompactVertexOutput,
    prefersCompactPrimitiveOutput: prefersCompactPrimitiveOutput,
  )

proc newVkDrawMeshTasksIndirectCommandEXT*(groupCountX: uint32, groupCountY: uint32, groupCountZ: uint32): VkDrawMeshTasksIndirectCommandEXT =
  result = VkDrawMeshTasksIndirectCommandEXT(
    groupCountX: groupCountX,
    groupCountY: groupCountY,
    groupCountZ: groupCountZ,
  )

proc newVkRayTracingShaderGroupCreateInfoNV*(sType: VkStructureType = VkStructureType.RayTracingShaderGroupCreateInfoNV, pNext: pointer = nil, `type`: VkRayTracingShaderGroupTypeKHR, generalShader: uint32, closestHitShader: uint32, anyHitShader: uint32, intersectionShader: uint32): VkRayTracingShaderGroupCreateInfoNV =
  result = VkRayTracingShaderGroupCreateInfoNV(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    generalShader: generalShader,
    closestHitShader: closestHitShader,
    anyHitShader: anyHitShader,
    intersectionShader: intersectionShader,
  )

proc newVkRayTracingShaderGroupCreateInfoKHR*(sType: VkStructureType = VkStructureType.RayTracingShaderGroupCreateInfoKHR, pNext: pointer = nil, `type`: VkRayTracingShaderGroupTypeKHR, generalShader: uint32, closestHitShader: uint32, anyHitShader: uint32, intersectionShader: uint32, pShaderGroupCaptureReplayHandle: pointer = nil): VkRayTracingShaderGroupCreateInfoKHR =
  result = VkRayTracingShaderGroupCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    generalShader: generalShader,
    closestHitShader: closestHitShader,
    anyHitShader: anyHitShader,
    intersectionShader: intersectionShader,
    pShaderGroupCaptureReplayHandle: pShaderGroupCaptureReplayHandle,
  )

proc newVkRayTracingPipelineCreateInfoNV*(sType: VkStructureType = VkStructureType.RayTracingPipelineCreateInfoNV, pNext: pointer = nil, flags: VkPipelineCreateFlags = 0.VkPipelineCreateFlags, stages: openarray[VkPipelineShaderStageCreateInfo], groups: openarray[VkRayTracingShaderGroupCreateInfoNV], maxRecursionDepth: uint32, layout: VkPipelineLayout, basePipelineHandle: VkPipeline, basePipelineIndex: int32): VkRayTracingPipelineCreateInfoNV =
  result = VkRayTracingPipelineCreateInfoNV(
    sType: sType,
    pNext: pNext,
    flags: flags,
    stageCount: len(stages).uint32,
    pStages: if len(stages) == 0: nil else: cast[ptr VkPipelineShaderStageCreateInfo](stages),
    groupCount: len(groups).uint32,
    pGroups: if len(groups) == 0: nil else: cast[ptr VkRayTracingShaderGroupCreateInfoNV](groups),
    maxRecursionDepth: maxRecursionDepth,
    layout: layout,
    basePipelineHandle: basePipelineHandle,
    basePipelineIndex: basePipelineIndex,
  )

proc newVkRayTracingPipelineCreateInfoKHR*(sType: VkStructureType = VkStructureType.RayTracingPipelineCreateInfoKHR, pNext: pointer = nil, flags: VkPipelineCreateFlags = 0.VkPipelineCreateFlags, stages: openarray[VkPipelineShaderStageCreateInfo], groups: openarray[VkRayTracingShaderGroupCreateInfoKHR], maxPipelineRayRecursionDepth: uint32, pLibraryInfo: ptr VkPipelineLibraryCreateInfoKHR, pLibraryInterface: ptr VkRayTracingPipelineInterfaceCreateInfoKHR, pDynamicState: ptr VkPipelineDynamicStateCreateInfo, layout: VkPipelineLayout, basePipelineHandle: VkPipeline, basePipelineIndex: int32): VkRayTracingPipelineCreateInfoKHR =
  result = VkRayTracingPipelineCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    stageCount: len(stages).uint32,
    pStages: if len(stages) == 0: nil else: cast[ptr VkPipelineShaderStageCreateInfo](stages),
    groupCount: len(groups).uint32,
    pGroups: if len(groups) == 0: nil else: cast[ptr VkRayTracingShaderGroupCreateInfoKHR](groups),
    maxPipelineRayRecursionDepth: maxPipelineRayRecursionDepth,
    pLibraryInfo: pLibraryInfo,
    pLibraryInterface: pLibraryInterface,
    pDynamicState: pDynamicState,
    layout: layout,
    basePipelineHandle: basePipelineHandle,
    basePipelineIndex: basePipelineIndex,
  )

proc newVkGeometryTrianglesNV*(sType: VkStructureType = VkStructureType.GeometryTrianglesNV, pNext: pointer = nil, vertexData: VkBuffer, vertexOffset: VkDeviceSize, vertexCount: uint32, vertexStride: VkDeviceSize, vertexFormat: VkFormat, indexData: VkBuffer, indexOffset: VkDeviceSize, indexCount: uint32, indexType: VkIndexType, transformData: VkBuffer, transformOffset: VkDeviceSize): VkGeometryTrianglesNV =
  result = VkGeometryTrianglesNV(
    sType: sType,
    pNext: pNext,
    vertexData: vertexData,
    vertexOffset: vertexOffset,
    vertexCount: vertexCount,
    vertexStride: vertexStride,
    vertexFormat: vertexFormat,
    indexData: indexData,
    indexOffset: indexOffset,
    indexCount: indexCount,
    indexType: indexType,
    transformData: transformData,
    transformOffset: transformOffset,
  )

proc newVkGeometryAABBNV*(sType: VkStructureType = VkStructureType.GeometryAABBNV, pNext: pointer = nil, aabbData: VkBuffer, numAABBs: uint32, stride: uint32, offset: VkDeviceSize): VkGeometryAABBNV =
  result = VkGeometryAABBNV(
    sType: sType,
    pNext: pNext,
    aabbData: aabbData,
    numAABBs: numAABBs,
    stride: stride,
    offset: offset,
  )

proc newVkGeometryDataNV*(triangles: VkGeometryTrianglesNV, aabbs: VkGeometryAABBNV): VkGeometryDataNV =
  result = VkGeometryDataNV(
    triangles: triangles,
    aabbs: aabbs,
  )

proc newVkGeometryNV*(sType: VkStructureType = VkStructureType.GeometryNV, pNext: pointer = nil, geometryType: VkGeometryTypeKHR, geometry: VkGeometryDataNV, flags: VkGeometryFlagsKHR = 0.VkGeometryFlagsKHR): VkGeometryNV =
  result = VkGeometryNV(
    sType: sType,
    pNext: pNext,
    geometryType: geometryType,
    geometry: geometry,
    flags: flags,
  )

proc newVkAccelerationStructureInfoNV*(sType: VkStructureType = VkStructureType.AccelerationStructureInfoNV, pNext: pointer = nil, `type`: VkAccelerationStructureTypeNV, flags: VkBuildAccelerationStructureFlagsNV = 0.VkBuildAccelerationStructureFlagsNV, instanceCount: uint32, geometries: openarray[VkGeometryNV]): VkAccelerationStructureInfoNV =
  result = VkAccelerationStructureInfoNV(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    flags: flags,
    instanceCount: instanceCount,
    geometryCount: len(geometries).uint32,
    pGeometries: if len(geometries) == 0: nil else: cast[ptr VkGeometryNV](geometries),
  )

proc newVkAccelerationStructureCreateInfoNV*(sType: VkStructureType = VkStructureType.AccelerationStructureCreateInfoNV, pNext: pointer = nil, compactedSize: VkDeviceSize, info: VkAccelerationStructureInfoNV): VkAccelerationStructureCreateInfoNV =
  result = VkAccelerationStructureCreateInfoNV(
    sType: sType,
    pNext: pNext,
    compactedSize: compactedSize,
    info: info,
  )

proc newVkBindAccelerationStructureMemoryInfoNV*(sType: VkStructureType = VkStructureType.BindAccelerationStructureMemoryInfoNV, pNext: pointer = nil, accelerationStructure: VkAccelerationStructureNV, memory: VkDeviceMemory, memoryOffset: VkDeviceSize, deviceIndices: openarray[uint32]): VkBindAccelerationStructureMemoryInfoNV =
  result = VkBindAccelerationStructureMemoryInfoNV(
    sType: sType,
    pNext: pNext,
    accelerationStructure: accelerationStructure,
    memory: memory,
    memoryOffset: memoryOffset,
    deviceIndexCount: len(deviceIndices).uint32,
    pDeviceIndices: if len(deviceIndices) == 0: nil else: cast[ptr uint32](deviceIndices),
  )

proc newVkWriteDescriptorSetAccelerationStructureKHR*(sType: VkStructureType = VkStructureType.WriteDescriptorSetAccelerationStructureKHR, pNext: pointer = nil, accelerationStructures: openarray[VkAccelerationStructureKHR]): VkWriteDescriptorSetAccelerationStructureKHR =
  result = VkWriteDescriptorSetAccelerationStructureKHR(
    sType: sType,
    pNext: pNext,
    accelerationStructureCount: len(accelerationStructures).uint32,
    pAccelerationStructures: if len(accelerationStructures) == 0: nil else: cast[ptr VkAccelerationStructureKHR](accelerationStructures),
  )

proc newVkWriteDescriptorSetAccelerationStructureNV*(sType: VkStructureType = VkStructureType.WriteDescriptorSetAccelerationStructureNV, pNext: pointer = nil, accelerationStructures: openarray[VkAccelerationStructureNV]): VkWriteDescriptorSetAccelerationStructureNV =
  result = VkWriteDescriptorSetAccelerationStructureNV(
    sType: sType,
    pNext: pNext,
    accelerationStructureCount: len(accelerationStructures).uint32,
    pAccelerationStructures: if len(accelerationStructures) == 0: nil else: cast[ptr VkAccelerationStructureNV](accelerationStructures),
  )

proc newVkAccelerationStructureMemoryRequirementsInfoNV*(sType: VkStructureType = VkStructureType.AccelerationStructureMemoryRequirementsInfoNV, pNext: pointer = nil, `type`: VkAccelerationStructureMemoryRequirementsTypeNV, accelerationStructure: VkAccelerationStructureNV): VkAccelerationStructureMemoryRequirementsInfoNV =
  result = VkAccelerationStructureMemoryRequirementsInfoNV(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    accelerationStructure: accelerationStructure,
  )

proc newVkPhysicalDeviceAccelerationStructureFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceAccelerationStructureFeaturesKHR, pNext: pointer = nil, accelerationStructure: VkBool32, accelerationStructureCaptureReplay: VkBool32, accelerationStructureIndirectBuild: VkBool32, accelerationStructureHostCommands: VkBool32, descriptorBindingAccelerationStructureUpdateAfterBind: VkBool32): VkPhysicalDeviceAccelerationStructureFeaturesKHR =
  result = VkPhysicalDeviceAccelerationStructureFeaturesKHR(
    sType: sType,
    pNext: pNext,
    accelerationStructure: accelerationStructure,
    accelerationStructureCaptureReplay: accelerationStructureCaptureReplay,
    accelerationStructureIndirectBuild: accelerationStructureIndirectBuild,
    accelerationStructureHostCommands: accelerationStructureHostCommands,
    descriptorBindingAccelerationStructureUpdateAfterBind: descriptorBindingAccelerationStructureUpdateAfterBind,
  )

proc newVkPhysicalDeviceRayTracingPipelineFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingPipelineFeaturesKHR, pNext: pointer = nil, rayTracingPipeline: VkBool32, rayTracingPipelineShaderGroupHandleCaptureReplay: VkBool32, rayTracingPipelineShaderGroupHandleCaptureReplayMixed: VkBool32, rayTracingPipelineTraceRaysIndirect: VkBool32, rayTraversalPrimitiveCulling: VkBool32): VkPhysicalDeviceRayTracingPipelineFeaturesKHR =
  result = VkPhysicalDeviceRayTracingPipelineFeaturesKHR(
    sType: sType,
    pNext: pNext,
    rayTracingPipeline: rayTracingPipeline,
    rayTracingPipelineShaderGroupHandleCaptureReplay: rayTracingPipelineShaderGroupHandleCaptureReplay,
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: rayTracingPipelineShaderGroupHandleCaptureReplayMixed,
    rayTracingPipelineTraceRaysIndirect: rayTracingPipelineTraceRaysIndirect,
    rayTraversalPrimitiveCulling: rayTraversalPrimitiveCulling,
  )

proc newVkPhysicalDeviceRayQueryFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayQueryFeaturesKHR, pNext: pointer = nil, rayQuery: VkBool32): VkPhysicalDeviceRayQueryFeaturesKHR =
  result = VkPhysicalDeviceRayQueryFeaturesKHR(
    sType: sType,
    pNext: pNext,
    rayQuery: rayQuery,
  )

proc newVkPhysicalDeviceAccelerationStructurePropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceAccelerationStructurePropertiesKHR, pNext: pointer = nil, maxGeometryCount: uint64, maxInstanceCount: uint64, maxPrimitiveCount: uint64, maxPerStageDescriptorAccelerationStructures: uint32, maxPerStageDescriptorUpdateAfterBindAccelerationStructures: uint32, maxDescriptorSetAccelerationStructures: uint32, maxDescriptorSetUpdateAfterBindAccelerationStructures: uint32, minAccelerationStructureScratchOffsetAlignment: uint32): VkPhysicalDeviceAccelerationStructurePropertiesKHR =
  result = VkPhysicalDeviceAccelerationStructurePropertiesKHR(
    sType: sType,
    pNext: pNext,
    maxGeometryCount: maxGeometryCount,
    maxInstanceCount: maxInstanceCount,
    maxPrimitiveCount: maxPrimitiveCount,
    maxPerStageDescriptorAccelerationStructures: maxPerStageDescriptorAccelerationStructures,
    maxPerStageDescriptorUpdateAfterBindAccelerationStructures: maxPerStageDescriptorUpdateAfterBindAccelerationStructures,
    maxDescriptorSetAccelerationStructures: maxDescriptorSetAccelerationStructures,
    maxDescriptorSetUpdateAfterBindAccelerationStructures: maxDescriptorSetUpdateAfterBindAccelerationStructures,
    minAccelerationStructureScratchOffsetAlignment: minAccelerationStructureScratchOffsetAlignment,
  )

proc newVkPhysicalDeviceRayTracingPipelinePropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingPipelinePropertiesKHR, pNext: pointer = nil, shaderGroupHandleSize: uint32, maxRayRecursionDepth: uint32, maxShaderGroupStride: uint32, shaderGroupBaseAlignment: uint32, shaderGroupHandleCaptureReplaySize: uint32, maxRayDispatchInvocationCount: uint32, shaderGroupHandleAlignment: uint32, maxRayHitAttributeSize: uint32): VkPhysicalDeviceRayTracingPipelinePropertiesKHR =
  result = VkPhysicalDeviceRayTracingPipelinePropertiesKHR(
    sType: sType,
    pNext: pNext,
    shaderGroupHandleSize: shaderGroupHandleSize,
    maxRayRecursionDepth: maxRayRecursionDepth,
    maxShaderGroupStride: maxShaderGroupStride,
    shaderGroupBaseAlignment: shaderGroupBaseAlignment,
    shaderGroupHandleCaptureReplaySize: shaderGroupHandleCaptureReplaySize,
    maxRayDispatchInvocationCount: maxRayDispatchInvocationCount,
    shaderGroupHandleAlignment: shaderGroupHandleAlignment,
    maxRayHitAttributeSize: maxRayHitAttributeSize,
  )

proc newVkPhysicalDeviceRayTracingPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingPropertiesNV, pNext: pointer = nil, shaderGroupHandleSize: uint32, maxRecursionDepth: uint32, maxShaderGroupStride: uint32, shaderGroupBaseAlignment: uint32, maxGeometryCount: uint64, maxInstanceCount: uint64, maxTriangleCount: uint64, maxDescriptorSetAccelerationStructures: uint32): VkPhysicalDeviceRayTracingPropertiesNV =
  result = VkPhysicalDeviceRayTracingPropertiesNV(
    sType: sType,
    pNext: pNext,
    shaderGroupHandleSize: shaderGroupHandleSize,
    maxRecursionDepth: maxRecursionDepth,
    maxShaderGroupStride: maxShaderGroupStride,
    shaderGroupBaseAlignment: shaderGroupBaseAlignment,
    maxGeometryCount: maxGeometryCount,
    maxInstanceCount: maxInstanceCount,
    maxTriangleCount: maxTriangleCount,
    maxDescriptorSetAccelerationStructures: maxDescriptorSetAccelerationStructures,
  )

proc newVkStridedDeviceAddressRegionKHR*(deviceAddress: VkDeviceAddress, stride: VkDeviceSize, size: VkDeviceSize): VkStridedDeviceAddressRegionKHR =
  result = VkStridedDeviceAddressRegionKHR(
    deviceAddress: deviceAddress,
    stride: stride,
    size: size,
  )

proc newVkTraceRaysIndirectCommandKHR*(width: uint32, height: uint32, depth: uint32): VkTraceRaysIndirectCommandKHR =
  result = VkTraceRaysIndirectCommandKHR(
    width: width,
    height: height,
    depth: depth,
  )

proc newVkTraceRaysIndirectCommand2KHR*(raygenShaderRecordAddress: VkDeviceAddress, raygenShaderRecordSize: VkDeviceSize, missShaderBindingTableAddress: VkDeviceAddress, missShaderBindingTableSize: VkDeviceSize, missShaderBindingTableStride: VkDeviceSize, hitShaderBindingTableAddress: VkDeviceAddress, hitShaderBindingTableSize: VkDeviceSize, hitShaderBindingTableStride: VkDeviceSize, callableShaderBindingTableAddress: VkDeviceAddress, callableShaderBindingTableSize: VkDeviceSize, callableShaderBindingTableStride: VkDeviceSize, width: uint32, height: uint32, depth: uint32): VkTraceRaysIndirectCommand2KHR =
  result = VkTraceRaysIndirectCommand2KHR(
    raygenShaderRecordAddress: raygenShaderRecordAddress,
    raygenShaderRecordSize: raygenShaderRecordSize,
    missShaderBindingTableAddress: missShaderBindingTableAddress,
    missShaderBindingTableSize: missShaderBindingTableSize,
    missShaderBindingTableStride: missShaderBindingTableStride,
    hitShaderBindingTableAddress: hitShaderBindingTableAddress,
    hitShaderBindingTableSize: hitShaderBindingTableSize,
    hitShaderBindingTableStride: hitShaderBindingTableStride,
    callableShaderBindingTableAddress: callableShaderBindingTableAddress,
    callableShaderBindingTableSize: callableShaderBindingTableSize,
    callableShaderBindingTableStride: callableShaderBindingTableStride,
    width: width,
    height: height,
    depth: depth,
  )

proc newVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingMaintenance1FeaturesKHR, pNext: pointer = nil, rayTracingMaintenance1: VkBool32, rayTracingPipelineTraceRaysIndirect2: VkBool32): VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR =
  result = VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(
    sType: sType,
    pNext: pNext,
    rayTracingMaintenance1: rayTracingMaintenance1,
    rayTracingPipelineTraceRaysIndirect2: rayTracingPipelineTraceRaysIndirect2,
  )

proc newVkDrmFormatModifierPropertiesListEXT*(sType: VkStructureType = VkStructureType.DrmFormatModifierPropertiesListEXT, pNext: pointer = nil, drmFormatModifierProperties: openarray[VkDrmFormatModifierPropertiesEXT]): VkDrmFormatModifierPropertiesListEXT =
  result = VkDrmFormatModifierPropertiesListEXT(
    sType: sType,
    pNext: pNext,
    drmFormatModifierCount: len(drmFormatModifierProperties).uint32,
    pDrmFormatModifierProperties: if len(drmFormatModifierProperties) == 0: nil else: cast[ptr VkDrmFormatModifierPropertiesEXT](drmFormatModifierProperties),
  )

proc newVkDrmFormatModifierPropertiesEXT*(drmFormatModifier: uint64, drmFormatModifierPlaneCount: uint32, drmFormatModifierTilingFeatures: VkFormatFeatureFlags): VkDrmFormatModifierPropertiesEXT =
  result = VkDrmFormatModifierPropertiesEXT(
    drmFormatModifier: drmFormatModifier,
    drmFormatModifierPlaneCount: drmFormatModifierPlaneCount,
    drmFormatModifierTilingFeatures: drmFormatModifierTilingFeatures,
  )

proc newVkPhysicalDeviceImageDrmFormatModifierInfoEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageDrmFormatModifierInfoEXT, pNext: pointer = nil, drmFormatModifier: uint64, sharingMode: VkSharingMode, queueFamilyIndices: openarray[uint32]): VkPhysicalDeviceImageDrmFormatModifierInfoEXT =
  result = VkPhysicalDeviceImageDrmFormatModifierInfoEXT(
    sType: sType,
    pNext: pNext,
    drmFormatModifier: drmFormatModifier,
    sharingMode: sharingMode,
    queueFamilyIndexCount: len(queueFamilyIndices).uint32,
    pQueueFamilyIndices: if len(queueFamilyIndices) == 0: nil else: cast[ptr uint32](queueFamilyIndices),
  )

proc newVkImageDrmFormatModifierListCreateInfoEXT*(sType: VkStructureType = VkStructureType.ImageDrmFormatModifierListCreateInfoEXT, pNext: pointer = nil, drmFormatModifiers: openarray[uint64]): VkImageDrmFormatModifierListCreateInfoEXT =
  result = VkImageDrmFormatModifierListCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    drmFormatModifierCount: len(drmFormatModifiers).uint32,
    pDrmFormatModifiers: if len(drmFormatModifiers) == 0: nil else: cast[ptr uint64](drmFormatModifiers),
  )

proc newVkImageDrmFormatModifierExplicitCreateInfoEXT*(sType: VkStructureType = VkStructureType.ImageDrmFormatModifierExplicitCreateInfoEXT, pNext: pointer = nil, drmFormatModifier: uint64, planeLayouts: openarray[VkSubresourceLayout]): VkImageDrmFormatModifierExplicitCreateInfoEXT =
  result = VkImageDrmFormatModifierExplicitCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    drmFormatModifier: drmFormatModifier,
    drmFormatModifierPlaneCount: len(planeLayouts).uint32,
    pPlaneLayouts: if len(planeLayouts) == 0: nil else: cast[ptr VkSubresourceLayout](planeLayouts),
  )

proc newVkImageDrmFormatModifierPropertiesEXT*(sType: VkStructureType = VkStructureType.ImageDrmFormatModifierPropertiesEXT, pNext: pointer = nil, drmFormatModifier: uint64): VkImageDrmFormatModifierPropertiesEXT =
  result = VkImageDrmFormatModifierPropertiesEXT(
    sType: sType,
    pNext: pNext,
    drmFormatModifier: drmFormatModifier,
  )

proc newVkImageStencilUsageCreateInfo*(sType: VkStructureType = VkStructureType.ImageStencilUsageCreateInfo, pNext: pointer = nil, stencilUsage: VkImageUsageFlags): VkImageStencilUsageCreateInfo =
  result = VkImageStencilUsageCreateInfo(
    sType: sType,
    pNext: pNext,
    stencilUsage: stencilUsage,
  )

proc newVkDeviceMemoryOverallocationCreateInfoAMD*(sType: VkStructureType = VkStructureType.DeviceMemoryOverallocationCreateInfoAMD, pNext: pointer = nil, overallocationBehavior: VkMemoryOverallocationBehaviorAMD): VkDeviceMemoryOverallocationCreateInfoAMD =
  result = VkDeviceMemoryOverallocationCreateInfoAMD(
    sType: sType,
    pNext: pNext,
    overallocationBehavior: overallocationBehavior,
  )

proc newVkPhysicalDeviceFragmentDensityMapFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentDensityMapFeaturesEXT, pNext: pointer = nil, fragmentDensityMap: VkBool32, fragmentDensityMapDynamic: VkBool32, fragmentDensityMapNonSubsampledImages: VkBool32): VkPhysicalDeviceFragmentDensityMapFeaturesEXT =
  result = VkPhysicalDeviceFragmentDensityMapFeaturesEXT(
    sType: sType,
    pNext: pNext,
    fragmentDensityMap: fragmentDensityMap,
    fragmentDensityMapDynamic: fragmentDensityMapDynamic,
    fragmentDensityMapNonSubsampledImages: fragmentDensityMapNonSubsampledImages,
  )

proc newVkPhysicalDeviceFragmentDensityMap2FeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentDensityMap2FeaturesEXT, pNext: pointer = nil, fragmentDensityMapDeferred: VkBool32): VkPhysicalDeviceFragmentDensityMap2FeaturesEXT =
  result = VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(
    sType: sType,
    pNext: pNext,
    fragmentDensityMapDeferred: fragmentDensityMapDeferred,
  )

proc newVkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT, pNext: pointer = nil, fragmentDensityMapOffset: VkBool32): VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT =
  result = VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(
    sType: sType,
    pNext: pNext,
    fragmentDensityMapOffset: fragmentDensityMapOffset,
  )

proc newVkPhysicalDeviceFragmentDensityMapPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentDensityMapPropertiesEXT, pNext: pointer = nil, minFragmentDensityTexelSize: VkExtent2D, maxFragmentDensityTexelSize: VkExtent2D, fragmentDensityInvocations: VkBool32): VkPhysicalDeviceFragmentDensityMapPropertiesEXT =
  result = VkPhysicalDeviceFragmentDensityMapPropertiesEXT(
    sType: sType,
    pNext: pNext,
    minFragmentDensityTexelSize: minFragmentDensityTexelSize,
    maxFragmentDensityTexelSize: maxFragmentDensityTexelSize,
    fragmentDensityInvocations: fragmentDensityInvocations,
  )

proc newVkPhysicalDeviceFragmentDensityMap2PropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentDensityMap2PropertiesEXT, pNext: pointer = nil, subsampledLoads: VkBool32, subsampledCoarseReconstructionEarlyAccess: VkBool32, maxSubsampledArrayLayers: uint32, maxDescriptorSetSubsampledSamplers: uint32): VkPhysicalDeviceFragmentDensityMap2PropertiesEXT =
  result = VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(
    sType: sType,
    pNext: pNext,
    subsampledLoads: subsampledLoads,
    subsampledCoarseReconstructionEarlyAccess: subsampledCoarseReconstructionEarlyAccess,
    maxSubsampledArrayLayers: maxSubsampledArrayLayers,
    maxDescriptorSetSubsampledSamplers: maxDescriptorSetSubsampledSamplers,
  )

proc newVkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT, pNext: pointer = nil, fragmentDensityOffsetGranularity: VkExtent2D): VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT =
  result = VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(
    sType: sType,
    pNext: pNext,
    fragmentDensityOffsetGranularity: fragmentDensityOffsetGranularity,
  )

proc newVkRenderPassFragmentDensityMapCreateInfoEXT*(sType: VkStructureType = VkStructureType.RenderPassFragmentDensityMapCreateInfoEXT, pNext: pointer = nil, fragmentDensityMapAttachment: VkAttachmentReference): VkRenderPassFragmentDensityMapCreateInfoEXT =
  result = VkRenderPassFragmentDensityMapCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    fragmentDensityMapAttachment: fragmentDensityMapAttachment,
  )

proc newVkRenderPassFragmentDensityMapOffsetEndInfoEXT*(sType: VkStructureType = VkStructureType.RenderPassFragmentDensityMapOffsetEndInfoEXT, pNext: pointer = nil, fragmentDensityOffsets: openarray[VkOffset2D]): VkRenderPassFragmentDensityMapOffsetEndInfoEXT =
  result = VkRenderPassFragmentDensityMapOffsetEndInfoEXT(
    sType: sType,
    pNext: pNext,
    fragmentDensityOffsetCount: len(fragmentDensityOffsets).uint32,
    pFragmentDensityOffsets: if len(fragmentDensityOffsets) == 0: nil else: cast[ptr VkOffset2D](fragmentDensityOffsets),
  )

proc newVkPhysicalDeviceScalarBlockLayoutFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceScalarBlockLayoutFeatures, pNext: pointer = nil, scalarBlockLayout: VkBool32): VkPhysicalDeviceScalarBlockLayoutFeatures =
  result = VkPhysicalDeviceScalarBlockLayoutFeatures(
    sType: sType,
    pNext: pNext,
    scalarBlockLayout: scalarBlockLayout,
  )

proc newVkSurfaceProtectedCapabilitiesKHR*(sType: VkStructureType = VkStructureType.SurfaceProtectedCapabilitiesKHR, pNext: pointer = nil, supportsProtected: VkBool32): VkSurfaceProtectedCapabilitiesKHR =
  result = VkSurfaceProtectedCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    supportsProtected: supportsProtected,
  )

proc newVkPhysicalDeviceUniformBufferStandardLayoutFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceUniformBufferStandardLayoutFeatures, pNext: pointer = nil, uniformBufferStandardLayout: VkBool32): VkPhysicalDeviceUniformBufferStandardLayoutFeatures =
  result = VkPhysicalDeviceUniformBufferStandardLayoutFeatures(
    sType: sType,
    pNext: pNext,
    uniformBufferStandardLayout: uniformBufferStandardLayout,
  )

proc newVkPhysicalDeviceDepthClipEnableFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDepthClipEnableFeaturesEXT, pNext: pointer = nil, depthClipEnable: VkBool32): VkPhysicalDeviceDepthClipEnableFeaturesEXT =
  result = VkPhysicalDeviceDepthClipEnableFeaturesEXT(
    sType: sType,
    pNext: pNext,
    depthClipEnable: depthClipEnable,
  )

proc newVkPipelineRasterizationDepthClipStateCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineRasterizationDepthClipStateCreateInfoEXT, pNext: pointer = nil, flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT = 0.VkPipelineRasterizationDepthClipStateCreateFlagsEXT, depthClipEnable: VkBool32): VkPipelineRasterizationDepthClipStateCreateInfoEXT =
  result = VkPipelineRasterizationDepthClipStateCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    depthClipEnable: depthClipEnable,
  )

proc newVkPhysicalDeviceMemoryBudgetPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMemoryBudgetPropertiesEXT, pNext: pointer = nil, heapBudget: array[VK_MAX_MEMORY_HEAPS, VkDeviceSize], heapUsage: array[VK_MAX_MEMORY_HEAPS, VkDeviceSize]): VkPhysicalDeviceMemoryBudgetPropertiesEXT =
  result = VkPhysicalDeviceMemoryBudgetPropertiesEXT(
    sType: sType,
    pNext: pNext,
    heapBudget: heapBudget,
    heapUsage: heapUsage,
  )

proc newVkPhysicalDeviceMemoryPriorityFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMemoryPriorityFeaturesEXT, pNext: pointer = nil, memoryPriority: VkBool32): VkPhysicalDeviceMemoryPriorityFeaturesEXT =
  result = VkPhysicalDeviceMemoryPriorityFeaturesEXT(
    sType: sType,
    pNext: pNext,
    memoryPriority: memoryPriority,
  )

proc newVkMemoryPriorityAllocateInfoEXT*(sType: VkStructureType = VkStructureType.MemoryPriorityAllocateInfoEXT, pNext: pointer = nil, priority: float32): VkMemoryPriorityAllocateInfoEXT =
  result = VkMemoryPriorityAllocateInfoEXT(
    sType: sType,
    pNext: pNext,
    priority: priority,
  )

proc newVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, pNext: pointer = nil, pageableDeviceLocalMemory: VkBool32): VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT =
  result = VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(
    sType: sType,
    pNext: pNext,
    pageableDeviceLocalMemory: pageableDeviceLocalMemory,
  )

proc newVkPhysicalDeviceBufferDeviceAddressFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceBufferDeviceAddressFeatures, pNext: pointer = nil, bufferDeviceAddress: VkBool32, bufferDeviceAddressCaptureReplay: VkBool32, bufferDeviceAddressMultiDevice: VkBool32): VkPhysicalDeviceBufferDeviceAddressFeatures =
  result = VkPhysicalDeviceBufferDeviceAddressFeatures(
    sType: sType,
    pNext: pNext,
    bufferDeviceAddress: bufferDeviceAddress,
    bufferDeviceAddressCaptureReplay: bufferDeviceAddressCaptureReplay,
    bufferDeviceAddressMultiDevice: bufferDeviceAddressMultiDevice,
  )

proc newVkPhysicalDeviceBufferDeviceAddressFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceBufferDeviceAddressFeaturesEXT, pNext: pointer = nil, bufferDeviceAddress: VkBool32, bufferDeviceAddressCaptureReplay: VkBool32, bufferDeviceAddressMultiDevice: VkBool32): VkPhysicalDeviceBufferDeviceAddressFeaturesEXT =
  result = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(
    sType: sType,
    pNext: pNext,
    bufferDeviceAddress: bufferDeviceAddress,
    bufferDeviceAddressCaptureReplay: bufferDeviceAddressCaptureReplay,
    bufferDeviceAddressMultiDevice: bufferDeviceAddressMultiDevice,
  )

proc newVkBufferDeviceAddressInfo*(sType: VkStructureType = VkStructureType.BufferDeviceAddressInfo, pNext: pointer = nil, buffer: VkBuffer): VkBufferDeviceAddressInfo =
  result = VkBufferDeviceAddressInfo(
    sType: sType,
    pNext: pNext,
    buffer: buffer,
  )

proc newVkBufferOpaqueCaptureAddressCreateInfo*(sType: VkStructureType = VkStructureType.BufferOpaqueCaptureAddressCreateInfo, pNext: pointer = nil, opaqueCaptureAddress: uint64): VkBufferOpaqueCaptureAddressCreateInfo =
  result = VkBufferOpaqueCaptureAddressCreateInfo(
    sType: sType,
    pNext: pNext,
    opaqueCaptureAddress: opaqueCaptureAddress,
  )

proc newVkBufferDeviceAddressCreateInfoEXT*(sType: VkStructureType = VkStructureType.BufferDeviceAddressCreateInfoEXT, pNext: pointer = nil, deviceAddress: VkDeviceAddress): VkBufferDeviceAddressCreateInfoEXT =
  result = VkBufferDeviceAddressCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    deviceAddress: deviceAddress,
  )

proc newVkPhysicalDeviceImageViewImageFormatInfoEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageViewImageFormatInfoEXT, pNext: pointer = nil, imageViewType: VkImageViewType): VkPhysicalDeviceImageViewImageFormatInfoEXT =
  result = VkPhysicalDeviceImageViewImageFormatInfoEXT(
    sType: sType,
    pNext: pNext,
    imageViewType: imageViewType,
  )

proc newVkFilterCubicImageViewImageFormatPropertiesEXT*(sType: VkStructureType = VkStructureType.FilterCubicImageViewImageFormatPropertiesEXT, pNext: pointer = nil, filterCubic: VkBool32, filterCubicMinmax: VkBool32): VkFilterCubicImageViewImageFormatPropertiesEXT =
  result = VkFilterCubicImageViewImageFormatPropertiesEXT(
    sType: sType,
    pNext: pNext,
    filterCubic: filterCubic,
    filterCubicMinmax: filterCubicMinmax,
  )

proc newVkPhysicalDeviceImagelessFramebufferFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceImagelessFramebufferFeatures, pNext: pointer = nil, imagelessFramebuffer: VkBool32): VkPhysicalDeviceImagelessFramebufferFeatures =
  result = VkPhysicalDeviceImagelessFramebufferFeatures(
    sType: sType,
    pNext: pNext,
    imagelessFramebuffer: imagelessFramebuffer,
  )

proc newVkFramebufferAttachmentsCreateInfo*(sType: VkStructureType = VkStructureType.FramebufferAttachmentsCreateInfo, pNext: pointer = nil, attachmentImageInfos: openarray[VkFramebufferAttachmentImageInfo]): VkFramebufferAttachmentsCreateInfo =
  result = VkFramebufferAttachmentsCreateInfo(
    sType: sType,
    pNext: pNext,
    attachmentImageInfoCount: len(attachmentImageInfos).uint32,
    pAttachmentImageInfos: if len(attachmentImageInfos) == 0: nil else: cast[ptr VkFramebufferAttachmentImageInfo](attachmentImageInfos),
  )

proc newVkFramebufferAttachmentImageInfo*(sType: VkStructureType = VkStructureType.FramebufferAttachmentImageInfo, pNext: pointer = nil, flags: VkImageCreateFlags = 0.VkImageCreateFlags, usage: VkImageUsageFlags, width: uint32, height: uint32, layerCount: uint32, viewFormats: openarray[VkFormat]): VkFramebufferAttachmentImageInfo =
  result = VkFramebufferAttachmentImageInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    usage: usage,
    width: width,
    height: height,
    layerCount: layerCount,
    viewFormatCount: len(viewFormats).uint32,
    pViewFormats: if len(viewFormats) == 0: nil else: cast[ptr VkFormat](viewFormats),
  )

proc newVkRenderPassAttachmentBeginInfo*(sType: VkStructureType = VkStructureType.RenderPassAttachmentBeginInfo, pNext: pointer = nil, attachments: openarray[VkImageView]): VkRenderPassAttachmentBeginInfo =
  result = VkRenderPassAttachmentBeginInfo(
    sType: sType,
    pNext: pNext,
    attachmentCount: len(attachments).uint32,
    pAttachments: if len(attachments) == 0: nil else: cast[ptr VkImageView](attachments),
  )

proc newVkPhysicalDeviceTextureCompressionASTCHDRFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceTextureCompressionASTCHDRFeatures, pNext: pointer = nil, textureCompressionASTC_HDR: VkBool32): VkPhysicalDeviceTextureCompressionASTCHDRFeatures =
  result = VkPhysicalDeviceTextureCompressionASTCHDRFeatures(
    sType: sType,
    pNext: pNext,
    textureCompressionASTC_HDR: textureCompressionASTC_HDR,
  )

proc newVkPhysicalDeviceCooperativeMatrixFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCooperativeMatrixFeaturesNV, pNext: pointer = nil, cooperativeMatrix: VkBool32, cooperativeMatrixRobustBufferAccess: VkBool32): VkPhysicalDeviceCooperativeMatrixFeaturesNV =
  result = VkPhysicalDeviceCooperativeMatrixFeaturesNV(
    sType: sType,
    pNext: pNext,
    cooperativeMatrix: cooperativeMatrix,
    cooperativeMatrixRobustBufferAccess: cooperativeMatrixRobustBufferAccess,
  )

proc newVkPhysicalDeviceCooperativeMatrixPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCooperativeMatrixPropertiesNV, pNext: pointer = nil, cooperativeMatrixSupportedStages: VkShaderStageFlags): VkPhysicalDeviceCooperativeMatrixPropertiesNV =
  result = VkPhysicalDeviceCooperativeMatrixPropertiesNV(
    sType: sType,
    pNext: pNext,
    cooperativeMatrixSupportedStages: cooperativeMatrixSupportedStages,
  )

proc newVkCooperativeMatrixPropertiesNV*(sType: VkStructureType = VkStructureType.CooperativeMatrixPropertiesNV, pNext: pointer = nil, MSize: uint32, NSize: uint32, KSize: uint32, AType: VkComponentTypeNV, BType: VkComponentTypeNV, CType: VkComponentTypeNV, DType: VkComponentTypeNV, scope: VkScopeNV): VkCooperativeMatrixPropertiesNV =
  result = VkCooperativeMatrixPropertiesNV(
    sType: sType,
    pNext: pNext,
    MSize: MSize,
    NSize: NSize,
    KSize: KSize,
    AType: AType,
    BType: BType,
    CType: CType,
    DType: DType,
    scope: scope,
  )

proc newVkPhysicalDeviceYcbcrImageArraysFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceYcbcrImageArraysFeaturesEXT, pNext: pointer = nil, ycbcrImageArrays: VkBool32): VkPhysicalDeviceYcbcrImageArraysFeaturesEXT =
  result = VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(
    sType: sType,
    pNext: pNext,
    ycbcrImageArrays: ycbcrImageArrays,
  )

proc newVkImageViewHandleInfoNVX*(sType: VkStructureType = VkStructureType.ImageViewHandleInfoNVX, pNext: pointer = nil, imageView: VkImageView, descriptorType: VkDescriptorType, sampler: VkSampler): VkImageViewHandleInfoNVX =
  result = VkImageViewHandleInfoNVX(
    sType: sType,
    pNext: pNext,
    imageView: imageView,
    descriptorType: descriptorType,
    sampler: sampler,
  )

proc newVkImageViewAddressPropertiesNVX*(sType: VkStructureType = VkStructureType.ImageViewAddressPropertiesNVX, pNext: pointer = nil, deviceAddress: VkDeviceAddress, size: VkDeviceSize): VkImageViewAddressPropertiesNVX =
  result = VkImageViewAddressPropertiesNVX(
    sType: sType,
    pNext: pNext,
    deviceAddress: deviceAddress,
    size: size,
  )

proc newVkPresentFrameTokenGGP*(sType: VkStructureType = VkStructureType.PresentFrameTokenGGP, pNext: pointer = nil, frameToken: GgpFrameToken): VkPresentFrameTokenGGP =
  result = VkPresentFrameTokenGGP(
    sType: sType,
    pNext: pNext,
    frameToken: frameToken,
  )

proc newVkPipelineCreationFeedback*(flags: VkPipelineCreationFeedbackFlags = 0.VkPipelineCreationFeedbackFlags, duration: uint64): VkPipelineCreationFeedback =
  result = VkPipelineCreationFeedback(
    flags: flags,
    duration: duration,
  )

proc newVkPipelineCreationFeedbackCreateInfo*(sType: VkStructureType = VkStructureType.PipelineCreationFeedbackCreateInfo, pNext: pointer = nil, pPipelineCreationFeedback: ptr VkPipelineCreationFeedback, pipelineStageCreationFeedbacks: openarray[ptr VkPipelineCreationFeedback]): VkPipelineCreationFeedbackCreateInfo =
  result = VkPipelineCreationFeedbackCreateInfo(
    sType: sType,
    pNext: pNext,
    pPipelineCreationFeedback: pPipelineCreationFeedback,
    pipelineStageCreationFeedbackCount: len(pipelineStageCreationFeedbacks).uint32,
    pPipelineStageCreationFeedbacks: if len(pipelineStageCreationFeedbacks) == 0: nil else: cast[ptr ptr VkPipelineCreationFeedback](pipelineStageCreationFeedbacks),
  )

proc newVkSurfaceFullScreenExclusiveInfoEXT*(sType: VkStructureType = VkStructureType.SurfaceFullScreenExclusiveInfoEXT, pNext: pointer = nil, fullScreenExclusive: VkFullScreenExclusiveEXT): VkSurfaceFullScreenExclusiveInfoEXT =
  result = VkSurfaceFullScreenExclusiveInfoEXT(
    sType: sType,
    pNext: pNext,
    fullScreenExclusive: fullScreenExclusive,
  )

proc newVkSurfaceFullScreenExclusiveWin32InfoEXT*(sType: VkStructureType = VkStructureType.SurfaceFullScreenExclusiveWin32InfoEXT, pNext: pointer = nil, hmonitor: HMONITOR): VkSurfaceFullScreenExclusiveWin32InfoEXT =
  result = VkSurfaceFullScreenExclusiveWin32InfoEXT(
    sType: sType,
    pNext: pNext,
    hmonitor: hmonitor,
  )

proc newVkSurfaceCapabilitiesFullScreenExclusiveEXT*(sType: VkStructureType = VkStructureType.SurfaceCapabilitiesFullScreenExclusiveEXT, pNext: pointer = nil, fullScreenExclusiveSupported: VkBool32): VkSurfaceCapabilitiesFullScreenExclusiveEXT =
  result = VkSurfaceCapabilitiesFullScreenExclusiveEXT(
    sType: sType,
    pNext: pNext,
    fullScreenExclusiveSupported: fullScreenExclusiveSupported,
  )

proc newVkPhysicalDevicePresentBarrierFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDevicePresentBarrierFeaturesNV, pNext: pointer = nil, presentBarrier: VkBool32): VkPhysicalDevicePresentBarrierFeaturesNV =
  result = VkPhysicalDevicePresentBarrierFeaturesNV(
    sType: sType,
    pNext: pNext,
    presentBarrier: presentBarrier,
  )

proc newVkSurfaceCapabilitiesPresentBarrierNV*(sType: VkStructureType = VkStructureType.SurfaceCapabilitiesPresentBarrierNV, pNext: pointer = nil, presentBarrierSupported: VkBool32): VkSurfaceCapabilitiesPresentBarrierNV =
  result = VkSurfaceCapabilitiesPresentBarrierNV(
    sType: sType,
    pNext: pNext,
    presentBarrierSupported: presentBarrierSupported,
  )

proc newVkSwapchainPresentBarrierCreateInfoNV*(sType: VkStructureType = VkStructureType.SwapchainPresentBarrierCreateInfoNV, pNext: pointer = nil, presentBarrierEnable: VkBool32): VkSwapchainPresentBarrierCreateInfoNV =
  result = VkSwapchainPresentBarrierCreateInfoNV(
    sType: sType,
    pNext: pNext,
    presentBarrierEnable: presentBarrierEnable,
  )

proc newVkPhysicalDevicePerformanceQueryFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePerformanceQueryFeaturesKHR, pNext: pointer = nil, performanceCounterQueryPools: VkBool32, performanceCounterMultipleQueryPools: VkBool32): VkPhysicalDevicePerformanceQueryFeaturesKHR =
  result = VkPhysicalDevicePerformanceQueryFeaturesKHR(
    sType: sType,
    pNext: pNext,
    performanceCounterQueryPools: performanceCounterQueryPools,
    performanceCounterMultipleQueryPools: performanceCounterMultipleQueryPools,
  )

proc newVkPhysicalDevicePerformanceQueryPropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePerformanceQueryPropertiesKHR, pNext: pointer = nil, allowCommandBufferQueryCopies: VkBool32): VkPhysicalDevicePerformanceQueryPropertiesKHR =
  result = VkPhysicalDevicePerformanceQueryPropertiesKHR(
    sType: sType,
    pNext: pNext,
    allowCommandBufferQueryCopies: allowCommandBufferQueryCopies,
  )

proc newVkPerformanceCounterKHR*(sType: VkStructureType = VkStructureType.PerformanceCounterKHR, pNext: pointer = nil, unit: VkPerformanceCounterUnitKHR, scope: VkPerformanceCounterScopeKHR, storage: VkPerformanceCounterStorageKHR, uuid: array[VK_UUID_SIZE, uint8]): VkPerformanceCounterKHR =
  result = VkPerformanceCounterKHR(
    sType: sType,
    pNext: pNext,
    unit: unit,
    scope: scope,
    storage: storage,
    uuid: uuid,
  )

proc newVkPerformanceCounterDescriptionKHR*(sType: VkStructureType = VkStructureType.PerformanceCounterDescriptionKHR, pNext: pointer = nil, flags: VkPerformanceCounterDescriptionFlagsKHR = 0.VkPerformanceCounterDescriptionFlagsKHR, name: array[VK_MAX_DESCRIPTION_SIZE, char], category: array[VK_MAX_DESCRIPTION_SIZE, char], description: array[VK_MAX_DESCRIPTION_SIZE, char]): VkPerformanceCounterDescriptionKHR =
  result = VkPerformanceCounterDescriptionKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    name: name,
    category: category,
    description: description,
  )

proc newVkQueryPoolPerformanceCreateInfoKHR*(sType: VkStructureType = VkStructureType.QueryPoolPerformanceCreateInfoKHR, pNext: pointer = nil, queueFamilyIndex: uint32, counterIndices: openarray[uint32]): VkQueryPoolPerformanceCreateInfoKHR =
  result = VkQueryPoolPerformanceCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    queueFamilyIndex: queueFamilyIndex,
    counterIndexCount: len(counterIndices).uint32,
    pCounterIndices: if len(counterIndices) == 0: nil else: cast[ptr uint32](counterIndices),
  )

proc newVkAcquireProfilingLockInfoKHR*(sType: VkStructureType = VkStructureType.AcquireProfilingLockInfoKHR, pNext: pointer = nil, flags: VkAcquireProfilingLockFlagsKHR = 0.VkAcquireProfilingLockFlagsKHR, timeout: uint64): VkAcquireProfilingLockInfoKHR =
  result = VkAcquireProfilingLockInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    timeout: timeout,
  )

proc newVkPerformanceQuerySubmitInfoKHR*(sType: VkStructureType = VkStructureType.PerformanceQuerySubmitInfoKHR, pNext: pointer = nil, counterPassIndex: uint32): VkPerformanceQuerySubmitInfoKHR =
  result = VkPerformanceQuerySubmitInfoKHR(
    sType: sType,
    pNext: pNext,
    counterPassIndex: counterPassIndex,
  )

proc newVkPerformanceQueryReservationInfoKHR*(sType: VkStructureType = VkStructureType.PerformanceQueryReservationInfoKHR, pNext: pointer = nil, maxPerformanceQueriesPerPool: uint32): VkPerformanceQueryReservationInfoKHR =
  result = VkPerformanceQueryReservationInfoKHR(
    sType: sType,
    pNext: pNext,
    maxPerformanceQueriesPerPool: maxPerformanceQueriesPerPool,
  )

proc newVkHeadlessSurfaceCreateInfoEXT*(sType: VkStructureType = VkStructureType.HeadlessSurfaceCreateInfoEXT, pNext: pointer = nil, flags: VkHeadlessSurfaceCreateFlagsEXT = 0.VkHeadlessSurfaceCreateFlagsEXT): VkHeadlessSurfaceCreateInfoEXT =
  result = VkHeadlessSurfaceCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkPhysicalDeviceCoverageReductionModeFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCoverageReductionModeFeaturesNV, pNext: pointer = nil, coverageReductionMode: VkBool32): VkPhysicalDeviceCoverageReductionModeFeaturesNV =
  result = VkPhysicalDeviceCoverageReductionModeFeaturesNV(
    sType: sType,
    pNext: pNext,
    coverageReductionMode: coverageReductionMode,
  )

proc newVkPipelineCoverageReductionStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineCoverageReductionStateCreateInfoNV, pNext: pointer = nil, flags: VkPipelineCoverageReductionStateCreateFlagsNV = 0.VkPipelineCoverageReductionStateCreateFlagsNV, coverageReductionMode: VkCoverageReductionModeNV): VkPipelineCoverageReductionStateCreateInfoNV =
  result = VkPipelineCoverageReductionStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    flags: flags,
    coverageReductionMode: coverageReductionMode,
  )

proc newVkFramebufferMixedSamplesCombinationNV*(sType: VkStructureType = VkStructureType.FramebufferMixedSamplesCombinationNV, pNext: pointer = nil, coverageReductionMode: VkCoverageReductionModeNV, rasterizationSamples: VkSampleCountFlagBits, depthStencilSamples: VkSampleCountFlags, colorSamples: VkSampleCountFlags): VkFramebufferMixedSamplesCombinationNV =
  result = VkFramebufferMixedSamplesCombinationNV(
    sType: sType,
    pNext: pNext,
    coverageReductionMode: coverageReductionMode,
    rasterizationSamples: rasterizationSamples,
    depthStencilSamples: depthStencilSamples,
    colorSamples: colorSamples,
  )

proc newVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, pNext: pointer = nil, shaderIntegerFunctions2: VkBool32): VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL =
  result = VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
    sType: sType,
    pNext: pNext,
    shaderIntegerFunctions2: shaderIntegerFunctions2,
  )

proc newVkPerformanceValueINTEL*(`type`: VkPerformanceValueTypeINTEL, data: VkPerformanceValueDataINTEL): VkPerformanceValueINTEL =
  result = VkPerformanceValueINTEL(
    `type`: `type`,
    data: data,
  )

proc newVkInitializePerformanceApiInfoINTEL*(sType: VkStructureType = VkStructureType.InitializePerformanceApiInfoINTEL, pNext: pointer = nil, pUserData: pointer = nil): VkInitializePerformanceApiInfoINTEL =
  result = VkInitializePerformanceApiInfoINTEL(
    sType: sType,
    pNext: pNext,
    pUserData: pUserData,
  )

proc newVkQueryPoolPerformanceQueryCreateInfoINTEL*(sType: VkStructureType = VkStructureType.QueryPoolPerformanceQueryCreateInfoINTEL, pNext: pointer = nil, performanceCountersSampling: VkQueryPoolSamplingModeINTEL): VkQueryPoolPerformanceQueryCreateInfoINTEL =
  result = VkQueryPoolPerformanceQueryCreateInfoINTEL(
    sType: sType,
    pNext: pNext,
    performanceCountersSampling: performanceCountersSampling,
  )

proc newVkPerformanceMarkerInfoINTEL*(sType: VkStructureType = VkStructureType.PerformanceMarkerInfoINTEL, pNext: pointer = nil, marker: uint64): VkPerformanceMarkerInfoINTEL =
  result = VkPerformanceMarkerInfoINTEL(
    sType: sType,
    pNext: pNext,
    marker: marker,
  )

proc newVkPerformanceStreamMarkerInfoINTEL*(sType: VkStructureType = VkStructureType.PerformanceStreamMarkerInfoINTEL, pNext: pointer = nil, marker: uint32): VkPerformanceStreamMarkerInfoINTEL =
  result = VkPerformanceStreamMarkerInfoINTEL(
    sType: sType,
    pNext: pNext,
    marker: marker,
  )

proc newVkPerformanceOverrideInfoINTEL*(sType: VkStructureType = VkStructureType.PerformanceOverrideInfoINTEL, pNext: pointer = nil, `type`: VkPerformanceOverrideTypeINTEL, enable: VkBool32, parameter: uint64): VkPerformanceOverrideInfoINTEL =
  result = VkPerformanceOverrideInfoINTEL(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    enable: enable,
    parameter: parameter,
  )

proc newVkPerformanceConfigurationAcquireInfoINTEL*(sType: VkStructureType = VkStructureType.PerformanceConfigurationAcquireInfoINTEL, pNext: pointer = nil, `type`: VkPerformanceConfigurationTypeINTEL): VkPerformanceConfigurationAcquireInfoINTEL =
  result = VkPerformanceConfigurationAcquireInfoINTEL(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
  )

proc newVkPhysicalDeviceShaderClockFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderClockFeaturesKHR, pNext: pointer = nil, shaderSubgroupClock: VkBool32, shaderDeviceClock: VkBool32): VkPhysicalDeviceShaderClockFeaturesKHR =
  result = VkPhysicalDeviceShaderClockFeaturesKHR(
    sType: sType,
    pNext: pNext,
    shaderSubgroupClock: shaderSubgroupClock,
    shaderDeviceClock: shaderDeviceClock,
  )

proc newVkPhysicalDeviceIndexTypeUint8Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceIndexTypeUint8Features, pNext: pointer = nil, indexTypeUint8: VkBool32): VkPhysicalDeviceIndexTypeUint8Features =
  result = VkPhysicalDeviceIndexTypeUint8Features(
    sType: sType,
    pNext: pNext,
    indexTypeUint8: indexTypeUint8,
  )

proc newVkPhysicalDeviceShaderSMBuiltinsPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderSMBuiltinsPropertiesNV, pNext: pointer = nil, shaderSMCount: uint32, shaderWarpsPerSM: uint32): VkPhysicalDeviceShaderSMBuiltinsPropertiesNV =
  result = VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(
    sType: sType,
    pNext: pNext,
    shaderSMCount: shaderSMCount,
    shaderWarpsPerSM: shaderWarpsPerSM,
  )

proc newVkPhysicalDeviceShaderSMBuiltinsFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderSMBuiltinsFeaturesNV, pNext: pointer = nil, shaderSMBuiltins: VkBool32): VkPhysicalDeviceShaderSMBuiltinsFeaturesNV =
  result = VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(
    sType: sType,
    pNext: pNext,
    shaderSMBuiltins: shaderSMBuiltins,
  )

proc newVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentShaderInterlockFeaturesEXT, pNext: pointer = nil, fragmentShaderSampleInterlock: VkBool32, fragmentShaderPixelInterlock: VkBool32, fragmentShaderShadingRateInterlock: VkBool32): VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT =
  result = VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(
    sType: sType,
    pNext: pNext,
    fragmentShaderSampleInterlock: fragmentShaderSampleInterlock,
    fragmentShaderPixelInterlock: fragmentShaderPixelInterlock,
    fragmentShaderShadingRateInterlock: fragmentShaderShadingRateInterlock,
  )

proc newVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceSeparateDepthStencilLayoutsFeatures, pNext: pointer = nil, separateDepthStencilLayouts: VkBool32): VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures =
  result = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(
    sType: sType,
    pNext: pNext,
    separateDepthStencilLayouts: separateDepthStencilLayouts,
  )

proc newVkAttachmentReferenceStencilLayout*(sType: VkStructureType = VkStructureType.AttachmentReferenceStencilLayout, pNext: pointer = nil, stencilLayout: VkImageLayout): VkAttachmentReferenceStencilLayout =
  result = VkAttachmentReferenceStencilLayout(
    sType: sType,
    pNext: pNext,
    stencilLayout: stencilLayout,
  )

proc newVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, pNext: pointer = nil, primitiveTopologyListRestart: VkBool32, primitiveTopologyPatchListRestart: VkBool32): VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT =
  result = VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(
    sType: sType,
    pNext: pNext,
    primitiveTopologyListRestart: primitiveTopologyListRestart,
    primitiveTopologyPatchListRestart: primitiveTopologyPatchListRestart,
  )

proc newVkAttachmentDescriptionStencilLayout*(sType: VkStructureType = VkStructureType.AttachmentDescriptionStencilLayout, pNext: pointer = nil, stencilInitialLayout: VkImageLayout, stencilFinalLayout: VkImageLayout): VkAttachmentDescriptionStencilLayout =
  result = VkAttachmentDescriptionStencilLayout(
    sType: sType,
    pNext: pNext,
    stencilInitialLayout: stencilInitialLayout,
    stencilFinalLayout: stencilFinalLayout,
  )

proc newVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineExecutablePropertiesFeaturesKHR, pNext: pointer = nil, pipelineExecutableInfo: VkBool32): VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR =
  result = VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
    sType: sType,
    pNext: pNext,
    pipelineExecutableInfo: pipelineExecutableInfo,
  )

proc newVkPipelineInfoKHR*(sType: VkStructureType = VkStructureType.PipelineInfoKHR, pNext: pointer = nil, pipeline: VkPipeline): VkPipelineInfoKHR =
  result = VkPipelineInfoKHR(
    sType: sType,
    pNext: pNext,
    pipeline: pipeline,
  )

proc newVkPipelineExecutablePropertiesKHR*(sType: VkStructureType = VkStructureType.PipelineExecutablePropertiesKHR, pNext: pointer = nil, stages: VkShaderStageFlags, name: array[VK_MAX_DESCRIPTION_SIZE, char], description: array[VK_MAX_DESCRIPTION_SIZE, char], subgroupSize: uint32): VkPipelineExecutablePropertiesKHR =
  result = VkPipelineExecutablePropertiesKHR(
    sType: sType,
    pNext: pNext,
    stages: stages,
    name: name,
    description: description,
    subgroupSize: subgroupSize,
  )

proc newVkPipelineExecutableInfoKHR*(sType: VkStructureType = VkStructureType.PipelineExecutableInfoKHR, pNext: pointer = nil, pipeline: VkPipeline, executableIndex: uint32): VkPipelineExecutableInfoKHR =
  result = VkPipelineExecutableInfoKHR(
    sType: sType,
    pNext: pNext,
    pipeline: pipeline,
    executableIndex: executableIndex,
  )

proc newVkPipelineExecutableStatisticKHR*(sType: VkStructureType = VkStructureType.PipelineExecutableStatisticKHR, pNext: pointer = nil, name: array[VK_MAX_DESCRIPTION_SIZE, char], description: array[VK_MAX_DESCRIPTION_SIZE, char], format: VkPipelineExecutableStatisticFormatKHR, value: VkPipelineExecutableStatisticValueKHR): VkPipelineExecutableStatisticKHR =
  result = VkPipelineExecutableStatisticKHR(
    sType: sType,
    pNext: pNext,
    name: name,
    description: description,
    format: format,
    value: value,
  )

proc newVkPipelineExecutableInternalRepresentationKHR*(sType: VkStructureType = VkStructureType.PipelineExecutableInternalRepresentationKHR, pNext: pointer = nil, name: array[VK_MAX_DESCRIPTION_SIZE, char], description: array[VK_MAX_DESCRIPTION_SIZE, char], isText: VkBool32, dataSize: uint, pData: pointer = nil): VkPipelineExecutableInternalRepresentationKHR =
  result = VkPipelineExecutableInternalRepresentationKHR(
    sType: sType,
    pNext: pNext,
    name: name,
    description: description,
    isText: isText,
    dataSize: dataSize,
    pData: pData,
  )

proc newVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderDemoteToHelperInvocationFeatures, pNext: pointer = nil, shaderDemoteToHelperInvocation: VkBool32): VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures =
  result = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(
    sType: sType,
    pNext: pNext,
    shaderDemoteToHelperInvocation: shaderDemoteToHelperInvocation,
  )

proc newVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceTexelBufferAlignmentFeaturesEXT, pNext: pointer = nil, texelBufferAlignment: VkBool32): VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT =
  result = VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(
    sType: sType,
    pNext: pNext,
    texelBufferAlignment: texelBufferAlignment,
  )

proc newVkPhysicalDeviceTexelBufferAlignmentProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceTexelBufferAlignmentProperties, pNext: pointer = nil, storageTexelBufferOffsetAlignmentBytes: VkDeviceSize, storageTexelBufferOffsetSingleTexelAlignment: VkBool32, uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize, uniformTexelBufferOffsetSingleTexelAlignment: VkBool32): VkPhysicalDeviceTexelBufferAlignmentProperties =
  result = VkPhysicalDeviceTexelBufferAlignmentProperties(
    sType: sType,
    pNext: pNext,
    storageTexelBufferOffsetAlignmentBytes: storageTexelBufferOffsetAlignmentBytes,
    storageTexelBufferOffsetSingleTexelAlignment: storageTexelBufferOffsetSingleTexelAlignment,
    uniformTexelBufferOffsetAlignmentBytes: uniformTexelBufferOffsetAlignmentBytes,
    uniformTexelBufferOffsetSingleTexelAlignment: uniformTexelBufferOffsetSingleTexelAlignment,
  )

proc newVkPhysicalDeviceSubgroupSizeControlFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceSubgroupSizeControlFeatures, pNext: pointer = nil, subgroupSizeControl: VkBool32, computeFullSubgroups: VkBool32): VkPhysicalDeviceSubgroupSizeControlFeatures =
  result = VkPhysicalDeviceSubgroupSizeControlFeatures(
    sType: sType,
    pNext: pNext,
    subgroupSizeControl: subgroupSizeControl,
    computeFullSubgroups: computeFullSubgroups,
  )

proc newVkPhysicalDeviceSubgroupSizeControlProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceSubgroupSizeControlProperties, pNext: pointer = nil, minSubgroupSize: uint32, maxSubgroupSize: uint32, maxComputeWorkgroupSubgroups: uint32, requiredSubgroupSizeStages: VkShaderStageFlags): VkPhysicalDeviceSubgroupSizeControlProperties =
  result = VkPhysicalDeviceSubgroupSizeControlProperties(
    sType: sType,
    pNext: pNext,
    minSubgroupSize: minSubgroupSize,
    maxSubgroupSize: maxSubgroupSize,
    maxComputeWorkgroupSubgroups: maxComputeWorkgroupSubgroups,
    requiredSubgroupSizeStages: requiredSubgroupSizeStages,
  )

proc newVkPipelineShaderStageRequiredSubgroupSizeCreateInfo*(sType: VkStructureType = VkStructureType.PipelineShaderStageRequiredSubgroupSizeCreateInfo, pNext: pointer = nil, requiredSubgroupSize: uint32): VkPipelineShaderStageRequiredSubgroupSizeCreateInfo =
  result = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(
    sType: sType,
    pNext: pNext,
    requiredSubgroupSize: requiredSubgroupSize,
  )

proc newVkSubpassShadingPipelineCreateInfoHUAWEI*(sType: VkStructureType = VkStructureType.SubpassShadingPipelineCreateInfoHUAWEI, pNext: pointer = nil, renderPass: VkRenderPass, subpass: uint32): VkSubpassShadingPipelineCreateInfoHUAWEI =
  result = VkSubpassShadingPipelineCreateInfoHUAWEI(
    sType: sType,
    pNext: pNext,
    renderPass: renderPass,
    subpass: subpass,
  )

proc newVkPhysicalDeviceSubpassShadingPropertiesHUAWEI*(sType: VkStructureType = VkStructureType.PhysicalDeviceSubpassShadingPropertiesHUAWEI, pNext: pointer = nil, maxSubpassShadingWorkgroupSizeAspectRatio: uint32): VkPhysicalDeviceSubpassShadingPropertiesHUAWEI =
  result = VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(
    sType: sType,
    pNext: pNext,
    maxSubpassShadingWorkgroupSizeAspectRatio: maxSubpassShadingWorkgroupSizeAspectRatio,
  )

proc newVkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*(sType: VkStructureType = VkStructureType.PhysicalDeviceClusterCullingShaderPropertiesHUAWEI, pNext: pointer = nil, maxWorkGroupCount: array[3, uint32], maxWorkGroupSize: array[3, uint32], maxOutputClusterCount: uint32, indirectBufferOffsetAlignment: VkDeviceSize): VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI =
  result = VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(
    sType: sType,
    pNext: pNext,
    maxWorkGroupCount: maxWorkGroupCount,
    maxWorkGroupSize: maxWorkGroupSize,
    maxOutputClusterCount: maxOutputClusterCount,
    indirectBufferOffsetAlignment: indirectBufferOffsetAlignment,
  )

proc newVkMemoryOpaqueCaptureAddressAllocateInfo*(sType: VkStructureType = VkStructureType.MemoryOpaqueCaptureAddressAllocateInfo, pNext: pointer = nil, opaqueCaptureAddress: uint64): VkMemoryOpaqueCaptureAddressAllocateInfo =
  result = VkMemoryOpaqueCaptureAddressAllocateInfo(
    sType: sType,
    pNext: pNext,
    opaqueCaptureAddress: opaqueCaptureAddress,
  )

proc newVkDeviceMemoryOpaqueCaptureAddressInfo*(sType: VkStructureType = VkStructureType.DeviceMemoryOpaqueCaptureAddressInfo, pNext: pointer = nil, memory: VkDeviceMemory): VkDeviceMemoryOpaqueCaptureAddressInfo =
  result = VkDeviceMemoryOpaqueCaptureAddressInfo(
    sType: sType,
    pNext: pNext,
    memory: memory,
  )

proc newVkPhysicalDeviceLineRasterizationFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceLineRasterizationFeatures, pNext: pointer = nil, rectangularLines: VkBool32, bresenhamLines: VkBool32, smoothLines: VkBool32, stippledRectangularLines: VkBool32, stippledBresenhamLines: VkBool32, stippledSmoothLines: VkBool32): VkPhysicalDeviceLineRasterizationFeatures =
  result = VkPhysicalDeviceLineRasterizationFeatures(
    sType: sType,
    pNext: pNext,
    rectangularLines: rectangularLines,
    bresenhamLines: bresenhamLines,
    smoothLines: smoothLines,
    stippledRectangularLines: stippledRectangularLines,
    stippledBresenhamLines: stippledBresenhamLines,
    stippledSmoothLines: stippledSmoothLines,
  )

proc newVkPhysicalDeviceLineRasterizationProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceLineRasterizationProperties, pNext: pointer = nil, lineSubPixelPrecisionBits: uint32): VkPhysicalDeviceLineRasterizationProperties =
  result = VkPhysicalDeviceLineRasterizationProperties(
    sType: sType,
    pNext: pNext,
    lineSubPixelPrecisionBits: lineSubPixelPrecisionBits,
  )

proc newVkPipelineRasterizationLineStateCreateInfo*(sType: VkStructureType = VkStructureType.PipelineRasterizationLineStateCreateInfo, pNext: pointer = nil, lineRasterizationMode: VkLineRasterizationMode, stippledLineEnable: VkBool32, lineStippleFactor: uint32, lineStipplePattern: uint16): VkPipelineRasterizationLineStateCreateInfo =
  result = VkPipelineRasterizationLineStateCreateInfo(
    sType: sType,
    pNext: pNext,
    lineRasterizationMode: lineRasterizationMode,
    stippledLineEnable: stippledLineEnable,
    lineStippleFactor: lineStippleFactor,
    lineStipplePattern: lineStipplePattern,
  )

proc newVkPhysicalDevicePipelineCreationCacheControlFeatures*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineCreationCacheControlFeatures, pNext: pointer = nil, pipelineCreationCacheControl: VkBool32): VkPhysicalDevicePipelineCreationCacheControlFeatures =
  result = VkPhysicalDevicePipelineCreationCacheControlFeatures(
    sType: sType,
    pNext: pNext,
    pipelineCreationCacheControl: pipelineCreationCacheControl,
  )

proc newVkPhysicalDeviceVulkan11Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkan11Features, pNext: pointer = nil, storageBuffer16BitAccess: VkBool32, uniformAndStorageBuffer16BitAccess: VkBool32, storagePushConstant16: VkBool32, storageInputOutput16: VkBool32, multiview: VkBool32, multiviewGeometryShader: VkBool32, multiviewTessellationShader: VkBool32, variablePointersStorageBuffer: VkBool32, variablePointers: VkBool32, protectedMemory: VkBool32, samplerYcbcrConversion: VkBool32, shaderDrawParameters: VkBool32): VkPhysicalDeviceVulkan11Features =
  result = VkPhysicalDeviceVulkan11Features(
    sType: sType,
    pNext: pNext,
    storageBuffer16BitAccess: storageBuffer16BitAccess,
    uniformAndStorageBuffer16BitAccess: uniformAndStorageBuffer16BitAccess,
    storagePushConstant16: storagePushConstant16,
    storageInputOutput16: storageInputOutput16,
    multiview: multiview,
    multiviewGeometryShader: multiviewGeometryShader,
    multiviewTessellationShader: multiviewTessellationShader,
    variablePointersStorageBuffer: variablePointersStorageBuffer,
    variablePointers: variablePointers,
    protectedMemory: protectedMemory,
    samplerYcbcrConversion: samplerYcbcrConversion,
    shaderDrawParameters: shaderDrawParameters,
  )

proc newVkPhysicalDeviceVulkan11Properties*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkan11Properties, pNext: pointer = nil, deviceUUID: array[VK_UUID_SIZE, uint8], driverUUID: array[VK_UUID_SIZE, uint8], deviceLUID: array[VK_LUID_SIZE, uint8], deviceNodeMask: uint32, deviceLUIDValid: VkBool32, subgroupSize: uint32, subgroupSupportedStages: VkShaderStageFlags, subgroupSupportedOperations: VkSubgroupFeatureFlags, subgroupQuadOperationsInAllStages: VkBool32, pointClippingBehavior: VkPointClippingBehavior, maxMultiviewViewCount: uint32, maxMultiviewInstanceIndex: uint32, protectedNoFault: VkBool32, maxPerSetDescriptors: uint32, maxMemoryAllocationSize: VkDeviceSize): VkPhysicalDeviceVulkan11Properties =
  result = VkPhysicalDeviceVulkan11Properties(
    sType: sType,
    pNext: pNext,
    deviceUUID: deviceUUID,
    driverUUID: driverUUID,
    deviceLUID: deviceLUID,
    deviceNodeMask: deviceNodeMask,
    deviceLUIDValid: deviceLUIDValid,
    subgroupSize: subgroupSize,
    subgroupSupportedStages: subgroupSupportedStages,
    subgroupSupportedOperations: subgroupSupportedOperations,
    subgroupQuadOperationsInAllStages: subgroupQuadOperationsInAllStages,
    pointClippingBehavior: pointClippingBehavior,
    maxMultiviewViewCount: maxMultiviewViewCount,
    maxMultiviewInstanceIndex: maxMultiviewInstanceIndex,
    protectedNoFault: protectedNoFault,
    maxPerSetDescriptors: maxPerSetDescriptors,
    maxMemoryAllocationSize: maxMemoryAllocationSize,
  )

proc newVkPhysicalDeviceVulkan12Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkan12Features, pNext: pointer = nil, samplerMirrorClampToEdge: VkBool32, drawIndirectCount: VkBool32, storageBuffer8BitAccess: VkBool32, uniformAndStorageBuffer8BitAccess: VkBool32, storagePushConstant8: VkBool32, shaderBufferInt64Atomics: VkBool32, shaderSharedInt64Atomics: VkBool32, shaderFloat16: VkBool32, shaderInt8: VkBool32, descriptorIndexing: VkBool32, shaderInputAttachmentArrayDynamicIndexing: VkBool32, shaderUniformTexelBufferArrayDynamicIndexing: VkBool32, shaderStorageTexelBufferArrayDynamicIndexing: VkBool32, shaderUniformBufferArrayNonUniformIndexing: VkBool32, shaderSampledImageArrayNonUniformIndexing: VkBool32, shaderStorageBufferArrayNonUniformIndexing: VkBool32, shaderStorageImageArrayNonUniformIndexing: VkBool32, shaderInputAttachmentArrayNonUniformIndexing: VkBool32, shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32, shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32, descriptorBindingUniformBufferUpdateAfterBind: VkBool32, descriptorBindingSampledImageUpdateAfterBind: VkBool32, descriptorBindingStorageImageUpdateAfterBind: VkBool32, descriptorBindingStorageBufferUpdateAfterBind: VkBool32, descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32, descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32, descriptorBindingUpdateUnusedWhilePending: VkBool32, descriptorBindingPartiallyBound: VkBool32, descriptorBindingVariableDescriptorCount: VkBool32, runtimeDescriptorArray: VkBool32, samplerFilterMinmax: VkBool32, scalarBlockLayout: VkBool32, imagelessFramebuffer: VkBool32, uniformBufferStandardLayout: VkBool32, shaderSubgroupExtendedTypes: VkBool32, separateDepthStencilLayouts: VkBool32, hostQueryReset: VkBool32, timelineSemaphore: VkBool32, bufferDeviceAddress: VkBool32, bufferDeviceAddressCaptureReplay: VkBool32, bufferDeviceAddressMultiDevice: VkBool32, vulkanMemoryModel: VkBool32, vulkanMemoryModelDeviceScope: VkBool32, vulkanMemoryModelAvailabilityVisibilityChains: VkBool32, shaderOutputViewportIndex: VkBool32, shaderOutputLayer: VkBool32, subgroupBroadcastDynamicId: VkBool32): VkPhysicalDeviceVulkan12Features =
  result = VkPhysicalDeviceVulkan12Features(
    sType: sType,
    pNext: pNext,
    samplerMirrorClampToEdge: samplerMirrorClampToEdge,
    drawIndirectCount: drawIndirectCount,
    storageBuffer8BitAccess: storageBuffer8BitAccess,
    uniformAndStorageBuffer8BitAccess: uniformAndStorageBuffer8BitAccess,
    storagePushConstant8: storagePushConstant8,
    shaderBufferInt64Atomics: shaderBufferInt64Atomics,
    shaderSharedInt64Atomics: shaderSharedInt64Atomics,
    shaderFloat16: shaderFloat16,
    shaderInt8: shaderInt8,
    descriptorIndexing: descriptorIndexing,
    shaderInputAttachmentArrayDynamicIndexing: shaderInputAttachmentArrayDynamicIndexing,
    shaderUniformTexelBufferArrayDynamicIndexing: shaderUniformTexelBufferArrayDynamicIndexing,
    shaderStorageTexelBufferArrayDynamicIndexing: shaderStorageTexelBufferArrayDynamicIndexing,
    shaderUniformBufferArrayNonUniformIndexing: shaderUniformBufferArrayNonUniformIndexing,
    shaderSampledImageArrayNonUniformIndexing: shaderSampledImageArrayNonUniformIndexing,
    shaderStorageBufferArrayNonUniformIndexing: shaderStorageBufferArrayNonUniformIndexing,
    shaderStorageImageArrayNonUniformIndexing: shaderStorageImageArrayNonUniformIndexing,
    shaderInputAttachmentArrayNonUniformIndexing: shaderInputAttachmentArrayNonUniformIndexing,
    shaderUniformTexelBufferArrayNonUniformIndexing: shaderUniformTexelBufferArrayNonUniformIndexing,
    shaderStorageTexelBufferArrayNonUniformIndexing: shaderStorageTexelBufferArrayNonUniformIndexing,
    descriptorBindingUniformBufferUpdateAfterBind: descriptorBindingUniformBufferUpdateAfterBind,
    descriptorBindingSampledImageUpdateAfterBind: descriptorBindingSampledImageUpdateAfterBind,
    descriptorBindingStorageImageUpdateAfterBind: descriptorBindingStorageImageUpdateAfterBind,
    descriptorBindingStorageBufferUpdateAfterBind: descriptorBindingStorageBufferUpdateAfterBind,
    descriptorBindingUniformTexelBufferUpdateAfterBind: descriptorBindingUniformTexelBufferUpdateAfterBind,
    descriptorBindingStorageTexelBufferUpdateAfterBind: descriptorBindingStorageTexelBufferUpdateAfterBind,
    descriptorBindingUpdateUnusedWhilePending: descriptorBindingUpdateUnusedWhilePending,
    descriptorBindingPartiallyBound: descriptorBindingPartiallyBound,
    descriptorBindingVariableDescriptorCount: descriptorBindingVariableDescriptorCount,
    runtimeDescriptorArray: runtimeDescriptorArray,
    samplerFilterMinmax: samplerFilterMinmax,
    scalarBlockLayout: scalarBlockLayout,
    imagelessFramebuffer: imagelessFramebuffer,
    uniformBufferStandardLayout: uniformBufferStandardLayout,
    shaderSubgroupExtendedTypes: shaderSubgroupExtendedTypes,
    separateDepthStencilLayouts: separateDepthStencilLayouts,
    hostQueryReset: hostQueryReset,
    timelineSemaphore: timelineSemaphore,
    bufferDeviceAddress: bufferDeviceAddress,
    bufferDeviceAddressCaptureReplay: bufferDeviceAddressCaptureReplay,
    bufferDeviceAddressMultiDevice: bufferDeviceAddressMultiDevice,
    vulkanMemoryModel: vulkanMemoryModel,
    vulkanMemoryModelDeviceScope: vulkanMemoryModelDeviceScope,
    vulkanMemoryModelAvailabilityVisibilityChains: vulkanMemoryModelAvailabilityVisibilityChains,
    shaderOutputViewportIndex: shaderOutputViewportIndex,
    shaderOutputLayer: shaderOutputLayer,
    subgroupBroadcastDynamicId: subgroupBroadcastDynamicId,
  )

proc newVkPhysicalDeviceVulkan12Properties*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkan12Properties, pNext: pointer = nil, driverID: VkDriverId, driverName: array[VK_MAX_DRIVER_NAME_SIZE, char], driverInfo: array[VK_MAX_DRIVER_INFO_SIZE, char], conformanceVersion: VkConformanceVersion, denormBehaviorIndependence: VkShaderFloatControlsIndependence, roundingModeIndependence: VkShaderFloatControlsIndependence, shaderSignedZeroInfNanPreserveFloat16: VkBool32, shaderSignedZeroInfNanPreserveFloat32: VkBool32, shaderSignedZeroInfNanPreserveFloat64: VkBool32, shaderDenormPreserveFloat16: VkBool32, shaderDenormPreserveFloat32: VkBool32, shaderDenormPreserveFloat64: VkBool32, shaderDenormFlushToZeroFloat16: VkBool32, shaderDenormFlushToZeroFloat32: VkBool32, shaderDenormFlushToZeroFloat64: VkBool32, shaderRoundingModeRTEFloat16: VkBool32, shaderRoundingModeRTEFloat32: VkBool32, shaderRoundingModeRTEFloat64: VkBool32, shaderRoundingModeRTZFloat16: VkBool32, shaderRoundingModeRTZFloat32: VkBool32, shaderRoundingModeRTZFloat64: VkBool32, maxUpdateAfterBindDescriptorsInAllPools: uint32, shaderUniformBufferArrayNonUniformIndexingNative: VkBool32, shaderSampledImageArrayNonUniformIndexingNative: VkBool32, shaderStorageBufferArrayNonUniformIndexingNative: VkBool32, shaderStorageImageArrayNonUniformIndexingNative: VkBool32, shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32, robustBufferAccessUpdateAfterBind: VkBool32, quadDivergentImplicitLod: VkBool32, maxPerStageDescriptorUpdateAfterBindSamplers: uint32, maxPerStageDescriptorUpdateAfterBindUniformBuffers: uint32, maxPerStageDescriptorUpdateAfterBindStorageBuffers: uint32, maxPerStageDescriptorUpdateAfterBindSampledImages: uint32, maxPerStageDescriptorUpdateAfterBindStorageImages: uint32, maxPerStageDescriptorUpdateAfterBindInputAttachments: uint32, maxPerStageUpdateAfterBindResources: uint32, maxDescriptorSetUpdateAfterBindSamplers: uint32, maxDescriptorSetUpdateAfterBindUniformBuffers: uint32, maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: uint32, maxDescriptorSetUpdateAfterBindStorageBuffers: uint32, maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: uint32, maxDescriptorSetUpdateAfterBindSampledImages: uint32, maxDescriptorSetUpdateAfterBindStorageImages: uint32, maxDescriptorSetUpdateAfterBindInputAttachments: uint32, supportedDepthResolveModes: VkResolveModeFlags, supportedStencilResolveModes: VkResolveModeFlags, independentResolveNone: VkBool32, independentResolve: VkBool32, filterMinmaxSingleComponentFormats: VkBool32, filterMinmaxImageComponentMapping: VkBool32, maxTimelineSemaphoreValueDifference: uint64, framebufferIntegerColorSampleCounts: VkSampleCountFlags): VkPhysicalDeviceVulkan12Properties =
  result = VkPhysicalDeviceVulkan12Properties(
    sType: sType,
    pNext: pNext,
    driverID: driverID,
    driverName: driverName,
    driverInfo: driverInfo,
    conformanceVersion: conformanceVersion,
    denormBehaviorIndependence: denormBehaviorIndependence,
    roundingModeIndependence: roundingModeIndependence,
    shaderSignedZeroInfNanPreserveFloat16: shaderSignedZeroInfNanPreserveFloat16,
    shaderSignedZeroInfNanPreserveFloat32: shaderSignedZeroInfNanPreserveFloat32,
    shaderSignedZeroInfNanPreserveFloat64: shaderSignedZeroInfNanPreserveFloat64,
    shaderDenormPreserveFloat16: shaderDenormPreserveFloat16,
    shaderDenormPreserveFloat32: shaderDenormPreserveFloat32,
    shaderDenormPreserveFloat64: shaderDenormPreserveFloat64,
    shaderDenormFlushToZeroFloat16: shaderDenormFlushToZeroFloat16,
    shaderDenormFlushToZeroFloat32: shaderDenormFlushToZeroFloat32,
    shaderDenormFlushToZeroFloat64: shaderDenormFlushToZeroFloat64,
    shaderRoundingModeRTEFloat16: shaderRoundingModeRTEFloat16,
    shaderRoundingModeRTEFloat32: shaderRoundingModeRTEFloat32,
    shaderRoundingModeRTEFloat64: shaderRoundingModeRTEFloat64,
    shaderRoundingModeRTZFloat16: shaderRoundingModeRTZFloat16,
    shaderRoundingModeRTZFloat32: shaderRoundingModeRTZFloat32,
    shaderRoundingModeRTZFloat64: shaderRoundingModeRTZFloat64,
    maxUpdateAfterBindDescriptorsInAllPools: maxUpdateAfterBindDescriptorsInAllPools,
    shaderUniformBufferArrayNonUniformIndexingNative: shaderUniformBufferArrayNonUniformIndexingNative,
    shaderSampledImageArrayNonUniformIndexingNative: shaderSampledImageArrayNonUniformIndexingNative,
    shaderStorageBufferArrayNonUniformIndexingNative: shaderStorageBufferArrayNonUniformIndexingNative,
    shaderStorageImageArrayNonUniformIndexingNative: shaderStorageImageArrayNonUniformIndexingNative,
    shaderInputAttachmentArrayNonUniformIndexingNative: shaderInputAttachmentArrayNonUniformIndexingNative,
    robustBufferAccessUpdateAfterBind: robustBufferAccessUpdateAfterBind,
    quadDivergentImplicitLod: quadDivergentImplicitLod,
    maxPerStageDescriptorUpdateAfterBindSamplers: maxPerStageDescriptorUpdateAfterBindSamplers,
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: maxPerStageDescriptorUpdateAfterBindUniformBuffers,
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: maxPerStageDescriptorUpdateAfterBindStorageBuffers,
    maxPerStageDescriptorUpdateAfterBindSampledImages: maxPerStageDescriptorUpdateAfterBindSampledImages,
    maxPerStageDescriptorUpdateAfterBindStorageImages: maxPerStageDescriptorUpdateAfterBindStorageImages,
    maxPerStageDescriptorUpdateAfterBindInputAttachments: maxPerStageDescriptorUpdateAfterBindInputAttachments,
    maxPerStageUpdateAfterBindResources: maxPerStageUpdateAfterBindResources,
    maxDescriptorSetUpdateAfterBindSamplers: maxDescriptorSetUpdateAfterBindSamplers,
    maxDescriptorSetUpdateAfterBindUniformBuffers: maxDescriptorSetUpdateAfterBindUniformBuffers,
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: maxDescriptorSetUpdateAfterBindUniformBuffersDynamic,
    maxDescriptorSetUpdateAfterBindStorageBuffers: maxDescriptorSetUpdateAfterBindStorageBuffers,
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: maxDescriptorSetUpdateAfterBindStorageBuffersDynamic,
    maxDescriptorSetUpdateAfterBindSampledImages: maxDescriptorSetUpdateAfterBindSampledImages,
    maxDescriptorSetUpdateAfterBindStorageImages: maxDescriptorSetUpdateAfterBindStorageImages,
    maxDescriptorSetUpdateAfterBindInputAttachments: maxDescriptorSetUpdateAfterBindInputAttachments,
    supportedDepthResolveModes: supportedDepthResolveModes,
    supportedStencilResolveModes: supportedStencilResolveModes,
    independentResolveNone: independentResolveNone,
    independentResolve: independentResolve,
    filterMinmaxSingleComponentFormats: filterMinmaxSingleComponentFormats,
    filterMinmaxImageComponentMapping: filterMinmaxImageComponentMapping,
    maxTimelineSemaphoreValueDifference: maxTimelineSemaphoreValueDifference,
    framebufferIntegerColorSampleCounts: framebufferIntegerColorSampleCounts,
  )

proc newVkPhysicalDeviceVulkan13Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkan13Features, pNext: pointer = nil, robustImageAccess: VkBool32, inlineUniformBlock: VkBool32, descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32, pipelineCreationCacheControl: VkBool32, privateData: VkBool32, shaderDemoteToHelperInvocation: VkBool32, shaderTerminateInvocation: VkBool32, subgroupSizeControl: VkBool32, computeFullSubgroups: VkBool32, synchronization2: VkBool32, textureCompressionASTC_HDR: VkBool32, shaderZeroInitializeWorkgroupMemory: VkBool32, dynamicRendering: VkBool32, shaderIntegerDotProduct: VkBool32, maintenance4: VkBool32): VkPhysicalDeviceVulkan13Features =
  result = VkPhysicalDeviceVulkan13Features(
    sType: sType,
    pNext: pNext,
    robustImageAccess: robustImageAccess,
    inlineUniformBlock: inlineUniformBlock,
    descriptorBindingInlineUniformBlockUpdateAfterBind: descriptorBindingInlineUniformBlockUpdateAfterBind,
    pipelineCreationCacheControl: pipelineCreationCacheControl,
    privateData: privateData,
    shaderDemoteToHelperInvocation: shaderDemoteToHelperInvocation,
    shaderTerminateInvocation: shaderTerminateInvocation,
    subgroupSizeControl: subgroupSizeControl,
    computeFullSubgroups: computeFullSubgroups,
    synchronization2: synchronization2,
    textureCompressionASTC_HDR: textureCompressionASTC_HDR,
    shaderZeroInitializeWorkgroupMemory: shaderZeroInitializeWorkgroupMemory,
    dynamicRendering: dynamicRendering,
    shaderIntegerDotProduct: shaderIntegerDotProduct,
    maintenance4: maintenance4,
  )

proc newVkPhysicalDeviceVulkan13Properties*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkan13Properties, pNext: pointer = nil, minSubgroupSize: uint32, maxSubgroupSize: uint32, maxComputeWorkgroupSubgroups: uint32, requiredSubgroupSizeStages: VkShaderStageFlags, maxInlineUniformBlockSize: uint32, maxPerStageDescriptorInlineUniformBlocks: uint32, maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: uint32, maxDescriptorSetInlineUniformBlocks: uint32, maxDescriptorSetUpdateAfterBindInlineUniformBlocks: uint32, maxInlineUniformTotalSize: uint32, integerDotProduct8BitUnsignedAccelerated: VkBool32, integerDotProduct8BitSignedAccelerated: VkBool32, integerDotProduct8BitMixedSignednessAccelerated: VkBool32, integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32, integerDotProduct4x8BitPackedSignedAccelerated: VkBool32, integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32, integerDotProduct16BitUnsignedAccelerated: VkBool32, integerDotProduct16BitSignedAccelerated: VkBool32, integerDotProduct16BitMixedSignednessAccelerated: VkBool32, integerDotProduct32BitUnsignedAccelerated: VkBool32, integerDotProduct32BitSignedAccelerated: VkBool32, integerDotProduct32BitMixedSignednessAccelerated: VkBool32, integerDotProduct64BitUnsignedAccelerated: VkBool32, integerDotProduct64BitSignedAccelerated: VkBool32, integerDotProduct64BitMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32, storageTexelBufferOffsetAlignmentBytes: VkDeviceSize, storageTexelBufferOffsetSingleTexelAlignment: VkBool32, uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize, uniformTexelBufferOffsetSingleTexelAlignment: VkBool32, maxBufferSize: VkDeviceSize): VkPhysicalDeviceVulkan13Properties =
  result = VkPhysicalDeviceVulkan13Properties(
    sType: sType,
    pNext: pNext,
    minSubgroupSize: minSubgroupSize,
    maxSubgroupSize: maxSubgroupSize,
    maxComputeWorkgroupSubgroups: maxComputeWorkgroupSubgroups,
    requiredSubgroupSizeStages: requiredSubgroupSizeStages,
    maxInlineUniformBlockSize: maxInlineUniformBlockSize,
    maxPerStageDescriptorInlineUniformBlocks: maxPerStageDescriptorInlineUniformBlocks,
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks,
    maxDescriptorSetInlineUniformBlocks: maxDescriptorSetInlineUniformBlocks,
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: maxDescriptorSetUpdateAfterBindInlineUniformBlocks,
    maxInlineUniformTotalSize: maxInlineUniformTotalSize,
    integerDotProduct8BitUnsignedAccelerated: integerDotProduct8BitUnsignedAccelerated,
    integerDotProduct8BitSignedAccelerated: integerDotProduct8BitSignedAccelerated,
    integerDotProduct8BitMixedSignednessAccelerated: integerDotProduct8BitMixedSignednessAccelerated,
    integerDotProduct4x8BitPackedUnsignedAccelerated: integerDotProduct4x8BitPackedUnsignedAccelerated,
    integerDotProduct4x8BitPackedSignedAccelerated: integerDotProduct4x8BitPackedSignedAccelerated,
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: integerDotProduct4x8BitPackedMixedSignednessAccelerated,
    integerDotProduct16BitUnsignedAccelerated: integerDotProduct16BitUnsignedAccelerated,
    integerDotProduct16BitSignedAccelerated: integerDotProduct16BitSignedAccelerated,
    integerDotProduct16BitMixedSignednessAccelerated: integerDotProduct16BitMixedSignednessAccelerated,
    integerDotProduct32BitUnsignedAccelerated: integerDotProduct32BitUnsignedAccelerated,
    integerDotProduct32BitSignedAccelerated: integerDotProduct32BitSignedAccelerated,
    integerDotProduct32BitMixedSignednessAccelerated: integerDotProduct32BitMixedSignednessAccelerated,
    integerDotProduct64BitUnsignedAccelerated: integerDotProduct64BitUnsignedAccelerated,
    integerDotProduct64BitSignedAccelerated: integerDotProduct64BitSignedAccelerated,
    integerDotProduct64BitMixedSignednessAccelerated: integerDotProduct64BitMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: integerDotProductAccumulatingSaturating8BitUnsignedAccelerated,
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: integerDotProductAccumulatingSaturating8BitSignedAccelerated,
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated,
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated,
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: integerDotProductAccumulatingSaturating16BitUnsignedAccelerated,
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: integerDotProductAccumulatingSaturating16BitSignedAccelerated,
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: integerDotProductAccumulatingSaturating32BitUnsignedAccelerated,
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: integerDotProductAccumulatingSaturating32BitSignedAccelerated,
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: integerDotProductAccumulatingSaturating64BitUnsignedAccelerated,
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: integerDotProductAccumulatingSaturating64BitSignedAccelerated,
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated,
    storageTexelBufferOffsetAlignmentBytes: storageTexelBufferOffsetAlignmentBytes,
    storageTexelBufferOffsetSingleTexelAlignment: storageTexelBufferOffsetSingleTexelAlignment,
    uniformTexelBufferOffsetAlignmentBytes: uniformTexelBufferOffsetAlignmentBytes,
    uniformTexelBufferOffsetSingleTexelAlignment: uniformTexelBufferOffsetSingleTexelAlignment,
    maxBufferSize: maxBufferSize,
  )

proc newVkPhysicalDeviceVulkan14Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkan14Features, pNext: pointer = nil, globalPriorityQuery: VkBool32, shaderSubgroupRotate: VkBool32, shaderSubgroupRotateClustered: VkBool32, shaderFloatControls2: VkBool32, shaderExpectAssume: VkBool32, rectangularLines: VkBool32, bresenhamLines: VkBool32, smoothLines: VkBool32, stippledRectangularLines: VkBool32, stippledBresenhamLines: VkBool32, stippledSmoothLines: VkBool32, vertexAttributeInstanceRateDivisor: VkBool32, vertexAttributeInstanceRateZeroDivisor: VkBool32, indexTypeUint8: VkBool32, dynamicRenderingLocalRead: VkBool32, maintenance5: VkBool32, maintenance6: VkBool32, pipelineProtectedAccess: VkBool32, pipelineRobustness: VkBool32, hostImageCopy: VkBool32, pushDescriptor: VkBool32): VkPhysicalDeviceVulkan14Features =
  result = VkPhysicalDeviceVulkan14Features(
    sType: sType,
    pNext: pNext,
    globalPriorityQuery: globalPriorityQuery,
    shaderSubgroupRotate: shaderSubgroupRotate,
    shaderSubgroupRotateClustered: shaderSubgroupRotateClustered,
    shaderFloatControls2: shaderFloatControls2,
    shaderExpectAssume: shaderExpectAssume,
    rectangularLines: rectangularLines,
    bresenhamLines: bresenhamLines,
    smoothLines: smoothLines,
    stippledRectangularLines: stippledRectangularLines,
    stippledBresenhamLines: stippledBresenhamLines,
    stippledSmoothLines: stippledSmoothLines,
    vertexAttributeInstanceRateDivisor: vertexAttributeInstanceRateDivisor,
    vertexAttributeInstanceRateZeroDivisor: vertexAttributeInstanceRateZeroDivisor,
    indexTypeUint8: indexTypeUint8,
    dynamicRenderingLocalRead: dynamicRenderingLocalRead,
    maintenance5: maintenance5,
    maintenance6: maintenance6,
    pipelineProtectedAccess: pipelineProtectedAccess,
    pipelineRobustness: pipelineRobustness,
    hostImageCopy: hostImageCopy,
    pushDescriptor: pushDescriptor,
  )

proc newVkPhysicalDeviceVulkan14Properties*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkan14Properties, pNext: pointer = nil, lineSubPixelPrecisionBits: uint32, maxVertexAttribDivisor: uint32, supportsNonZeroFirstInstance: VkBool32, maxPushDescriptors: uint32, dynamicRenderingLocalReadDepthStencilAttachments: VkBool32, dynamicRenderingLocalReadMultisampledAttachments: VkBool32, earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32, earlyFragmentSampleMaskTestBeforeSampleCounting: VkBool32, depthStencilSwizzleOneSupport: VkBool32, polygonModePointSize: VkBool32, nonStrictSinglePixelWideLinesUseParallelogram: VkBool32, nonStrictWideLinesUseParallelogram: VkBool32, blockTexelViewCompatibleMultipleLayers: VkBool32, maxCombinedImageSamplerDescriptorCount: uint32, fragmentShadingRateClampCombinerInputs: VkBool32, defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior, defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior, defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior, defaultRobustnessImages: VkPipelineRobustnessImageBehavior, copySrcLayouts: openarray[VkImageLayout], copyDstLayouts: openarray[VkImageLayout], optimalTilingLayoutUUID: array[VK_UUID_SIZE, uint8], identicalMemoryTypeRequirements: VkBool32): VkPhysicalDeviceVulkan14Properties =
  result = VkPhysicalDeviceVulkan14Properties(
    sType: sType,
    pNext: pNext,
    lineSubPixelPrecisionBits: lineSubPixelPrecisionBits,
    maxVertexAttribDivisor: maxVertexAttribDivisor,
    supportsNonZeroFirstInstance: supportsNonZeroFirstInstance,
    maxPushDescriptors: maxPushDescriptors,
    dynamicRenderingLocalReadDepthStencilAttachments: dynamicRenderingLocalReadDepthStencilAttachments,
    dynamicRenderingLocalReadMultisampledAttachments: dynamicRenderingLocalReadMultisampledAttachments,
    earlyFragmentMultisampleCoverageAfterSampleCounting: earlyFragmentMultisampleCoverageAfterSampleCounting,
    earlyFragmentSampleMaskTestBeforeSampleCounting: earlyFragmentSampleMaskTestBeforeSampleCounting,
    depthStencilSwizzleOneSupport: depthStencilSwizzleOneSupport,
    polygonModePointSize: polygonModePointSize,
    nonStrictSinglePixelWideLinesUseParallelogram: nonStrictSinglePixelWideLinesUseParallelogram,
    nonStrictWideLinesUseParallelogram: nonStrictWideLinesUseParallelogram,
    blockTexelViewCompatibleMultipleLayers: blockTexelViewCompatibleMultipleLayers,
    maxCombinedImageSamplerDescriptorCount: maxCombinedImageSamplerDescriptorCount,
    fragmentShadingRateClampCombinerInputs: fragmentShadingRateClampCombinerInputs,
    defaultRobustnessStorageBuffers: defaultRobustnessStorageBuffers,
    defaultRobustnessUniformBuffers: defaultRobustnessUniformBuffers,
    defaultRobustnessVertexInputs: defaultRobustnessVertexInputs,
    defaultRobustnessImages: defaultRobustnessImages,
    copySrcLayoutCount: len(copySrcLayouts).uint32,
    pCopySrcLayouts: if len(copySrcLayouts) == 0: nil else: cast[ptr VkImageLayout](copySrcLayouts),
    copyDstLayoutCount: len(copyDstLayouts).uint32,
    pCopyDstLayouts: if len(copyDstLayouts) == 0: nil else: cast[ptr VkImageLayout](copyDstLayouts),
    optimalTilingLayoutUUID: optimalTilingLayoutUUID,
    identicalMemoryTypeRequirements: identicalMemoryTypeRequirements,
  )

proc newVkPipelineCompilerControlCreateInfoAMD*(sType: VkStructureType = VkStructureType.PipelineCompilerControlCreateInfoAMD, pNext: pointer = nil, compilerControlFlags: VkPipelineCompilerControlFlagsAMD): VkPipelineCompilerControlCreateInfoAMD =
  result = VkPipelineCompilerControlCreateInfoAMD(
    sType: sType,
    pNext: pNext,
    compilerControlFlags: compilerControlFlags,
  )

proc newVkPhysicalDeviceCoherentMemoryFeaturesAMD*(sType: VkStructureType = VkStructureType.PhysicalDeviceCoherentMemoryFeaturesAMD, pNext: pointer = nil, deviceCoherentMemory: VkBool32): VkPhysicalDeviceCoherentMemoryFeaturesAMD =
  result = VkPhysicalDeviceCoherentMemoryFeaturesAMD(
    sType: sType,
    pNext: pNext,
    deviceCoherentMemory: deviceCoherentMemory,
  )

proc newVkFaultData*(sType: VkStructureType = VkStructureType.FaultData, pNext: pointer = nil, faultLevel: VkFaultLevel, faultType: VkFaultType): VkFaultData =
  result = VkFaultData(
    sType: sType,
    pNext: pNext,
    faultLevel: faultLevel,
    faultType: faultType,
  )

proc newVkFaultCallbackInfo*(sType: VkStructureType = VkStructureType.FaultCallbackInfo, pNext: pointer = nil, faults: openarray[VkFaultData], pfnFaultCallback: PFN_vkFaultCallbackFunction): VkFaultCallbackInfo =
  result = VkFaultCallbackInfo(
    sType: sType,
    pNext: pNext,
    faultCount: len(faults).uint32,
    pFaults: if len(faults) == 0: nil else: cast[ptr VkFaultData](faults),
    pfnFaultCallback: pfnFaultCallback,
  )

proc newVkPhysicalDeviceToolProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceToolProperties, pNext: pointer = nil, name: array[VK_MAX_EXTENSION_NAME_SIZE, char], version: array[VK_MAX_EXTENSION_NAME_SIZE, char], purposes: VkToolPurposeFlags, description: array[VK_MAX_DESCRIPTION_SIZE, char], layer: array[VK_MAX_EXTENSION_NAME_SIZE, char]): VkPhysicalDeviceToolProperties =
  result = VkPhysicalDeviceToolProperties(
    sType: sType,
    pNext: pNext,
    name: name,
    version: version,
    purposes: purposes,
    description: description,
    layer: layer,
  )

proc newVkSamplerCustomBorderColorCreateInfoEXT*(sType: VkStructureType = VkStructureType.SamplerCustomBorderColorCreateInfoEXT, pNext: pointer = nil, customBorderColor: VkClearColorValue, format: VkFormat): VkSamplerCustomBorderColorCreateInfoEXT =
  result = VkSamplerCustomBorderColorCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    customBorderColor: customBorderColor,
    format: format,
  )

proc newVkPhysicalDeviceCustomBorderColorPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceCustomBorderColorPropertiesEXT, pNext: pointer = nil, maxCustomBorderColorSamplers: uint32): VkPhysicalDeviceCustomBorderColorPropertiesEXT =
  result = VkPhysicalDeviceCustomBorderColorPropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxCustomBorderColorSamplers: maxCustomBorderColorSamplers,
  )

proc newVkPhysicalDeviceCustomBorderColorFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceCustomBorderColorFeaturesEXT, pNext: pointer = nil, customBorderColors: VkBool32, customBorderColorWithoutFormat: VkBool32): VkPhysicalDeviceCustomBorderColorFeaturesEXT =
  result = VkPhysicalDeviceCustomBorderColorFeaturesEXT(
    sType: sType,
    pNext: pNext,
    customBorderColors: customBorderColors,
    customBorderColorWithoutFormat: customBorderColorWithoutFormat,
  )

proc newVkSamplerBorderColorComponentMappingCreateInfoEXT*(sType: VkStructureType = VkStructureType.SamplerBorderColorComponentMappingCreateInfoEXT, pNext: pointer = nil, components: VkComponentMapping, srgb: VkBool32): VkSamplerBorderColorComponentMappingCreateInfoEXT =
  result = VkSamplerBorderColorComponentMappingCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    components: components,
    srgb: srgb,
  )

proc newVkPhysicalDeviceBorderColorSwizzleFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceBorderColorSwizzleFeaturesEXT, pNext: pointer = nil, borderColorSwizzle: VkBool32, borderColorSwizzleFromImage: VkBool32): VkPhysicalDeviceBorderColorSwizzleFeaturesEXT =
  result = VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(
    sType: sType,
    pNext: pNext,
    borderColorSwizzle: borderColorSwizzle,
    borderColorSwizzleFromImage: borderColorSwizzleFromImage,
  )

proc newVkAccelerationStructureGeometryTrianglesDataKHR*(sType: VkStructureType = VkStructureType.AccelerationStructureGeometryTrianglesDataKHR, pNext: pointer = nil, vertexFormat: VkFormat, vertexData: VkDeviceOrHostAddressConstKHR, vertexStride: VkDeviceSize, maxVertex: uint32, indexType: VkIndexType, indexData: VkDeviceOrHostAddressConstKHR, transformData: VkDeviceOrHostAddressConstKHR): VkAccelerationStructureGeometryTrianglesDataKHR =
  result = VkAccelerationStructureGeometryTrianglesDataKHR(
    sType: sType,
    pNext: pNext,
    vertexFormat: vertexFormat,
    vertexData: vertexData,
    vertexStride: vertexStride,
    maxVertex: maxVertex,
    indexType: indexType,
    indexData: indexData,
    transformData: transformData,
  )

proc newVkAccelerationStructureGeometryAabbsDataKHR*(sType: VkStructureType = VkStructureType.AccelerationStructureGeometryAabbsDataKHR, pNext: pointer = nil, data: VkDeviceOrHostAddressConstKHR, stride: VkDeviceSize): VkAccelerationStructureGeometryAabbsDataKHR =
  result = VkAccelerationStructureGeometryAabbsDataKHR(
    sType: sType,
    pNext: pNext,
    data: data,
    stride: stride,
  )

proc newVkAccelerationStructureGeometryInstancesDataKHR*(sType: VkStructureType = VkStructureType.AccelerationStructureGeometryInstancesDataKHR, pNext: pointer = nil, arrayOfPointers: VkBool32, data: VkDeviceOrHostAddressConstKHR): VkAccelerationStructureGeometryInstancesDataKHR =
  result = VkAccelerationStructureGeometryInstancesDataKHR(
    sType: sType,
    pNext: pNext,
    arrayOfPointers: arrayOfPointers,
    data: data,
  )

proc newVkAccelerationStructureGeometryLinearSweptSpheresDataNV*(sType: VkStructureType = VkStructureType.AccelerationStructureGeometryLinearSweptSpheresDataNV, pNext: pointer = nil, vertexFormat: VkFormat, vertexData: VkDeviceOrHostAddressConstKHR, vertexStride: VkDeviceSize, radiusFormat: VkFormat, radiusData: VkDeviceOrHostAddressConstKHR, radiusStride: VkDeviceSize, indexType: VkIndexType, indexData: VkDeviceOrHostAddressConstKHR, indexStride: VkDeviceSize, indexingMode: VkRayTracingLssIndexingModeNV, endCapsMode: VkRayTracingLssPrimitiveEndCapsModeNV): VkAccelerationStructureGeometryLinearSweptSpheresDataNV =
  result = VkAccelerationStructureGeometryLinearSweptSpheresDataNV(
    sType: sType,
    pNext: pNext,
    vertexFormat: vertexFormat,
    vertexData: vertexData,
    vertexStride: vertexStride,
    radiusFormat: radiusFormat,
    radiusData: radiusData,
    radiusStride: radiusStride,
    indexType: indexType,
    indexData: indexData,
    indexStride: indexStride,
    indexingMode: indexingMode,
    endCapsMode: endCapsMode,
  )

proc newVkAccelerationStructureGeometrySpheresDataNV*(sType: VkStructureType = VkStructureType.AccelerationStructureGeometrySpheresDataNV, pNext: pointer = nil, vertexFormat: VkFormat, vertexData: VkDeviceOrHostAddressConstKHR, vertexStride: VkDeviceSize, radiusFormat: VkFormat, radiusData: VkDeviceOrHostAddressConstKHR, radiusStride: VkDeviceSize, indexType: VkIndexType, indexData: VkDeviceOrHostAddressConstKHR, indexStride: VkDeviceSize): VkAccelerationStructureGeometrySpheresDataNV =
  result = VkAccelerationStructureGeometrySpheresDataNV(
    sType: sType,
    pNext: pNext,
    vertexFormat: vertexFormat,
    vertexData: vertexData,
    vertexStride: vertexStride,
    radiusFormat: radiusFormat,
    radiusData: radiusData,
    radiusStride: radiusStride,
    indexType: indexType,
    indexData: indexData,
    indexStride: indexStride,
  )

proc newVkAccelerationStructureGeometryKHR*(sType: VkStructureType = VkStructureType.AccelerationStructureGeometryKHR, pNext: pointer = nil, geometryType: VkGeometryTypeKHR, geometry: VkAccelerationStructureGeometryDataKHR, flags: VkGeometryFlagsKHR = 0.VkGeometryFlagsKHR): VkAccelerationStructureGeometryKHR =
  result = VkAccelerationStructureGeometryKHR(
    sType: sType,
    pNext: pNext,
    geometryType: geometryType,
    geometry: geometry,
    flags: flags,
  )

proc newVkAccelerationStructureBuildGeometryInfoKHR*(sType: VkStructureType = VkStructureType.AccelerationStructureBuildGeometryInfoKHR, pNext: pointer = nil, `type`: VkAccelerationStructureTypeKHR, flags: VkBuildAccelerationStructureFlagsKHR = 0.VkBuildAccelerationStructureFlagsKHR, mode: VkBuildAccelerationStructureModeKHR, srcAccelerationStructure: VkAccelerationStructureKHR, dstAccelerationStructure: VkAccelerationStructureKHR, geometries: openarray[VkAccelerationStructureGeometryKHR], pGeometries: openarray[ptr VkAccelerationStructureGeometryKHR], scratchData: VkDeviceOrHostAddressKHR): VkAccelerationStructureBuildGeometryInfoKHR =
  result = VkAccelerationStructureBuildGeometryInfoKHR(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    flags: flags,
    mode: mode,
    srcAccelerationStructure: srcAccelerationStructure,
    dstAccelerationStructure: dstAccelerationStructure,
    geometryCount: if len(geometries) == 0: len(pGeometries).uint32 else: len(geometries).uint32,
    pGeometries: if len(geometries) == 0: nil else: cast[ptr VkAccelerationStructureGeometryKHR](geometries),
    ppGeometries: if len(pGeometries) == 0: nil else: cast[ptr ptr VkAccelerationStructureGeometryKHR](pGeometries),
    scratchData: scratchData,
  )

proc newVkAccelerationStructureBuildRangeInfoKHR*(primitiveCount: uint32, primitiveOffset: uint32, firstVertex: uint32, transformOffset: uint32): VkAccelerationStructureBuildRangeInfoKHR =
  result = VkAccelerationStructureBuildRangeInfoKHR(
    primitiveCount: primitiveCount,
    primitiveOffset: primitiveOffset,
    firstVertex: firstVertex,
    transformOffset: transformOffset,
  )

proc newVkAccelerationStructureCreateInfoKHR*(sType: VkStructureType = VkStructureType.AccelerationStructureCreateInfoKHR, pNext: pointer = nil, createFlags: VkAccelerationStructureCreateFlagsKHR, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, `type`: VkAccelerationStructureTypeKHR, deviceAddress: VkDeviceAddress): VkAccelerationStructureCreateInfoKHR =
  result = VkAccelerationStructureCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    createFlags: createFlags,
    buffer: buffer,
    offset: offset,
    size: size,
    `type`: `type`,
    deviceAddress: deviceAddress,
  )

proc newVkAabbPositionsKHR*(minX: float32, minY: float32, minZ: float32, maxX: float32, maxY: float32, maxZ: float32): VkAabbPositionsKHR =
  result = VkAabbPositionsKHR(
    minX: minX,
    minY: minY,
    minZ: minZ,
    maxX: maxX,
    maxY: maxY,
    maxZ: maxZ,
  )

proc newVkTransformMatrixKHR*(matrix: array[3, float32]): VkTransformMatrixKHR =
  result = VkTransformMatrixKHR(
    matrix: matrix,
  )

proc newVkAccelerationStructureInstanceKHR*(transform: VkTransformMatrixKHR, instanceCustomIndex: uint32, mask: uint32, instanceShaderBindingTableRecordOffset: uint32, flags: VkGeometryInstanceFlagsKHR = 0.VkGeometryInstanceFlagsKHR, accelerationStructureReference: uint64): VkAccelerationStructureInstanceKHR =
  result = VkAccelerationStructureInstanceKHR(
    transform: transform,
    instanceCustomIndex: instanceCustomIndex,
    mask: mask,
    instanceShaderBindingTableRecordOffset: instanceShaderBindingTableRecordOffset,
    flags: flags,
    accelerationStructureReference: accelerationStructureReference,
  )

proc newVkAccelerationStructureDeviceAddressInfoKHR*(sType: VkStructureType = VkStructureType.AccelerationStructureDeviceAddressInfoKHR, pNext: pointer = nil, accelerationStructure: VkAccelerationStructureKHR): VkAccelerationStructureDeviceAddressInfoKHR =
  result = VkAccelerationStructureDeviceAddressInfoKHR(
    sType: sType,
    pNext: pNext,
    accelerationStructure: accelerationStructure,
  )

proc newVkAccelerationStructureVersionInfoKHR*(sType: VkStructureType = VkStructureType.AccelerationStructureVersionInfoKHR, pNext: pointer = nil, pVersionData: ptr uint8): VkAccelerationStructureVersionInfoKHR =
  result = VkAccelerationStructureVersionInfoKHR(
    sType: sType,
    pNext: pNext,
    pVersionData: pVersionData,
  )

proc newVkCopyAccelerationStructureInfoKHR*(sType: VkStructureType = VkStructureType.CopyAccelerationStructureInfoKHR, pNext: pointer = nil, src: VkAccelerationStructureKHR, dst: VkAccelerationStructureKHR, mode: VkCopyAccelerationStructureModeKHR): VkCopyAccelerationStructureInfoKHR =
  result = VkCopyAccelerationStructureInfoKHR(
    sType: sType,
    pNext: pNext,
    src: src,
    dst: dst,
    mode: mode,
  )

proc newVkCopyAccelerationStructureToMemoryInfoKHR*(sType: VkStructureType = VkStructureType.CopyAccelerationStructureToMemoryInfoKHR, pNext: pointer = nil, src: VkAccelerationStructureKHR, dst: VkDeviceOrHostAddressKHR, mode: VkCopyAccelerationStructureModeKHR): VkCopyAccelerationStructureToMemoryInfoKHR =
  result = VkCopyAccelerationStructureToMemoryInfoKHR(
    sType: sType,
    pNext: pNext,
    src: src,
    dst: dst,
    mode: mode,
  )

proc newVkCopyMemoryToAccelerationStructureInfoKHR*(sType: VkStructureType = VkStructureType.CopyMemoryToAccelerationStructureInfoKHR, pNext: pointer = nil, src: VkDeviceOrHostAddressConstKHR, dst: VkAccelerationStructureKHR, mode: VkCopyAccelerationStructureModeKHR): VkCopyMemoryToAccelerationStructureInfoKHR =
  result = VkCopyMemoryToAccelerationStructureInfoKHR(
    sType: sType,
    pNext: pNext,
    src: src,
    dst: dst,
    mode: mode,
  )

proc newVkRayTracingPipelineInterfaceCreateInfoKHR*(sType: VkStructureType = VkStructureType.RayTracingPipelineInterfaceCreateInfoKHR, pNext: pointer = nil, maxPipelineRayPayloadSize: uint32, maxPipelineRayHitAttributeSize: uint32): VkRayTracingPipelineInterfaceCreateInfoKHR =
  result = VkRayTracingPipelineInterfaceCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    maxPipelineRayPayloadSize: maxPipelineRayPayloadSize,
    maxPipelineRayHitAttributeSize: maxPipelineRayHitAttributeSize,
  )

proc newVkPipelineLibraryCreateInfoKHR*(sType: VkStructureType = VkStructureType.PipelineLibraryCreateInfoKHR, pNext: pointer = nil, libraries: openarray[VkPipeline]): VkPipelineLibraryCreateInfoKHR =
  result = VkPipelineLibraryCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    libraryCount: len(libraries).uint32,
    pLibraries: if len(libraries) == 0: nil else: cast[ptr VkPipeline](libraries),
  )

proc newVkRefreshObjectKHR*(objectType: VkObjectType, objectHandle: uint64, flags: VkRefreshObjectFlagsKHR = 0.VkRefreshObjectFlagsKHR): VkRefreshObjectKHR =
  result = VkRefreshObjectKHR(
    objectType: objectType,
    objectHandle: objectHandle,
    flags: flags,
  )

proc newVkRefreshObjectListKHR*(sType: VkStructureType = VkStructureType.RefreshObjectListKHR, pNext: pointer = nil, objects: openarray[VkRefreshObjectKHR]): VkRefreshObjectListKHR =
  result = VkRefreshObjectListKHR(
    sType: sType,
    pNext: pNext,
    objectCount: len(objects).uint32,
    pObjects: if len(objects) == 0: nil else: cast[ptr VkRefreshObjectKHR](objects),
  )

proc newVkPhysicalDeviceExtendedDynamicStateFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceExtendedDynamicStateFeaturesEXT, pNext: pointer = nil, extendedDynamicState: VkBool32): VkPhysicalDeviceExtendedDynamicStateFeaturesEXT =
  result = VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(
    sType: sType,
    pNext: pNext,
    extendedDynamicState: extendedDynamicState,
  )

proc newVkPhysicalDeviceExtendedDynamicState2FeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceExtendedDynamicState2FeaturesEXT, pNext: pointer = nil, extendedDynamicState2: VkBool32, extendedDynamicState2LogicOp: VkBool32, extendedDynamicState2PatchControlPoints: VkBool32): VkPhysicalDeviceExtendedDynamicState2FeaturesEXT =
  result = VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(
    sType: sType,
    pNext: pNext,
    extendedDynamicState2: extendedDynamicState2,
    extendedDynamicState2LogicOp: extendedDynamicState2LogicOp,
    extendedDynamicState2PatchControlPoints: extendedDynamicState2PatchControlPoints,
  )

proc newVkPhysicalDeviceExtendedDynamicState3FeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceExtendedDynamicState3FeaturesEXT, pNext: pointer = nil, extendedDynamicState3TessellationDomainOrigin: VkBool32, extendedDynamicState3DepthClampEnable: VkBool32, extendedDynamicState3PolygonMode: VkBool32, extendedDynamicState3RasterizationSamples: VkBool32, extendedDynamicState3SampleMask: VkBool32, extendedDynamicState3AlphaToCoverageEnable: VkBool32, extendedDynamicState3AlphaToOneEnable: VkBool32, extendedDynamicState3LogicOpEnable: VkBool32, extendedDynamicState3ColorBlendEnable: VkBool32, extendedDynamicState3ColorBlendEquation: VkBool32, extendedDynamicState3ColorWriteMask: VkBool32, extendedDynamicState3RasterizationStream: VkBool32, extendedDynamicState3ConservativeRasterizationMode: VkBool32, extendedDynamicState3ExtraPrimitiveOverestimationSize: VkBool32, extendedDynamicState3DepthClipEnable: VkBool32, extendedDynamicState3SampleLocationsEnable: VkBool32, extendedDynamicState3ColorBlendAdvanced: VkBool32, extendedDynamicState3ProvokingVertexMode: VkBool32, extendedDynamicState3LineRasterizationMode: VkBool32, extendedDynamicState3LineStippleEnable: VkBool32, extendedDynamicState3DepthClipNegativeOneToOne: VkBool32, extendedDynamicState3ViewportWScalingEnable: VkBool32, extendedDynamicState3ViewportSwizzle: VkBool32, extendedDynamicState3CoverageToColorEnable: VkBool32, extendedDynamicState3CoverageToColorLocation: VkBool32, extendedDynamicState3CoverageModulationMode: VkBool32, extendedDynamicState3CoverageModulationTableEnable: VkBool32, extendedDynamicState3CoverageModulationTable: VkBool32, extendedDynamicState3CoverageReductionMode: VkBool32, extendedDynamicState3RepresentativeFragmentTestEnable: VkBool32, extendedDynamicState3ShadingRateImageEnable: VkBool32): VkPhysicalDeviceExtendedDynamicState3FeaturesEXT =
  result = VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(
    sType: sType,
    pNext: pNext,
    extendedDynamicState3TessellationDomainOrigin: extendedDynamicState3TessellationDomainOrigin,
    extendedDynamicState3DepthClampEnable: extendedDynamicState3DepthClampEnable,
    extendedDynamicState3PolygonMode: extendedDynamicState3PolygonMode,
    extendedDynamicState3RasterizationSamples: extendedDynamicState3RasterizationSamples,
    extendedDynamicState3SampleMask: extendedDynamicState3SampleMask,
    extendedDynamicState3AlphaToCoverageEnable: extendedDynamicState3AlphaToCoverageEnable,
    extendedDynamicState3AlphaToOneEnable: extendedDynamicState3AlphaToOneEnable,
    extendedDynamicState3LogicOpEnable: extendedDynamicState3LogicOpEnable,
    extendedDynamicState3ColorBlendEnable: extendedDynamicState3ColorBlendEnable,
    extendedDynamicState3ColorBlendEquation: extendedDynamicState3ColorBlendEquation,
    extendedDynamicState3ColorWriteMask: extendedDynamicState3ColorWriteMask,
    extendedDynamicState3RasterizationStream: extendedDynamicState3RasterizationStream,
    extendedDynamicState3ConservativeRasterizationMode: extendedDynamicState3ConservativeRasterizationMode,
    extendedDynamicState3ExtraPrimitiveOverestimationSize: extendedDynamicState3ExtraPrimitiveOverestimationSize,
    extendedDynamicState3DepthClipEnable: extendedDynamicState3DepthClipEnable,
    extendedDynamicState3SampleLocationsEnable: extendedDynamicState3SampleLocationsEnable,
    extendedDynamicState3ColorBlendAdvanced: extendedDynamicState3ColorBlendAdvanced,
    extendedDynamicState3ProvokingVertexMode: extendedDynamicState3ProvokingVertexMode,
    extendedDynamicState3LineRasterizationMode: extendedDynamicState3LineRasterizationMode,
    extendedDynamicState3LineStippleEnable: extendedDynamicState3LineStippleEnable,
    extendedDynamicState3DepthClipNegativeOneToOne: extendedDynamicState3DepthClipNegativeOneToOne,
    extendedDynamicState3ViewportWScalingEnable: extendedDynamicState3ViewportWScalingEnable,
    extendedDynamicState3ViewportSwizzle: extendedDynamicState3ViewportSwizzle,
    extendedDynamicState3CoverageToColorEnable: extendedDynamicState3CoverageToColorEnable,
    extendedDynamicState3CoverageToColorLocation: extendedDynamicState3CoverageToColorLocation,
    extendedDynamicState3CoverageModulationMode: extendedDynamicState3CoverageModulationMode,
    extendedDynamicState3CoverageModulationTableEnable: extendedDynamicState3CoverageModulationTableEnable,
    extendedDynamicState3CoverageModulationTable: extendedDynamicState3CoverageModulationTable,
    extendedDynamicState3CoverageReductionMode: extendedDynamicState3CoverageReductionMode,
    extendedDynamicState3RepresentativeFragmentTestEnable: extendedDynamicState3RepresentativeFragmentTestEnable,
    extendedDynamicState3ShadingRateImageEnable: extendedDynamicState3ShadingRateImageEnable,
  )

proc newVkPhysicalDeviceExtendedDynamicState3PropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceExtendedDynamicState3PropertiesEXT, pNext: pointer = nil, dynamicPrimitiveTopologyUnrestricted: VkBool32): VkPhysicalDeviceExtendedDynamicState3PropertiesEXT =
  result = VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(
    sType: sType,
    pNext: pNext,
    dynamicPrimitiveTopologyUnrestricted: dynamicPrimitiveTopologyUnrestricted,
  )

proc newVkColorBlendEquationEXT*(srcColorBlendFactor: VkBlendFactor, dstColorBlendFactor: VkBlendFactor, colorBlendOp: VkBlendOp, srcAlphaBlendFactor: VkBlendFactor, dstAlphaBlendFactor: VkBlendFactor, alphaBlendOp: VkBlendOp): VkColorBlendEquationEXT =
  result = VkColorBlendEquationEXT(
    srcColorBlendFactor: srcColorBlendFactor,
    dstColorBlendFactor: dstColorBlendFactor,
    colorBlendOp: colorBlendOp,
    srcAlphaBlendFactor: srcAlphaBlendFactor,
    dstAlphaBlendFactor: dstAlphaBlendFactor,
    alphaBlendOp: alphaBlendOp,
  )

proc newVkColorBlendAdvancedEXT*(advancedBlendOp: VkBlendOp, srcPremultiplied: VkBool32, dstPremultiplied: VkBool32, blendOverlap: VkBlendOverlapEXT, clampResults: VkBool32): VkColorBlendAdvancedEXT =
  result = VkColorBlendAdvancedEXT(
    advancedBlendOp: advancedBlendOp,
    srcPremultiplied: srcPremultiplied,
    dstPremultiplied: dstPremultiplied,
    blendOverlap: blendOverlap,
    clampResults: clampResults,
  )

proc newVkRenderPassTransformBeginInfoQCOM*(sType: VkStructureType = VkStructureType.RenderPassTransformBeginInfoQCOM, pNext: pointer = nil, transform: VkSurfaceTransformFlagBitsKHR): VkRenderPassTransformBeginInfoQCOM =
  result = VkRenderPassTransformBeginInfoQCOM(
    sType: sType,
    pNext: pNext,
    transform: transform,
  )

proc newVkCopyCommandTransformInfoQCOM*(sType: VkStructureType = VkStructureType.CopyCommandTransformInfoQCOM, pNext: pointer = nil, transform: VkSurfaceTransformFlagBitsKHR): VkCopyCommandTransformInfoQCOM =
  result = VkCopyCommandTransformInfoQCOM(
    sType: sType,
    pNext: pNext,
    transform: transform,
  )

proc newVkCommandBufferInheritanceRenderPassTransformInfoQCOM*(sType: VkStructureType = VkStructureType.CommandBufferInheritanceRenderPassTransformInfoQCOM, pNext: pointer = nil, transform: VkSurfaceTransformFlagBitsKHR, renderArea: VkRect2D): VkCommandBufferInheritanceRenderPassTransformInfoQCOM =
  result = VkCommandBufferInheritanceRenderPassTransformInfoQCOM(
    sType: sType,
    pNext: pNext,
    transform: transform,
    renderArea: renderArea,
  )

proc newVkPhysicalDevicePartitionedAccelerationStructureFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDevicePartitionedAccelerationStructureFeaturesNV, pNext: pointer = nil, partitionedAccelerationStructure: VkBool32): VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV =
  result = VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV(
    sType: sType,
    pNext: pNext,
    partitionedAccelerationStructure: partitionedAccelerationStructure,
  )

proc newVkPhysicalDevicePartitionedAccelerationStructurePropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDevicePartitionedAccelerationStructurePropertiesNV, pNext: pointer = nil, maxPartitionCount: uint32): VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV =
  result = VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV(
    sType: sType,
    pNext: pNext,
    maxPartitionCount: maxPartitionCount,
  )

proc newVkBuildPartitionedAccelerationStructureIndirectCommandNV*(opType: VkPartitionedAccelerationStructureOpTypeNV, argCount: uint32, argData: VkStridedDeviceAddressNV): VkBuildPartitionedAccelerationStructureIndirectCommandNV =
  result = VkBuildPartitionedAccelerationStructureIndirectCommandNV(
    opType: opType,
    argCount: argCount,
    argData: argData,
  )

proc newVkPartitionedAccelerationStructureFlagsNV*(sType: VkStructureType = VkStructureType.PartitionedAccelerationStructureFlagsNV, pNext: pointer = nil, enablePartitionTranslation: VkBool32): VkPartitionedAccelerationStructureFlagsNV =
  result = VkPartitionedAccelerationStructureFlagsNV(
    sType: sType,
    pNext: pNext,
    enablePartitionTranslation: enablePartitionTranslation,
  )

proc newVkPartitionedAccelerationStructureWriteInstanceDataNV*(transform: VkTransformMatrixKHR, explicitAABB: array[6, float32], instanceID: uint32, instanceMask: uint32, instanceContributionToHitGroupIndex: uint32, instanceFlags: VkPartitionedAccelerationStructureInstanceFlagsNV, instanceIndex: uint32, partitionIndex: uint32, accelerationStructure: VkDeviceAddress): VkPartitionedAccelerationStructureWriteInstanceDataNV =
  result = VkPartitionedAccelerationStructureWriteInstanceDataNV(
    transform: transform,
    explicitAABB: explicitAABB,
    instanceID: instanceID,
    instanceMask: instanceMask,
    instanceContributionToHitGroupIndex: instanceContributionToHitGroupIndex,
    instanceFlags: instanceFlags,
    instanceIndex: instanceIndex,
    partitionIndex: partitionIndex,
    accelerationStructure: accelerationStructure,
  )

proc newVkPartitionedAccelerationStructureUpdateInstanceDataNV*(instanceIndex: uint32, instanceContributionToHitGroupIndex: uint32, accelerationStructure: VkDeviceAddress): VkPartitionedAccelerationStructureUpdateInstanceDataNV =
  result = VkPartitionedAccelerationStructureUpdateInstanceDataNV(
    instanceIndex: instanceIndex,
    instanceContributionToHitGroupIndex: instanceContributionToHitGroupIndex,
    accelerationStructure: accelerationStructure,
  )

proc newVkPartitionedAccelerationStructureWritePartitionTranslationDataNV*(partitionIndex: uint32, partitionTranslation: array[3, float32]): VkPartitionedAccelerationStructureWritePartitionTranslationDataNV =
  result = VkPartitionedAccelerationStructureWritePartitionTranslationDataNV(
    partitionIndex: partitionIndex,
    partitionTranslation: partitionTranslation,
  )

proc newVkWriteDescriptorSetPartitionedAccelerationStructureNV*(sType: VkStructureType = VkStructureType.WriteDescriptorSetPartitionedAccelerationStructureNV, pNext: pointer = nil, accelerationStructures: openarray[VkDeviceAddress]): VkWriteDescriptorSetPartitionedAccelerationStructureNV =
  result = VkWriteDescriptorSetPartitionedAccelerationStructureNV(
    sType: sType,
    pNext: pNext,
    accelerationStructureCount: len(accelerationStructures).uint32,
    pAccelerationStructures: if len(accelerationStructures) == 0: nil else: cast[ptr VkDeviceAddress](accelerationStructures),
  )

proc newVkPartitionedAccelerationStructureInstancesInputNV*(sType: VkStructureType = VkStructureType.PartitionedAccelerationStructureInstancesInputNV, pNext: pointer = nil, flags: VkBuildAccelerationStructureFlagsKHR = 0.VkBuildAccelerationStructureFlagsKHR, instanceCount: uint32, maxInstancePerPartitionCount: uint32, partitionCount: uint32, maxInstanceInGlobalPartitionCount: uint32): VkPartitionedAccelerationStructureInstancesInputNV =
  result = VkPartitionedAccelerationStructureInstancesInputNV(
    sType: sType,
    pNext: pNext,
    flags: flags,
    instanceCount: instanceCount,
    maxInstancePerPartitionCount: maxInstancePerPartitionCount,
    partitionCount: partitionCount,
    maxInstanceInGlobalPartitionCount: maxInstanceInGlobalPartitionCount,
  )

proc newVkBuildPartitionedAccelerationStructureInfoNV*(sType: VkStructureType = VkStructureType.BuildPartitionedAccelerationStructureInfoNV, pNext: pointer = nil, input: VkPartitionedAccelerationStructureInstancesInputNV, srcAccelerationStructureData: VkDeviceAddress, dstAccelerationStructureData: VkDeviceAddress, scratchData: VkDeviceAddress, srcInfos: VkDeviceAddress, srcInfosCount: VkDeviceAddress): VkBuildPartitionedAccelerationStructureInfoNV =
  result = VkBuildPartitionedAccelerationStructureInfoNV(
    sType: sType,
    pNext: pNext,
    input: input,
    srcAccelerationStructureData: srcAccelerationStructureData,
    dstAccelerationStructureData: dstAccelerationStructureData,
    scratchData: scratchData,
    srcInfos: srcInfos,
    srcInfosCount: srcInfosCount,
  )

proc newVkPhysicalDeviceDiagnosticsConfigFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceDiagnosticsConfigFeaturesNV, pNext: pointer = nil, diagnosticsConfig: VkBool32): VkPhysicalDeviceDiagnosticsConfigFeaturesNV =
  result = VkPhysicalDeviceDiagnosticsConfigFeaturesNV(
    sType: sType,
    pNext: pNext,
    diagnosticsConfig: diagnosticsConfig,
  )

proc newVkDeviceDiagnosticsConfigCreateInfoNV*(sType: VkStructureType = VkStructureType.DeviceDiagnosticsConfigCreateInfoNV, pNext: pointer = nil, flags: VkDeviceDiagnosticsConfigFlagsNV = 0.VkDeviceDiagnosticsConfigFlagsNV): VkDeviceDiagnosticsConfigCreateInfoNV =
  result = VkDeviceDiagnosticsConfigCreateInfoNV(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkPipelineOfflineCreateInfo*(sType: VkStructureType = VkStructureType.PipelineOfflineCreateInfo, pNext: pointer = nil, pipelineIdentifier: array[VK_UUID_SIZE, uint8], matchControl: VkPipelineMatchControl, poolEntrySize: VkDeviceSize): VkPipelineOfflineCreateInfo =
  result = VkPipelineOfflineCreateInfo(
    sType: sType,
    pNext: pNext,
    pipelineIdentifier: pipelineIdentifier,
    matchControl: matchControl,
    poolEntrySize: poolEntrySize,
  )

proc newVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, pNext: pointer = nil, shaderZeroInitializeWorkgroupMemory: VkBool32): VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures =
  result = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(
    sType: sType,
    pNext: pNext,
    shaderZeroInitializeWorkgroupMemory: shaderZeroInitializeWorkgroupMemory,
  )

proc newVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, pNext: pointer = nil, shaderSubgroupUniformControlFlow: VkBool32): VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR =
  result = VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(
    sType: sType,
    pNext: pNext,
    shaderSubgroupUniformControlFlow: shaderSubgroupUniformControlFlow,
  )

proc newVkPhysicalDeviceRobustness2FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceRobustness2FeaturesKHR, pNext: pointer = nil, robustBufferAccess2: VkBool32, robustImageAccess2: VkBool32, nullDescriptor: VkBool32): VkPhysicalDeviceRobustness2FeaturesKHR =
  result = VkPhysicalDeviceRobustness2FeaturesKHR(
    sType: sType,
    pNext: pNext,
    robustBufferAccess2: robustBufferAccess2,
    robustImageAccess2: robustImageAccess2,
    nullDescriptor: nullDescriptor,
  )

proc newVkPhysicalDeviceRobustness2PropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceRobustness2PropertiesKHR, pNext: pointer = nil, robustStorageBufferAccessSizeAlignment: VkDeviceSize, robustUniformBufferAccessSizeAlignment: VkDeviceSize): VkPhysicalDeviceRobustness2PropertiesKHR =
  result = VkPhysicalDeviceRobustness2PropertiesKHR(
    sType: sType,
    pNext: pNext,
    robustStorageBufferAccessSizeAlignment: robustStorageBufferAccessSizeAlignment,
    robustUniformBufferAccessSizeAlignment: robustUniformBufferAccessSizeAlignment,
  )

proc newVkPhysicalDeviceImageRobustnessFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageRobustnessFeatures, pNext: pointer = nil, robustImageAccess: VkBool32): VkPhysicalDeviceImageRobustnessFeatures =
  result = VkPhysicalDeviceImageRobustnessFeatures(
    sType: sType,
    pNext: pNext,
    robustImageAccess: robustImageAccess,
  )

proc newVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, pNext: pointer = nil, workgroupMemoryExplicitLayout: VkBool32, workgroupMemoryExplicitLayoutScalarBlockLayout: VkBool32, workgroupMemoryExplicitLayout8BitAccess: VkBool32, workgroupMemoryExplicitLayout16BitAccess: VkBool32): VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR =
  result = VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(
    sType: sType,
    pNext: pNext,
    workgroupMemoryExplicitLayout: workgroupMemoryExplicitLayout,
    workgroupMemoryExplicitLayoutScalarBlockLayout: workgroupMemoryExplicitLayoutScalarBlockLayout,
    workgroupMemoryExplicitLayout8BitAccess: workgroupMemoryExplicitLayout8BitAccess,
    workgroupMemoryExplicitLayout16BitAccess: workgroupMemoryExplicitLayout16BitAccess,
  )

proc newVkPhysicalDevicePortabilitySubsetFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePortabilitySubsetFeaturesKHR, pNext: pointer = nil, constantAlphaColorBlendFactors: VkBool32, events: VkBool32, imageViewFormatReinterpretation: VkBool32, imageViewFormatSwizzle: VkBool32, imageView2DOn3DImage: VkBool32, multisampleArrayImage: VkBool32, mutableComparisonSamplers: VkBool32, pointPolygons: VkBool32, samplerMipLodBias: VkBool32, separateStencilMaskRef: VkBool32, shaderSampleRateInterpolationFunctions: VkBool32, tessellationIsolines: VkBool32, tessellationPointMode: VkBool32, triangleFans: VkBool32, vertexAttributeAccessBeyondStride: VkBool32): VkPhysicalDevicePortabilitySubsetFeaturesKHR =
  result = VkPhysicalDevicePortabilitySubsetFeaturesKHR(
    sType: sType,
    pNext: pNext,
    constantAlphaColorBlendFactors: constantAlphaColorBlendFactors,
    events: events,
    imageViewFormatReinterpretation: imageViewFormatReinterpretation,
    imageViewFormatSwizzle: imageViewFormatSwizzle,
    imageView2DOn3DImage: imageView2DOn3DImage,
    multisampleArrayImage: multisampleArrayImage,
    mutableComparisonSamplers: mutableComparisonSamplers,
    pointPolygons: pointPolygons,
    samplerMipLodBias: samplerMipLodBias,
    separateStencilMaskRef: separateStencilMaskRef,
    shaderSampleRateInterpolationFunctions: shaderSampleRateInterpolationFunctions,
    tessellationIsolines: tessellationIsolines,
    tessellationPointMode: tessellationPointMode,
    triangleFans: triangleFans,
    vertexAttributeAccessBeyondStride: vertexAttributeAccessBeyondStride,
  )

proc newVkPhysicalDevicePortabilitySubsetPropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePortabilitySubsetPropertiesKHR, pNext: pointer = nil, minVertexInputBindingStrideAlignment: uint32): VkPhysicalDevicePortabilitySubsetPropertiesKHR =
  result = VkPhysicalDevicePortabilitySubsetPropertiesKHR(
    sType: sType,
    pNext: pNext,
    minVertexInputBindingStrideAlignment: minVertexInputBindingStrideAlignment,
  )

proc newVkPhysicalDevice4444FormatsFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDevice4444FormatsFeaturesEXT, pNext: pointer = nil, formatA4R4G4B4: VkBool32, formatA4B4G4R4: VkBool32): VkPhysicalDevice4444FormatsFeaturesEXT =
  result = VkPhysicalDevice4444FormatsFeaturesEXT(
    sType: sType,
    pNext: pNext,
    formatA4R4G4B4: formatA4R4G4B4,
    formatA4B4G4R4: formatA4B4G4R4,
  )

proc newVkPhysicalDeviceSubpassShadingFeaturesHUAWEI*(sType: VkStructureType = VkStructureType.PhysicalDeviceSubpassShadingFeaturesHUAWEI, pNext: pointer = nil, subpassShading: VkBool32): VkPhysicalDeviceSubpassShadingFeaturesHUAWEI =
  result = VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(
    sType: sType,
    pNext: pNext,
    subpassShading: subpassShading,
  )

proc newVkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*(sType: VkStructureType = VkStructureType.PhysicalDeviceClusterCullingShaderFeaturesHUAWEI, pNext: pointer = nil, clustercullingShader: VkBool32, multiviewClusterCullingShader: VkBool32): VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI =
  result = VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(
    sType: sType,
    pNext: pNext,
    clustercullingShader: clustercullingShader,
    multiviewClusterCullingShader: multiviewClusterCullingShader,
  )

proc newVkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*(sType: VkStructureType = VkStructureType.PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI, pNext: pointer = nil, clusterShadingRate: VkBool32): VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI =
  result = VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(
    sType: sType,
    pNext: pNext,
    clusterShadingRate: clusterShadingRate,
  )

proc newVkBufferCopy2*(sType: VkStructureType = VkStructureType.BufferCopy2, pNext: pointer = nil, srcOffset: VkDeviceSize, dstOffset: VkDeviceSize, size: VkDeviceSize): VkBufferCopy2 =
  result = VkBufferCopy2(
    sType: sType,
    pNext: pNext,
    srcOffset: srcOffset,
    dstOffset: dstOffset,
    size: size,
  )

proc newVkImageCopy2*(sType: VkStructureType = VkStructureType.ImageCopy2, pNext: pointer = nil, srcSubresource: VkImageSubresourceLayers, srcOffset: VkOffset3D, dstSubresource: VkImageSubresourceLayers, dstOffset: VkOffset3D, extent: VkExtent3D): VkImageCopy2 =
  result = VkImageCopy2(
    sType: sType,
    pNext: pNext,
    srcSubresource: srcSubresource,
    srcOffset: srcOffset,
    dstSubresource: dstSubresource,
    dstOffset: dstOffset,
    extent: extent,
  )

proc newVkImageBlit2*(sType: VkStructureType = VkStructureType.ImageBlit2, pNext: pointer = nil, srcSubresource: VkImageSubresourceLayers, srcOffsets: array[2, VkOffset3D], dstSubresource: VkImageSubresourceLayers, dstOffsets: array[2, VkOffset3D]): VkImageBlit2 =
  result = VkImageBlit2(
    sType: sType,
    pNext: pNext,
    srcSubresource: srcSubresource,
    srcOffsets: srcOffsets,
    dstSubresource: dstSubresource,
    dstOffsets: dstOffsets,
  )

proc newVkBufferImageCopy2*(sType: VkStructureType = VkStructureType.BufferImageCopy2, pNext: pointer = nil, bufferOffset: VkDeviceSize, bufferRowLength: uint32, bufferImageHeight: uint32, imageSubresource: VkImageSubresourceLayers, imageOffset: VkOffset3D, imageExtent: VkExtent3D): VkBufferImageCopy2 =
  result = VkBufferImageCopy2(
    sType: sType,
    pNext: pNext,
    bufferOffset: bufferOffset,
    bufferRowLength: bufferRowLength,
    bufferImageHeight: bufferImageHeight,
    imageSubresource: imageSubresource,
    imageOffset: imageOffset,
    imageExtent: imageExtent,
  )

proc newVkImageResolve2*(sType: VkStructureType = VkStructureType.ImageResolve2, pNext: pointer = nil, srcSubresource: VkImageSubresourceLayers, srcOffset: VkOffset3D, dstSubresource: VkImageSubresourceLayers, dstOffset: VkOffset3D, extent: VkExtent3D): VkImageResolve2 =
  result = VkImageResolve2(
    sType: sType,
    pNext: pNext,
    srcSubresource: srcSubresource,
    srcOffset: srcOffset,
    dstSubresource: dstSubresource,
    dstOffset: dstOffset,
    extent: extent,
  )

proc newVkCopyBufferInfo2*(sType: VkStructureType = VkStructureType.CopyBufferInfo2, pNext: pointer = nil, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regions: openarray[VkBufferCopy2]): VkCopyBufferInfo2 =
  result = VkCopyBufferInfo2(
    sType: sType,
    pNext: pNext,
    srcBuffer: srcBuffer,
    dstBuffer: dstBuffer,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkBufferCopy2](regions),
  )

proc newVkCopyImageInfo2*(sType: VkStructureType = VkStructureType.CopyImageInfo2, pNext: pointer = nil, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regions: openarray[VkImageCopy2]): VkCopyImageInfo2 =
  result = VkCopyImageInfo2(
    sType: sType,
    pNext: pNext,
    srcImage: srcImage,
    srcImageLayout: srcImageLayout,
    dstImage: dstImage,
    dstImageLayout: dstImageLayout,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkImageCopy2](regions),
  )

proc newVkBlitImageInfo2*(sType: VkStructureType = VkStructureType.BlitImageInfo2, pNext: pointer = nil, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regions: openarray[VkImageBlit2], filter: VkFilter): VkBlitImageInfo2 =
  result = VkBlitImageInfo2(
    sType: sType,
    pNext: pNext,
    srcImage: srcImage,
    srcImageLayout: srcImageLayout,
    dstImage: dstImage,
    dstImageLayout: dstImageLayout,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkImageBlit2](regions),
    filter: filter,
  )

proc newVkCopyBufferToImageInfo2*(sType: VkStructureType = VkStructureType.CopyBufferToImageInfo2, pNext: pointer = nil, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regions: openarray[VkBufferImageCopy2]): VkCopyBufferToImageInfo2 =
  result = VkCopyBufferToImageInfo2(
    sType: sType,
    pNext: pNext,
    srcBuffer: srcBuffer,
    dstImage: dstImage,
    dstImageLayout: dstImageLayout,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkBufferImageCopy2](regions),
  )

proc newVkCopyImageToBufferInfo2*(sType: VkStructureType = VkStructureType.CopyImageToBufferInfo2, pNext: pointer = nil, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regions: openarray[VkBufferImageCopy2]): VkCopyImageToBufferInfo2 =
  result = VkCopyImageToBufferInfo2(
    sType: sType,
    pNext: pNext,
    srcImage: srcImage,
    srcImageLayout: srcImageLayout,
    dstBuffer: dstBuffer,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkBufferImageCopy2](regions),
  )

proc newVkResolveImageInfo2*(sType: VkStructureType = VkStructureType.ResolveImageInfo2, pNext: pointer = nil, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regions: openarray[VkImageResolve2]): VkResolveImageInfo2 =
  result = VkResolveImageInfo2(
    sType: sType,
    pNext: pNext,
    srcImage: srcImage,
    srcImageLayout: srcImageLayout,
    dstImage: dstImage,
    dstImageLayout: dstImageLayout,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkImageResolve2](regions),
  )

proc newVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderImageAtomicInt64FeaturesEXT, pNext: pointer = nil, shaderImageInt64Atomics: VkBool32, sparseImageInt64Atomics: VkBool32): VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT =
  result = VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderImageInt64Atomics: shaderImageInt64Atomics,
    sparseImageInt64Atomics: sparseImageInt64Atomics,
  )

proc newVkFragmentShadingRateAttachmentInfoKHR*(sType: VkStructureType = VkStructureType.FragmentShadingRateAttachmentInfoKHR, pNext: pointer = nil, pFragmentShadingRateAttachment: ptr VkAttachmentReference2, shadingRateAttachmentTexelSize: VkExtent2D): VkFragmentShadingRateAttachmentInfoKHR =
  result = VkFragmentShadingRateAttachmentInfoKHR(
    sType: sType,
    pNext: pNext,
    pFragmentShadingRateAttachment: pFragmentShadingRateAttachment,
    shadingRateAttachmentTexelSize: shadingRateAttachmentTexelSize,
  )

proc newVkPipelineFragmentShadingRateStateCreateInfoKHR*(sType: VkStructureType = VkStructureType.PipelineFragmentShadingRateStateCreateInfoKHR, pNext: pointer = nil, fragmentSize: VkExtent2D, combinerOps: array[2, VkFragmentShadingRateCombinerOpKHR]): VkPipelineFragmentShadingRateStateCreateInfoKHR =
  result = VkPipelineFragmentShadingRateStateCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    fragmentSize: fragmentSize,
    combinerOps: combinerOps,
  )

proc newVkPhysicalDeviceFragmentShadingRateFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentShadingRateFeaturesKHR, pNext: pointer = nil, pipelineFragmentShadingRate: VkBool32, primitiveFragmentShadingRate: VkBool32, attachmentFragmentShadingRate: VkBool32): VkPhysicalDeviceFragmentShadingRateFeaturesKHR =
  result = VkPhysicalDeviceFragmentShadingRateFeaturesKHR(
    sType: sType,
    pNext: pNext,
    pipelineFragmentShadingRate: pipelineFragmentShadingRate,
    primitiveFragmentShadingRate: primitiveFragmentShadingRate,
    attachmentFragmentShadingRate: attachmentFragmentShadingRate,
  )

proc newVkPhysicalDeviceFragmentShadingRatePropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentShadingRatePropertiesKHR, pNext: pointer = nil, minFragmentShadingRateAttachmentTexelSize: VkExtent2D, maxFragmentShadingRateAttachmentTexelSize: VkExtent2D, maxFragmentShadingRateAttachmentTexelSizeAspectRatio: uint32, primitiveFragmentShadingRateWithMultipleViewports: VkBool32, layeredShadingRateAttachments: VkBool32, fragmentShadingRateNonTrivialCombinerOps: VkBool32, maxFragmentSize: VkExtent2D, maxFragmentSizeAspectRatio: uint32, maxFragmentShadingRateCoverageSamples: uint32, maxFragmentShadingRateRasterizationSamples: VkSampleCountFlagBits, fragmentShadingRateWithShaderDepthStencilWrites: VkBool32, fragmentShadingRateWithSampleMask: VkBool32, fragmentShadingRateWithShaderSampleMask: VkBool32, fragmentShadingRateWithConservativeRasterization: VkBool32, fragmentShadingRateWithFragmentShaderInterlock: VkBool32, fragmentShadingRateWithCustomSampleLocations: VkBool32, fragmentShadingRateStrictMultiplyCombiner: VkBool32): VkPhysicalDeviceFragmentShadingRatePropertiesKHR =
  result = VkPhysicalDeviceFragmentShadingRatePropertiesKHR(
    sType: sType,
    pNext: pNext,
    minFragmentShadingRateAttachmentTexelSize: minFragmentShadingRateAttachmentTexelSize,
    maxFragmentShadingRateAttachmentTexelSize: maxFragmentShadingRateAttachmentTexelSize,
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio: maxFragmentShadingRateAttachmentTexelSizeAspectRatio,
    primitiveFragmentShadingRateWithMultipleViewports: primitiveFragmentShadingRateWithMultipleViewports,
    layeredShadingRateAttachments: layeredShadingRateAttachments,
    fragmentShadingRateNonTrivialCombinerOps: fragmentShadingRateNonTrivialCombinerOps,
    maxFragmentSize: maxFragmentSize,
    maxFragmentSizeAspectRatio: maxFragmentSizeAspectRatio,
    maxFragmentShadingRateCoverageSamples: maxFragmentShadingRateCoverageSamples,
    maxFragmentShadingRateRasterizationSamples: maxFragmentShadingRateRasterizationSamples,
    fragmentShadingRateWithShaderDepthStencilWrites: fragmentShadingRateWithShaderDepthStencilWrites,
    fragmentShadingRateWithSampleMask: fragmentShadingRateWithSampleMask,
    fragmentShadingRateWithShaderSampleMask: fragmentShadingRateWithShaderSampleMask,
    fragmentShadingRateWithConservativeRasterization: fragmentShadingRateWithConservativeRasterization,
    fragmentShadingRateWithFragmentShaderInterlock: fragmentShadingRateWithFragmentShaderInterlock,
    fragmentShadingRateWithCustomSampleLocations: fragmentShadingRateWithCustomSampleLocations,
    fragmentShadingRateStrictMultiplyCombiner: fragmentShadingRateStrictMultiplyCombiner,
  )

proc newVkPhysicalDeviceFragmentShadingRateKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentShadingRateKHR, pNext: pointer = nil, sampleCounts: VkSampleCountFlags, fragmentSize: VkExtent2D): VkPhysicalDeviceFragmentShadingRateKHR =
  result = VkPhysicalDeviceFragmentShadingRateKHR(
    sType: sType,
    pNext: pNext,
    sampleCounts: sampleCounts,
    fragmentSize: fragmentSize,
  )

proc newVkPhysicalDeviceShaderTerminateInvocationFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderTerminateInvocationFeatures, pNext: pointer = nil, shaderTerminateInvocation: VkBool32): VkPhysicalDeviceShaderTerminateInvocationFeatures =
  result = VkPhysicalDeviceShaderTerminateInvocationFeatures(
    sType: sType,
    pNext: pNext,
    shaderTerminateInvocation: shaderTerminateInvocation,
  )

proc newVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentShadingRateEnumsFeaturesNV, pNext: pointer = nil, fragmentShadingRateEnums: VkBool32, supersampleFragmentShadingRates: VkBool32, noInvocationFragmentShadingRates: VkBool32): VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV =
  result = VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(
    sType: sType,
    pNext: pNext,
    fragmentShadingRateEnums: fragmentShadingRateEnums,
    supersampleFragmentShadingRates: supersampleFragmentShadingRates,
    noInvocationFragmentShadingRates: noInvocationFragmentShadingRates,
  )

proc newVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentShadingRateEnumsPropertiesNV, pNext: pointer = nil, maxFragmentShadingRateInvocationCount: VkSampleCountFlagBits): VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV =
  result = VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(
    sType: sType,
    pNext: pNext,
    maxFragmentShadingRateInvocationCount: maxFragmentShadingRateInvocationCount,
  )

proc newVkPipelineFragmentShadingRateEnumStateCreateInfoNV*(sType: VkStructureType = VkStructureType.PipelineFragmentShadingRateEnumStateCreateInfoNV, pNext: pointer = nil, shadingRateType: VkFragmentShadingRateTypeNV, shadingRate: VkFragmentShadingRateNV, combinerOps: array[2, VkFragmentShadingRateCombinerOpKHR]): VkPipelineFragmentShadingRateEnumStateCreateInfoNV =
  result = VkPipelineFragmentShadingRateEnumStateCreateInfoNV(
    sType: sType,
    pNext: pNext,
    shadingRateType: shadingRateType,
    shadingRate: shadingRate,
    combinerOps: combinerOps,
  )

proc newVkAccelerationStructureBuildSizesInfoKHR*(sType: VkStructureType = VkStructureType.AccelerationStructureBuildSizesInfoKHR, pNext: pointer = nil, accelerationStructureSize: VkDeviceSize, updateScratchSize: VkDeviceSize, buildScratchSize: VkDeviceSize): VkAccelerationStructureBuildSizesInfoKHR =
  result = VkAccelerationStructureBuildSizesInfoKHR(
    sType: sType,
    pNext: pNext,
    accelerationStructureSize: accelerationStructureSize,
    updateScratchSize: updateScratchSize,
    buildScratchSize: buildScratchSize,
  )

proc newVkPhysicalDeviceImage2DViewOf3DFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceImage2DViewOf3DFeaturesEXT, pNext: pointer = nil, image2DViewOf3D: VkBool32, sampler2DViewOf3D: VkBool32): VkPhysicalDeviceImage2DViewOf3DFeaturesEXT =
  result = VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(
    sType: sType,
    pNext: pNext,
    image2DViewOf3D: image2DViewOf3D,
    sampler2DViewOf3D: sampler2DViewOf3D,
  )

proc newVkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageSlicedViewOf3DFeaturesEXT, pNext: pointer = nil, imageSlicedViewOf3D: VkBool32): VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT =
  result = VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(
    sType: sType,
    pNext: pNext,
    imageSlicedViewOf3D: imageSlicedViewOf3D,
  )

proc newVkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, pNext: pointer = nil, attachmentFeedbackLoopDynamicState: VkBool32): VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT =
  result = VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(
    sType: sType,
    pNext: pNext,
    attachmentFeedbackLoopDynamicState: attachmentFeedbackLoopDynamicState,
  )

proc newVkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceLegacyVertexAttributesFeaturesEXT, pNext: pointer = nil, legacyVertexAttributes: VkBool32): VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT =
  result = VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(
    sType: sType,
    pNext: pNext,
    legacyVertexAttributes: legacyVertexAttributes,
  )

proc newVkPhysicalDeviceLegacyVertexAttributesPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceLegacyVertexAttributesPropertiesEXT, pNext: pointer = nil, nativeUnalignedPerformance: VkBool32): VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT =
  result = VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(
    sType: sType,
    pNext: pNext,
    nativeUnalignedPerformance: nativeUnalignedPerformance,
  )

proc newVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMutableDescriptorTypeFeaturesEXT, pNext: pointer = nil, mutableDescriptorType: VkBool32): VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT =
  result = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(
    sType: sType,
    pNext: pNext,
    mutableDescriptorType: mutableDescriptorType,
  )

proc newVkMutableDescriptorTypeListEXT*(descriptorTypes: openarray[VkDescriptorType]): VkMutableDescriptorTypeListEXT =
  result = VkMutableDescriptorTypeListEXT(
    descriptorTypeCount: len(descriptorTypes).uint32,
    pDescriptorTypes: if len(descriptorTypes) == 0: nil else: cast[ptr VkDescriptorType](descriptorTypes),
  )

proc newVkMutableDescriptorTypeCreateInfoEXT*(sType: VkStructureType = VkStructureType.MutableDescriptorTypeCreateInfoEXT, pNext: pointer = nil, mutableDescriptorTypeLists: openarray[VkMutableDescriptorTypeListEXT]): VkMutableDescriptorTypeCreateInfoEXT =
  result = VkMutableDescriptorTypeCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    mutableDescriptorTypeListCount: len(mutableDescriptorTypeLists).uint32,
    pMutableDescriptorTypeLists: if len(mutableDescriptorTypeLists) == 0: nil else: cast[ptr VkMutableDescriptorTypeListEXT](mutableDescriptorTypeLists),
  )

proc newVkPhysicalDeviceDepthClipControlFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDepthClipControlFeaturesEXT, pNext: pointer = nil, depthClipControl: VkBool32): VkPhysicalDeviceDepthClipControlFeaturesEXT =
  result = VkPhysicalDeviceDepthClipControlFeaturesEXT(
    sType: sType,
    pNext: pNext,
    depthClipControl: depthClipControl,
  )

proc newVkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT, pNext: pointer = nil, zeroInitializeDeviceMemory: VkBool32): VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT =
  result = VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(
    sType: sType,
    pNext: pNext,
    zeroInitializeDeviceMemory: zeroInitializeDeviceMemory,
  )

proc newVkBeginCustomResolveInfoEXT*(sType: VkStructureType = VkStructureType.BeginCustomResolveInfoEXT, pNext: pointer = nil): VkBeginCustomResolveInfoEXT =
  result = VkBeginCustomResolveInfoEXT(
    sType: sType,
    pNext: pNext,
  )

proc newVkPhysicalDeviceCustomResolveFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceCustomResolveFeaturesEXT, pNext: pointer = nil, customResolve: VkBool32): VkPhysicalDeviceCustomResolveFeaturesEXT =
  result = VkPhysicalDeviceCustomResolveFeaturesEXT(
    sType: sType,
    pNext: pNext,
    customResolve: customResolve,
  )

proc newVkCustomResolveCreateInfoEXT*(sType: VkStructureType = VkStructureType.CustomResolveCreateInfoEXT, pNext: pointer = nil, customResolve: VkBool32, colorAttachmentFormats: openarray[VkFormat], depthAttachmentFormat: VkFormat, stencilAttachmentFormat: VkFormat): VkCustomResolveCreateInfoEXT =
  result = VkCustomResolveCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    customResolve: customResolve,
    colorAttachmentCount: len(colorAttachmentFormats).uint32,
    pColorAttachmentFormats: if len(colorAttachmentFormats) == 0: nil else: cast[ptr VkFormat](colorAttachmentFormats),
    depthAttachmentFormat: depthAttachmentFormat,
    stencilAttachmentFormat: stencilAttachmentFormat,
  )

proc newVkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, pNext: pointer = nil, deviceGeneratedCommands: VkBool32, dynamicGeneratedPipelineLayout: VkBool32): VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT =
  result = VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(
    sType: sType,
    pNext: pNext,
    deviceGeneratedCommands: deviceGeneratedCommands,
    dynamicGeneratedPipelineLayout: dynamicGeneratedPipelineLayout,
  )

proc newVkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT, pNext: pointer = nil, maxIndirectPipelineCount: uint32, maxIndirectShaderObjectCount: uint32, maxIndirectSequenceCount: uint32, maxIndirectCommandsTokenCount: uint32, maxIndirectCommandsTokenOffset: uint32, maxIndirectCommandsIndirectStride: uint32, supportedIndirectCommandsInputModes: VkIndirectCommandsInputModeFlagsEXT, supportedIndirectCommandsShaderStages: VkShaderStageFlags, supportedIndirectCommandsShaderStagesPipelineBinding: VkShaderStageFlags, supportedIndirectCommandsShaderStagesShaderBinding: VkShaderStageFlags, deviceGeneratedCommandsTransformFeedback: VkBool32, deviceGeneratedCommandsMultiDrawIndirectCount: VkBool32): VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT =
  result = VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxIndirectPipelineCount: maxIndirectPipelineCount,
    maxIndirectShaderObjectCount: maxIndirectShaderObjectCount,
    maxIndirectSequenceCount: maxIndirectSequenceCount,
    maxIndirectCommandsTokenCount: maxIndirectCommandsTokenCount,
    maxIndirectCommandsTokenOffset: maxIndirectCommandsTokenOffset,
    maxIndirectCommandsIndirectStride: maxIndirectCommandsIndirectStride,
    supportedIndirectCommandsInputModes: supportedIndirectCommandsInputModes,
    supportedIndirectCommandsShaderStages: supportedIndirectCommandsShaderStages,
    supportedIndirectCommandsShaderStagesPipelineBinding: supportedIndirectCommandsShaderStagesPipelineBinding,
    supportedIndirectCommandsShaderStagesShaderBinding: supportedIndirectCommandsShaderStagesShaderBinding,
    deviceGeneratedCommandsTransformFeedback: deviceGeneratedCommandsTransformFeedback,
    deviceGeneratedCommandsMultiDrawIndirectCount: deviceGeneratedCommandsMultiDrawIndirectCount,
  )

proc newVkGeneratedCommandsPipelineInfoEXT*(sType: VkStructureType = VkStructureType.GeneratedCommandsPipelineInfoEXT, pNext: pointer = nil, pipeline: VkPipeline): VkGeneratedCommandsPipelineInfoEXT =
  result = VkGeneratedCommandsPipelineInfoEXT(
    sType: sType,
    pNext: pNext,
    pipeline: pipeline,
  )

proc newVkGeneratedCommandsShaderInfoEXT*(sType: VkStructureType = VkStructureType.GeneratedCommandsShaderInfoEXT, pNext: pointer = nil, shaders: openarray[VkShaderEXT]): VkGeneratedCommandsShaderInfoEXT =
  result = VkGeneratedCommandsShaderInfoEXT(
    sType: sType,
    pNext: pNext,
    shaderCount: len(shaders).uint32,
    pShaders: if len(shaders) == 0: nil else: cast[ptr VkShaderEXT](shaders),
  )

proc newVkGeneratedCommandsMemoryRequirementsInfoEXT*(sType: VkStructureType = VkStructureType.GeneratedCommandsMemoryRequirementsInfoEXT, pNext: pointer = nil, indirectExecutionSet: VkIndirectExecutionSetEXT, indirectCommandsLayout: VkIndirectCommandsLayoutEXT, maxSequenceCount: uint32, maxDrawCount: uint32): VkGeneratedCommandsMemoryRequirementsInfoEXT =
  result = VkGeneratedCommandsMemoryRequirementsInfoEXT(
    sType: sType,
    pNext: pNext,
    indirectExecutionSet: indirectExecutionSet,
    indirectCommandsLayout: indirectCommandsLayout,
    maxSequenceCount: maxSequenceCount,
    maxDrawCount: maxDrawCount,
  )

proc newVkIndirectExecutionSetPipelineInfoEXT*(sType: VkStructureType = VkStructureType.IndirectExecutionSetPipelineInfoEXT, pNext: pointer = nil, initialPipeline: VkPipeline, maxPipelineCount: uint32): VkIndirectExecutionSetPipelineInfoEXT =
  result = VkIndirectExecutionSetPipelineInfoEXT(
    sType: sType,
    pNext: pNext,
    initialPipeline: initialPipeline,
    maxPipelineCount: maxPipelineCount,
  )

proc newVkIndirectExecutionSetShaderLayoutInfoEXT*(sType: VkStructureType = VkStructureType.IndirectExecutionSetShaderLayoutInfoEXT, pNext: pointer = nil, setLayouts: openarray[VkDescriptorSetLayout]): VkIndirectExecutionSetShaderLayoutInfoEXT =
  result = VkIndirectExecutionSetShaderLayoutInfoEXT(
    sType: sType,
    pNext: pNext,
    setLayoutCount: len(setLayouts).uint32,
    pSetLayouts: if len(setLayouts) == 0: nil else: cast[ptr VkDescriptorSetLayout](setLayouts),
  )

proc newVkIndirectExecutionSetShaderInfoEXT*(sType: VkStructureType = VkStructureType.IndirectExecutionSetShaderInfoEXT, pNext: pointer = nil, initialShaders: openarray[VkShaderEXT], setLayoutInfos: openarray[VkIndirectExecutionSetShaderLayoutInfoEXT], maxShaderCount: uint32, pushConstantRanges: openarray[VkPushConstantRange]): VkIndirectExecutionSetShaderInfoEXT =
  result = VkIndirectExecutionSetShaderInfoEXT(
    sType: sType,
    pNext: pNext,
    shaderCount: len(initialShaders).uint32,
    pInitialShaders: if len(initialShaders) == 0: nil else: cast[ptr VkShaderEXT](initialShaders),
    pSetLayoutInfos: if len(setLayoutInfos) == 0: nil else: cast[ptr VkIndirectExecutionSetShaderLayoutInfoEXT](setLayoutInfos),
    maxShaderCount: maxShaderCount,
    pushConstantRangeCount: len(pushConstantRanges).uint32,
    pPushConstantRanges: if len(pushConstantRanges) == 0: nil else: cast[ptr VkPushConstantRange](pushConstantRanges),
  )

proc newVkIndirectExecutionSetCreateInfoEXT*(sType: VkStructureType = VkStructureType.IndirectExecutionSetCreateInfoEXT, pNext: pointer = nil, `type`: VkIndirectExecutionSetInfoTypeEXT, info: VkIndirectExecutionSetInfoEXT): VkIndirectExecutionSetCreateInfoEXT =
  result = VkIndirectExecutionSetCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    info: info,
  )

proc newVkGeneratedCommandsInfoEXT*(sType: VkStructureType = VkStructureType.GeneratedCommandsInfoEXT, pNext: pointer = nil, shaderStages: VkShaderStageFlags, indirectExecutionSet: VkIndirectExecutionSetEXT, indirectCommandsLayout: VkIndirectCommandsLayoutEXT, indirectAddress: VkDeviceAddress, indirectAddressSize: VkDeviceSize, preprocessAddress: VkDeviceAddress, preprocessSize: VkDeviceSize, maxSequenceCount: uint32, sequenceCountAddress: VkDeviceAddress, maxDrawCount: uint32): VkGeneratedCommandsInfoEXT =
  result = VkGeneratedCommandsInfoEXT(
    sType: sType,
    pNext: pNext,
    shaderStages: shaderStages,
    indirectExecutionSet: indirectExecutionSet,
    indirectCommandsLayout: indirectCommandsLayout,
    indirectAddress: indirectAddress,
    indirectAddressSize: indirectAddressSize,
    preprocessAddress: preprocessAddress,
    preprocessSize: preprocessSize,
    maxSequenceCount: maxSequenceCount,
    sequenceCountAddress: sequenceCountAddress,
    maxDrawCount: maxDrawCount,
  )

proc newVkWriteIndirectExecutionSetPipelineEXT*(sType: VkStructureType = VkStructureType.WriteIndirectExecutionSetPipelineEXT, pNext: pointer = nil, index: uint32, pipeline: VkPipeline): VkWriteIndirectExecutionSetPipelineEXT =
  result = VkWriteIndirectExecutionSetPipelineEXT(
    sType: sType,
    pNext: pNext,
    index: index,
    pipeline: pipeline,
  )

proc newVkWriteIndirectExecutionSetShaderEXT*(sType: VkStructureType = VkStructureType.WriteIndirectExecutionSetShaderEXT, pNext: pointer = nil, index: uint32, shader: VkShaderEXT): VkWriteIndirectExecutionSetShaderEXT =
  result = VkWriteIndirectExecutionSetShaderEXT(
    sType: sType,
    pNext: pNext,
    index: index,
    shader: shader,
  )

proc newVkIndirectCommandsLayoutCreateInfoEXT*(sType: VkStructureType = VkStructureType.IndirectCommandsLayoutCreateInfoEXT, pNext: pointer = nil, flags: VkIndirectCommandsLayoutUsageFlagsEXT = 0.VkIndirectCommandsLayoutUsageFlagsEXT, shaderStages: VkShaderStageFlags, indirectStride: uint32, pipelineLayout: VkPipelineLayout, tokens: openarray[VkIndirectCommandsLayoutTokenEXT]): VkIndirectCommandsLayoutCreateInfoEXT =
  result = VkIndirectCommandsLayoutCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    shaderStages: shaderStages,
    indirectStride: indirectStride,
    pipelineLayout: pipelineLayout,
    tokenCount: len(tokens).uint32,
    pTokens: if len(tokens) == 0: nil else: cast[ptr VkIndirectCommandsLayoutTokenEXT](tokens),
  )

proc newVkIndirectCommandsLayoutTokenEXT*(sType: VkStructureType = VkStructureType.IndirectCommandsLayoutTokenEXT, pNext: pointer = nil, `type`: VkIndirectCommandsTokenTypeEXT, data: VkIndirectCommandsTokenDataEXT, offset: uint32): VkIndirectCommandsLayoutTokenEXT =
  result = VkIndirectCommandsLayoutTokenEXT(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    data: data,
    offset: offset,
  )

proc newVkDrawIndirectCountIndirectCommandEXT*(bufferAddress: VkDeviceAddress, stride: uint32, commandCount: uint32): VkDrawIndirectCountIndirectCommandEXT =
  result = VkDrawIndirectCountIndirectCommandEXT(
    bufferAddress: bufferAddress,
    stride: stride,
    commandCount: commandCount,
  )

proc newVkIndirectCommandsVertexBufferTokenEXT*(vertexBindingUnit: uint32): VkIndirectCommandsVertexBufferTokenEXT =
  result = VkIndirectCommandsVertexBufferTokenEXT(
    vertexBindingUnit: vertexBindingUnit,
  )

proc newVkBindVertexBufferIndirectCommandEXT*(bufferAddress: VkDeviceAddress, size: uint32, stride: uint32): VkBindVertexBufferIndirectCommandEXT =
  result = VkBindVertexBufferIndirectCommandEXT(
    bufferAddress: bufferAddress,
    size: size,
    stride: stride,
  )

proc newVkIndirectCommandsIndexBufferTokenEXT*(mode: VkIndirectCommandsInputModeFlagBitsEXT): VkIndirectCommandsIndexBufferTokenEXT =
  result = VkIndirectCommandsIndexBufferTokenEXT(
    mode: mode,
  )

proc newVkBindIndexBufferIndirectCommandEXT*(bufferAddress: VkDeviceAddress, size: uint32, indexType: VkIndexType): VkBindIndexBufferIndirectCommandEXT =
  result = VkBindIndexBufferIndirectCommandEXT(
    bufferAddress: bufferAddress,
    size: size,
    indexType: indexType,
  )

proc newVkIndirectCommandsPushConstantTokenEXT*(updateRange: VkPushConstantRange): VkIndirectCommandsPushConstantTokenEXT =
  result = VkIndirectCommandsPushConstantTokenEXT(
    updateRange: updateRange,
  )

proc newVkIndirectCommandsExecutionSetTokenEXT*(`type`: VkIndirectExecutionSetInfoTypeEXT, shaderStages: VkShaderStageFlags): VkIndirectCommandsExecutionSetTokenEXT =
  result = VkIndirectCommandsExecutionSetTokenEXT(
    `type`: `type`,
    shaderStages: shaderStages,
  )

proc newVkPipelineViewportDepthClipControlCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineViewportDepthClipControlCreateInfoEXT, pNext: pointer = nil, negativeOneToOne: VkBool32): VkPipelineViewportDepthClipControlCreateInfoEXT =
  result = VkPipelineViewportDepthClipControlCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    negativeOneToOne: negativeOneToOne,
  )

proc newVkPhysicalDeviceDepthClampControlFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDepthClampControlFeaturesEXT, pNext: pointer = nil, depthClampControl: VkBool32): VkPhysicalDeviceDepthClampControlFeaturesEXT =
  result = VkPhysicalDeviceDepthClampControlFeaturesEXT(
    sType: sType,
    pNext: pNext,
    depthClampControl: depthClampControl,
  )

proc newVkPipelineViewportDepthClampControlCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineViewportDepthClampControlCreateInfoEXT, pNext: pointer = nil, depthClampMode: VkDepthClampModeEXT, pDepthClampRange: ptr VkDepthClampRangeEXT): VkPipelineViewportDepthClampControlCreateInfoEXT =
  result = VkPipelineViewportDepthClampControlCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    depthClampMode: depthClampMode,
    pDepthClampRange: pDepthClampRange,
  )

proc newVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceVertexInputDynamicStateFeaturesEXT, pNext: pointer = nil, vertexInputDynamicState: VkBool32): VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT =
  result = VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(
    sType: sType,
    pNext: pNext,
    vertexInputDynamicState: vertexInputDynamicState,
  )

proc newVkPhysicalDeviceExternalMemoryRDMAFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalMemoryRDMAFeaturesNV, pNext: pointer = nil, externalMemoryRDMA: VkBool32): VkPhysicalDeviceExternalMemoryRDMAFeaturesNV =
  result = VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(
    sType: sType,
    pNext: pNext,
    externalMemoryRDMA: externalMemoryRDMA,
  )

proc newVkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR, pNext: pointer = nil, shaderRelaxedExtendedInstruction: VkBool32): VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR =
  result = VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(
    sType: sType,
    pNext: pNext,
    shaderRelaxedExtendedInstruction: shaderRelaxedExtendedInstruction,
  )

proc newVkVertexInputBindingDescription2EXT*(sType: VkStructureType = VkStructureType.VertexInputBindingDescription2EXT, pNext: pointer = nil, binding: uint32, stride: uint32, inputRate: VkVertexInputRate, divisor: uint32): VkVertexInputBindingDescription2EXT =
  result = VkVertexInputBindingDescription2EXT(
    sType: sType,
    pNext: pNext,
    binding: binding,
    stride: stride,
    inputRate: inputRate,
    divisor: divisor,
  )

proc newVkVertexInputAttributeDescription2EXT*(sType: VkStructureType = VkStructureType.VertexInputAttributeDescription2EXT, pNext: pointer = nil, location: uint32, binding: uint32, format: VkFormat, offset: uint32): VkVertexInputAttributeDescription2EXT =
  result = VkVertexInputAttributeDescription2EXT(
    sType: sType,
    pNext: pNext,
    location: location,
    binding: binding,
    format: format,
    offset: offset,
  )

proc newVkPhysicalDeviceColorWriteEnableFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceColorWriteEnableFeaturesEXT, pNext: pointer = nil, colorWriteEnable: VkBool32): VkPhysicalDeviceColorWriteEnableFeaturesEXT =
  result = VkPhysicalDeviceColorWriteEnableFeaturesEXT(
    sType: sType,
    pNext: pNext,
    colorWriteEnable: colorWriteEnable,
  )

proc newVkPipelineColorWriteCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineColorWriteCreateInfoEXT, pNext: pointer = nil, colorWriteEnables: openarray[VkBool32]): VkPipelineColorWriteCreateInfoEXT =
  result = VkPipelineColorWriteCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    attachmentCount: len(colorWriteEnables).uint32,
    pColorWriteEnables: if len(colorWriteEnables) == 0: nil else: cast[ptr VkBool32](colorWriteEnables),
  )

proc newVkMemoryBarrier2*(sType: VkStructureType = VkStructureType.MemoryBarrier2, pNext: pointer = nil, srcStageMask: VkPipelineStageFlags2, srcAccessMask: VkAccessFlags2, dstStageMask: VkPipelineStageFlags2, dstAccessMask: VkAccessFlags2): VkMemoryBarrier2 =
  result = VkMemoryBarrier2(
    sType: sType,
    pNext: pNext,
    srcStageMask: srcStageMask,
    srcAccessMask: srcAccessMask,
    dstStageMask: dstStageMask,
    dstAccessMask: dstAccessMask,
  )

proc newVkImageMemoryBarrier2*(sType: VkStructureType = VkStructureType.ImageMemoryBarrier2, pNext: pointer = nil, srcStageMask: VkPipelineStageFlags2, srcAccessMask: VkAccessFlags2, dstStageMask: VkPipelineStageFlags2, dstAccessMask: VkAccessFlags2, oldLayout: VkImageLayout, newLayout: VkImageLayout, srcQueueFamilyIndex: uint32, dstQueueFamilyIndex: uint32, image: VkImage, subresourceRange: VkImageSubresourceRange): VkImageMemoryBarrier2 =
  result = VkImageMemoryBarrier2(
    sType: sType,
    pNext: pNext,
    srcStageMask: srcStageMask,
    srcAccessMask: srcAccessMask,
    dstStageMask: dstStageMask,
    dstAccessMask: dstAccessMask,
    oldLayout: oldLayout,
    newLayout: newLayout,
    srcQueueFamilyIndex: srcQueueFamilyIndex,
    dstQueueFamilyIndex: dstQueueFamilyIndex,
    image: image,
    subresourceRange: subresourceRange,
  )

proc newVkBufferMemoryBarrier2*(sType: VkStructureType = VkStructureType.BufferMemoryBarrier2, pNext: pointer = nil, srcStageMask: VkPipelineStageFlags2, srcAccessMask: VkAccessFlags2, dstStageMask: VkPipelineStageFlags2, dstAccessMask: VkAccessFlags2, srcQueueFamilyIndex: uint32, dstQueueFamilyIndex: uint32, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize): VkBufferMemoryBarrier2 =
  result = VkBufferMemoryBarrier2(
    sType: sType,
    pNext: pNext,
    srcStageMask: srcStageMask,
    srcAccessMask: srcAccessMask,
    dstStageMask: dstStageMask,
    dstAccessMask: dstAccessMask,
    srcQueueFamilyIndex: srcQueueFamilyIndex,
    dstQueueFamilyIndex: dstQueueFamilyIndex,
    buffer: buffer,
    offset: offset,
    size: size,
  )

proc newVkMemoryBarrierAccessFlags3KHR*(sType: VkStructureType = VkStructureType.MemoryBarrierAccessFlags3KHR, pNext: pointer = nil, srcAccessMask3: VkAccessFlags3KHR, dstAccessMask3: VkAccessFlags3KHR): VkMemoryBarrierAccessFlags3KHR =
  result = VkMemoryBarrierAccessFlags3KHR(
    sType: sType,
    pNext: pNext,
    srcAccessMask3: srcAccessMask3,
    dstAccessMask3: dstAccessMask3,
  )

proc newVkDependencyInfo*(sType: VkStructureType = VkStructureType.DependencyInfo, pNext: pointer = nil, dependencyFlags: VkDependencyFlags, memoryBarriers: openarray[VkMemoryBarrier2], bufferMemoryBarriers: openarray[VkBufferMemoryBarrier2], imageMemoryBarriers: openarray[VkImageMemoryBarrier2]): VkDependencyInfo =
  result = VkDependencyInfo(
    sType: sType,
    pNext: pNext,
    dependencyFlags: dependencyFlags,
    memoryBarrierCount: len(memoryBarriers).uint32,
    pMemoryBarriers: if len(memoryBarriers) == 0: nil else: cast[ptr VkMemoryBarrier2](memoryBarriers),
    bufferMemoryBarrierCount: len(bufferMemoryBarriers).uint32,
    pBufferMemoryBarriers: if len(bufferMemoryBarriers) == 0: nil else: cast[ptr VkBufferMemoryBarrier2](bufferMemoryBarriers),
    imageMemoryBarrierCount: len(imageMemoryBarriers).uint32,
    pImageMemoryBarriers: if len(imageMemoryBarriers) == 0: nil else: cast[ptr VkImageMemoryBarrier2](imageMemoryBarriers),
  )

proc newVkSemaphoreSubmitInfo*(sType: VkStructureType = VkStructureType.SemaphoreSubmitInfo, pNext: pointer = nil, semaphore: VkSemaphore, value: uint64, stageMask: VkPipelineStageFlags2, deviceIndex: uint32): VkSemaphoreSubmitInfo =
  result = VkSemaphoreSubmitInfo(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    value: value,
    stageMask: stageMask,
    deviceIndex: deviceIndex,
  )

proc newVkCommandBufferSubmitInfo*(sType: VkStructureType = VkStructureType.CommandBufferSubmitInfo, pNext: pointer = nil, commandBuffer: VkCommandBuffer, deviceMask: uint32): VkCommandBufferSubmitInfo =
  result = VkCommandBufferSubmitInfo(
    sType: sType,
    pNext: pNext,
    commandBuffer: commandBuffer,
    deviceMask: deviceMask,
  )

proc newVkSubmitInfo2*(sType: VkStructureType = VkStructureType.SubmitInfo2, pNext: pointer = nil, flags: VkSubmitFlags = 0.VkSubmitFlags, waitSemaphoreInfos: openarray[VkSemaphoreSubmitInfo], commandBufferInfos: openarray[VkCommandBufferSubmitInfo], signalSemaphoreInfos: openarray[VkSemaphoreSubmitInfo]): VkSubmitInfo2 =
  result = VkSubmitInfo2(
    sType: sType,
    pNext: pNext,
    flags: flags,
    waitSemaphoreInfoCount: len(waitSemaphoreInfos).uint32,
    pWaitSemaphoreInfos: if len(waitSemaphoreInfos) == 0: nil else: cast[ptr VkSemaphoreSubmitInfo](waitSemaphoreInfos),
    commandBufferInfoCount: len(commandBufferInfos).uint32,
    pCommandBufferInfos: if len(commandBufferInfos) == 0: nil else: cast[ptr VkCommandBufferSubmitInfo](commandBufferInfos),
    signalSemaphoreInfoCount: len(signalSemaphoreInfos).uint32,
    pSignalSemaphoreInfos: if len(signalSemaphoreInfos) == 0: nil else: cast[ptr VkSemaphoreSubmitInfo](signalSemaphoreInfos),
  )

proc newVkQueueFamilyCheckpointProperties2NV*(sType: VkStructureType = VkStructureType.QueueFamilyCheckpointProperties2NV, pNext: pointer = nil, checkpointExecutionStageMask: VkPipelineStageFlags2): VkQueueFamilyCheckpointProperties2NV =
  result = VkQueueFamilyCheckpointProperties2NV(
    sType: sType,
    pNext: pNext,
    checkpointExecutionStageMask: checkpointExecutionStageMask,
  )

proc newVkCheckpointData2NV*(sType: VkStructureType = VkStructureType.CheckpointData2NV, pNext: pointer = nil, stage: VkPipelineStageFlags2, pCheckpointMarker: pointer = nil): VkCheckpointData2NV =
  result = VkCheckpointData2NV(
    sType: sType,
    pNext: pNext,
    stage: stage,
    pCheckpointMarker: pCheckpointMarker,
  )

proc newVkPhysicalDeviceSynchronization2Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceSynchronization2Features, pNext: pointer = nil, synchronization2: VkBool32): VkPhysicalDeviceSynchronization2Features =
  result = VkPhysicalDeviceSynchronization2Features(
    sType: sType,
    pNext: pNext,
    synchronization2: synchronization2,
  )

proc newVkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceUnifiedImageLayoutsFeaturesKHR, pNext: pointer = nil, unifiedImageLayouts: VkBool32, unifiedImageLayoutsVideo: VkBool32): VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR =
  result = VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(
    sType: sType,
    pNext: pNext,
    unifiedImageLayouts: unifiedImageLayouts,
    unifiedImageLayoutsVideo: unifiedImageLayoutsVideo,
  )

proc newVkPhysicalDeviceHostImageCopyFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceHostImageCopyFeatures, pNext: pointer = nil, hostImageCopy: VkBool32): VkPhysicalDeviceHostImageCopyFeatures =
  result = VkPhysicalDeviceHostImageCopyFeatures(
    sType: sType,
    pNext: pNext,
    hostImageCopy: hostImageCopy,
  )

proc newVkPhysicalDeviceHostImageCopyProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceHostImageCopyProperties, pNext: pointer = nil, copySrcLayouts: openarray[VkImageLayout], copyDstLayouts: openarray[VkImageLayout], optimalTilingLayoutUUID: array[VK_UUID_SIZE, uint8], identicalMemoryTypeRequirements: VkBool32): VkPhysicalDeviceHostImageCopyProperties =
  result = VkPhysicalDeviceHostImageCopyProperties(
    sType: sType,
    pNext: pNext,
    copySrcLayoutCount: len(copySrcLayouts).uint32,
    pCopySrcLayouts: if len(copySrcLayouts) == 0: nil else: cast[ptr VkImageLayout](copySrcLayouts),
    copyDstLayoutCount: len(copyDstLayouts).uint32,
    pCopyDstLayouts: if len(copyDstLayouts) == 0: nil else: cast[ptr VkImageLayout](copyDstLayouts),
    optimalTilingLayoutUUID: optimalTilingLayoutUUID,
    identicalMemoryTypeRequirements: identicalMemoryTypeRequirements,
  )

proc newVkMemoryToImageCopy*(sType: VkStructureType = VkStructureType.MemoryToImageCopy, pNext: pointer = nil, pHostPointer: pointer = nil, memoryRowLength: uint32, memoryImageHeight: uint32, imageSubresource: VkImageSubresourceLayers, imageOffset: VkOffset3D, imageExtent: VkExtent3D): VkMemoryToImageCopy =
  result = VkMemoryToImageCopy(
    sType: sType,
    pNext: pNext,
    pHostPointer: pHostPointer,
    memoryRowLength: memoryRowLength,
    memoryImageHeight: memoryImageHeight,
    imageSubresource: imageSubresource,
    imageOffset: imageOffset,
    imageExtent: imageExtent,
  )

proc newVkImageToMemoryCopy*(sType: VkStructureType = VkStructureType.ImageToMemoryCopy, pNext: pointer = nil, pHostPointer: pointer = nil, memoryRowLength: uint32, memoryImageHeight: uint32, imageSubresource: VkImageSubresourceLayers, imageOffset: VkOffset3D, imageExtent: VkExtent3D): VkImageToMemoryCopy =
  result = VkImageToMemoryCopy(
    sType: sType,
    pNext: pNext,
    pHostPointer: pHostPointer,
    memoryRowLength: memoryRowLength,
    memoryImageHeight: memoryImageHeight,
    imageSubresource: imageSubresource,
    imageOffset: imageOffset,
    imageExtent: imageExtent,
  )

proc newVkCopyMemoryToImageInfo*(sType: VkStructureType = VkStructureType.CopyMemoryToImageInfo, pNext: pointer = nil, flags: VkHostImageCopyFlags = 0.VkHostImageCopyFlags, dstImage: VkImage, dstImageLayout: VkImageLayout, regions: openarray[VkMemoryToImageCopy]): VkCopyMemoryToImageInfo =
  result = VkCopyMemoryToImageInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    dstImage: dstImage,
    dstImageLayout: dstImageLayout,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkMemoryToImageCopy](regions),
  )

proc newVkCopyImageToMemoryInfo*(sType: VkStructureType = VkStructureType.CopyImageToMemoryInfo, pNext: pointer = nil, flags: VkHostImageCopyFlags = 0.VkHostImageCopyFlags, srcImage: VkImage, srcImageLayout: VkImageLayout, regions: openarray[VkImageToMemoryCopy]): VkCopyImageToMemoryInfo =
  result = VkCopyImageToMemoryInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    srcImage: srcImage,
    srcImageLayout: srcImageLayout,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkImageToMemoryCopy](regions),
  )

proc newVkCopyImageToImageInfo*(sType: VkStructureType = VkStructureType.CopyImageToImageInfo, pNext: pointer = nil, flags: VkHostImageCopyFlags = 0.VkHostImageCopyFlags, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regions: openarray[VkImageCopy2]): VkCopyImageToImageInfo =
  result = VkCopyImageToImageInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    srcImage: srcImage,
    srcImageLayout: srcImageLayout,
    dstImage: dstImage,
    dstImageLayout: dstImageLayout,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkImageCopy2](regions),
  )

proc newVkHostImageLayoutTransitionInfo*(sType: VkStructureType = VkStructureType.HostImageLayoutTransitionInfo, pNext: pointer = nil, image: VkImage, oldLayout: VkImageLayout, newLayout: VkImageLayout, subresourceRange: VkImageSubresourceRange): VkHostImageLayoutTransitionInfo =
  result = VkHostImageLayoutTransitionInfo(
    sType: sType,
    pNext: pNext,
    image: image,
    oldLayout: oldLayout,
    newLayout: newLayout,
    subresourceRange: subresourceRange,
  )

proc newVkSubresourceHostMemcpySize*(sType: VkStructureType = VkStructureType.SubresourceHostMemcpySize, pNext: pointer = nil, size: VkDeviceSize): VkSubresourceHostMemcpySize =
  result = VkSubresourceHostMemcpySize(
    sType: sType,
    pNext: pNext,
    size: size,
  )

proc newVkHostImageCopyDevicePerformanceQuery*(sType: VkStructureType = VkStructureType.HostImageCopyDevicePerformanceQuery, pNext: pointer = nil, optimalDeviceAccess: VkBool32, identicalMemoryLayout: VkBool32): VkHostImageCopyDevicePerformanceQuery =
  result = VkHostImageCopyDevicePerformanceQuery(
    sType: sType,
    pNext: pNext,
    optimalDeviceAccess: optimalDeviceAccess,
    identicalMemoryLayout: identicalMemoryLayout,
  )

proc newVkPhysicalDeviceVulkanSC10Properties*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkanSC10Properties, pNext: pointer = nil, deviceNoDynamicHostAllocations: VkBool32, deviceDestroyFreesMemory: VkBool32, commandPoolMultipleCommandBuffersRecording: VkBool32, commandPoolResetCommandBuffer: VkBool32, commandBufferSimultaneousUse: VkBool32, secondaryCommandBufferNullOrImagelessFramebuffer: VkBool32, recycleDescriptorSetMemory: VkBool32, recyclePipelineMemory: VkBool32, maxRenderPassSubpasses: uint32, maxRenderPassDependencies: uint32, maxSubpassInputAttachments: uint32, maxSubpassPreserveAttachments: uint32, maxFramebufferAttachments: uint32, maxDescriptorSetLayoutBindings: uint32, maxQueryFaultCount: uint32, maxCallbackFaultCount: uint32, maxCommandPoolCommandBuffers: uint32, maxCommandBufferSize: VkDeviceSize): VkPhysicalDeviceVulkanSC10Properties =
  result = VkPhysicalDeviceVulkanSC10Properties(
    sType: sType,
    pNext: pNext,
    deviceNoDynamicHostAllocations: deviceNoDynamicHostAllocations,
    deviceDestroyFreesMemory: deviceDestroyFreesMemory,
    commandPoolMultipleCommandBuffersRecording: commandPoolMultipleCommandBuffersRecording,
    commandPoolResetCommandBuffer: commandPoolResetCommandBuffer,
    commandBufferSimultaneousUse: commandBufferSimultaneousUse,
    secondaryCommandBufferNullOrImagelessFramebuffer: secondaryCommandBufferNullOrImagelessFramebuffer,
    recycleDescriptorSetMemory: recycleDescriptorSetMemory,
    recyclePipelineMemory: recyclePipelineMemory,
    maxRenderPassSubpasses: maxRenderPassSubpasses,
    maxRenderPassDependencies: maxRenderPassDependencies,
    maxSubpassInputAttachments: maxSubpassInputAttachments,
    maxSubpassPreserveAttachments: maxSubpassPreserveAttachments,
    maxFramebufferAttachments: maxFramebufferAttachments,
    maxDescriptorSetLayoutBindings: maxDescriptorSetLayoutBindings,
    maxQueryFaultCount: maxQueryFaultCount,
    maxCallbackFaultCount: maxCallbackFaultCount,
    maxCommandPoolCommandBuffers: maxCommandPoolCommandBuffers,
    maxCommandBufferSize: maxCommandBufferSize,
  )

proc newVkPipelinePoolSize*(sType: VkStructureType = VkStructureType.PipelinePoolSize, pNext: pointer = nil, poolEntrySize: VkDeviceSize, poolEntryCount: uint32): VkPipelinePoolSize =
  result = VkPipelinePoolSize(
    sType: sType,
    pNext: pNext,
    poolEntrySize: poolEntrySize,
    poolEntryCount: poolEntryCount,
  )

proc newVkDeviceObjectReservationCreateInfo*(sType: VkStructureType = VkStructureType.DeviceObjectReservationCreateInfo, pNext: pointer = nil, pipelineCacheCreateInfos: openarray[VkPipelineCacheCreateInfo], pipelinePoolSizes: openarray[VkPipelinePoolSize], semaphoreRequestCount: uint32, commandBufferRequestCount: uint32, fenceRequestCount: uint32, deviceMemoryRequestCount: uint32, bufferRequestCount: uint32, imageRequestCount: uint32, eventRequestCount: uint32, queryPoolRequestCount: uint32, bufferViewRequestCount: uint32, imageViewRequestCount: uint32, layeredImageViewRequestCount: uint32, pipelineCacheRequestCount: uint32, pipelineLayoutRequestCount: uint32, renderPassRequestCount: uint32, graphicsPipelineRequestCount: uint32, computePipelineRequestCount: uint32, descriptorSetLayoutRequestCount: uint32, samplerRequestCount: uint32, descriptorPoolRequestCount: uint32, descriptorSetRequestCount: uint32, framebufferRequestCount: uint32, commandPoolRequestCount: uint32, samplerYcbcrConversionRequestCount: uint32, surfaceRequestCount: uint32, swapchainRequestCount: uint32, displayModeRequestCount: uint32, subpassDescriptionRequestCount: uint32, attachmentDescriptionRequestCount: uint32, descriptorSetLayoutBindingRequestCount: uint32, descriptorSetLayoutBindingLimit: uint32, maxImageViewMipLevels: uint32, maxImageViewArrayLayers: uint32, maxLayeredImageViewMipLevels: uint32, maxOcclusionQueriesPerPool: uint32, maxPipelineStatisticsQueriesPerPool: uint32, maxTimestampQueriesPerPool: uint32, maxImmutableSamplersPerDescriptorSetLayout: uint32): VkDeviceObjectReservationCreateInfo =
  result = VkDeviceObjectReservationCreateInfo(
    sType: sType,
    pNext: pNext,
    pipelineCacheCreateInfoCount: len(pipelineCacheCreateInfos).uint32,
    pPipelineCacheCreateInfos: if len(pipelineCacheCreateInfos) == 0: nil else: cast[ptr VkPipelineCacheCreateInfo](pipelineCacheCreateInfos),
    pipelinePoolSizeCount: len(pipelinePoolSizes).uint32,
    pPipelinePoolSizes: if len(pipelinePoolSizes) == 0: nil else: cast[ptr VkPipelinePoolSize](pipelinePoolSizes),
    semaphoreRequestCount: semaphoreRequestCount,
    commandBufferRequestCount: commandBufferRequestCount,
    fenceRequestCount: fenceRequestCount,
    deviceMemoryRequestCount: deviceMemoryRequestCount,
    bufferRequestCount: bufferRequestCount,
    imageRequestCount: imageRequestCount,
    eventRequestCount: eventRequestCount,
    queryPoolRequestCount: queryPoolRequestCount,
    bufferViewRequestCount: bufferViewRequestCount,
    imageViewRequestCount: imageViewRequestCount,
    layeredImageViewRequestCount: layeredImageViewRequestCount,
    pipelineCacheRequestCount: pipelineCacheRequestCount,
    pipelineLayoutRequestCount: pipelineLayoutRequestCount,
    renderPassRequestCount: renderPassRequestCount,
    graphicsPipelineRequestCount: graphicsPipelineRequestCount,
    computePipelineRequestCount: computePipelineRequestCount,
    descriptorSetLayoutRequestCount: descriptorSetLayoutRequestCount,
    samplerRequestCount: samplerRequestCount,
    descriptorPoolRequestCount: descriptorPoolRequestCount,
    descriptorSetRequestCount: descriptorSetRequestCount,
    framebufferRequestCount: framebufferRequestCount,
    commandPoolRequestCount: commandPoolRequestCount,
    samplerYcbcrConversionRequestCount: samplerYcbcrConversionRequestCount,
    surfaceRequestCount: surfaceRequestCount,
    swapchainRequestCount: swapchainRequestCount,
    displayModeRequestCount: displayModeRequestCount,
    subpassDescriptionRequestCount: subpassDescriptionRequestCount,
    attachmentDescriptionRequestCount: attachmentDescriptionRequestCount,
    descriptorSetLayoutBindingRequestCount: descriptorSetLayoutBindingRequestCount,
    descriptorSetLayoutBindingLimit: descriptorSetLayoutBindingLimit,
    maxImageViewMipLevels: maxImageViewMipLevels,
    maxImageViewArrayLayers: maxImageViewArrayLayers,
    maxLayeredImageViewMipLevels: maxLayeredImageViewMipLevels,
    maxOcclusionQueriesPerPool: maxOcclusionQueriesPerPool,
    maxPipelineStatisticsQueriesPerPool: maxPipelineStatisticsQueriesPerPool,
    maxTimestampQueriesPerPool: maxTimestampQueriesPerPool,
    maxImmutableSamplersPerDescriptorSetLayout: maxImmutableSamplersPerDescriptorSetLayout,
  )

proc newVkCommandPoolMemoryReservationCreateInfo*(sType: VkStructureType = VkStructureType.CommandPoolMemoryReservationCreateInfo, pNext: pointer = nil, commandPoolReservedSize: VkDeviceSize, commandPoolMaxCommandBuffers: uint32): VkCommandPoolMemoryReservationCreateInfo =
  result = VkCommandPoolMemoryReservationCreateInfo(
    sType: sType,
    pNext: pNext,
    commandPoolReservedSize: commandPoolReservedSize,
    commandPoolMaxCommandBuffers: commandPoolMaxCommandBuffers,
  )

proc newVkCommandPoolMemoryConsumption*(sType: VkStructureType = VkStructureType.CommandPoolMemoryConsumption, pNext: pointer = nil, commandPoolAllocated: VkDeviceSize, commandPoolReservedSize: VkDeviceSize, commandBufferAllocated: VkDeviceSize): VkCommandPoolMemoryConsumption =
  result = VkCommandPoolMemoryConsumption(
    sType: sType,
    pNext: pNext,
    commandPoolAllocated: commandPoolAllocated,
    commandPoolReservedSize: commandPoolReservedSize,
    commandBufferAllocated: commandBufferAllocated,
  )

proc newVkPhysicalDeviceVulkanSC10Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceVulkanSC10Features, pNext: pointer = nil, shaderAtomicInstructions: VkBool32): VkPhysicalDeviceVulkanSC10Features =
  result = VkPhysicalDeviceVulkanSC10Features(
    sType: sType,
    pNext: pNext,
    shaderAtomicInstructions: shaderAtomicInstructions,
  )

proc newVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, pNext: pointer = nil, primitivesGeneratedQuery: VkBool32, primitivesGeneratedQueryWithRasterizerDiscard: VkBool32, primitivesGeneratedQueryWithNonZeroStreams: VkBool32): VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT =
  result = VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(
    sType: sType,
    pNext: pNext,
    primitivesGeneratedQuery: primitivesGeneratedQuery,
    primitivesGeneratedQueryWithRasterizerDiscard: primitivesGeneratedQueryWithRasterizerDiscard,
    primitivesGeneratedQueryWithNonZeroStreams: primitivesGeneratedQueryWithNonZeroStreams,
  )

proc newVkPhysicalDeviceLegacyDitheringFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceLegacyDitheringFeaturesEXT, pNext: pointer = nil, legacyDithering: VkBool32): VkPhysicalDeviceLegacyDitheringFeaturesEXT =
  result = VkPhysicalDeviceLegacyDitheringFeaturesEXT(
    sType: sType,
    pNext: pNext,
    legacyDithering: legacyDithering,
  )

proc newVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, pNext: pointer = nil, multisampledRenderToSingleSampled: VkBool32): VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT =
  result = VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(
    sType: sType,
    pNext: pNext,
    multisampledRenderToSingleSampled: multisampledRenderToSingleSampled,
  )

proc newVkSurfaceCapabilitiesPresentId2KHR*(sType: VkStructureType = VkStructureType.SurfaceCapabilitiesPresentId2KHR, pNext: pointer = nil, presentId2Supported: VkBool32): VkSurfaceCapabilitiesPresentId2KHR =
  result = VkSurfaceCapabilitiesPresentId2KHR(
    sType: sType,
    pNext: pNext,
    presentId2Supported: presentId2Supported,
  )

proc newVkSurfaceCapabilitiesPresentWait2KHR*(sType: VkStructureType = VkStructureType.SurfaceCapabilitiesPresentWait2KHR, pNext: pointer = nil, presentWait2Supported: VkBool32): VkSurfaceCapabilitiesPresentWait2KHR =
  result = VkSurfaceCapabilitiesPresentWait2KHR(
    sType: sType,
    pNext: pNext,
    presentWait2Supported: presentWait2Supported,
  )

proc newVkSubpassResolvePerformanceQueryEXT*(sType: VkStructureType = VkStructureType.SubpassResolvePerformanceQueryEXT, pNext: pointer = nil, optimal: VkBool32): VkSubpassResolvePerformanceQueryEXT =
  result = VkSubpassResolvePerformanceQueryEXT(
    sType: sType,
    pNext: pNext,
    optimal: optimal,
  )

proc newVkMultisampledRenderToSingleSampledInfoEXT*(sType: VkStructureType = VkStructureType.MultisampledRenderToSingleSampledInfoEXT, pNext: pointer = nil, multisampledRenderToSingleSampledEnable: VkBool32, rasterizationSamples: VkSampleCountFlagBits): VkMultisampledRenderToSingleSampledInfoEXT =
  result = VkMultisampledRenderToSingleSampledInfoEXT(
    sType: sType,
    pNext: pNext,
    multisampledRenderToSingleSampledEnable: multisampledRenderToSingleSampledEnable,
    rasterizationSamples: rasterizationSamples,
  )

proc newVkPhysicalDevicePipelineProtectedAccessFeatures*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineProtectedAccessFeatures, pNext: pointer = nil, pipelineProtectedAccess: VkBool32): VkPhysicalDevicePipelineProtectedAccessFeatures =
  result = VkPhysicalDevicePipelineProtectedAccessFeatures(
    sType: sType,
    pNext: pNext,
    pipelineProtectedAccess: pipelineProtectedAccess,
  )

proc newVkQueueFamilyVideoPropertiesKHR*(sType: VkStructureType = VkStructureType.QueueFamilyVideoPropertiesKHR, pNext: pointer = nil, videoCodecOperations: VkVideoCodecOperationFlagsKHR): VkQueueFamilyVideoPropertiesKHR =
  result = VkQueueFamilyVideoPropertiesKHR(
    sType: sType,
    pNext: pNext,
    videoCodecOperations: videoCodecOperations,
  )

proc newVkQueueFamilyQueryResultStatusPropertiesKHR*(sType: VkStructureType = VkStructureType.QueueFamilyQueryResultStatusPropertiesKHR, pNext: pointer = nil, queryResultStatusSupport: VkBool32): VkQueueFamilyQueryResultStatusPropertiesKHR =
  result = VkQueueFamilyQueryResultStatusPropertiesKHR(
    sType: sType,
    pNext: pNext,
    queryResultStatusSupport: queryResultStatusSupport,
  )

proc newVkVideoProfileListInfoKHR*(sType: VkStructureType = VkStructureType.VideoProfileListInfoKHR, pNext: pointer = nil, profiles: openarray[VkVideoProfileInfoKHR]): VkVideoProfileListInfoKHR =
  result = VkVideoProfileListInfoKHR(
    sType: sType,
    pNext: pNext,
    profileCount: len(profiles).uint32,
    pProfiles: if len(profiles) == 0: nil else: cast[ptr VkVideoProfileInfoKHR](profiles),
  )

proc newVkPhysicalDeviceVideoFormatInfoKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceVideoFormatInfoKHR, pNext: pointer = nil, imageUsage: VkImageUsageFlags): VkPhysicalDeviceVideoFormatInfoKHR =
  result = VkPhysicalDeviceVideoFormatInfoKHR(
    sType: sType,
    pNext: pNext,
    imageUsage: imageUsage,
  )

proc newVkVideoFormatPropertiesKHR*(sType: VkStructureType = VkStructureType.VideoFormatPropertiesKHR, pNext: pointer = nil, format: VkFormat, componentMapping: VkComponentMapping, imageCreateFlags: VkImageCreateFlags, imageType: VkImageType, imageTiling: VkImageTiling, imageUsageFlags: VkImageUsageFlags): VkVideoFormatPropertiesKHR =
  result = VkVideoFormatPropertiesKHR(
    sType: sType,
    pNext: pNext,
    format: format,
    componentMapping: componentMapping,
    imageCreateFlags: imageCreateFlags,
    imageType: imageType,
    imageTiling: imageTiling,
    imageUsageFlags: imageUsageFlags,
  )

proc newVkVideoEncodeQuantizationMapCapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeQuantizationMapCapabilitiesKHR, pNext: pointer = nil, maxQuantizationMapExtent: VkExtent2D): VkVideoEncodeQuantizationMapCapabilitiesKHR =
  result = VkVideoEncodeQuantizationMapCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    maxQuantizationMapExtent: maxQuantizationMapExtent,
  )

proc newVkVideoEncodeH264QuantizationMapCapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264QuantizationMapCapabilitiesKHR, pNext: pointer = nil, minQpDelta: int32, maxQpDelta: int32): VkVideoEncodeH264QuantizationMapCapabilitiesKHR =
  result = VkVideoEncodeH264QuantizationMapCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    minQpDelta: minQpDelta,
    maxQpDelta: maxQpDelta,
  )

proc newVkVideoEncodeH265QuantizationMapCapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265QuantizationMapCapabilitiesKHR, pNext: pointer = nil, minQpDelta: int32, maxQpDelta: int32): VkVideoEncodeH265QuantizationMapCapabilitiesKHR =
  result = VkVideoEncodeH265QuantizationMapCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    minQpDelta: minQpDelta,
    maxQpDelta: maxQpDelta,
  )

proc newVkVideoEncodeAV1QuantizationMapCapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1QuantizationMapCapabilitiesKHR, pNext: pointer = nil, minQIndexDelta: int32, maxQIndexDelta: int32): VkVideoEncodeAV1QuantizationMapCapabilitiesKHR =
  result = VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    minQIndexDelta: minQIndexDelta,
    maxQIndexDelta: maxQIndexDelta,
  )

proc newVkVideoFormatQuantizationMapPropertiesKHR*(sType: VkStructureType = VkStructureType.VideoFormatQuantizationMapPropertiesKHR, pNext: pointer = nil, quantizationMapTexelSize: VkExtent2D): VkVideoFormatQuantizationMapPropertiesKHR =
  result = VkVideoFormatQuantizationMapPropertiesKHR(
    sType: sType,
    pNext: pNext,
    quantizationMapTexelSize: quantizationMapTexelSize,
  )

proc newVkVideoFormatH265QuantizationMapPropertiesKHR*(sType: VkStructureType = VkStructureType.VideoFormatH265QuantizationMapPropertiesKHR, pNext: pointer = nil, compatibleCtbSizes: VkVideoEncodeH265CtbSizeFlagsKHR): VkVideoFormatH265QuantizationMapPropertiesKHR =
  result = VkVideoFormatH265QuantizationMapPropertiesKHR(
    sType: sType,
    pNext: pNext,
    compatibleCtbSizes: compatibleCtbSizes,
  )

proc newVkVideoFormatAV1QuantizationMapPropertiesKHR*(sType: VkStructureType = VkStructureType.VideoFormatAV1QuantizationMapPropertiesKHR, pNext: pointer = nil, compatibleSuperblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR): VkVideoFormatAV1QuantizationMapPropertiesKHR =
  result = VkVideoFormatAV1QuantizationMapPropertiesKHR(
    sType: sType,
    pNext: pNext,
    compatibleSuperblockSizes: compatibleSuperblockSizes,
  )

proc newVkVideoProfileInfoKHR*(sType: VkStructureType = VkStructureType.VideoProfileInfoKHR, pNext: pointer = nil, videoCodecOperation: VkVideoCodecOperationFlagBitsKHR, chromaSubsampling: VkVideoChromaSubsamplingFlagsKHR, lumaBitDepth: VkVideoComponentBitDepthFlagsKHR, chromaBitDepth: VkVideoComponentBitDepthFlagsKHR): VkVideoProfileInfoKHR =
  result = VkVideoProfileInfoKHR(
    sType: sType,
    pNext: pNext,
    videoCodecOperation: videoCodecOperation,
    chromaSubsampling: chromaSubsampling,
    lumaBitDepth: lumaBitDepth,
    chromaBitDepth: chromaBitDepth,
  )

proc newVkVideoCapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoCapabilitiesKHR, pNext: pointer = nil, flags: VkVideoCapabilityFlagsKHR = 0.VkVideoCapabilityFlagsKHR, minBitstreamBufferOffsetAlignment: VkDeviceSize, minBitstreamBufferSizeAlignment: VkDeviceSize, pictureAccessGranularity: VkExtent2D, minCodedExtent: VkExtent2D, maxCodedExtent: VkExtent2D, maxDpbSlots: uint32, maxActiveReferencePictures: uint32, stdHeaderVersion: VkExtensionProperties): VkVideoCapabilitiesKHR =
  result = VkVideoCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    minBitstreamBufferOffsetAlignment: minBitstreamBufferOffsetAlignment,
    minBitstreamBufferSizeAlignment: minBitstreamBufferSizeAlignment,
    pictureAccessGranularity: pictureAccessGranularity,
    minCodedExtent: minCodedExtent,
    maxCodedExtent: maxCodedExtent,
    maxDpbSlots: maxDpbSlots,
    maxActiveReferencePictures: maxActiveReferencePictures,
    stdHeaderVersion: stdHeaderVersion,
  )

proc newVkVideoSessionMemoryRequirementsKHR*(sType: VkStructureType = VkStructureType.VideoSessionMemoryRequirementsKHR, pNext: pointer = nil, memoryBindIndex: uint32, memoryRequirements: VkMemoryRequirements): VkVideoSessionMemoryRequirementsKHR =
  result = VkVideoSessionMemoryRequirementsKHR(
    sType: sType,
    pNext: pNext,
    memoryBindIndex: memoryBindIndex,
    memoryRequirements: memoryRequirements,
  )

proc newVkBindVideoSessionMemoryInfoKHR*(sType: VkStructureType = VkStructureType.BindVideoSessionMemoryInfoKHR, pNext: pointer = nil, memoryBindIndex: uint32, memory: VkDeviceMemory, memoryOffset: VkDeviceSize, memorySize: VkDeviceSize): VkBindVideoSessionMemoryInfoKHR =
  result = VkBindVideoSessionMemoryInfoKHR(
    sType: sType,
    pNext: pNext,
    memoryBindIndex: memoryBindIndex,
    memory: memory,
    memoryOffset: memoryOffset,
    memorySize: memorySize,
  )

proc newVkVideoPictureResourceInfoKHR*(sType: VkStructureType = VkStructureType.VideoPictureResourceInfoKHR, pNext: pointer = nil, codedOffset: VkOffset2D, codedExtent: VkExtent2D, baseArrayLayer: uint32, imageViewBinding: VkImageView): VkVideoPictureResourceInfoKHR =
  result = VkVideoPictureResourceInfoKHR(
    sType: sType,
    pNext: pNext,
    codedOffset: codedOffset,
    codedExtent: codedExtent,
    baseArrayLayer: baseArrayLayer,
    imageViewBinding: imageViewBinding,
  )

proc newVkVideoReferenceSlotInfoKHR*(sType: VkStructureType = VkStructureType.VideoReferenceSlotInfoKHR, pNext: pointer = nil, slotIndex: int32, pPictureResource: ptr VkVideoPictureResourceInfoKHR): VkVideoReferenceSlotInfoKHR =
  result = VkVideoReferenceSlotInfoKHR(
    sType: sType,
    pNext: pNext,
    slotIndex: slotIndex,
    pPictureResource: pPictureResource,
  )

proc newVkVideoDecodeCapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoDecodeCapabilitiesKHR, pNext: pointer = nil, flags: VkVideoDecodeCapabilityFlagsKHR = 0.VkVideoDecodeCapabilityFlagsKHR): VkVideoDecodeCapabilitiesKHR =
  result = VkVideoDecodeCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkVideoDecodeUsageInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeUsageInfoKHR, pNext: pointer = nil, videoUsageHints: VkVideoDecodeUsageFlagsKHR): VkVideoDecodeUsageInfoKHR =
  result = VkVideoDecodeUsageInfoKHR(
    sType: sType,
    pNext: pNext,
    videoUsageHints: videoUsageHints,
  )

proc newVkVideoDecodeInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeInfoKHR, pNext: pointer = nil, flags: VkVideoDecodeFlagsKHR = 0.VkVideoDecodeFlagsKHR, srcBuffer: VkBuffer, srcBufferOffset: VkDeviceSize, srcBufferRange: VkDeviceSize, dstPictureResource: VkVideoPictureResourceInfoKHR, pSetupReferenceSlot: ptr VkVideoReferenceSlotInfoKHR, referenceSlots: openarray[VkVideoReferenceSlotInfoKHR]): VkVideoDecodeInfoKHR =
  result = VkVideoDecodeInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    srcBuffer: srcBuffer,
    srcBufferOffset: srcBufferOffset,
    srcBufferRange: srcBufferRange,
    dstPictureResource: dstPictureResource,
    pSetupReferenceSlot: pSetupReferenceSlot,
    referenceSlotCount: len(referenceSlots).uint32,
    pReferenceSlots: if len(referenceSlots) == 0: nil else: cast[ptr VkVideoReferenceSlotInfoKHR](referenceSlots),
  )

proc newVkPhysicalDeviceVideoMaintenance1FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceVideoMaintenance1FeaturesKHR, pNext: pointer = nil, videoMaintenance1: VkBool32): VkPhysicalDeviceVideoMaintenance1FeaturesKHR =
  result = VkPhysicalDeviceVideoMaintenance1FeaturesKHR(
    sType: sType,
    pNext: pNext,
    videoMaintenance1: videoMaintenance1,
  )

proc newVkPhysicalDeviceVideoMaintenance2FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceVideoMaintenance2FeaturesKHR, pNext: pointer = nil, videoMaintenance2: VkBool32): VkPhysicalDeviceVideoMaintenance2FeaturesKHR =
  result = VkPhysicalDeviceVideoMaintenance2FeaturesKHR(
    sType: sType,
    pNext: pNext,
    videoMaintenance2: videoMaintenance2,
  )

proc newVkVideoInlineQueryInfoKHR*(sType: VkStructureType = VkStructureType.VideoInlineQueryInfoKHR, pNext: pointer = nil, queryPool: VkQueryPool, firstQuery: uint32, queryCount: uint32): VkVideoInlineQueryInfoKHR =
  result = VkVideoInlineQueryInfoKHR(
    sType: sType,
    pNext: pNext,
    queryPool: queryPool,
    firstQuery: firstQuery,
    queryCount: queryCount,
  )

proc newVkVideoDecodeH264ProfileInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH264ProfileInfoKHR, pNext: pointer = nil, stdProfileIdc: StdVideoH264ProfileIdc, pictureLayout: VkVideoDecodeH264PictureLayoutFlagBitsKHR): VkVideoDecodeH264ProfileInfoKHR =
  result = VkVideoDecodeH264ProfileInfoKHR(
    sType: sType,
    pNext: pNext,
    stdProfileIdc: stdProfileIdc,
    pictureLayout: pictureLayout,
  )

proc newVkVideoDecodeH264CapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH264CapabilitiesKHR, pNext: pointer = nil, maxLevelIdc: StdVideoH264LevelIdc, fieldOffsetGranularity: VkOffset2D): VkVideoDecodeH264CapabilitiesKHR =
  result = VkVideoDecodeH264CapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    maxLevelIdc: maxLevelIdc,
    fieldOffsetGranularity: fieldOffsetGranularity,
  )

proc newVkVideoDecodeH264SessionParametersAddInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH264SessionParametersAddInfoKHR, pNext: pointer = nil, stdSPSs: openarray[StdVideoH264SequenceParameterSet], stdPPSs: openarray[StdVideoH264PictureParameterSet]): VkVideoDecodeH264SessionParametersAddInfoKHR =
  result = VkVideoDecodeH264SessionParametersAddInfoKHR(
    sType: sType,
    pNext: pNext,
    stdSPSCount: len(stdSPSs).uint32,
    pStdSPSs: if len(stdSPSs) == 0: nil else: cast[ptr StdVideoH264SequenceParameterSet](stdSPSs),
    stdPPSCount: len(stdPPSs).uint32,
    pStdPPSs: if len(stdPPSs) == 0: nil else: cast[ptr StdVideoH264PictureParameterSet](stdPPSs),
  )

proc newVkVideoDecodeH264SessionParametersCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH264SessionParametersCreateInfoKHR, pNext: pointer = nil, maxStdSPSCount: uint32, maxStdPPSCount: uint32, pParametersAddInfo: ptr VkVideoDecodeH264SessionParametersAddInfoKHR): VkVideoDecodeH264SessionParametersCreateInfoKHR =
  result = VkVideoDecodeH264SessionParametersCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    maxStdSPSCount: maxStdSPSCount,
    maxStdPPSCount: maxStdPPSCount,
    pParametersAddInfo: pParametersAddInfo,
  )

proc newVkVideoDecodeH264InlineSessionParametersInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH264InlineSessionParametersInfoKHR, pNext: pointer = nil, pStdSPS: ptr StdVideoH264SequenceParameterSet, pStdPPS: ptr StdVideoH264PictureParameterSet): VkVideoDecodeH264InlineSessionParametersInfoKHR =
  result = VkVideoDecodeH264InlineSessionParametersInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdSPS: pStdSPS,
    pStdPPS: pStdPPS,
  )

proc newVkVideoDecodeH264PictureInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH264PictureInfoKHR, pNext: pointer = nil, pStdPictureInfo: ptr StdVideoDecodeH264PictureInfo, sliceOffsets: openarray[uint32]): VkVideoDecodeH264PictureInfoKHR =
  result = VkVideoDecodeH264PictureInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdPictureInfo: pStdPictureInfo,
    sliceCount: len(sliceOffsets).uint32,
    pSliceOffsets: if len(sliceOffsets) == 0: nil else: cast[ptr uint32](sliceOffsets),
  )

proc newVkVideoDecodeH264DpbSlotInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH264DpbSlotInfoKHR, pNext: pointer = nil, pStdReferenceInfo: ptr StdVideoDecodeH264ReferenceInfo): VkVideoDecodeH264DpbSlotInfoKHR =
  result = VkVideoDecodeH264DpbSlotInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdReferenceInfo: pStdReferenceInfo,
  )

proc newVkVideoDecodeH265ProfileInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH265ProfileInfoKHR, pNext: pointer = nil, stdProfileIdc: StdVideoH265ProfileIdc): VkVideoDecodeH265ProfileInfoKHR =
  result = VkVideoDecodeH265ProfileInfoKHR(
    sType: sType,
    pNext: pNext,
    stdProfileIdc: stdProfileIdc,
  )

proc newVkVideoDecodeH265CapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH265CapabilitiesKHR, pNext: pointer = nil, maxLevelIdc: StdVideoH265LevelIdc): VkVideoDecodeH265CapabilitiesKHR =
  result = VkVideoDecodeH265CapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    maxLevelIdc: maxLevelIdc,
  )

proc newVkVideoDecodeH265SessionParametersAddInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH265SessionParametersAddInfoKHR, pNext: pointer = nil, stdVPSs: openarray[StdVideoH265VideoParameterSet], stdSPSs: openarray[StdVideoH265SequenceParameterSet], stdPPSs: openarray[StdVideoH265PictureParameterSet]): VkVideoDecodeH265SessionParametersAddInfoKHR =
  result = VkVideoDecodeH265SessionParametersAddInfoKHR(
    sType: sType,
    pNext: pNext,
    stdVPSCount: len(stdVPSs).uint32,
    pStdVPSs: if len(stdVPSs) == 0: nil else: cast[ptr StdVideoH265VideoParameterSet](stdVPSs),
    stdSPSCount: len(stdSPSs).uint32,
    pStdSPSs: if len(stdSPSs) == 0: nil else: cast[ptr StdVideoH265SequenceParameterSet](stdSPSs),
    stdPPSCount: len(stdPPSs).uint32,
    pStdPPSs: if len(stdPPSs) == 0: nil else: cast[ptr StdVideoH265PictureParameterSet](stdPPSs),
  )

proc newVkVideoDecodeH265SessionParametersCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH265SessionParametersCreateInfoKHR, pNext: pointer = nil, maxStdVPSCount: uint32, maxStdSPSCount: uint32, maxStdPPSCount: uint32, pParametersAddInfo: ptr VkVideoDecodeH265SessionParametersAddInfoKHR): VkVideoDecodeH265SessionParametersCreateInfoKHR =
  result = VkVideoDecodeH265SessionParametersCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    maxStdVPSCount: maxStdVPSCount,
    maxStdSPSCount: maxStdSPSCount,
    maxStdPPSCount: maxStdPPSCount,
    pParametersAddInfo: pParametersAddInfo,
  )

proc newVkVideoDecodeH265InlineSessionParametersInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH265InlineSessionParametersInfoKHR, pNext: pointer = nil, pStdVPS: ptr StdVideoH265VideoParameterSet, pStdSPS: ptr StdVideoH265SequenceParameterSet, pStdPPS: ptr StdVideoH265PictureParameterSet): VkVideoDecodeH265InlineSessionParametersInfoKHR =
  result = VkVideoDecodeH265InlineSessionParametersInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdVPS: pStdVPS,
    pStdSPS: pStdSPS,
    pStdPPS: pStdPPS,
  )

proc newVkVideoDecodeH265PictureInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH265PictureInfoKHR, pNext: pointer = nil, pStdPictureInfo: ptr StdVideoDecodeH265PictureInfo, sliceSegmentOffsets: openarray[uint32]): VkVideoDecodeH265PictureInfoKHR =
  result = VkVideoDecodeH265PictureInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdPictureInfo: pStdPictureInfo,
    sliceSegmentCount: len(sliceSegmentOffsets).uint32,
    pSliceSegmentOffsets: if len(sliceSegmentOffsets) == 0: nil else: cast[ptr uint32](sliceSegmentOffsets),
  )

proc newVkVideoDecodeH265DpbSlotInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeH265DpbSlotInfoKHR, pNext: pointer = nil, pStdReferenceInfo: ptr StdVideoDecodeH265ReferenceInfo): VkVideoDecodeH265DpbSlotInfoKHR =
  result = VkVideoDecodeH265DpbSlotInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdReferenceInfo: pStdReferenceInfo,
  )

proc newVkPhysicalDeviceVideoDecodeVP9FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceVideoDecodeVP9FeaturesKHR, pNext: pointer = nil, videoDecodeVP9: VkBool32): VkPhysicalDeviceVideoDecodeVP9FeaturesKHR =
  result = VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(
    sType: sType,
    pNext: pNext,
    videoDecodeVP9: videoDecodeVP9,
  )

proc newVkVideoDecodeVP9ProfileInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeVP9ProfileInfoKHR, pNext: pointer = nil, stdProfile: StdVideoVP9Profile): VkVideoDecodeVP9ProfileInfoKHR =
  result = VkVideoDecodeVP9ProfileInfoKHR(
    sType: sType,
    pNext: pNext,
    stdProfile: stdProfile,
  )

proc newVkVideoDecodeVP9CapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoDecodeVP9CapabilitiesKHR, pNext: pointer = nil, maxLevel: StdVideoVP9Level): VkVideoDecodeVP9CapabilitiesKHR =
  result = VkVideoDecodeVP9CapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    maxLevel: maxLevel,
  )

proc newVkVideoDecodeVP9PictureInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeVP9PictureInfoKHR, pNext: pointer = nil, pStdPictureInfo: ptr StdVideoDecodeVP9PictureInfo, referenceNameSlotIndices: array[VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR, int32], uncompressedHeaderOffset: uint32, compressedHeaderOffset: uint32, tilesOffset: uint32): VkVideoDecodeVP9PictureInfoKHR =
  result = VkVideoDecodeVP9PictureInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdPictureInfo: pStdPictureInfo,
    referenceNameSlotIndices: referenceNameSlotIndices,
    uncompressedHeaderOffset: uncompressedHeaderOffset,
    compressedHeaderOffset: compressedHeaderOffset,
    tilesOffset: tilesOffset,
  )

proc newVkVideoDecodeAV1ProfileInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeAV1ProfileInfoKHR, pNext: pointer = nil, stdProfile: StdVideoAV1Profile, filmGrainSupport: VkBool32): VkVideoDecodeAV1ProfileInfoKHR =
  result = VkVideoDecodeAV1ProfileInfoKHR(
    sType: sType,
    pNext: pNext,
    stdProfile: stdProfile,
    filmGrainSupport: filmGrainSupport,
  )

proc newVkVideoDecodeAV1CapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoDecodeAV1CapabilitiesKHR, pNext: pointer = nil, maxLevel: StdVideoAV1Level): VkVideoDecodeAV1CapabilitiesKHR =
  result = VkVideoDecodeAV1CapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    maxLevel: maxLevel,
  )

proc newVkVideoDecodeAV1SessionParametersCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeAV1SessionParametersCreateInfoKHR, pNext: pointer = nil, pStdSequenceHeader: ptr StdVideoAV1SequenceHeader): VkVideoDecodeAV1SessionParametersCreateInfoKHR =
  result = VkVideoDecodeAV1SessionParametersCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdSequenceHeader: pStdSequenceHeader,
  )

proc newVkVideoDecodeAV1InlineSessionParametersInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeAV1InlineSessionParametersInfoKHR, pNext: pointer = nil, pStdSequenceHeader: ptr StdVideoAV1SequenceHeader): VkVideoDecodeAV1InlineSessionParametersInfoKHR =
  result = VkVideoDecodeAV1InlineSessionParametersInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdSequenceHeader: pStdSequenceHeader,
  )

proc newVkVideoDecodeAV1PictureInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeAV1PictureInfoKHR, pNext: pointer = nil, pStdPictureInfo: ptr StdVideoDecodeAV1PictureInfo, referenceNameSlotIndices: array[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR, int32], frameHeaderOffset: uint32, tileOffsets: openarray[uint32], tileSizes: openarray[uint32]): VkVideoDecodeAV1PictureInfoKHR =
  result = VkVideoDecodeAV1PictureInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdPictureInfo: pStdPictureInfo,
    referenceNameSlotIndices: referenceNameSlotIndices,
    frameHeaderOffset: frameHeaderOffset,
    tileCount: len(tileOffsets).uint32,
    pTileOffsets: if len(tileOffsets) == 0: nil else: cast[ptr uint32](tileOffsets),
    pTileSizes: if len(tileSizes) == 0: nil else: cast[ptr uint32](tileSizes),
  )

proc newVkVideoDecodeAV1DpbSlotInfoKHR*(sType: VkStructureType = VkStructureType.VideoDecodeAV1DpbSlotInfoKHR, pNext: pointer = nil, pStdReferenceInfo: ptr StdVideoDecodeAV1ReferenceInfo): VkVideoDecodeAV1DpbSlotInfoKHR =
  result = VkVideoDecodeAV1DpbSlotInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdReferenceInfo: pStdReferenceInfo,
  )

proc newVkVideoSessionCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoSessionCreateInfoKHR, pNext: pointer = nil, queueFamilyIndex: uint32, flags: VkVideoSessionCreateFlagsKHR = 0.VkVideoSessionCreateFlagsKHR, pVideoProfile: ptr VkVideoProfileInfoKHR, pictureFormat: VkFormat, maxCodedExtent: VkExtent2D, referencePictureFormat: VkFormat, maxDpbSlots: uint32, maxActiveReferencePictures: uint32, pStdHeaderVersion: ptr VkExtensionProperties): VkVideoSessionCreateInfoKHR =
  result = VkVideoSessionCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    queueFamilyIndex: queueFamilyIndex,
    flags: flags,
    pVideoProfile: pVideoProfile,
    pictureFormat: pictureFormat,
    maxCodedExtent: maxCodedExtent,
    referencePictureFormat: referencePictureFormat,
    maxDpbSlots: maxDpbSlots,
    maxActiveReferencePictures: maxActiveReferencePictures,
    pStdHeaderVersion: pStdHeaderVersion,
  )

proc newVkVideoSessionParametersCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoSessionParametersCreateInfoKHR, pNext: pointer = nil, flags: VkVideoSessionParametersCreateFlagsKHR = 0.VkVideoSessionParametersCreateFlagsKHR, videoSessionParametersTemplate: VkVideoSessionParametersKHR, videoSession: VkVideoSessionKHR): VkVideoSessionParametersCreateInfoKHR =
  result = VkVideoSessionParametersCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    videoSessionParametersTemplate: videoSessionParametersTemplate,
    videoSession: videoSession,
  )

proc newVkVideoSessionParametersUpdateInfoKHR*(sType: VkStructureType = VkStructureType.VideoSessionParametersUpdateInfoKHR, pNext: pointer = nil, updateSequenceCount: uint32): VkVideoSessionParametersUpdateInfoKHR =
  result = VkVideoSessionParametersUpdateInfoKHR(
    sType: sType,
    pNext: pNext,
    updateSequenceCount: updateSequenceCount,
  )

proc newVkVideoEncodeSessionParametersGetInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeSessionParametersGetInfoKHR, pNext: pointer = nil, videoSessionParameters: VkVideoSessionParametersKHR): VkVideoEncodeSessionParametersGetInfoKHR =
  result = VkVideoEncodeSessionParametersGetInfoKHR(
    sType: sType,
    pNext: pNext,
    videoSessionParameters: videoSessionParameters,
  )

proc newVkVideoEncodeSessionParametersFeedbackInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeSessionParametersFeedbackInfoKHR, pNext: pointer = nil, hasOverrides: VkBool32): VkVideoEncodeSessionParametersFeedbackInfoKHR =
  result = VkVideoEncodeSessionParametersFeedbackInfoKHR(
    sType: sType,
    pNext: pNext,
    hasOverrides: hasOverrides,
  )

proc newVkVideoBeginCodingInfoKHR*(sType: VkStructureType = VkStructureType.VideoBeginCodingInfoKHR, pNext: pointer = nil, flags: VkVideoBeginCodingFlagsKHR = 0.VkVideoBeginCodingFlagsKHR, videoSession: VkVideoSessionKHR, videoSessionParameters: VkVideoSessionParametersKHR, referenceSlots: openarray[VkVideoReferenceSlotInfoKHR]): VkVideoBeginCodingInfoKHR =
  result = VkVideoBeginCodingInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    videoSession: videoSession,
    videoSessionParameters: videoSessionParameters,
    referenceSlotCount: len(referenceSlots).uint32,
    pReferenceSlots: if len(referenceSlots) == 0: nil else: cast[ptr VkVideoReferenceSlotInfoKHR](referenceSlots),
  )

proc newVkVideoEndCodingInfoKHR*(sType: VkStructureType = VkStructureType.VideoEndCodingInfoKHR, pNext: pointer = nil, flags: VkVideoEndCodingFlagsKHR = 0.VkVideoEndCodingFlagsKHR): VkVideoEndCodingInfoKHR =
  result = VkVideoEndCodingInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkVideoCodingControlInfoKHR*(sType: VkStructureType = VkStructureType.VideoCodingControlInfoKHR, pNext: pointer = nil, flags: VkVideoCodingControlFlagsKHR = 0.VkVideoCodingControlFlagsKHR): VkVideoCodingControlInfoKHR =
  result = VkVideoCodingControlInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkVideoEncodeUsageInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeUsageInfoKHR, pNext: pointer = nil, videoUsageHints: VkVideoEncodeUsageFlagsKHR, videoContentHints: VkVideoEncodeContentFlagsKHR, tuningMode: VkVideoEncodeTuningModeKHR): VkVideoEncodeUsageInfoKHR =
  result = VkVideoEncodeUsageInfoKHR(
    sType: sType,
    pNext: pNext,
    videoUsageHints: videoUsageHints,
    videoContentHints: videoContentHints,
    tuningMode: tuningMode,
  )

proc newVkVideoEncodeInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeInfoKHR, pNext: pointer = nil, flags: VkVideoEncodeFlagsKHR = 0.VkVideoEncodeFlagsKHR, dstBuffer: VkBuffer, dstBufferOffset: VkDeviceSize, dstBufferRange: VkDeviceSize, srcPictureResource: VkVideoPictureResourceInfoKHR, pSetupReferenceSlot: ptr VkVideoReferenceSlotInfoKHR, referenceSlots: openarray[VkVideoReferenceSlotInfoKHR], precedingExternallyEncodedBytes: uint32): VkVideoEncodeInfoKHR =
  result = VkVideoEncodeInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    dstBuffer: dstBuffer,
    dstBufferOffset: dstBufferOffset,
    dstBufferRange: dstBufferRange,
    srcPictureResource: srcPictureResource,
    pSetupReferenceSlot: pSetupReferenceSlot,
    referenceSlotCount: len(referenceSlots).uint32,
    pReferenceSlots: if len(referenceSlots) == 0: nil else: cast[ptr VkVideoReferenceSlotInfoKHR](referenceSlots),
    precedingExternallyEncodedBytes: precedingExternallyEncodedBytes,
  )

proc newVkVideoEncodeQuantizationMapInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeQuantizationMapInfoKHR, pNext: pointer = nil, quantizationMap: VkImageView, quantizationMapExtent: VkExtent2D): VkVideoEncodeQuantizationMapInfoKHR =
  result = VkVideoEncodeQuantizationMapInfoKHR(
    sType: sType,
    pNext: pNext,
    quantizationMap: quantizationMap,
    quantizationMapExtent: quantizationMapExtent,
  )

proc newVkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeQuantizationMapSessionParametersCreateInfoKHR, pNext: pointer = nil, quantizationMapTexelSize: VkExtent2D): VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR =
  result = VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    quantizationMapTexelSize: quantizationMapTexelSize,
  )

proc newVkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR, pNext: pointer = nil, videoEncodeQuantizationMap: VkBool32): VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR =
  result = VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(
    sType: sType,
    pNext: pNext,
    videoEncodeQuantizationMap: videoEncodeQuantizationMap,
  )

proc newVkQueryPoolVideoEncodeFeedbackCreateInfoKHR*(sType: VkStructureType = VkStructureType.QueryPoolVideoEncodeFeedbackCreateInfoKHR, pNext: pointer = nil, encodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR): VkQueryPoolVideoEncodeFeedbackCreateInfoKHR =
  result = VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    encodeFeedbackFlags: encodeFeedbackFlags,
  )

proc newVkVideoEncodeQualityLevelInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeQualityLevelInfoKHR, pNext: pointer = nil, qualityLevel: uint32): VkVideoEncodeQualityLevelInfoKHR =
  result = VkVideoEncodeQualityLevelInfoKHR(
    sType: sType,
    pNext: pNext,
    qualityLevel: qualityLevel,
  )

proc newVkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceVideoEncodeQualityLevelInfoKHR, pNext: pointer = nil, pVideoProfile: ptr VkVideoProfileInfoKHR, qualityLevel: uint32): VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR =
  result = VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(
    sType: sType,
    pNext: pNext,
    pVideoProfile: pVideoProfile,
    qualityLevel: qualityLevel,
  )

proc newVkVideoEncodeQualityLevelPropertiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeQualityLevelPropertiesKHR, pNext: pointer = nil, preferredRateControlMode: VkVideoEncodeRateControlModeFlagBitsKHR, preferredRateControlLayerCount: uint32): VkVideoEncodeQualityLevelPropertiesKHR =
  result = VkVideoEncodeQualityLevelPropertiesKHR(
    sType: sType,
    pNext: pNext,
    preferredRateControlMode: preferredRateControlMode,
    preferredRateControlLayerCount: preferredRateControlLayerCount,
  )

proc newVkVideoEncodeRateControlInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeRateControlInfoKHR, pNext: pointer = nil, flags: VkVideoEncodeRateControlFlagsKHR = 0.VkVideoEncodeRateControlFlagsKHR, rateControlMode: VkVideoEncodeRateControlModeFlagBitsKHR, layers: openarray[VkVideoEncodeRateControlLayerInfoKHR], virtualBufferSizeInMs: uint32, initialVirtualBufferSizeInMs: uint32): VkVideoEncodeRateControlInfoKHR =
  result = VkVideoEncodeRateControlInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    rateControlMode: rateControlMode,
    layerCount: len(layers).uint32,
    pLayers: if len(layers) == 0: nil else: cast[ptr VkVideoEncodeRateControlLayerInfoKHR](layers),
    virtualBufferSizeInMs: virtualBufferSizeInMs,
    initialVirtualBufferSizeInMs: initialVirtualBufferSizeInMs,
  )

proc newVkVideoEncodeRateControlLayerInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeRateControlLayerInfoKHR, pNext: pointer = nil, averageBitrate: uint64, maxBitrate: uint64, frameRateNumerator: uint32, frameRateDenominator: uint32): VkVideoEncodeRateControlLayerInfoKHR =
  result = VkVideoEncodeRateControlLayerInfoKHR(
    sType: sType,
    pNext: pNext,
    averageBitrate: averageBitrate,
    maxBitrate: maxBitrate,
    frameRateNumerator: frameRateNumerator,
    frameRateDenominator: frameRateDenominator,
  )

proc newVkVideoEncodeCapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeCapabilitiesKHR, pNext: pointer = nil, flags: VkVideoEncodeCapabilityFlagsKHR = 0.VkVideoEncodeCapabilityFlagsKHR, rateControlModes: VkVideoEncodeRateControlModeFlagsKHR, maxRateControlLayers: uint32, maxBitrate: uint64, maxQualityLevels: uint32, encodeInputPictureGranularity: VkExtent2D, supportedEncodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR): VkVideoEncodeCapabilitiesKHR =
  result = VkVideoEncodeCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    rateControlModes: rateControlModes,
    maxRateControlLayers: maxRateControlLayers,
    maxBitrate: maxBitrate,
    maxQualityLevels: maxQualityLevels,
    encodeInputPictureGranularity: encodeInputPictureGranularity,
    supportedEncodeFeedbackFlags: supportedEncodeFeedbackFlags,
  )

proc newVkVideoEncodeH264CapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264CapabilitiesKHR, pNext: pointer = nil, flags: VkVideoEncodeH264CapabilityFlagsKHR = 0.VkVideoEncodeH264CapabilityFlagsKHR, maxLevelIdc: StdVideoH264LevelIdc, maxSliceCount: uint32, maxPPictureL0ReferenceCount: uint32, maxBPictureL0ReferenceCount: uint32, maxL1ReferenceCount: uint32, maxTemporalLayerCount: uint32, expectDyadicTemporalLayerPattern: VkBool32, minQp: int32, maxQp: int32, prefersGopRemainingFrames: VkBool32, requiresGopRemainingFrames: VkBool32, stdSyntaxFlags: VkVideoEncodeH264StdFlagsKHR): VkVideoEncodeH264CapabilitiesKHR =
  result = VkVideoEncodeH264CapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    maxLevelIdc: maxLevelIdc,
    maxSliceCount: maxSliceCount,
    maxPPictureL0ReferenceCount: maxPPictureL0ReferenceCount,
    maxBPictureL0ReferenceCount: maxBPictureL0ReferenceCount,
    maxL1ReferenceCount: maxL1ReferenceCount,
    maxTemporalLayerCount: maxTemporalLayerCount,
    expectDyadicTemporalLayerPattern: expectDyadicTemporalLayerPattern,
    minQp: minQp,
    maxQp: maxQp,
    prefersGopRemainingFrames: prefersGopRemainingFrames,
    requiresGopRemainingFrames: requiresGopRemainingFrames,
    stdSyntaxFlags: stdSyntaxFlags,
  )

proc newVkVideoEncodeH264QualityLevelPropertiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264QualityLevelPropertiesKHR, pNext: pointer = nil, preferredRateControlFlags: VkVideoEncodeH264RateControlFlagsKHR, preferredGopFrameCount: uint32, preferredIdrPeriod: uint32, preferredConsecutiveBFrameCount: uint32, preferredTemporalLayerCount: uint32, preferredConstantQp: VkVideoEncodeH264QpKHR, preferredMaxL0ReferenceCount: uint32, preferredMaxL1ReferenceCount: uint32, preferredStdEntropyCodingModeFlag: VkBool32): VkVideoEncodeH264QualityLevelPropertiesKHR =
  result = VkVideoEncodeH264QualityLevelPropertiesKHR(
    sType: sType,
    pNext: pNext,
    preferredRateControlFlags: preferredRateControlFlags,
    preferredGopFrameCount: preferredGopFrameCount,
    preferredIdrPeriod: preferredIdrPeriod,
    preferredConsecutiveBFrameCount: preferredConsecutiveBFrameCount,
    preferredTemporalLayerCount: preferredTemporalLayerCount,
    preferredConstantQp: preferredConstantQp,
    preferredMaxL0ReferenceCount: preferredMaxL0ReferenceCount,
    preferredMaxL1ReferenceCount: preferredMaxL1ReferenceCount,
    preferredStdEntropyCodingModeFlag: preferredStdEntropyCodingModeFlag,
  )

proc newVkVideoEncodeH264SessionCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264SessionCreateInfoKHR, pNext: pointer = nil, useMaxLevelIdc: VkBool32, maxLevelIdc: StdVideoH264LevelIdc): VkVideoEncodeH264SessionCreateInfoKHR =
  result = VkVideoEncodeH264SessionCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    useMaxLevelIdc: useMaxLevelIdc,
    maxLevelIdc: maxLevelIdc,
  )

proc newVkVideoEncodeH264SessionParametersAddInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264SessionParametersAddInfoKHR, pNext: pointer = nil, stdSPSs: openarray[StdVideoH264SequenceParameterSet], stdPPSs: openarray[StdVideoH264PictureParameterSet]): VkVideoEncodeH264SessionParametersAddInfoKHR =
  result = VkVideoEncodeH264SessionParametersAddInfoKHR(
    sType: sType,
    pNext: pNext,
    stdSPSCount: len(stdSPSs).uint32,
    pStdSPSs: if len(stdSPSs) == 0: nil else: cast[ptr StdVideoH264SequenceParameterSet](stdSPSs),
    stdPPSCount: len(stdPPSs).uint32,
    pStdPPSs: if len(stdPPSs) == 0: nil else: cast[ptr StdVideoH264PictureParameterSet](stdPPSs),
  )

proc newVkVideoEncodeH264SessionParametersCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264SessionParametersCreateInfoKHR, pNext: pointer = nil, maxStdSPSCount: uint32, maxStdPPSCount: uint32, pParametersAddInfo: ptr VkVideoEncodeH264SessionParametersAddInfoKHR): VkVideoEncodeH264SessionParametersCreateInfoKHR =
  result = VkVideoEncodeH264SessionParametersCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    maxStdSPSCount: maxStdSPSCount,
    maxStdPPSCount: maxStdPPSCount,
    pParametersAddInfo: pParametersAddInfo,
  )

proc newVkVideoEncodeH264SessionParametersGetInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264SessionParametersGetInfoKHR, pNext: pointer = nil, writeStdSPS: VkBool32, writeStdPPS: VkBool32, stdSPSId: uint32, stdPPSId: uint32): VkVideoEncodeH264SessionParametersGetInfoKHR =
  result = VkVideoEncodeH264SessionParametersGetInfoKHR(
    sType: sType,
    pNext: pNext,
    writeStdSPS: writeStdSPS,
    writeStdPPS: writeStdPPS,
    stdSPSId: stdSPSId,
    stdPPSId: stdPPSId,
  )

proc newVkVideoEncodeH264SessionParametersFeedbackInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264SessionParametersFeedbackInfoKHR, pNext: pointer = nil, hasStdSPSOverrides: VkBool32, hasStdPPSOverrides: VkBool32): VkVideoEncodeH264SessionParametersFeedbackInfoKHR =
  result = VkVideoEncodeH264SessionParametersFeedbackInfoKHR(
    sType: sType,
    pNext: pNext,
    hasStdSPSOverrides: hasStdSPSOverrides,
    hasStdPPSOverrides: hasStdPPSOverrides,
  )

proc newVkVideoEncodeH264DpbSlotInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264DpbSlotInfoKHR, pNext: pointer = nil, pStdReferenceInfo: ptr StdVideoEncodeH264ReferenceInfo): VkVideoEncodeH264DpbSlotInfoKHR =
  result = VkVideoEncodeH264DpbSlotInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdReferenceInfo: pStdReferenceInfo,
  )

proc newVkVideoEncodeH264PictureInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264PictureInfoKHR, pNext: pointer = nil, naluSliceEntries: openarray[VkVideoEncodeH264NaluSliceInfoKHR], pStdPictureInfo: ptr StdVideoEncodeH264PictureInfo, generatePrefixNalu: VkBool32): VkVideoEncodeH264PictureInfoKHR =
  result = VkVideoEncodeH264PictureInfoKHR(
    sType: sType,
    pNext: pNext,
    naluSliceEntryCount: len(naluSliceEntries).uint32,
    pNaluSliceEntries: if len(naluSliceEntries) == 0: nil else: cast[ptr VkVideoEncodeH264NaluSliceInfoKHR](naluSliceEntries),
    pStdPictureInfo: pStdPictureInfo,
    generatePrefixNalu: generatePrefixNalu,
  )

proc newVkVideoEncodeH264ProfileInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264ProfileInfoKHR, pNext: pointer = nil, stdProfileIdc: StdVideoH264ProfileIdc): VkVideoEncodeH264ProfileInfoKHR =
  result = VkVideoEncodeH264ProfileInfoKHR(
    sType: sType,
    pNext: pNext,
    stdProfileIdc: stdProfileIdc,
  )

proc newVkVideoEncodeH264NaluSliceInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264NaluSliceInfoKHR, pNext: pointer = nil, constantQp: int32, pStdSliceHeader: ptr StdVideoEncodeH264SliceHeader): VkVideoEncodeH264NaluSliceInfoKHR =
  result = VkVideoEncodeH264NaluSliceInfoKHR(
    sType: sType,
    pNext: pNext,
    constantQp: constantQp,
    pStdSliceHeader: pStdSliceHeader,
  )

proc newVkVideoEncodeH264RateControlInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264RateControlInfoKHR, pNext: pointer = nil, flags: VkVideoEncodeH264RateControlFlagsKHR = 0.VkVideoEncodeH264RateControlFlagsKHR, gopFrameCount: uint32, idrPeriod: uint32, consecutiveBFrameCount: uint32, temporalLayerCount: uint32): VkVideoEncodeH264RateControlInfoKHR =
  result = VkVideoEncodeH264RateControlInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    gopFrameCount: gopFrameCount,
    idrPeriod: idrPeriod,
    consecutiveBFrameCount: consecutiveBFrameCount,
    temporalLayerCount: temporalLayerCount,
  )

proc newVkVideoEncodeH264QpKHR*(qpI: int32, qpP: int32, qpB: int32): VkVideoEncodeH264QpKHR =
  result = VkVideoEncodeH264QpKHR(
    qpI: qpI,
    qpP: qpP,
    qpB: qpB,
  )

proc newVkVideoEncodeH264FrameSizeKHR*(frameISize: uint32, framePSize: uint32, frameBSize: uint32): VkVideoEncodeH264FrameSizeKHR =
  result = VkVideoEncodeH264FrameSizeKHR(
    frameISize: frameISize,
    framePSize: framePSize,
    frameBSize: frameBSize,
  )

proc newVkVideoEncodeH264GopRemainingFrameInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264GopRemainingFrameInfoKHR, pNext: pointer = nil, useGopRemainingFrames: VkBool32, gopRemainingI: uint32, gopRemainingP: uint32, gopRemainingB: uint32): VkVideoEncodeH264GopRemainingFrameInfoKHR =
  result = VkVideoEncodeH264GopRemainingFrameInfoKHR(
    sType: sType,
    pNext: pNext,
    useGopRemainingFrames: useGopRemainingFrames,
    gopRemainingI: gopRemainingI,
    gopRemainingP: gopRemainingP,
    gopRemainingB: gopRemainingB,
  )

proc newVkVideoEncodeH264RateControlLayerInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH264RateControlLayerInfoKHR, pNext: pointer = nil, useMinQp: VkBool32, minQp: VkVideoEncodeH264QpKHR, useMaxQp: VkBool32, maxQp: VkVideoEncodeH264QpKHR, useMaxFrameSize: VkBool32, maxFrameSize: VkVideoEncodeH264FrameSizeKHR): VkVideoEncodeH264RateControlLayerInfoKHR =
  result = VkVideoEncodeH264RateControlLayerInfoKHR(
    sType: sType,
    pNext: pNext,
    useMinQp: useMinQp,
    minQp: minQp,
    useMaxQp: useMaxQp,
    maxQp: maxQp,
    useMaxFrameSize: useMaxFrameSize,
    maxFrameSize: maxFrameSize,
  )

proc newVkVideoEncodeH265CapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265CapabilitiesKHR, pNext: pointer = nil, flags: VkVideoEncodeH265CapabilityFlagsKHR = 0.VkVideoEncodeH265CapabilityFlagsKHR, maxLevelIdc: StdVideoH265LevelIdc, maxSliceSegmentCount: uint32, maxTiles: VkExtent2D, ctbSizes: VkVideoEncodeH265CtbSizeFlagsKHR, transformBlockSizes: VkVideoEncodeH265TransformBlockSizeFlagsKHR, maxPPictureL0ReferenceCount: uint32, maxBPictureL0ReferenceCount: uint32, maxL1ReferenceCount: uint32, maxSubLayerCount: uint32, expectDyadicTemporalSubLayerPattern: VkBool32, minQp: int32, maxQp: int32, prefersGopRemainingFrames: VkBool32, requiresGopRemainingFrames: VkBool32, stdSyntaxFlags: VkVideoEncodeH265StdFlagsKHR): VkVideoEncodeH265CapabilitiesKHR =
  result = VkVideoEncodeH265CapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    maxLevelIdc: maxLevelIdc,
    maxSliceSegmentCount: maxSliceSegmentCount,
    maxTiles: maxTiles,
    ctbSizes: ctbSizes,
    transformBlockSizes: transformBlockSizes,
    maxPPictureL0ReferenceCount: maxPPictureL0ReferenceCount,
    maxBPictureL0ReferenceCount: maxBPictureL0ReferenceCount,
    maxL1ReferenceCount: maxL1ReferenceCount,
    maxSubLayerCount: maxSubLayerCount,
    expectDyadicTemporalSubLayerPattern: expectDyadicTemporalSubLayerPattern,
    minQp: minQp,
    maxQp: maxQp,
    prefersGopRemainingFrames: prefersGopRemainingFrames,
    requiresGopRemainingFrames: requiresGopRemainingFrames,
    stdSyntaxFlags: stdSyntaxFlags,
  )

proc newVkVideoEncodeH265QualityLevelPropertiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265QualityLevelPropertiesKHR, pNext: pointer = nil, preferredRateControlFlags: VkVideoEncodeH265RateControlFlagsKHR, preferredGopFrameCount: uint32, preferredIdrPeriod: uint32, preferredConsecutiveBFrameCount: uint32, preferredSubLayerCount: uint32, preferredConstantQp: VkVideoEncodeH265QpKHR, preferredMaxL0ReferenceCount: uint32, preferredMaxL1ReferenceCount: uint32): VkVideoEncodeH265QualityLevelPropertiesKHR =
  result = VkVideoEncodeH265QualityLevelPropertiesKHR(
    sType: sType,
    pNext: pNext,
    preferredRateControlFlags: preferredRateControlFlags,
    preferredGopFrameCount: preferredGopFrameCount,
    preferredIdrPeriod: preferredIdrPeriod,
    preferredConsecutiveBFrameCount: preferredConsecutiveBFrameCount,
    preferredSubLayerCount: preferredSubLayerCount,
    preferredConstantQp: preferredConstantQp,
    preferredMaxL0ReferenceCount: preferredMaxL0ReferenceCount,
    preferredMaxL1ReferenceCount: preferredMaxL1ReferenceCount,
  )

proc newVkVideoEncodeH265SessionCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265SessionCreateInfoKHR, pNext: pointer = nil, useMaxLevelIdc: VkBool32, maxLevelIdc: StdVideoH265LevelIdc): VkVideoEncodeH265SessionCreateInfoKHR =
  result = VkVideoEncodeH265SessionCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    useMaxLevelIdc: useMaxLevelIdc,
    maxLevelIdc: maxLevelIdc,
  )

proc newVkVideoEncodeH265SessionParametersAddInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265SessionParametersAddInfoKHR, pNext: pointer = nil, stdVPSs: openarray[StdVideoH265VideoParameterSet], stdSPSs: openarray[StdVideoH265SequenceParameterSet], stdPPSs: openarray[StdVideoH265PictureParameterSet]): VkVideoEncodeH265SessionParametersAddInfoKHR =
  result = VkVideoEncodeH265SessionParametersAddInfoKHR(
    sType: sType,
    pNext: pNext,
    stdVPSCount: len(stdVPSs).uint32,
    pStdVPSs: if len(stdVPSs) == 0: nil else: cast[ptr StdVideoH265VideoParameterSet](stdVPSs),
    stdSPSCount: len(stdSPSs).uint32,
    pStdSPSs: if len(stdSPSs) == 0: nil else: cast[ptr StdVideoH265SequenceParameterSet](stdSPSs),
    stdPPSCount: len(stdPPSs).uint32,
    pStdPPSs: if len(stdPPSs) == 0: nil else: cast[ptr StdVideoH265PictureParameterSet](stdPPSs),
  )

proc newVkVideoEncodeH265SessionParametersCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265SessionParametersCreateInfoKHR, pNext: pointer = nil, maxStdVPSCount: uint32, maxStdSPSCount: uint32, maxStdPPSCount: uint32, pParametersAddInfo: ptr VkVideoEncodeH265SessionParametersAddInfoKHR): VkVideoEncodeH265SessionParametersCreateInfoKHR =
  result = VkVideoEncodeH265SessionParametersCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    maxStdVPSCount: maxStdVPSCount,
    maxStdSPSCount: maxStdSPSCount,
    maxStdPPSCount: maxStdPPSCount,
    pParametersAddInfo: pParametersAddInfo,
  )

proc newVkVideoEncodeH265SessionParametersGetInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265SessionParametersGetInfoKHR, pNext: pointer = nil, writeStdVPS: VkBool32, writeStdSPS: VkBool32, writeStdPPS: VkBool32, stdVPSId: uint32, stdSPSId: uint32, stdPPSId: uint32): VkVideoEncodeH265SessionParametersGetInfoKHR =
  result = VkVideoEncodeH265SessionParametersGetInfoKHR(
    sType: sType,
    pNext: pNext,
    writeStdVPS: writeStdVPS,
    writeStdSPS: writeStdSPS,
    writeStdPPS: writeStdPPS,
    stdVPSId: stdVPSId,
    stdSPSId: stdSPSId,
    stdPPSId: stdPPSId,
  )

proc newVkVideoEncodeH265SessionParametersFeedbackInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265SessionParametersFeedbackInfoKHR, pNext: pointer = nil, hasStdVPSOverrides: VkBool32, hasStdSPSOverrides: VkBool32, hasStdPPSOverrides: VkBool32): VkVideoEncodeH265SessionParametersFeedbackInfoKHR =
  result = VkVideoEncodeH265SessionParametersFeedbackInfoKHR(
    sType: sType,
    pNext: pNext,
    hasStdVPSOverrides: hasStdVPSOverrides,
    hasStdSPSOverrides: hasStdSPSOverrides,
    hasStdPPSOverrides: hasStdPPSOverrides,
  )

proc newVkVideoEncodeH265PictureInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265PictureInfoKHR, pNext: pointer = nil, naluSliceSegmentEntries: openarray[VkVideoEncodeH265NaluSliceSegmentInfoKHR], pStdPictureInfo: ptr StdVideoEncodeH265PictureInfo): VkVideoEncodeH265PictureInfoKHR =
  result = VkVideoEncodeH265PictureInfoKHR(
    sType: sType,
    pNext: pNext,
    naluSliceSegmentEntryCount: len(naluSliceSegmentEntries).uint32,
    pNaluSliceSegmentEntries: if len(naluSliceSegmentEntries) == 0: nil else: cast[ptr VkVideoEncodeH265NaluSliceSegmentInfoKHR](naluSliceSegmentEntries),
    pStdPictureInfo: pStdPictureInfo,
  )

proc newVkVideoEncodeH265NaluSliceSegmentInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265NaluSliceSegmentInfoKHR, pNext: pointer = nil, constantQp: int32, pStdSliceSegmentHeader: ptr StdVideoEncodeH265SliceSegmentHeader): VkVideoEncodeH265NaluSliceSegmentInfoKHR =
  result = VkVideoEncodeH265NaluSliceSegmentInfoKHR(
    sType: sType,
    pNext: pNext,
    constantQp: constantQp,
    pStdSliceSegmentHeader: pStdSliceSegmentHeader,
  )

proc newVkVideoEncodeH265RateControlInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265RateControlInfoKHR, pNext: pointer = nil, flags: VkVideoEncodeH265RateControlFlagsKHR = 0.VkVideoEncodeH265RateControlFlagsKHR, gopFrameCount: uint32, idrPeriod: uint32, consecutiveBFrameCount: uint32, subLayerCount: uint32): VkVideoEncodeH265RateControlInfoKHR =
  result = VkVideoEncodeH265RateControlInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    gopFrameCount: gopFrameCount,
    idrPeriod: idrPeriod,
    consecutiveBFrameCount: consecutiveBFrameCount,
    subLayerCount: subLayerCount,
  )

proc newVkVideoEncodeH265QpKHR*(qpI: int32, qpP: int32, qpB: int32): VkVideoEncodeH265QpKHR =
  result = VkVideoEncodeH265QpKHR(
    qpI: qpI,
    qpP: qpP,
    qpB: qpB,
  )

proc newVkVideoEncodeH265FrameSizeKHR*(frameISize: uint32, framePSize: uint32, frameBSize: uint32): VkVideoEncodeH265FrameSizeKHR =
  result = VkVideoEncodeH265FrameSizeKHR(
    frameISize: frameISize,
    framePSize: framePSize,
    frameBSize: frameBSize,
  )

proc newVkVideoEncodeH265GopRemainingFrameInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265GopRemainingFrameInfoKHR, pNext: pointer = nil, useGopRemainingFrames: VkBool32, gopRemainingI: uint32, gopRemainingP: uint32, gopRemainingB: uint32): VkVideoEncodeH265GopRemainingFrameInfoKHR =
  result = VkVideoEncodeH265GopRemainingFrameInfoKHR(
    sType: sType,
    pNext: pNext,
    useGopRemainingFrames: useGopRemainingFrames,
    gopRemainingI: gopRemainingI,
    gopRemainingP: gopRemainingP,
    gopRemainingB: gopRemainingB,
  )

proc newVkVideoEncodeH265RateControlLayerInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265RateControlLayerInfoKHR, pNext: pointer = nil, useMinQp: VkBool32, minQp: VkVideoEncodeH265QpKHR, useMaxQp: VkBool32, maxQp: VkVideoEncodeH265QpKHR, useMaxFrameSize: VkBool32, maxFrameSize: VkVideoEncodeH265FrameSizeKHR): VkVideoEncodeH265RateControlLayerInfoKHR =
  result = VkVideoEncodeH265RateControlLayerInfoKHR(
    sType: sType,
    pNext: pNext,
    useMinQp: useMinQp,
    minQp: minQp,
    useMaxQp: useMaxQp,
    maxQp: maxQp,
    useMaxFrameSize: useMaxFrameSize,
    maxFrameSize: maxFrameSize,
  )

proc newVkVideoEncodeH265ProfileInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265ProfileInfoKHR, pNext: pointer = nil, stdProfileIdc: StdVideoH265ProfileIdc): VkVideoEncodeH265ProfileInfoKHR =
  result = VkVideoEncodeH265ProfileInfoKHR(
    sType: sType,
    pNext: pNext,
    stdProfileIdc: stdProfileIdc,
  )

proc newVkVideoEncodeH265DpbSlotInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeH265DpbSlotInfoKHR, pNext: pointer = nil, pStdReferenceInfo: ptr StdVideoEncodeH265ReferenceInfo): VkVideoEncodeH265DpbSlotInfoKHR =
  result = VkVideoEncodeH265DpbSlotInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdReferenceInfo: pStdReferenceInfo,
  )

proc newVkVideoEncodeAV1CapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1CapabilitiesKHR, pNext: pointer = nil, flags: VkVideoEncodeAV1CapabilityFlagsKHR = 0.VkVideoEncodeAV1CapabilityFlagsKHR, maxLevel: StdVideoAV1Level, codedPictureAlignment: VkExtent2D, maxTiles: VkExtent2D, minTileSize: VkExtent2D, maxTileSize: VkExtent2D, superblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR, maxSingleReferenceCount: uint32, singleReferenceNameMask: uint32, maxUnidirectionalCompoundReferenceCount: uint32, maxUnidirectionalCompoundGroup1ReferenceCount: uint32, unidirectionalCompoundReferenceNameMask: uint32, maxBidirectionalCompoundReferenceCount: uint32, maxBidirectionalCompoundGroup1ReferenceCount: uint32, maxBidirectionalCompoundGroup2ReferenceCount: uint32, bidirectionalCompoundReferenceNameMask: uint32, maxTemporalLayerCount: uint32, maxSpatialLayerCount: uint32, maxOperatingPoints: uint32, minQIndex: uint32, maxQIndex: uint32, prefersGopRemainingFrames: VkBool32, requiresGopRemainingFrames: VkBool32, stdSyntaxFlags: VkVideoEncodeAV1StdFlagsKHR): VkVideoEncodeAV1CapabilitiesKHR =
  result = VkVideoEncodeAV1CapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    maxLevel: maxLevel,
    codedPictureAlignment: codedPictureAlignment,
    maxTiles: maxTiles,
    minTileSize: minTileSize,
    maxTileSize: maxTileSize,
    superblockSizes: superblockSizes,
    maxSingleReferenceCount: maxSingleReferenceCount,
    singleReferenceNameMask: singleReferenceNameMask,
    maxUnidirectionalCompoundReferenceCount: maxUnidirectionalCompoundReferenceCount,
    maxUnidirectionalCompoundGroup1ReferenceCount: maxUnidirectionalCompoundGroup1ReferenceCount,
    unidirectionalCompoundReferenceNameMask: unidirectionalCompoundReferenceNameMask,
    maxBidirectionalCompoundReferenceCount: maxBidirectionalCompoundReferenceCount,
    maxBidirectionalCompoundGroup1ReferenceCount: maxBidirectionalCompoundGroup1ReferenceCount,
    maxBidirectionalCompoundGroup2ReferenceCount: maxBidirectionalCompoundGroup2ReferenceCount,
    bidirectionalCompoundReferenceNameMask: bidirectionalCompoundReferenceNameMask,
    maxTemporalLayerCount: maxTemporalLayerCount,
    maxSpatialLayerCount: maxSpatialLayerCount,
    maxOperatingPoints: maxOperatingPoints,
    minQIndex: minQIndex,
    maxQIndex: maxQIndex,
    prefersGopRemainingFrames: prefersGopRemainingFrames,
    requiresGopRemainingFrames: requiresGopRemainingFrames,
    stdSyntaxFlags: stdSyntaxFlags,
  )

proc newVkVideoEncodeAV1QualityLevelPropertiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1QualityLevelPropertiesKHR, pNext: pointer = nil, preferredRateControlFlags: VkVideoEncodeAV1RateControlFlagsKHR, preferredGopFrameCount: uint32, preferredKeyFramePeriod: uint32, preferredConsecutiveBipredictiveFrameCount: uint32, preferredTemporalLayerCount: uint32, preferredConstantQIndex: VkVideoEncodeAV1QIndexKHR, preferredMaxSingleReferenceCount: uint32, preferredSingleReferenceNameMask: uint32, preferredMaxUnidirectionalCompoundReferenceCount: uint32, preferredMaxUnidirectionalCompoundGroup1ReferenceCount: uint32, preferredUnidirectionalCompoundReferenceNameMask: uint32, preferredMaxBidirectionalCompoundReferenceCount: uint32, preferredMaxBidirectionalCompoundGroup1ReferenceCount: uint32, preferredMaxBidirectionalCompoundGroup2ReferenceCount: uint32, preferredBidirectionalCompoundReferenceNameMask: uint32): VkVideoEncodeAV1QualityLevelPropertiesKHR =
  result = VkVideoEncodeAV1QualityLevelPropertiesKHR(
    sType: sType,
    pNext: pNext,
    preferredRateControlFlags: preferredRateControlFlags,
    preferredGopFrameCount: preferredGopFrameCount,
    preferredKeyFramePeriod: preferredKeyFramePeriod,
    preferredConsecutiveBipredictiveFrameCount: preferredConsecutiveBipredictiveFrameCount,
    preferredTemporalLayerCount: preferredTemporalLayerCount,
    preferredConstantQIndex: preferredConstantQIndex,
    preferredMaxSingleReferenceCount: preferredMaxSingleReferenceCount,
    preferredSingleReferenceNameMask: preferredSingleReferenceNameMask,
    preferredMaxUnidirectionalCompoundReferenceCount: preferredMaxUnidirectionalCompoundReferenceCount,
    preferredMaxUnidirectionalCompoundGroup1ReferenceCount: preferredMaxUnidirectionalCompoundGroup1ReferenceCount,
    preferredUnidirectionalCompoundReferenceNameMask: preferredUnidirectionalCompoundReferenceNameMask,
    preferredMaxBidirectionalCompoundReferenceCount: preferredMaxBidirectionalCompoundReferenceCount,
    preferredMaxBidirectionalCompoundGroup1ReferenceCount: preferredMaxBidirectionalCompoundGroup1ReferenceCount,
    preferredMaxBidirectionalCompoundGroup2ReferenceCount: preferredMaxBidirectionalCompoundGroup2ReferenceCount,
    preferredBidirectionalCompoundReferenceNameMask: preferredBidirectionalCompoundReferenceNameMask,
  )

proc newVkPhysicalDeviceVideoEncodeAV1FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceVideoEncodeAV1FeaturesKHR, pNext: pointer = nil, videoEncodeAV1: VkBool32): VkPhysicalDeviceVideoEncodeAV1FeaturesKHR =
  result = VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(
    sType: sType,
    pNext: pNext,
    videoEncodeAV1: videoEncodeAV1,
  )

proc newVkVideoEncodeAV1SessionCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1SessionCreateInfoKHR, pNext: pointer = nil, useMaxLevel: VkBool32, maxLevel: StdVideoAV1Level): VkVideoEncodeAV1SessionCreateInfoKHR =
  result = VkVideoEncodeAV1SessionCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    useMaxLevel: useMaxLevel,
    maxLevel: maxLevel,
  )

proc newVkVideoEncodeAV1SessionParametersCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1SessionParametersCreateInfoKHR, pNext: pointer = nil, pStdSequenceHeader: ptr StdVideoAV1SequenceHeader, pStdDecoderModelInfo: ptr StdVideoEncodeAV1DecoderModelInfo, stdOperatingPoints: openarray[StdVideoEncodeAV1OperatingPointInfo]): VkVideoEncodeAV1SessionParametersCreateInfoKHR =
  result = VkVideoEncodeAV1SessionParametersCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdSequenceHeader: pStdSequenceHeader,
    pStdDecoderModelInfo: pStdDecoderModelInfo,
    stdOperatingPointCount: len(stdOperatingPoints).uint32,
    pStdOperatingPoints: if len(stdOperatingPoints) == 0: nil else: cast[ptr StdVideoEncodeAV1OperatingPointInfo](stdOperatingPoints),
  )

proc newVkVideoEncodeAV1DpbSlotInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1DpbSlotInfoKHR, pNext: pointer = nil, pStdReferenceInfo: ptr StdVideoEncodeAV1ReferenceInfo): VkVideoEncodeAV1DpbSlotInfoKHR =
  result = VkVideoEncodeAV1DpbSlotInfoKHR(
    sType: sType,
    pNext: pNext,
    pStdReferenceInfo: pStdReferenceInfo,
  )

proc newVkVideoEncodeAV1PictureInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1PictureInfoKHR, pNext: pointer = nil, predictionMode: VkVideoEncodeAV1PredictionModeKHR, rateControlGroup: VkVideoEncodeAV1RateControlGroupKHR, constantQIndex: uint32, pStdPictureInfo: ptr StdVideoEncodeAV1PictureInfo, referenceNameSlotIndices: array[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR, int32], primaryReferenceCdfOnly: VkBool32, generateObuExtensionHeader: VkBool32): VkVideoEncodeAV1PictureInfoKHR =
  result = VkVideoEncodeAV1PictureInfoKHR(
    sType: sType,
    pNext: pNext,
    predictionMode: predictionMode,
    rateControlGroup: rateControlGroup,
    constantQIndex: constantQIndex,
    pStdPictureInfo: pStdPictureInfo,
    referenceNameSlotIndices: referenceNameSlotIndices,
    primaryReferenceCdfOnly: primaryReferenceCdfOnly,
    generateObuExtensionHeader: generateObuExtensionHeader,
  )

proc newVkVideoEncodeAV1ProfileInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1ProfileInfoKHR, pNext: pointer = nil, stdProfile: StdVideoAV1Profile): VkVideoEncodeAV1ProfileInfoKHR =
  result = VkVideoEncodeAV1ProfileInfoKHR(
    sType: sType,
    pNext: pNext,
    stdProfile: stdProfile,
  )

proc newVkVideoEncodeAV1RateControlInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1RateControlInfoKHR, pNext: pointer = nil, flags: VkVideoEncodeAV1RateControlFlagsKHR = 0.VkVideoEncodeAV1RateControlFlagsKHR, gopFrameCount: uint32, keyFramePeriod: uint32, consecutiveBipredictiveFrameCount: uint32, temporalLayerCount: uint32): VkVideoEncodeAV1RateControlInfoKHR =
  result = VkVideoEncodeAV1RateControlInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    gopFrameCount: gopFrameCount,
    keyFramePeriod: keyFramePeriod,
    consecutiveBipredictiveFrameCount: consecutiveBipredictiveFrameCount,
    temporalLayerCount: temporalLayerCount,
  )

proc newVkVideoEncodeAV1QIndexKHR*(intraQIndex: uint32, predictiveQIndex: uint32, bipredictiveQIndex: uint32): VkVideoEncodeAV1QIndexKHR =
  result = VkVideoEncodeAV1QIndexKHR(
    intraQIndex: intraQIndex,
    predictiveQIndex: predictiveQIndex,
    bipredictiveQIndex: bipredictiveQIndex,
  )

proc newVkVideoEncodeAV1FrameSizeKHR*(intraFrameSize: uint32, predictiveFrameSize: uint32, bipredictiveFrameSize: uint32): VkVideoEncodeAV1FrameSizeKHR =
  result = VkVideoEncodeAV1FrameSizeKHR(
    intraFrameSize: intraFrameSize,
    predictiveFrameSize: predictiveFrameSize,
    bipredictiveFrameSize: bipredictiveFrameSize,
  )

proc newVkVideoEncodeAV1GopRemainingFrameInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1GopRemainingFrameInfoKHR, pNext: pointer = nil, useGopRemainingFrames: VkBool32, gopRemainingIntra: uint32, gopRemainingPredictive: uint32, gopRemainingBipredictive: uint32): VkVideoEncodeAV1GopRemainingFrameInfoKHR =
  result = VkVideoEncodeAV1GopRemainingFrameInfoKHR(
    sType: sType,
    pNext: pNext,
    useGopRemainingFrames: useGopRemainingFrames,
    gopRemainingIntra: gopRemainingIntra,
    gopRemainingPredictive: gopRemainingPredictive,
    gopRemainingBipredictive: gopRemainingBipredictive,
  )

proc newVkVideoEncodeAV1RateControlLayerInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeAV1RateControlLayerInfoKHR, pNext: pointer = nil, useMinQIndex: VkBool32, minQIndex: VkVideoEncodeAV1QIndexKHR, useMaxQIndex: VkBool32, maxQIndex: VkVideoEncodeAV1QIndexKHR, useMaxFrameSize: VkBool32, maxFrameSize: VkVideoEncodeAV1FrameSizeKHR): VkVideoEncodeAV1RateControlLayerInfoKHR =
  result = VkVideoEncodeAV1RateControlLayerInfoKHR(
    sType: sType,
    pNext: pNext,
    useMinQIndex: useMinQIndex,
    minQIndex: minQIndex,
    useMaxQIndex: useMaxQIndex,
    maxQIndex: maxQIndex,
    useMaxFrameSize: useMaxFrameSize,
    maxFrameSize: maxFrameSize,
  )

proc newVkPhysicalDeviceInheritedViewportScissorFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceInheritedViewportScissorFeaturesNV, pNext: pointer = nil, inheritedViewportScissor2D: VkBool32): VkPhysicalDeviceInheritedViewportScissorFeaturesNV =
  result = VkPhysicalDeviceInheritedViewportScissorFeaturesNV(
    sType: sType,
    pNext: pNext,
    inheritedViewportScissor2D: inheritedViewportScissor2D,
  )

proc newVkCommandBufferInheritanceViewportScissorInfoNV*(sType: VkStructureType = VkStructureType.CommandBufferInheritanceViewportScissorInfoNV, pNext: pointer = nil, viewportScissor2D: VkBool32, viewportDepths: openarray[VkViewport]): VkCommandBufferInheritanceViewportScissorInfoNV =
  result = VkCommandBufferInheritanceViewportScissorInfoNV(
    sType: sType,
    pNext: pNext,
    viewportScissor2D: viewportScissor2D,
    viewportDepthCount: len(viewportDepths).uint32,
    pViewportDepths: if len(viewportDepths) == 0: nil else: cast[ptr VkViewport](viewportDepths),
  )

proc newVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, pNext: pointer = nil, ycbcr2plane444Formats: VkBool32): VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT =
  result = VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(
    sType: sType,
    pNext: pNext,
    ycbcr2plane444Formats: ycbcr2plane444Formats,
  )

proc newVkPhysicalDeviceProvokingVertexFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceProvokingVertexFeaturesEXT, pNext: pointer = nil, provokingVertexLast: VkBool32, transformFeedbackPreservesProvokingVertex: VkBool32): VkPhysicalDeviceProvokingVertexFeaturesEXT =
  result = VkPhysicalDeviceProvokingVertexFeaturesEXT(
    sType: sType,
    pNext: pNext,
    provokingVertexLast: provokingVertexLast,
    transformFeedbackPreservesProvokingVertex: transformFeedbackPreservesProvokingVertex,
  )

proc newVkPhysicalDeviceProvokingVertexPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceProvokingVertexPropertiesEXT, pNext: pointer = nil, provokingVertexModePerPipeline: VkBool32, transformFeedbackPreservesTriangleFanProvokingVertex: VkBool32): VkPhysicalDeviceProvokingVertexPropertiesEXT =
  result = VkPhysicalDeviceProvokingVertexPropertiesEXT(
    sType: sType,
    pNext: pNext,
    provokingVertexModePerPipeline: provokingVertexModePerPipeline,
    transformFeedbackPreservesTriangleFanProvokingVertex: transformFeedbackPreservesTriangleFanProvokingVertex,
  )

proc newVkPipelineRasterizationProvokingVertexStateCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineRasterizationProvokingVertexStateCreateInfoEXT, pNext: pointer = nil, provokingVertexMode: VkProvokingVertexModeEXT): VkPipelineRasterizationProvokingVertexStateCreateInfoEXT =
  result = VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    provokingVertexMode: provokingVertexMode,
  )

proc newVkVideoEncodeIntraRefreshCapabilitiesKHR*(sType: VkStructureType = VkStructureType.VideoEncodeIntraRefreshCapabilitiesKHR, pNext: pointer = nil, intraRefreshModes: VkVideoEncodeIntraRefreshModeFlagsKHR, maxIntraRefreshCycleDuration: uint32, maxIntraRefreshActiveReferencePictures: uint32, partitionIndependentIntraRefreshRegions: VkBool32, nonRectangularIntraRefreshRegions: VkBool32): VkVideoEncodeIntraRefreshCapabilitiesKHR =
  result = VkVideoEncodeIntraRefreshCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    intraRefreshModes: intraRefreshModes,
    maxIntraRefreshCycleDuration: maxIntraRefreshCycleDuration,
    maxIntraRefreshActiveReferencePictures: maxIntraRefreshActiveReferencePictures,
    partitionIndependentIntraRefreshRegions: partitionIndependentIntraRefreshRegions,
    nonRectangularIntraRefreshRegions: nonRectangularIntraRefreshRegions,
  )

proc newVkVideoEncodeSessionIntraRefreshCreateInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeSessionIntraRefreshCreateInfoKHR, pNext: pointer = nil, intraRefreshMode: VkVideoEncodeIntraRefreshModeFlagBitsKHR): VkVideoEncodeSessionIntraRefreshCreateInfoKHR =
  result = VkVideoEncodeSessionIntraRefreshCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    intraRefreshMode: intraRefreshMode,
  )

proc newVkVideoEncodeIntraRefreshInfoKHR*(sType: VkStructureType = VkStructureType.VideoEncodeIntraRefreshInfoKHR, pNext: pointer = nil, intraRefreshCycleDuration: uint32, intraRefreshIndex: uint32): VkVideoEncodeIntraRefreshInfoKHR =
  result = VkVideoEncodeIntraRefreshInfoKHR(
    sType: sType,
    pNext: pNext,
    intraRefreshCycleDuration: intraRefreshCycleDuration,
    intraRefreshIndex: intraRefreshIndex,
  )

proc newVkVideoReferenceIntraRefreshInfoKHR*(sType: VkStructureType = VkStructureType.VideoReferenceIntraRefreshInfoKHR, pNext: pointer = nil, dirtyIntraRefreshRegions: uint32): VkVideoReferenceIntraRefreshInfoKHR =
  result = VkVideoReferenceIntraRefreshInfoKHR(
    sType: sType,
    pNext: pNext,
    dirtyIntraRefreshRegions: dirtyIntraRefreshRegions,
  )

proc newVkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR, pNext: pointer = nil, videoEncodeIntraRefresh: VkBool32): VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR =
  result = VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(
    sType: sType,
    pNext: pNext,
    videoEncodeIntraRefresh: videoEncodeIntraRefresh,
  )

proc newVkCuModuleCreateInfoNVX*(sType: VkStructureType = VkStructureType.CuModuleCreateInfoNVX, pNext: pointer = nil, dataSize: uint, pData: pointer = nil): VkCuModuleCreateInfoNVX =
  result = VkCuModuleCreateInfoNVX(
    sType: sType,
    pNext: pNext,
    dataSize: dataSize,
    pData: pData,
  )

proc newVkCuModuleTexturingModeCreateInfoNVX*(sType: VkStructureType = VkStructureType.CuModuleTexturingModeCreateInfoNVX, pNext: pointer = nil, use64bitTexturing: VkBool32): VkCuModuleTexturingModeCreateInfoNVX =
  result = VkCuModuleTexturingModeCreateInfoNVX(
    sType: sType,
    pNext: pNext,
    use64bitTexturing: use64bitTexturing,
  )

proc newVkCuFunctionCreateInfoNVX*(sType: VkStructureType = VkStructureType.CuFunctionCreateInfoNVX, pNext: pointer = nil, module: VkCuModuleNVX, pName: cstring): VkCuFunctionCreateInfoNVX =
  result = VkCuFunctionCreateInfoNVX(
    sType: sType,
    pNext: pNext,
    module: module,
    pName: pName,
  )

proc newVkCuLaunchInfoNVX*(sType: VkStructureType = VkStructureType.CuLaunchInfoNVX, pNext: pointer = nil, function: VkCuFunctionNVX, gridDimX: uint32, gridDimY: uint32, gridDimZ: uint32, blockDimX: uint32, blockDimY: uint32, blockDimZ: uint32, sharedMemBytes: uint32, params: openarray[pointer], extras: openarray[pointer]): VkCuLaunchInfoNVX =
  result = VkCuLaunchInfoNVX(
    sType: sType,
    pNext: pNext,
    function: function,
    gridDimX: gridDimX,
    gridDimY: gridDimY,
    gridDimZ: gridDimZ,
    blockDimX: blockDimX,
    blockDimY: blockDimY,
    blockDimZ: blockDimZ,
    sharedMemBytes: sharedMemBytes,
    paramCount: len(params).uint,
    pParams: if len(params) == 0: nil else: cast[ptr pointer](params),
    extraCount: len(extras).uint,
    pExtras: if len(extras) == 0: nil else: cast[ptr pointer](extras),
  )

proc newVkPhysicalDeviceDescriptorBufferFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorBufferFeaturesEXT, pNext: pointer = nil, descriptorBuffer: VkBool32, descriptorBufferCaptureReplay: VkBool32, descriptorBufferImageLayoutIgnored: VkBool32, descriptorBufferPushDescriptors: VkBool32): VkPhysicalDeviceDescriptorBufferFeaturesEXT =
  result = VkPhysicalDeviceDescriptorBufferFeaturesEXT(
    sType: sType,
    pNext: pNext,
    descriptorBuffer: descriptorBuffer,
    descriptorBufferCaptureReplay: descriptorBufferCaptureReplay,
    descriptorBufferImageLayoutIgnored: descriptorBufferImageLayoutIgnored,
    descriptorBufferPushDescriptors: descriptorBufferPushDescriptors,
  )

proc newVkPhysicalDeviceDescriptorBufferPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorBufferPropertiesEXT, pNext: pointer = nil, combinedImageSamplerDescriptorSingleArray: VkBool32, bufferlessPushDescriptors: VkBool32, allowSamplerImageViewPostSubmitCreation: VkBool32, descriptorBufferOffsetAlignment: VkDeviceSize, maxDescriptorBufferBindings: uint32, maxResourceDescriptorBufferBindings: uint32, maxSamplerDescriptorBufferBindings: uint32, maxEmbeddedImmutableSamplerBindings: uint32, maxEmbeddedImmutableSamplers: uint32, bufferCaptureReplayDescriptorDataSize: uint, imageCaptureReplayDescriptorDataSize: uint, imageViewCaptureReplayDescriptorDataSize: uint, samplerCaptureReplayDescriptorDataSize: uint, accelerationStructureCaptureReplayDescriptorDataSize: uint, samplerDescriptorSize: uint, combinedImageSamplerDescriptorSize: uint, sampledImageDescriptorSize: uint, storageImageDescriptorSize: uint, uniformTexelBufferDescriptorSize: uint, robustUniformTexelBufferDescriptorSize: uint, storageTexelBufferDescriptorSize: uint, robustStorageTexelBufferDescriptorSize: uint, uniformBufferDescriptorSize: uint, robustUniformBufferDescriptorSize: uint, storageBufferDescriptorSize: uint, robustStorageBufferDescriptorSize: uint, inputAttachmentDescriptorSize: uint, accelerationStructureDescriptorSize: uint, maxSamplerDescriptorBufferRange: VkDeviceSize, maxResourceDescriptorBufferRange: VkDeviceSize, samplerDescriptorBufferAddressSpaceSize: VkDeviceSize, resourceDescriptorBufferAddressSpaceSize: VkDeviceSize, descriptorBufferAddressSpaceSize: VkDeviceSize): VkPhysicalDeviceDescriptorBufferPropertiesEXT =
  result = VkPhysicalDeviceDescriptorBufferPropertiesEXT(
    sType: sType,
    pNext: pNext,
    combinedImageSamplerDescriptorSingleArray: combinedImageSamplerDescriptorSingleArray,
    bufferlessPushDescriptors: bufferlessPushDescriptors,
    allowSamplerImageViewPostSubmitCreation: allowSamplerImageViewPostSubmitCreation,
    descriptorBufferOffsetAlignment: descriptorBufferOffsetAlignment,
    maxDescriptorBufferBindings: maxDescriptorBufferBindings,
    maxResourceDescriptorBufferBindings: maxResourceDescriptorBufferBindings,
    maxSamplerDescriptorBufferBindings: maxSamplerDescriptorBufferBindings,
    maxEmbeddedImmutableSamplerBindings: maxEmbeddedImmutableSamplerBindings,
    maxEmbeddedImmutableSamplers: maxEmbeddedImmutableSamplers,
    bufferCaptureReplayDescriptorDataSize: bufferCaptureReplayDescriptorDataSize,
    imageCaptureReplayDescriptorDataSize: imageCaptureReplayDescriptorDataSize,
    imageViewCaptureReplayDescriptorDataSize: imageViewCaptureReplayDescriptorDataSize,
    samplerCaptureReplayDescriptorDataSize: samplerCaptureReplayDescriptorDataSize,
    accelerationStructureCaptureReplayDescriptorDataSize: accelerationStructureCaptureReplayDescriptorDataSize,
    samplerDescriptorSize: samplerDescriptorSize,
    combinedImageSamplerDescriptorSize: combinedImageSamplerDescriptorSize,
    sampledImageDescriptorSize: sampledImageDescriptorSize,
    storageImageDescriptorSize: storageImageDescriptorSize,
    uniformTexelBufferDescriptorSize: uniformTexelBufferDescriptorSize,
    robustUniformTexelBufferDescriptorSize: robustUniformTexelBufferDescriptorSize,
    storageTexelBufferDescriptorSize: storageTexelBufferDescriptorSize,
    robustStorageTexelBufferDescriptorSize: robustStorageTexelBufferDescriptorSize,
    uniformBufferDescriptorSize: uniformBufferDescriptorSize,
    robustUniformBufferDescriptorSize: robustUniformBufferDescriptorSize,
    storageBufferDescriptorSize: storageBufferDescriptorSize,
    robustStorageBufferDescriptorSize: robustStorageBufferDescriptorSize,
    inputAttachmentDescriptorSize: inputAttachmentDescriptorSize,
    accelerationStructureDescriptorSize: accelerationStructureDescriptorSize,
    maxSamplerDescriptorBufferRange: maxSamplerDescriptorBufferRange,
    maxResourceDescriptorBufferRange: maxResourceDescriptorBufferRange,
    samplerDescriptorBufferAddressSpaceSize: samplerDescriptorBufferAddressSpaceSize,
    resourceDescriptorBufferAddressSpaceSize: resourceDescriptorBufferAddressSpaceSize,
    descriptorBufferAddressSpaceSize: descriptorBufferAddressSpaceSize,
  )

proc newVkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, pNext: pointer = nil, combinedImageSamplerDensityMapDescriptorSize: uint): VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT =
  result = VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(
    sType: sType,
    pNext: pNext,
    combinedImageSamplerDensityMapDescriptorSize: combinedImageSamplerDensityMapDescriptorSize,
  )

proc newVkDescriptorAddressInfoEXT*(sType: VkStructureType = VkStructureType.DescriptorAddressInfoEXT, pNext: pointer = nil, address: VkDeviceAddress, range: VkDeviceSize, format: VkFormat): VkDescriptorAddressInfoEXT =
  result = VkDescriptorAddressInfoEXT(
    sType: sType,
    pNext: pNext,
    address: address,
    range: range,
    format: format,
  )

proc newVkDescriptorBufferBindingInfoEXT*(sType: VkStructureType = VkStructureType.DescriptorBufferBindingInfoEXT, pNext: pointer = nil, address: VkDeviceAddress, usage: VkBufferUsageFlags): VkDescriptorBufferBindingInfoEXT =
  result = VkDescriptorBufferBindingInfoEXT(
    sType: sType,
    pNext: pNext,
    address: address,
    usage: usage,
  )

proc newVkDescriptorBufferBindingPushDescriptorBufferHandleEXT*(sType: VkStructureType = VkStructureType.DescriptorBufferBindingPushDescriptorBufferHandleEXT, pNext: pointer = nil, buffer: VkBuffer): VkDescriptorBufferBindingPushDescriptorBufferHandleEXT =
  result = VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(
    sType: sType,
    pNext: pNext,
    buffer: buffer,
  )

proc newVkDescriptorGetInfoEXT*(sType: VkStructureType = VkStructureType.DescriptorGetInfoEXT, pNext: pointer = nil, `type`: VkDescriptorType, data: VkDescriptorDataEXT): VkDescriptorGetInfoEXT =
  result = VkDescriptorGetInfoEXT(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    data: data,
  )

proc newVkBufferCaptureDescriptorDataInfoEXT*(sType: VkStructureType = VkStructureType.BufferCaptureDescriptorDataInfoEXT, pNext: pointer = nil, buffer: VkBuffer): VkBufferCaptureDescriptorDataInfoEXT =
  result = VkBufferCaptureDescriptorDataInfoEXT(
    sType: sType,
    pNext: pNext,
    buffer: buffer,
  )

proc newVkImageCaptureDescriptorDataInfoEXT*(sType: VkStructureType = VkStructureType.ImageCaptureDescriptorDataInfoEXT, pNext: pointer = nil, image: VkImage): VkImageCaptureDescriptorDataInfoEXT =
  result = VkImageCaptureDescriptorDataInfoEXT(
    sType: sType,
    pNext: pNext,
    image: image,
  )

proc newVkImageViewCaptureDescriptorDataInfoEXT*(sType: VkStructureType = VkStructureType.ImageViewCaptureDescriptorDataInfoEXT, pNext: pointer = nil, imageView: VkImageView): VkImageViewCaptureDescriptorDataInfoEXT =
  result = VkImageViewCaptureDescriptorDataInfoEXT(
    sType: sType,
    pNext: pNext,
    imageView: imageView,
  )

proc newVkSamplerCaptureDescriptorDataInfoEXT*(sType: VkStructureType = VkStructureType.SamplerCaptureDescriptorDataInfoEXT, pNext: pointer = nil, sampler: VkSampler): VkSamplerCaptureDescriptorDataInfoEXT =
  result = VkSamplerCaptureDescriptorDataInfoEXT(
    sType: sType,
    pNext: pNext,
    sampler: sampler,
  )

proc newVkAccelerationStructureCaptureDescriptorDataInfoEXT*(sType: VkStructureType = VkStructureType.AccelerationStructureCaptureDescriptorDataInfoEXT, pNext: pointer = nil, accelerationStructure: VkAccelerationStructureKHR, accelerationStructureNV: VkAccelerationStructureNV): VkAccelerationStructureCaptureDescriptorDataInfoEXT =
  result = VkAccelerationStructureCaptureDescriptorDataInfoEXT(
    sType: sType,
    pNext: pNext,
    accelerationStructure: accelerationStructure,
    accelerationStructureNV: accelerationStructureNV,
  )

proc newVkOpaqueCaptureDescriptorDataCreateInfoEXT*(sType: VkStructureType = VkStructureType.OpaqueCaptureDescriptorDataCreateInfoEXT, pNext: pointer = nil, opaqueCaptureDescriptorData: pointer = nil): VkOpaqueCaptureDescriptorDataCreateInfoEXT =
  result = VkOpaqueCaptureDescriptorDataCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    opaqueCaptureDescriptorData: opaqueCaptureDescriptorData,
  )

proc newVkPhysicalDeviceShaderIntegerDotProductFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderIntegerDotProductFeatures, pNext: pointer = nil, shaderIntegerDotProduct: VkBool32): VkPhysicalDeviceShaderIntegerDotProductFeatures =
  result = VkPhysicalDeviceShaderIntegerDotProductFeatures(
    sType: sType,
    pNext: pNext,
    shaderIntegerDotProduct: shaderIntegerDotProduct,
  )

proc newVkPhysicalDeviceShaderIntegerDotProductProperties*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderIntegerDotProductProperties, pNext: pointer = nil, integerDotProduct8BitUnsignedAccelerated: VkBool32, integerDotProduct8BitSignedAccelerated: VkBool32, integerDotProduct8BitMixedSignednessAccelerated: VkBool32, integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32, integerDotProduct4x8BitPackedSignedAccelerated: VkBool32, integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32, integerDotProduct16BitUnsignedAccelerated: VkBool32, integerDotProduct16BitSignedAccelerated: VkBool32, integerDotProduct16BitMixedSignednessAccelerated: VkBool32, integerDotProduct32BitUnsignedAccelerated: VkBool32, integerDotProduct32BitSignedAccelerated: VkBool32, integerDotProduct32BitMixedSignednessAccelerated: VkBool32, integerDotProduct64BitUnsignedAccelerated: VkBool32, integerDotProduct64BitSignedAccelerated: VkBool32, integerDotProduct64BitMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32, integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32, integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32): VkPhysicalDeviceShaderIntegerDotProductProperties =
  result = VkPhysicalDeviceShaderIntegerDotProductProperties(
    sType: sType,
    pNext: pNext,
    integerDotProduct8BitUnsignedAccelerated: integerDotProduct8BitUnsignedAccelerated,
    integerDotProduct8BitSignedAccelerated: integerDotProduct8BitSignedAccelerated,
    integerDotProduct8BitMixedSignednessAccelerated: integerDotProduct8BitMixedSignednessAccelerated,
    integerDotProduct4x8BitPackedUnsignedAccelerated: integerDotProduct4x8BitPackedUnsignedAccelerated,
    integerDotProduct4x8BitPackedSignedAccelerated: integerDotProduct4x8BitPackedSignedAccelerated,
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: integerDotProduct4x8BitPackedMixedSignednessAccelerated,
    integerDotProduct16BitUnsignedAccelerated: integerDotProduct16BitUnsignedAccelerated,
    integerDotProduct16BitSignedAccelerated: integerDotProduct16BitSignedAccelerated,
    integerDotProduct16BitMixedSignednessAccelerated: integerDotProduct16BitMixedSignednessAccelerated,
    integerDotProduct32BitUnsignedAccelerated: integerDotProduct32BitUnsignedAccelerated,
    integerDotProduct32BitSignedAccelerated: integerDotProduct32BitSignedAccelerated,
    integerDotProduct32BitMixedSignednessAccelerated: integerDotProduct32BitMixedSignednessAccelerated,
    integerDotProduct64BitUnsignedAccelerated: integerDotProduct64BitUnsignedAccelerated,
    integerDotProduct64BitSignedAccelerated: integerDotProduct64BitSignedAccelerated,
    integerDotProduct64BitMixedSignednessAccelerated: integerDotProduct64BitMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: integerDotProductAccumulatingSaturating8BitUnsignedAccelerated,
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: integerDotProductAccumulatingSaturating8BitSignedAccelerated,
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated,
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated,
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: integerDotProductAccumulatingSaturating16BitUnsignedAccelerated,
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: integerDotProductAccumulatingSaturating16BitSignedAccelerated,
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: integerDotProductAccumulatingSaturating32BitUnsignedAccelerated,
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: integerDotProductAccumulatingSaturating32BitSignedAccelerated,
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated,
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: integerDotProductAccumulatingSaturating64BitUnsignedAccelerated,
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: integerDotProductAccumulatingSaturating64BitSignedAccelerated,
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated,
  )

proc newVkPhysicalDeviceDrmPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDrmPropertiesEXT, pNext: pointer = nil, hasPrimary: VkBool32, hasRender: VkBool32, primaryMajor: int64, primaryMinor: int64, renderMajor: int64, renderMinor: int64): VkPhysicalDeviceDrmPropertiesEXT =
  result = VkPhysicalDeviceDrmPropertiesEXT(
    sType: sType,
    pNext: pNext,
    hasPrimary: hasPrimary,
    hasRender: hasRender,
    primaryMajor: primaryMajor,
    primaryMinor: primaryMinor,
    renderMajor: renderMajor,
    renderMinor: renderMinor,
  )

proc newVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentShaderBarycentricFeaturesKHR, pNext: pointer = nil, fragmentShaderBarycentric: VkBool32): VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR =
  result = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(
    sType: sType,
    pNext: pNext,
    fragmentShaderBarycentric: fragmentShaderBarycentric,
  )

proc newVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentShaderBarycentricPropertiesKHR, pNext: pointer = nil, triStripVertexOrderIndependentOfProvokingVertex: VkBool32): VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR =
  result = VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(
    sType: sType,
    pNext: pNext,
    triStripVertexOrderIndependentOfProvokingVertex: triStripVertexOrderIndependentOfProvokingVertex,
  )

proc newVkPhysicalDeviceShaderFmaFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderFmaFeaturesKHR, pNext: pointer = nil, shaderFmaFloat16: VkBool32, shaderFmaFloat32: VkBool32, shaderFmaFloat64: VkBool32): VkPhysicalDeviceShaderFmaFeaturesKHR =
  result = VkPhysicalDeviceShaderFmaFeaturesKHR(
    sType: sType,
    pNext: pNext,
    shaderFmaFloat16: shaderFmaFloat16,
    shaderFmaFloat32: shaderFmaFloat32,
    shaderFmaFloat64: shaderFmaFloat64,
  )

proc newVkPhysicalDeviceRayTracingMotionBlurFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingMotionBlurFeaturesNV, pNext: pointer = nil, rayTracingMotionBlur: VkBool32, rayTracingMotionBlurPipelineTraceRaysIndirect: VkBool32): VkPhysicalDeviceRayTracingMotionBlurFeaturesNV =
  result = VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(
    sType: sType,
    pNext: pNext,
    rayTracingMotionBlur: rayTracingMotionBlur,
    rayTracingMotionBlurPipelineTraceRaysIndirect: rayTracingMotionBlurPipelineTraceRaysIndirect,
  )

proc newVkPhysicalDeviceRayTracingValidationFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingValidationFeaturesNV, pNext: pointer = nil, rayTracingValidation: VkBool32): VkPhysicalDeviceRayTracingValidationFeaturesNV =
  result = VkPhysicalDeviceRayTracingValidationFeaturesNV(
    sType: sType,
    pNext: pNext,
    rayTracingValidation: rayTracingValidation,
  )

proc newVkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV, pNext: pointer = nil, spheres: VkBool32, linearSweptSpheres: VkBool32): VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV =
  result = VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(
    sType: sType,
    pNext: pNext,
    spheres: spheres,
    linearSweptSpheres: linearSweptSpheres,
  )

proc newVkAccelerationStructureGeometryMotionTrianglesDataNV*(sType: VkStructureType = VkStructureType.AccelerationStructureGeometryMotionTrianglesDataNV, pNext: pointer = nil, vertexData: VkDeviceOrHostAddressConstKHR): VkAccelerationStructureGeometryMotionTrianglesDataNV =
  result = VkAccelerationStructureGeometryMotionTrianglesDataNV(
    sType: sType,
    pNext: pNext,
    vertexData: vertexData,
  )

proc newVkAccelerationStructureMotionInfoNV*(sType: VkStructureType = VkStructureType.AccelerationStructureMotionInfoNV, pNext: pointer = nil, maxInstances: uint32, flags: VkAccelerationStructureMotionInfoFlagsNV = 0.VkAccelerationStructureMotionInfoFlagsNV): VkAccelerationStructureMotionInfoNV =
  result = VkAccelerationStructureMotionInfoNV(
    sType: sType,
    pNext: pNext,
    maxInstances: maxInstances,
    flags: flags,
  )

proc newVkSRTDataNV*(sx: float32, a: float32, b: float32, pvx: float32, sy: float32, c: float32, pvy: float32, sz: float32, pvz: float32, qx: float32, qy: float32, qz: float32, qw: float32, tx: float32, ty: float32, tz: float32): VkSRTDataNV =
  result = VkSRTDataNV(
    sx: sx,
    a: a,
    b: b,
    pvx: pvx,
    sy: sy,
    c: c,
    pvy: pvy,
    sz: sz,
    pvz: pvz,
    qx: qx,
    qy: qy,
    qz: qz,
    qw: qw,
    tx: tx,
    ty: ty,
    tz: tz,
  )

proc newVkAccelerationStructureSRTMotionInstanceNV*(transformT0: VkSRTDataNV, transformT1: VkSRTDataNV, instanceCustomIndex: uint32, mask: uint32, instanceShaderBindingTableRecordOffset: uint32, flags: VkGeometryInstanceFlagsKHR = 0.VkGeometryInstanceFlagsKHR, accelerationStructureReference: uint64): VkAccelerationStructureSRTMotionInstanceNV =
  result = VkAccelerationStructureSRTMotionInstanceNV(
    transformT0: transformT0,
    transformT1: transformT1,
    instanceCustomIndex: instanceCustomIndex,
    mask: mask,
    instanceShaderBindingTableRecordOffset: instanceShaderBindingTableRecordOffset,
    flags: flags,
    accelerationStructureReference: accelerationStructureReference,
  )

proc newVkAccelerationStructureMatrixMotionInstanceNV*(transformT0: VkTransformMatrixKHR, transformT1: VkTransformMatrixKHR, instanceCustomIndex: uint32, mask: uint32, instanceShaderBindingTableRecordOffset: uint32, flags: VkGeometryInstanceFlagsKHR = 0.VkGeometryInstanceFlagsKHR, accelerationStructureReference: uint64): VkAccelerationStructureMatrixMotionInstanceNV =
  result = VkAccelerationStructureMatrixMotionInstanceNV(
    transformT0: transformT0,
    transformT1: transformT1,
    instanceCustomIndex: instanceCustomIndex,
    mask: mask,
    instanceShaderBindingTableRecordOffset: instanceShaderBindingTableRecordOffset,
    flags: flags,
    accelerationStructureReference: accelerationStructureReference,
  )

proc newVkAccelerationStructureMotionInstanceNV*(`type`: VkAccelerationStructureMotionInstanceTypeNV, flags: VkAccelerationStructureMotionInstanceFlagsNV = 0.VkAccelerationStructureMotionInstanceFlagsNV, data: VkAccelerationStructureMotionInstanceDataNV): VkAccelerationStructureMotionInstanceNV =
  result = VkAccelerationStructureMotionInstanceNV(
    `type`: `type`,
    flags: flags,
    data: data,
  )

proc newVkMemoryGetRemoteAddressInfoNV*(sType: VkStructureType = VkStructureType.MemoryGetRemoteAddressInfoNV, pNext: pointer = nil, memory: VkDeviceMemory, handleType: VkExternalMemoryHandleTypeFlagBits): VkMemoryGetRemoteAddressInfoNV =
  result = VkMemoryGetRemoteAddressInfoNV(
    sType: sType,
    pNext: pNext,
    memory: memory,
    handleType: handleType,
  )

proc newVkImportMemoryBufferCollectionFUCHSIA*(sType: VkStructureType = VkStructureType.ImportMemoryBufferCollectionFUCHSIA, pNext: pointer = nil, collection: VkBufferCollectionFUCHSIA, index: uint32): VkImportMemoryBufferCollectionFUCHSIA =
  result = VkImportMemoryBufferCollectionFUCHSIA(
    sType: sType,
    pNext: pNext,
    collection: collection,
    index: index,
  )

proc newVkBufferCollectionImageCreateInfoFUCHSIA*(sType: VkStructureType = VkStructureType.BufferCollectionImageCreateInfoFUCHSIA, pNext: pointer = nil, collection: VkBufferCollectionFUCHSIA, index: uint32): VkBufferCollectionImageCreateInfoFUCHSIA =
  result = VkBufferCollectionImageCreateInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    collection: collection,
    index: index,
  )

proc newVkBufferCollectionBufferCreateInfoFUCHSIA*(sType: VkStructureType = VkStructureType.BufferCollectionBufferCreateInfoFUCHSIA, pNext: pointer = nil, collection: VkBufferCollectionFUCHSIA, index: uint32): VkBufferCollectionBufferCreateInfoFUCHSIA =
  result = VkBufferCollectionBufferCreateInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    collection: collection,
    index: index,
  )

proc newVkBufferCollectionCreateInfoFUCHSIA*(sType: VkStructureType = VkStructureType.BufferCollectionCreateInfoFUCHSIA, pNext: pointer = nil, collectionToken: zx_handle_t): VkBufferCollectionCreateInfoFUCHSIA =
  result = VkBufferCollectionCreateInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    collectionToken: collectionToken,
  )

proc newVkBufferCollectionPropertiesFUCHSIA*(sType: VkStructureType = VkStructureType.BufferCollectionPropertiesFUCHSIA, pNext: pointer = nil, memoryTypeBits: uint32, bufferCount: uint32, createInfoIndex: uint32, sysmemPixelFormat: uint64, formatFeatures: VkFormatFeatureFlags, sysmemColorSpaceIndex: VkSysmemColorSpaceFUCHSIA, samplerYcbcrConversionComponents: VkComponentMapping, suggestedYcbcrModel: VkSamplerYcbcrModelConversion, suggestedYcbcrRange: VkSamplerYcbcrRange, suggestedXChromaOffset: VkChromaLocation, suggestedYChromaOffset: VkChromaLocation): VkBufferCollectionPropertiesFUCHSIA =
  result = VkBufferCollectionPropertiesFUCHSIA(
    sType: sType,
    pNext: pNext,
    memoryTypeBits: memoryTypeBits,
    bufferCount: bufferCount,
    createInfoIndex: createInfoIndex,
    sysmemPixelFormat: sysmemPixelFormat,
    formatFeatures: formatFeatures,
    sysmemColorSpaceIndex: sysmemColorSpaceIndex,
    samplerYcbcrConversionComponents: samplerYcbcrConversionComponents,
    suggestedYcbcrModel: suggestedYcbcrModel,
    suggestedYcbcrRange: suggestedYcbcrRange,
    suggestedXChromaOffset: suggestedXChromaOffset,
    suggestedYChromaOffset: suggestedYChromaOffset,
  )

proc newVkBufferConstraintsInfoFUCHSIA*(sType: VkStructureType = VkStructureType.BufferConstraintsInfoFUCHSIA, pNext: pointer = nil, createInfo: VkBufferCreateInfo, requiredFormatFeatures: VkFormatFeatureFlags, bufferCollectionConstraints: VkBufferCollectionConstraintsInfoFUCHSIA): VkBufferConstraintsInfoFUCHSIA =
  result = VkBufferConstraintsInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    createInfo: createInfo,
    requiredFormatFeatures: requiredFormatFeatures,
    bufferCollectionConstraints: bufferCollectionConstraints,
  )

proc newVkSysmemColorSpaceFUCHSIA*(sType: VkStructureType = VkStructureType.SysmemColorSpaceFUCHSIA, pNext: pointer = nil, colorSpace: uint32): VkSysmemColorSpaceFUCHSIA =
  result = VkSysmemColorSpaceFUCHSIA(
    sType: sType,
    pNext: pNext,
    colorSpace: colorSpace,
  )

proc newVkImageFormatConstraintsInfoFUCHSIA*(sType: VkStructureType = VkStructureType.ImageFormatConstraintsInfoFUCHSIA, pNext: pointer = nil, imageCreateInfo: VkImageCreateInfo, requiredFormatFeatures: VkFormatFeatureFlags, flags: VkImageFormatConstraintsFlagsFUCHSIA = 0.VkImageFormatConstraintsFlagsFUCHSIA, sysmemPixelFormat: uint64, colorSpaces: openarray[VkSysmemColorSpaceFUCHSIA]): VkImageFormatConstraintsInfoFUCHSIA =
  result = VkImageFormatConstraintsInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    imageCreateInfo: imageCreateInfo,
    requiredFormatFeatures: requiredFormatFeatures,
    flags: flags,
    sysmemPixelFormat: sysmemPixelFormat,
    colorSpaceCount: len(colorSpaces).uint32,
    pColorSpaces: if len(colorSpaces) == 0: nil else: cast[ptr VkSysmemColorSpaceFUCHSIA](colorSpaces),
  )

proc newVkImageConstraintsInfoFUCHSIA*(sType: VkStructureType = VkStructureType.ImageConstraintsInfoFUCHSIA, pNext: pointer = nil, formatConstraints: openarray[VkImageFormatConstraintsInfoFUCHSIA], bufferCollectionConstraints: VkBufferCollectionConstraintsInfoFUCHSIA, flags: VkImageConstraintsInfoFlagsFUCHSIA = 0.VkImageConstraintsInfoFlagsFUCHSIA): VkImageConstraintsInfoFUCHSIA =
  result = VkImageConstraintsInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    formatConstraintsCount: len(formatConstraints).uint32,
    pFormatConstraints: if len(formatConstraints) == 0: nil else: cast[ptr VkImageFormatConstraintsInfoFUCHSIA](formatConstraints),
    bufferCollectionConstraints: bufferCollectionConstraints,
    flags: flags,
  )

proc newVkBufferCollectionConstraintsInfoFUCHSIA*(sType: VkStructureType = VkStructureType.BufferCollectionConstraintsInfoFUCHSIA, pNext: pointer = nil, minBufferCount: uint32, maxBufferCount: uint32, minBufferCountForCamping: uint32, minBufferCountForDedicatedSlack: uint32, minBufferCountForSharedSlack: uint32): VkBufferCollectionConstraintsInfoFUCHSIA =
  result = VkBufferCollectionConstraintsInfoFUCHSIA(
    sType: sType,
    pNext: pNext,
    minBufferCount: minBufferCount,
    maxBufferCount: maxBufferCount,
    minBufferCountForCamping: minBufferCountForCamping,
    minBufferCountForDedicatedSlack: minBufferCountForDedicatedSlack,
    minBufferCountForSharedSlack: minBufferCountForSharedSlack,
  )

proc newVkCudaModuleCreateInfoNV*(sType: VkStructureType = VkStructureType.CudaModuleCreateInfoNV, pNext: pointer = nil, dataSize: uint, pData: pointer = nil): VkCudaModuleCreateInfoNV =
  result = VkCudaModuleCreateInfoNV(
    sType: sType,
    pNext: pNext,
    dataSize: dataSize,
    pData: pData,
  )

proc newVkCudaFunctionCreateInfoNV*(sType: VkStructureType = VkStructureType.CudaFunctionCreateInfoNV, pNext: pointer = nil, module: VkCudaModuleNV, pName: cstring): VkCudaFunctionCreateInfoNV =
  result = VkCudaFunctionCreateInfoNV(
    sType: sType,
    pNext: pNext,
    module: module,
    pName: pName,
  )

proc newVkCudaLaunchInfoNV*(sType: VkStructureType = VkStructureType.CudaLaunchInfoNV, pNext: pointer = nil, function: VkCudaFunctionNV, gridDimX: uint32, gridDimY: uint32, gridDimZ: uint32, blockDimX: uint32, blockDimY: uint32, blockDimZ: uint32, sharedMemBytes: uint32, params: openarray[pointer], extras: openarray[pointer]): VkCudaLaunchInfoNV =
  result = VkCudaLaunchInfoNV(
    sType: sType,
    pNext: pNext,
    function: function,
    gridDimX: gridDimX,
    gridDimY: gridDimY,
    gridDimZ: gridDimZ,
    blockDimX: blockDimX,
    blockDimY: blockDimY,
    blockDimZ: blockDimZ,
    sharedMemBytes: sharedMemBytes,
    paramCount: len(params).uint,
    pParams: if len(params) == 0: nil else: cast[ptr pointer](params),
    extraCount: len(extras).uint,
    pExtras: if len(extras) == 0: nil else: cast[ptr pointer](extras),
  )

proc newVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceRGBA10X6FormatsFeaturesEXT, pNext: pointer = nil, formatRgba10x6WithoutYCbCrSampler: VkBool32): VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT =
  result = VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(
    sType: sType,
    pNext: pNext,
    formatRgba10x6WithoutYCbCrSampler: formatRgba10x6WithoutYCbCrSampler,
  )

proc newVkFormatProperties3*(sType: VkStructureType = VkStructureType.FormatProperties3, pNext: pointer = nil, linearTilingFeatures: VkFormatFeatureFlags2, optimalTilingFeatures: VkFormatFeatureFlags2, bufferFeatures: VkFormatFeatureFlags2): VkFormatProperties3 =
  result = VkFormatProperties3(
    sType: sType,
    pNext: pNext,
    linearTilingFeatures: linearTilingFeatures,
    optimalTilingFeatures: optimalTilingFeatures,
    bufferFeatures: bufferFeatures,
  )

proc newVkDrmFormatModifierPropertiesList2EXT*(sType: VkStructureType = VkStructureType.DrmFormatModifierPropertiesList2EXT, pNext: pointer = nil, drmFormatModifierProperties: openarray[VkDrmFormatModifierProperties2EXT]): VkDrmFormatModifierPropertiesList2EXT =
  result = VkDrmFormatModifierPropertiesList2EXT(
    sType: sType,
    pNext: pNext,
    drmFormatModifierCount: len(drmFormatModifierProperties).uint32,
    pDrmFormatModifierProperties: if len(drmFormatModifierProperties) == 0: nil else: cast[ptr VkDrmFormatModifierProperties2EXT](drmFormatModifierProperties),
  )

proc newVkDrmFormatModifierProperties2EXT*(drmFormatModifier: uint64, drmFormatModifierPlaneCount: uint32, drmFormatModifierTilingFeatures: VkFormatFeatureFlags2): VkDrmFormatModifierProperties2EXT =
  result = VkDrmFormatModifierProperties2EXT(
    drmFormatModifier: drmFormatModifier,
    drmFormatModifierPlaneCount: drmFormatModifierPlaneCount,
    drmFormatModifierTilingFeatures: drmFormatModifierTilingFeatures,
  )

proc newVkAndroidHardwareBufferFormatProperties2ANDROID*(sType: VkStructureType = VkStructureType.AndroidHardwareBufferFormatProperties2ANDROID, pNext: pointer = nil, format: VkFormat, externalFormat: uint64, formatFeatures: VkFormatFeatureFlags2, samplerYcbcrConversionComponents: VkComponentMapping, suggestedYcbcrModel: VkSamplerYcbcrModelConversion, suggestedYcbcrRange: VkSamplerYcbcrRange, suggestedXChromaOffset: VkChromaLocation, suggestedYChromaOffset: VkChromaLocation): VkAndroidHardwareBufferFormatProperties2ANDROID =
  result = VkAndroidHardwareBufferFormatProperties2ANDROID(
    sType: sType,
    pNext: pNext,
    format: format,
    externalFormat: externalFormat,
    formatFeatures: formatFeatures,
    samplerYcbcrConversionComponents: samplerYcbcrConversionComponents,
    suggestedYcbcrModel: suggestedYcbcrModel,
    suggestedYcbcrRange: suggestedYcbcrRange,
    suggestedXChromaOffset: suggestedXChromaOffset,
    suggestedYChromaOffset: suggestedYChromaOffset,
  )

proc newVkPipelineRenderingCreateInfo*(sType: VkStructureType = VkStructureType.PipelineRenderingCreateInfo, pNext: pointer = nil, viewMask: uint32, colorAttachmentFormats: openarray[VkFormat], depthAttachmentFormat: VkFormat, stencilAttachmentFormat: VkFormat): VkPipelineRenderingCreateInfo =
  result = VkPipelineRenderingCreateInfo(
    sType: sType,
    pNext: pNext,
    viewMask: viewMask,
    colorAttachmentCount: len(colorAttachmentFormats).uint32,
    pColorAttachmentFormats: if len(colorAttachmentFormats) == 0: nil else: cast[ptr VkFormat](colorAttachmentFormats),
    depthAttachmentFormat: depthAttachmentFormat,
    stencilAttachmentFormat: stencilAttachmentFormat,
  )

proc newVkRenderingInfo*(sType: VkStructureType = VkStructureType.RenderingInfo, pNext: pointer = nil, flags: VkRenderingFlags = 0.VkRenderingFlags, renderArea: VkRect2D, layerCount: uint32, viewMask: uint32, colorAttachments: openarray[VkRenderingAttachmentInfo], pDepthAttachment: ptr VkRenderingAttachmentInfo, pStencilAttachment: ptr VkRenderingAttachmentInfo): VkRenderingInfo =
  result = VkRenderingInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    renderArea: renderArea,
    layerCount: layerCount,
    viewMask: viewMask,
    colorAttachmentCount: len(colorAttachments).uint32,
    pColorAttachments: if len(colorAttachments) == 0: nil else: cast[ptr VkRenderingAttachmentInfo](colorAttachments),
    pDepthAttachment: pDepthAttachment,
    pStencilAttachment: pStencilAttachment,
  )

proc newVkRenderingEndInfoKHR*(sType: VkStructureType = VkStructureType.RenderingEndInfoKHR, pNext: pointer = nil): VkRenderingEndInfoKHR =
  result = VkRenderingEndInfoKHR(
    sType: sType,
    pNext: pNext,
  )

proc newVkRenderingAttachmentInfo*(sType: VkStructureType = VkStructureType.RenderingAttachmentInfo, pNext: pointer = nil, imageView: VkImageView, imageLayout: VkImageLayout, resolveMode: VkResolveModeFlagBits, resolveImageView: VkImageView, resolveImageLayout: VkImageLayout, loadOp: VkAttachmentLoadOp, storeOp: VkAttachmentStoreOp, clearValue: VkClearValue): VkRenderingAttachmentInfo =
  result = VkRenderingAttachmentInfo(
    sType: sType,
    pNext: pNext,
    imageView: imageView,
    imageLayout: imageLayout,
    resolveMode: resolveMode,
    resolveImageView: resolveImageView,
    resolveImageLayout: resolveImageLayout,
    loadOp: loadOp,
    storeOp: storeOp,
    clearValue: clearValue,
  )

proc newVkRenderingFragmentShadingRateAttachmentInfoKHR*(sType: VkStructureType = VkStructureType.RenderingFragmentShadingRateAttachmentInfoKHR, pNext: pointer = nil, imageView: VkImageView, imageLayout: VkImageLayout, shadingRateAttachmentTexelSize: VkExtent2D): VkRenderingFragmentShadingRateAttachmentInfoKHR =
  result = VkRenderingFragmentShadingRateAttachmentInfoKHR(
    sType: sType,
    pNext: pNext,
    imageView: imageView,
    imageLayout: imageLayout,
    shadingRateAttachmentTexelSize: shadingRateAttachmentTexelSize,
  )

proc newVkRenderingFragmentDensityMapAttachmentInfoEXT*(sType: VkStructureType = VkStructureType.RenderingFragmentDensityMapAttachmentInfoEXT, pNext: pointer = nil, imageView: VkImageView, imageLayout: VkImageLayout): VkRenderingFragmentDensityMapAttachmentInfoEXT =
  result = VkRenderingFragmentDensityMapAttachmentInfoEXT(
    sType: sType,
    pNext: pNext,
    imageView: imageView,
    imageLayout: imageLayout,
  )

proc newVkPhysicalDeviceDynamicRenderingFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceDynamicRenderingFeatures, pNext: pointer = nil, dynamicRendering: VkBool32): VkPhysicalDeviceDynamicRenderingFeatures =
  result = VkPhysicalDeviceDynamicRenderingFeatures(
    sType: sType,
    pNext: pNext,
    dynamicRendering: dynamicRendering,
  )

proc newVkCommandBufferInheritanceRenderingInfo*(sType: VkStructureType = VkStructureType.CommandBufferInheritanceRenderingInfo, pNext: pointer = nil, flags: VkRenderingFlags = 0.VkRenderingFlags, viewMask: uint32, colorAttachmentFormats: openarray[VkFormat], depthAttachmentFormat: VkFormat, stencilAttachmentFormat: VkFormat, rasterizationSamples: VkSampleCountFlagBits): VkCommandBufferInheritanceRenderingInfo =
  result = VkCommandBufferInheritanceRenderingInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    viewMask: viewMask,
    colorAttachmentCount: len(colorAttachmentFormats).uint32,
    pColorAttachmentFormats: if len(colorAttachmentFormats) == 0: nil else: cast[ptr VkFormat](colorAttachmentFormats),
    depthAttachmentFormat: depthAttachmentFormat,
    stencilAttachmentFormat: stencilAttachmentFormat,
    rasterizationSamples: rasterizationSamples,
  )

proc newVkAttachmentSampleCountInfoAMD*(sType: VkStructureType = VkStructureType.AttachmentSampleCountInfoAMD, pNext: pointer = nil, colorAttachmentSamples: openarray[VkSampleCountFlagBits], depthStencilAttachmentSamples: VkSampleCountFlagBits): VkAttachmentSampleCountInfoAMD =
  result = VkAttachmentSampleCountInfoAMD(
    sType: sType,
    pNext: pNext,
    colorAttachmentCount: len(colorAttachmentSamples).uint32,
    pColorAttachmentSamples: if len(colorAttachmentSamples) == 0: nil else: cast[ptr VkSampleCountFlagBits](colorAttachmentSamples),
    depthStencilAttachmentSamples: depthStencilAttachmentSamples,
  )

proc newVkMultiviewPerViewAttributesInfoNVX*(sType: VkStructureType = VkStructureType.MultiviewPerViewAttributesInfoNVX, pNext: pointer = nil, perViewAttributes: VkBool32, perViewAttributesPositionXOnly: VkBool32): VkMultiviewPerViewAttributesInfoNVX =
  result = VkMultiviewPerViewAttributesInfoNVX(
    sType: sType,
    pNext: pNext,
    perViewAttributes: perViewAttributes,
    perViewAttributesPositionXOnly: perViewAttributesPositionXOnly,
  )

proc newVkPhysicalDeviceImageViewMinLodFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageViewMinLodFeaturesEXT, pNext: pointer = nil, minLod: VkBool32): VkPhysicalDeviceImageViewMinLodFeaturesEXT =
  result = VkPhysicalDeviceImageViewMinLodFeaturesEXT(
    sType: sType,
    pNext: pNext,
    minLod: minLod,
  )

proc newVkImageViewMinLodCreateInfoEXT*(sType: VkStructureType = VkStructureType.ImageViewMinLodCreateInfoEXT, pNext: pointer = nil, minLod: float32): VkImageViewMinLodCreateInfoEXT =
  result = VkImageViewMinLodCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    minLod: minLod,
  )

proc newVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, pNext: pointer = nil, rasterizationOrderColorAttachmentAccess: VkBool32, rasterizationOrderDepthAttachmentAccess: VkBool32, rasterizationOrderStencilAttachmentAccess: VkBool32): VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT =
  result = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(
    sType: sType,
    pNext: pNext,
    rasterizationOrderColorAttachmentAccess: rasterizationOrderColorAttachmentAccess,
    rasterizationOrderDepthAttachmentAccess: rasterizationOrderDepthAttachmentAccess,
    rasterizationOrderStencilAttachmentAccess: rasterizationOrderStencilAttachmentAccess,
  )

proc newVkPhysicalDeviceLinearColorAttachmentFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceLinearColorAttachmentFeaturesNV, pNext: pointer = nil, linearColorAttachment: VkBool32): VkPhysicalDeviceLinearColorAttachmentFeaturesNV =
  result = VkPhysicalDeviceLinearColorAttachmentFeaturesNV(
    sType: sType,
    pNext: pNext,
    linearColorAttachment: linearColorAttachment,
  )

proc newVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, pNext: pointer = nil, graphicsPipelineLibrary: VkBool32): VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT =
  result = VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(
    sType: sType,
    pNext: pNext,
    graphicsPipelineLibrary: graphicsPipelineLibrary,
  )

proc newVkPhysicalDevicePipelineBinaryFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineBinaryFeaturesKHR, pNext: pointer = nil, pipelineBinaries: VkBool32): VkPhysicalDevicePipelineBinaryFeaturesKHR =
  result = VkPhysicalDevicePipelineBinaryFeaturesKHR(
    sType: sType,
    pNext: pNext,
    pipelineBinaries: pipelineBinaries,
  )

proc newVkDevicePipelineBinaryInternalCacheControlKHR*(sType: VkStructureType = VkStructureType.DevicePipelineBinaryInternalCacheControlKHR, pNext: pointer = nil, disableInternalCache: VkBool32): VkDevicePipelineBinaryInternalCacheControlKHR =
  result = VkDevicePipelineBinaryInternalCacheControlKHR(
    sType: sType,
    pNext: pNext,
    disableInternalCache: disableInternalCache,
  )

proc newVkPhysicalDevicePipelineBinaryPropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineBinaryPropertiesKHR, pNext: pointer = nil, pipelineBinaryInternalCache: VkBool32, pipelineBinaryInternalCacheControl: VkBool32, pipelineBinaryPrefersInternalCache: VkBool32, pipelineBinaryPrecompiledInternalCache: VkBool32, pipelineBinaryCompressedData: VkBool32): VkPhysicalDevicePipelineBinaryPropertiesKHR =
  result = VkPhysicalDevicePipelineBinaryPropertiesKHR(
    sType: sType,
    pNext: pNext,
    pipelineBinaryInternalCache: pipelineBinaryInternalCache,
    pipelineBinaryInternalCacheControl: pipelineBinaryInternalCacheControl,
    pipelineBinaryPrefersInternalCache: pipelineBinaryPrefersInternalCache,
    pipelineBinaryPrecompiledInternalCache: pipelineBinaryPrecompiledInternalCache,
    pipelineBinaryCompressedData: pipelineBinaryCompressedData,
  )

proc newVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, pNext: pointer = nil, graphicsPipelineLibraryFastLinking: VkBool32, graphicsPipelineLibraryIndependentInterpolationDecoration: VkBool32): VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT =
  result = VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(
    sType: sType,
    pNext: pNext,
    graphicsPipelineLibraryFastLinking: graphicsPipelineLibraryFastLinking,
    graphicsPipelineLibraryIndependentInterpolationDecoration: graphicsPipelineLibraryIndependentInterpolationDecoration,
  )

proc newVkGraphicsPipelineLibraryCreateInfoEXT*(sType: VkStructureType = VkStructureType.GraphicsPipelineLibraryCreateInfoEXT, pNext: pointer = nil, flags: VkGraphicsPipelineLibraryFlagsEXT = 0.VkGraphicsPipelineLibraryFlagsEXT): VkGraphicsPipelineLibraryCreateInfoEXT =
  result = VkGraphicsPipelineLibraryCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, pNext: pointer = nil, descriptorSetHostMapping: VkBool32): VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE =
  result = VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(
    sType: sType,
    pNext: pNext,
    descriptorSetHostMapping: descriptorSetHostMapping,
  )

proc newVkDescriptorSetBindingReferenceVALVE*(sType: VkStructureType = VkStructureType.DescriptorSetBindingReferenceVALVE, pNext: pointer = nil, descriptorSetLayout: VkDescriptorSetLayout, binding: uint32): VkDescriptorSetBindingReferenceVALVE =
  result = VkDescriptorSetBindingReferenceVALVE(
    sType: sType,
    pNext: pNext,
    descriptorSetLayout: descriptorSetLayout,
    binding: binding,
  )

proc newVkDescriptorSetLayoutHostMappingInfoVALVE*(sType: VkStructureType = VkStructureType.DescriptorSetLayoutHostMappingInfoVALVE, pNext: pointer = nil, descriptorOffset: uint, descriptorSize: uint32): VkDescriptorSetLayoutHostMappingInfoVALVE =
  result = VkDescriptorSetLayoutHostMappingInfoVALVE(
    sType: sType,
    pNext: pNext,
    descriptorOffset: descriptorOffset,
    descriptorSize: descriptorSize,
  )

proc newVkPhysicalDeviceNestedCommandBufferFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceNestedCommandBufferFeaturesEXT, pNext: pointer = nil, nestedCommandBuffer: VkBool32, nestedCommandBufferRendering: VkBool32, nestedCommandBufferSimultaneousUse: VkBool32): VkPhysicalDeviceNestedCommandBufferFeaturesEXT =
  result = VkPhysicalDeviceNestedCommandBufferFeaturesEXT(
    sType: sType,
    pNext: pNext,
    nestedCommandBuffer: nestedCommandBuffer,
    nestedCommandBufferRendering: nestedCommandBufferRendering,
    nestedCommandBufferSimultaneousUse: nestedCommandBufferSimultaneousUse,
  )

proc newVkPhysicalDeviceNestedCommandBufferPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceNestedCommandBufferPropertiesEXT, pNext: pointer = nil, maxCommandBufferNestingLevel: uint32): VkPhysicalDeviceNestedCommandBufferPropertiesEXT =
  result = VkPhysicalDeviceNestedCommandBufferPropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxCommandBufferNestingLevel: maxCommandBufferNestingLevel,
  )

proc newVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderModuleIdentifierFeaturesEXT, pNext: pointer = nil, shaderModuleIdentifier: VkBool32): VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT =
  result = VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderModuleIdentifier: shaderModuleIdentifier,
  )

proc newVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderModuleIdentifierPropertiesEXT, pNext: pointer = nil, shaderModuleIdentifierAlgorithmUUID: array[VK_UUID_SIZE, uint8]): VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT =
  result = VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(
    sType: sType,
    pNext: pNext,
    shaderModuleIdentifierAlgorithmUUID: shaderModuleIdentifierAlgorithmUUID,
  )

proc newVkPipelineShaderStageModuleIdentifierCreateInfoEXT*(sType: VkStructureType = VkStructureType.PipelineShaderStageModuleIdentifierCreateInfoEXT, pNext: pointer = nil, identifierSize: uint32, pIdentifier: ptr uint8): VkPipelineShaderStageModuleIdentifierCreateInfoEXT =
  result = VkPipelineShaderStageModuleIdentifierCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    identifierSize: identifierSize,
    pIdentifier: pIdentifier,
  )

proc newVkShaderModuleIdentifierEXT*(sType: VkStructureType = VkStructureType.ShaderModuleIdentifierEXT, pNext: pointer = nil, identifierSize: uint32, identifier: array[VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT, uint8]): VkShaderModuleIdentifierEXT =
  result = VkShaderModuleIdentifierEXT(
    sType: sType,
    pNext: pNext,
    identifierSize: identifierSize,
    identifier: identifier,
  )

proc newVkImageCompressionControlEXT*(sType: VkStructureType = VkStructureType.ImageCompressionControlEXT, pNext: pointer = nil, flags: VkImageCompressionFlagsEXT = 0.VkImageCompressionFlagsEXT, fixedRateFlags: openarray[VkImageCompressionFixedRateFlagsEXT]): VkImageCompressionControlEXT =
  result = VkImageCompressionControlEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    compressionControlPlaneCount: len(fixedRateFlags).uint32,
    pFixedRateFlags: if len(fixedRateFlags) == 0: nil else: cast[ptr VkImageCompressionFixedRateFlagsEXT](fixedRateFlags),
  )

proc newVkPhysicalDeviceImageCompressionControlFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageCompressionControlFeaturesEXT, pNext: pointer = nil, imageCompressionControl: VkBool32): VkPhysicalDeviceImageCompressionControlFeaturesEXT =
  result = VkPhysicalDeviceImageCompressionControlFeaturesEXT(
    sType: sType,
    pNext: pNext,
    imageCompressionControl: imageCompressionControl,
  )

proc newVkImageCompressionPropertiesEXT*(sType: VkStructureType = VkStructureType.ImageCompressionPropertiesEXT, pNext: pointer = nil, imageCompressionFlags: VkImageCompressionFlagsEXT, imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT): VkImageCompressionPropertiesEXT =
  result = VkImageCompressionPropertiesEXT(
    sType: sType,
    pNext: pNext,
    imageCompressionFlags: imageCompressionFlags,
    imageCompressionFixedRateFlags: imageCompressionFixedRateFlags,
  )

proc newVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, pNext: pointer = nil, imageCompressionControlSwapchain: VkBool32): VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT =
  result = VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(
    sType: sType,
    pNext: pNext,
    imageCompressionControlSwapchain: imageCompressionControlSwapchain,
  )

proc newVkImageSubresource2*(sType: VkStructureType = VkStructureType.ImageSubresource2, pNext: pointer = nil, imageSubresource: VkImageSubresource): VkImageSubresource2 =
  result = VkImageSubresource2(
    sType: sType,
    pNext: pNext,
    imageSubresource: imageSubresource,
  )

proc newVkSubresourceLayout2*(sType: VkStructureType = VkStructureType.SubresourceLayout2, pNext: pointer = nil, subresourceLayout: VkSubresourceLayout): VkSubresourceLayout2 =
  result = VkSubresourceLayout2(
    sType: sType,
    pNext: pNext,
    subresourceLayout: subresourceLayout,
  )

proc newVkRenderPassCreationControlEXT*(sType: VkStructureType = VkStructureType.RenderPassCreationControlEXT, pNext: pointer = nil, disallowMerging: VkBool32): VkRenderPassCreationControlEXT =
  result = VkRenderPassCreationControlEXT(
    sType: sType,
    pNext: pNext,
    disallowMerging: disallowMerging,
  )

proc newVkRenderPassCreationFeedbackInfoEXT*(postMergeSubpassCount: uint32): VkRenderPassCreationFeedbackInfoEXT =
  result = VkRenderPassCreationFeedbackInfoEXT(
    postMergeSubpassCount: postMergeSubpassCount,
  )

proc newVkRenderPassCreationFeedbackCreateInfoEXT*(sType: VkStructureType = VkStructureType.RenderPassCreationFeedbackCreateInfoEXT, pNext: pointer = nil, pRenderPassFeedback: ptr VkRenderPassCreationFeedbackInfoEXT): VkRenderPassCreationFeedbackCreateInfoEXT =
  result = VkRenderPassCreationFeedbackCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    pRenderPassFeedback: pRenderPassFeedback,
  )

proc newVkRenderPassSubpassFeedbackInfoEXT*(subpassMergeStatus: VkSubpassMergeStatusEXT, description: array[VK_MAX_DESCRIPTION_SIZE, char], postMergeIndex: uint32): VkRenderPassSubpassFeedbackInfoEXT =
  result = VkRenderPassSubpassFeedbackInfoEXT(
    subpassMergeStatus: subpassMergeStatus,
    description: description,
    postMergeIndex: postMergeIndex,
  )

proc newVkRenderPassSubpassFeedbackCreateInfoEXT*(sType: VkStructureType = VkStructureType.RenderPassSubpassFeedbackCreateInfoEXT, pNext: pointer = nil, pSubpassFeedback: ptr VkRenderPassSubpassFeedbackInfoEXT): VkRenderPassSubpassFeedbackCreateInfoEXT =
  result = VkRenderPassSubpassFeedbackCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    pSubpassFeedback: pSubpassFeedback,
  )

proc newVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceSubpassMergeFeedbackFeaturesEXT, pNext: pointer = nil, subpassMergeFeedback: VkBool32): VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT =
  result = VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(
    sType: sType,
    pNext: pNext,
    subpassMergeFeedback: subpassMergeFeedback,
  )

proc newVkMicromapBuildInfoEXT*(sType: VkStructureType = VkStructureType.MicromapBuildInfoEXT, pNext: pointer = nil, `type`: VkMicromapTypeEXT, flags: VkBuildMicromapFlagsEXT = 0.VkBuildMicromapFlagsEXT, mode: VkBuildMicromapModeEXT, dstMicromap: VkMicromapEXT, usageCounts: openarray[VkMicromapUsageEXT], pUsageCounts: openarray[ptr VkMicromapUsageEXT], data: VkDeviceOrHostAddressConstKHR, scratchData: VkDeviceOrHostAddressKHR, triangleArray: VkDeviceOrHostAddressConstKHR, triangleArrayStride: VkDeviceSize): VkMicromapBuildInfoEXT =
  result = VkMicromapBuildInfoEXT(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    flags: flags,
    mode: mode,
    dstMicromap: dstMicromap,
    usageCountsCount: if len(usageCounts) == 0: len(pUsageCounts).uint32 else: len(usageCounts).uint32,
    pUsageCounts: if len(usageCounts) == 0: nil else: cast[ptr VkMicromapUsageEXT](usageCounts),
    ppUsageCounts: if len(pUsageCounts) == 0: nil else: cast[ptr ptr VkMicromapUsageEXT](pUsageCounts),
    data: data,
    scratchData: scratchData,
    triangleArray: triangleArray,
    triangleArrayStride: triangleArrayStride,
  )

proc newVkMicromapCreateInfoEXT*(sType: VkStructureType = VkStructureType.MicromapCreateInfoEXT, pNext: pointer = nil, createFlags: VkMicromapCreateFlagsEXT, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, `type`: VkMicromapTypeEXT, deviceAddress: VkDeviceAddress): VkMicromapCreateInfoEXT =
  result = VkMicromapCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    createFlags: createFlags,
    buffer: buffer,
    offset: offset,
    size: size,
    `type`: `type`,
    deviceAddress: deviceAddress,
  )

proc newVkMicromapVersionInfoEXT*(sType: VkStructureType = VkStructureType.MicromapVersionInfoEXT, pNext: pointer = nil, pVersionData: ptr uint8): VkMicromapVersionInfoEXT =
  result = VkMicromapVersionInfoEXT(
    sType: sType,
    pNext: pNext,
    pVersionData: pVersionData,
  )

proc newVkCopyMicromapInfoEXT*(sType: VkStructureType = VkStructureType.CopyMicromapInfoEXT, pNext: pointer = nil, src: VkMicromapEXT, dst: VkMicromapEXT, mode: VkCopyMicromapModeEXT): VkCopyMicromapInfoEXT =
  result = VkCopyMicromapInfoEXT(
    sType: sType,
    pNext: pNext,
    src: src,
    dst: dst,
    mode: mode,
  )

proc newVkCopyMicromapToMemoryInfoEXT*(sType: VkStructureType = VkStructureType.CopyMicromapToMemoryInfoEXT, pNext: pointer = nil, src: VkMicromapEXT, dst: VkDeviceOrHostAddressKHR, mode: VkCopyMicromapModeEXT): VkCopyMicromapToMemoryInfoEXT =
  result = VkCopyMicromapToMemoryInfoEXT(
    sType: sType,
    pNext: pNext,
    src: src,
    dst: dst,
    mode: mode,
  )

proc newVkCopyMemoryToMicromapInfoEXT*(sType: VkStructureType = VkStructureType.CopyMemoryToMicromapInfoEXT, pNext: pointer = nil, src: VkDeviceOrHostAddressConstKHR, dst: VkMicromapEXT, mode: VkCopyMicromapModeEXT): VkCopyMemoryToMicromapInfoEXT =
  result = VkCopyMemoryToMicromapInfoEXT(
    sType: sType,
    pNext: pNext,
    src: src,
    dst: dst,
    mode: mode,
  )

proc newVkMicromapBuildSizesInfoEXT*(sType: VkStructureType = VkStructureType.MicromapBuildSizesInfoEXT, pNext: pointer = nil, micromapSize: VkDeviceSize, buildScratchSize: VkDeviceSize, discardable: VkBool32): VkMicromapBuildSizesInfoEXT =
  result = VkMicromapBuildSizesInfoEXT(
    sType: sType,
    pNext: pNext,
    micromapSize: micromapSize,
    buildScratchSize: buildScratchSize,
    discardable: discardable,
  )

proc newVkMicromapUsageEXT*(count: uint32, subdivisionLevel: uint32, format: uint32): VkMicromapUsageEXT =
  result = VkMicromapUsageEXT(
    count: count,
    subdivisionLevel: subdivisionLevel,
    format: format,
  )

proc newVkMicromapTriangleEXT*(dataOffset: uint32, subdivisionLevel: uint16, format: uint16): VkMicromapTriangleEXT =
  result = VkMicromapTriangleEXT(
    dataOffset: dataOffset,
    subdivisionLevel: subdivisionLevel,
    format: format,
  )

proc newVkPhysicalDeviceOpacityMicromapFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceOpacityMicromapFeaturesEXT, pNext: pointer = nil, micromap: VkBool32, micromapCaptureReplay: VkBool32, micromapHostCommands: VkBool32): VkPhysicalDeviceOpacityMicromapFeaturesEXT =
  result = VkPhysicalDeviceOpacityMicromapFeaturesEXT(
    sType: sType,
    pNext: pNext,
    micromap: micromap,
    micromapCaptureReplay: micromapCaptureReplay,
    micromapHostCommands: micromapHostCommands,
  )

proc newVkPhysicalDeviceOpacityMicromapPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceOpacityMicromapPropertiesEXT, pNext: pointer = nil, maxOpacity2StateSubdivisionLevel: uint32, maxOpacity4StateSubdivisionLevel: uint32): VkPhysicalDeviceOpacityMicromapPropertiesEXT =
  result = VkPhysicalDeviceOpacityMicromapPropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxOpacity2StateSubdivisionLevel: maxOpacity2StateSubdivisionLevel,
    maxOpacity4StateSubdivisionLevel: maxOpacity4StateSubdivisionLevel,
  )

proc newVkAccelerationStructureTrianglesOpacityMicromapEXT*(sType: VkStructureType = VkStructureType.AccelerationStructureTrianglesOpacityMicromapEXT, pNext: pointer = nil, indexType: VkIndexType, indexBuffer: VkDeviceOrHostAddressConstKHR, indexStride: VkDeviceSize, baseTriangle: uint32, usageCounts: openarray[VkMicromapUsageEXT], pUsageCounts: openarray[ptr VkMicromapUsageEXT], micromap: VkMicromapEXT): VkAccelerationStructureTrianglesOpacityMicromapEXT =
  result = VkAccelerationStructureTrianglesOpacityMicromapEXT(
    sType: sType,
    pNext: pNext,
    indexType: indexType,
    indexBuffer: indexBuffer,
    indexStride: indexStride,
    baseTriangle: baseTriangle,
    usageCountsCount: if len(usageCounts) == 0: len(pUsageCounts).uint32 else: len(usageCounts).uint32,
    pUsageCounts: if len(usageCounts) == 0: nil else: cast[ptr VkMicromapUsageEXT](usageCounts),
    ppUsageCounts: if len(pUsageCounts) == 0: nil else: cast[ptr ptr VkMicromapUsageEXT](pUsageCounts),
    micromap: micromap,
  )

proc newVkPhysicalDeviceDisplacementMicromapFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceDisplacementMicromapFeaturesNV, pNext: pointer = nil, displacementMicromap: VkBool32): VkPhysicalDeviceDisplacementMicromapFeaturesNV =
  result = VkPhysicalDeviceDisplacementMicromapFeaturesNV(
    sType: sType,
    pNext: pNext,
    displacementMicromap: displacementMicromap,
  )

proc newVkPhysicalDeviceDisplacementMicromapPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceDisplacementMicromapPropertiesNV, pNext: pointer = nil, maxDisplacementMicromapSubdivisionLevel: uint32): VkPhysicalDeviceDisplacementMicromapPropertiesNV =
  result = VkPhysicalDeviceDisplacementMicromapPropertiesNV(
    sType: sType,
    pNext: pNext,
    maxDisplacementMicromapSubdivisionLevel: maxDisplacementMicromapSubdivisionLevel,
  )

proc newVkAccelerationStructureTrianglesDisplacementMicromapNV*(sType: VkStructureType = VkStructureType.AccelerationStructureTrianglesDisplacementMicromapNV, pNext: pointer = nil, displacementBiasAndScaleFormat: VkFormat, displacementVectorFormat: VkFormat, displacementBiasAndScaleBuffer: VkDeviceOrHostAddressConstKHR, displacementBiasAndScaleStride: VkDeviceSize, displacementVectorBuffer: VkDeviceOrHostAddressConstKHR, displacementVectorStride: VkDeviceSize, displacedMicromapPrimitiveFlags: VkDeviceOrHostAddressConstKHR, displacedMicromapPrimitiveFlagsStride: VkDeviceSize, indexType: VkIndexType, indexBuffer: VkDeviceOrHostAddressConstKHR, indexStride: VkDeviceSize, baseTriangle: uint32, usageCounts: openarray[VkMicromapUsageEXT], pUsageCounts: openarray[ptr VkMicromapUsageEXT], micromap: VkMicromapEXT): VkAccelerationStructureTrianglesDisplacementMicromapNV =
  result = VkAccelerationStructureTrianglesDisplacementMicromapNV(
    sType: sType,
    pNext: pNext,
    displacementBiasAndScaleFormat: displacementBiasAndScaleFormat,
    displacementVectorFormat: displacementVectorFormat,
    displacementBiasAndScaleBuffer: displacementBiasAndScaleBuffer,
    displacementBiasAndScaleStride: displacementBiasAndScaleStride,
    displacementVectorBuffer: displacementVectorBuffer,
    displacementVectorStride: displacementVectorStride,
    displacedMicromapPrimitiveFlags: displacedMicromapPrimitiveFlags,
    displacedMicromapPrimitiveFlagsStride: displacedMicromapPrimitiveFlagsStride,
    indexType: indexType,
    indexBuffer: indexBuffer,
    indexStride: indexStride,
    baseTriangle: baseTriangle,
    usageCountsCount: if len(usageCounts) == 0: len(pUsageCounts).uint32 else: len(usageCounts).uint32,
    pUsageCounts: if len(usageCounts) == 0: nil else: cast[ptr VkMicromapUsageEXT](usageCounts),
    ppUsageCounts: if len(pUsageCounts) == 0: nil else: cast[ptr ptr VkMicromapUsageEXT](pUsageCounts),
    micromap: micromap,
  )

proc newVkPipelinePropertiesIdentifierEXT*(sType: VkStructureType = VkStructureType.PipelinePropertiesIdentifierEXT, pNext: pointer = nil, pipelineIdentifier: array[VK_UUID_SIZE, uint8]): VkPipelinePropertiesIdentifierEXT =
  result = VkPipelinePropertiesIdentifierEXT(
    sType: sType,
    pNext: pNext,
    pipelineIdentifier: pipelineIdentifier,
  )

proc newVkPhysicalDevicePipelinePropertiesFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelinePropertiesFeaturesEXT, pNext: pointer = nil, pipelinePropertiesIdentifier: VkBool32): VkPhysicalDevicePipelinePropertiesFeaturesEXT =
  result = VkPhysicalDevicePipelinePropertiesFeaturesEXT(
    sType: sType,
    pNext: pNext,
    pipelinePropertiesIdentifier: pipelinePropertiesIdentifier,
  )

proc newVkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, pNext: pointer = nil, shaderEarlyAndLateFragmentTests: VkBool32): VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD =
  result = VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(
    sType: sType,
    pNext: pNext,
    shaderEarlyAndLateFragmentTests: shaderEarlyAndLateFragmentTests,
  )

proc newVkExternalMemoryAcquireUnmodifiedEXT*(sType: VkStructureType = VkStructureType.ExternalMemoryAcquireUnmodifiedEXT, pNext: pointer = nil, acquireUnmodifiedMemory: VkBool32): VkExternalMemoryAcquireUnmodifiedEXT =
  result = VkExternalMemoryAcquireUnmodifiedEXT(
    sType: sType,
    pNext: pNext,
    acquireUnmodifiedMemory: acquireUnmodifiedMemory,
  )

proc newVkExportMetalObjectCreateInfoEXT*(sType: VkStructureType = VkStructureType.ExportMetalObjectCreateInfoEXT, pNext: pointer = nil, exportObjectType: VkExportMetalObjectTypeFlagBitsEXT): VkExportMetalObjectCreateInfoEXT =
  result = VkExportMetalObjectCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    exportObjectType: exportObjectType,
  )

proc newVkExportMetalObjectsInfoEXT*(sType: VkStructureType = VkStructureType.ExportMetalObjectsInfoEXT, pNext: pointer = nil): VkExportMetalObjectsInfoEXT =
  result = VkExportMetalObjectsInfoEXT(
    sType: sType,
    pNext: pNext,
  )

proc newVkExportMetalDeviceInfoEXT*(sType: VkStructureType = VkStructureType.ExportMetalDeviceInfoEXT, pNext: pointer = nil, mtlDevice: MTLDevice_id): VkExportMetalDeviceInfoEXT =
  result = VkExportMetalDeviceInfoEXT(
    sType: sType,
    pNext: pNext,
    mtlDevice: mtlDevice,
  )

proc newVkExportMetalCommandQueueInfoEXT*(sType: VkStructureType = VkStructureType.ExportMetalCommandQueueInfoEXT, pNext: pointer = nil, queue: VkQueue, mtlCommandQueue: MTLCommandQueue_id): VkExportMetalCommandQueueInfoEXT =
  result = VkExportMetalCommandQueueInfoEXT(
    sType: sType,
    pNext: pNext,
    queue: queue,
    mtlCommandQueue: mtlCommandQueue,
  )

proc newVkExportMetalBufferInfoEXT*(sType: VkStructureType = VkStructureType.ExportMetalBufferInfoEXT, pNext: pointer = nil, memory: VkDeviceMemory, mtlBuffer: MTLBuffer_id): VkExportMetalBufferInfoEXT =
  result = VkExportMetalBufferInfoEXT(
    sType: sType,
    pNext: pNext,
    memory: memory,
    mtlBuffer: mtlBuffer,
  )

proc newVkImportMetalBufferInfoEXT*(sType: VkStructureType = VkStructureType.ImportMetalBufferInfoEXT, pNext: pointer = nil, mtlBuffer: MTLBuffer_id): VkImportMetalBufferInfoEXT =
  result = VkImportMetalBufferInfoEXT(
    sType: sType,
    pNext: pNext,
    mtlBuffer: mtlBuffer,
  )

proc newVkExportMetalTextureInfoEXT*(sType: VkStructureType = VkStructureType.ExportMetalTextureInfoEXT, pNext: pointer = nil, image: VkImage, imageView: VkImageView, bufferView: VkBufferView, plane: VkImageAspectFlagBits, mtlTexture: MTLTexture_id): VkExportMetalTextureInfoEXT =
  result = VkExportMetalTextureInfoEXT(
    sType: sType,
    pNext: pNext,
    image: image,
    imageView: imageView,
    bufferView: bufferView,
    plane: plane,
    mtlTexture: mtlTexture,
  )

proc newVkImportMetalTextureInfoEXT*(sType: VkStructureType = VkStructureType.ImportMetalTextureInfoEXT, pNext: pointer = nil, plane: VkImageAspectFlagBits, mtlTexture: MTLTexture_id): VkImportMetalTextureInfoEXT =
  result = VkImportMetalTextureInfoEXT(
    sType: sType,
    pNext: pNext,
    plane: plane,
    mtlTexture: mtlTexture,
  )

proc newVkExportMetalIOSurfaceInfoEXT*(sType: VkStructureType = VkStructureType.ExportMetalIOSurfaceInfoEXT, pNext: pointer = nil, image: VkImage, ioSurface: IOSurfaceRef): VkExportMetalIOSurfaceInfoEXT =
  result = VkExportMetalIOSurfaceInfoEXT(
    sType: sType,
    pNext: pNext,
    image: image,
    ioSurface: ioSurface,
  )

proc newVkImportMetalIOSurfaceInfoEXT*(sType: VkStructureType = VkStructureType.ImportMetalIOSurfaceInfoEXT, pNext: pointer = nil, ioSurface: IOSurfaceRef): VkImportMetalIOSurfaceInfoEXT =
  result = VkImportMetalIOSurfaceInfoEXT(
    sType: sType,
    pNext: pNext,
    ioSurface: ioSurface,
  )

proc newVkExportMetalSharedEventInfoEXT*(sType: VkStructureType = VkStructureType.ExportMetalSharedEventInfoEXT, pNext: pointer = nil, semaphore: VkSemaphore, event: VkEvent, mtlSharedEvent: MTLSharedEvent_id): VkExportMetalSharedEventInfoEXT =
  result = VkExportMetalSharedEventInfoEXT(
    sType: sType,
    pNext: pNext,
    semaphore: semaphore,
    event: event,
    mtlSharedEvent: mtlSharedEvent,
  )

proc newVkImportMetalSharedEventInfoEXT*(sType: VkStructureType = VkStructureType.ImportMetalSharedEventInfoEXT, pNext: pointer = nil, mtlSharedEvent: MTLSharedEvent_id): VkImportMetalSharedEventInfoEXT =
  result = VkImportMetalSharedEventInfoEXT(
    sType: sType,
    pNext: pNext,
    mtlSharedEvent: mtlSharedEvent,
  )

proc newVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceNonSeamlessCubeMapFeaturesEXT, pNext: pointer = nil, nonSeamlessCubeMap: VkBool32): VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT =
  result = VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(
    sType: sType,
    pNext: pNext,
    nonSeamlessCubeMap: nonSeamlessCubeMap,
  )

proc newVkPhysicalDevicePipelineRobustnessFeatures*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineRobustnessFeatures, pNext: pointer = nil, pipelineRobustness: VkBool32): VkPhysicalDevicePipelineRobustnessFeatures =
  result = VkPhysicalDevicePipelineRobustnessFeatures(
    sType: sType,
    pNext: pNext,
    pipelineRobustness: pipelineRobustness,
  )

proc newVkPipelineRobustnessCreateInfo*(sType: VkStructureType = VkStructureType.PipelineRobustnessCreateInfo, pNext: pointer = nil, storageBuffers: VkPipelineRobustnessBufferBehavior, uniformBuffers: VkPipelineRobustnessBufferBehavior, vertexInputs: VkPipelineRobustnessBufferBehavior, images: VkPipelineRobustnessImageBehavior): VkPipelineRobustnessCreateInfo =
  result = VkPipelineRobustnessCreateInfo(
    sType: sType,
    pNext: pNext,
    storageBuffers: storageBuffers,
    uniformBuffers: uniformBuffers,
    vertexInputs: vertexInputs,
    images: images,
  )

proc newVkPhysicalDevicePipelineRobustnessProperties*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineRobustnessProperties, pNext: pointer = nil, defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior, defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior, defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior, defaultRobustnessImages: VkPipelineRobustnessImageBehavior): VkPhysicalDevicePipelineRobustnessProperties =
  result = VkPhysicalDevicePipelineRobustnessProperties(
    sType: sType,
    pNext: pNext,
    defaultRobustnessStorageBuffers: defaultRobustnessStorageBuffers,
    defaultRobustnessUniformBuffers: defaultRobustnessUniformBuffers,
    defaultRobustnessVertexInputs: defaultRobustnessVertexInputs,
    defaultRobustnessImages: defaultRobustnessImages,
  )

proc newVkImageViewSampleWeightCreateInfoQCOM*(sType: VkStructureType = VkStructureType.ImageViewSampleWeightCreateInfoQCOM, pNext: pointer = nil, filterCenter: VkOffset2D, filterSize: VkExtent2D, numPhases: uint32): VkImageViewSampleWeightCreateInfoQCOM =
  result = VkImageViewSampleWeightCreateInfoQCOM(
    sType: sType,
    pNext: pNext,
    filterCenter: filterCenter,
    filterSize: filterSize,
    numPhases: numPhases,
  )

proc newVkPhysicalDeviceImageProcessingFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageProcessingFeaturesQCOM, pNext: pointer = nil, textureSampleWeighted: VkBool32, textureBoxFilter: VkBool32, textureBlockMatch: VkBool32): VkPhysicalDeviceImageProcessingFeaturesQCOM =
  result = VkPhysicalDeviceImageProcessingFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    textureSampleWeighted: textureSampleWeighted,
    textureBoxFilter: textureBoxFilter,
    textureBlockMatch: textureBlockMatch,
  )

proc newVkPhysicalDeviceImageProcessingPropertiesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageProcessingPropertiesQCOM, pNext: pointer = nil, maxWeightFilterPhases: uint32, maxWeightFilterDimension: VkExtent2D, maxBlockMatchRegion: VkExtent2D, maxBoxFilterBlockSize: VkExtent2D): VkPhysicalDeviceImageProcessingPropertiesQCOM =
  result = VkPhysicalDeviceImageProcessingPropertiesQCOM(
    sType: sType,
    pNext: pNext,
    maxWeightFilterPhases: maxWeightFilterPhases,
    maxWeightFilterDimension: maxWeightFilterDimension,
    maxBlockMatchRegion: maxBlockMatchRegion,
    maxBoxFilterBlockSize: maxBoxFilterBlockSize,
  )

proc newVkPhysicalDeviceTilePropertiesFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceTilePropertiesFeaturesQCOM, pNext: pointer = nil, tileProperties: VkBool32): VkPhysicalDeviceTilePropertiesFeaturesQCOM =
  result = VkPhysicalDeviceTilePropertiesFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    tileProperties: tileProperties,
  )

proc newVkTilePropertiesQCOM*(sType: VkStructureType = VkStructureType.TilePropertiesQCOM, pNext: pointer = nil, tileSize: VkExtent3D, apronSize: VkExtent2D, origin: VkOffset2D): VkTilePropertiesQCOM =
  result = VkTilePropertiesQCOM(
    sType: sType,
    pNext: pNext,
    tileSize: tileSize,
    apronSize: apronSize,
    origin: origin,
  )

proc newVkTileMemoryBindInfoQCOM*(sType: VkStructureType = VkStructureType.TileMemoryBindInfoQCOM, pNext: pointer = nil, memory: VkDeviceMemory): VkTileMemoryBindInfoQCOM =
  result = VkTileMemoryBindInfoQCOM(
    sType: sType,
    pNext: pNext,
    memory: memory,
  )

proc newVkPhysicalDeviceAmigoProfilingFeaturesSEC*(sType: VkStructureType = VkStructureType.PhysicalDeviceAmigoProfilingFeaturesSEC, pNext: pointer = nil, amigoProfiling: VkBool32): VkPhysicalDeviceAmigoProfilingFeaturesSEC =
  result = VkPhysicalDeviceAmigoProfilingFeaturesSEC(
    sType: sType,
    pNext: pNext,
    amigoProfiling: amigoProfiling,
  )

proc newVkAmigoProfilingSubmitInfoSEC*(sType: VkStructureType = VkStructureType.AmigoProfilingSubmitInfoSEC, pNext: pointer = nil, firstDrawTimestamp: uint64, swapBufferTimestamp: uint64): VkAmigoProfilingSubmitInfoSEC =
  result = VkAmigoProfilingSubmitInfoSEC(
    sType: sType,
    pNext: pNext,
    firstDrawTimestamp: firstDrawTimestamp,
    swapBufferTimestamp: swapBufferTimestamp,
  )

proc newVkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, pNext: pointer = nil, attachmentFeedbackLoopLayout: VkBool32): VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT =
  result = VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(
    sType: sType,
    pNext: pNext,
    attachmentFeedbackLoopLayout: attachmentFeedbackLoopLayout,
  )

proc newVkAttachmentFeedbackLoopInfoEXT*(sType: VkStructureType = VkStructureType.AttachmentFeedbackLoopInfoEXT, pNext: pointer = nil, feedbackLoopEnable: VkBool32): VkAttachmentFeedbackLoopInfoEXT =
  result = VkAttachmentFeedbackLoopInfoEXT(
    sType: sType,
    pNext: pNext,
    feedbackLoopEnable: feedbackLoopEnable,
  )

proc newVkPhysicalDeviceAddressBindingReportFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceAddressBindingReportFeaturesEXT, pNext: pointer = nil, reportAddressBinding: VkBool32): VkPhysicalDeviceAddressBindingReportFeaturesEXT =
  result = VkPhysicalDeviceAddressBindingReportFeaturesEXT(
    sType: sType,
    pNext: pNext,
    reportAddressBinding: reportAddressBinding,
  )

proc newVkRenderingAttachmentFlagsInfoKHR*(sType: VkStructureType = VkStructureType.RenderingAttachmentFlagsInfoKHR, pNext: pointer = nil, flags: VkRenderingAttachmentFlagsKHR = 0.VkRenderingAttachmentFlagsKHR): VkRenderingAttachmentFlagsInfoKHR =
  result = VkRenderingAttachmentFlagsInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkResolveImageModeInfoKHR*(sType: VkStructureType = VkStructureType.ResolveImageModeInfoKHR, pNext: pointer = nil, flags: VkResolveImageFlagsKHR = 0.VkResolveImageFlagsKHR, resolveMode: VkResolveModeFlagBits, stencilResolveMode: VkResolveModeFlagBits): VkResolveImageModeInfoKHR =
  result = VkResolveImageModeInfoKHR(
    sType: sType,
    pNext: pNext,
    flags: flags,
    resolveMode: resolveMode,
    stencilResolveMode: stencilResolveMode,
  )

proc newVkDeviceAddressBindingCallbackDataEXT*(sType: VkStructureType = VkStructureType.DeviceAddressBindingCallbackDataEXT, pNext: pointer = nil, flags: VkDeviceAddressBindingFlagsEXT = 0.VkDeviceAddressBindingFlagsEXT, baseAddress: VkDeviceAddress, size: VkDeviceSize, bindingType: VkDeviceAddressBindingTypeEXT): VkDeviceAddressBindingCallbackDataEXT =
  result = VkDeviceAddressBindingCallbackDataEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    baseAddress: baseAddress,
    size: size,
    bindingType: bindingType,
  )

proc newVkPhysicalDeviceOpticalFlowFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceOpticalFlowFeaturesNV, pNext: pointer = nil, opticalFlow: VkBool32): VkPhysicalDeviceOpticalFlowFeaturesNV =
  result = VkPhysicalDeviceOpticalFlowFeaturesNV(
    sType: sType,
    pNext: pNext,
    opticalFlow: opticalFlow,
  )

proc newVkPhysicalDeviceOpticalFlowPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceOpticalFlowPropertiesNV, pNext: pointer = nil, supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV, supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV, hintSupported: VkBool32, costSupported: VkBool32, bidirectionalFlowSupported: VkBool32, globalFlowSupported: VkBool32, minWidth: uint32, minHeight: uint32, maxWidth: uint32, maxHeight: uint32, maxNumRegionsOfInterest: uint32): VkPhysicalDeviceOpticalFlowPropertiesNV =
  result = VkPhysicalDeviceOpticalFlowPropertiesNV(
    sType: sType,
    pNext: pNext,
    supportedOutputGridSizes: supportedOutputGridSizes,
    supportedHintGridSizes: supportedHintGridSizes,
    hintSupported: hintSupported,
    costSupported: costSupported,
    bidirectionalFlowSupported: bidirectionalFlowSupported,
    globalFlowSupported: globalFlowSupported,
    minWidth: minWidth,
    minHeight: minHeight,
    maxWidth: maxWidth,
    maxHeight: maxHeight,
    maxNumRegionsOfInterest: maxNumRegionsOfInterest,
  )

proc newVkOpticalFlowImageFormatInfoNV*(sType: VkStructureType = VkStructureType.OpticalFlowImageFormatInfoNV, pNext: pointer = nil, usage: VkOpticalFlowUsageFlagsNV): VkOpticalFlowImageFormatInfoNV =
  result = VkOpticalFlowImageFormatInfoNV(
    sType: sType,
    pNext: pNext,
    usage: usage,
  )

proc newVkOpticalFlowImageFormatPropertiesNV*(sType: VkStructureType = VkStructureType.OpticalFlowImageFormatPropertiesNV, pNext: pointer = nil, format: VkFormat): VkOpticalFlowImageFormatPropertiesNV =
  result = VkOpticalFlowImageFormatPropertiesNV(
    sType: sType,
    pNext: pNext,
    format: format,
  )

proc newVkOpticalFlowSessionCreateInfoNV*(sType: VkStructureType = VkStructureType.OpticalFlowSessionCreateInfoNV, pNext: pointer = nil, width: uint32, height: uint32, imageFormat: VkFormat, flowVectorFormat: VkFormat, costFormat: VkFormat, outputGridSize: VkOpticalFlowGridSizeFlagsNV, hintGridSize: VkOpticalFlowGridSizeFlagsNV, performanceLevel: VkOpticalFlowPerformanceLevelNV, flags: VkOpticalFlowSessionCreateFlagsNV = 0.VkOpticalFlowSessionCreateFlagsNV): VkOpticalFlowSessionCreateInfoNV =
  result = VkOpticalFlowSessionCreateInfoNV(
    sType: sType,
    pNext: pNext,
    width: width,
    height: height,
    imageFormat: imageFormat,
    flowVectorFormat: flowVectorFormat,
    costFormat: costFormat,
    outputGridSize: outputGridSize,
    hintGridSize: hintGridSize,
    performanceLevel: performanceLevel,
    flags: flags,
  )

proc newVkOpticalFlowSessionCreatePrivateDataInfoNV*(sType: VkStructureType = VkStructureType.OpticalFlowSessionCreatePrivateDataInfoNV, pNext: pointer = nil, id: uint32, size: uint32, pPrivateData: pointer = nil): VkOpticalFlowSessionCreatePrivateDataInfoNV =
  result = VkOpticalFlowSessionCreatePrivateDataInfoNV(
    sType: sType,
    pNext: pNext,
    id: id,
    size: size,
    pPrivateData: pPrivateData,
  )

proc newVkOpticalFlowExecuteInfoNV*(sType: VkStructureType = VkStructureType.OpticalFlowExecuteInfoNV, pNext: pointer = nil, flags: VkOpticalFlowExecuteFlagsNV = 0.VkOpticalFlowExecuteFlagsNV, regions: openarray[VkRect2D]): VkOpticalFlowExecuteInfoNV =
  result = VkOpticalFlowExecuteInfoNV(
    sType: sType,
    pNext: pNext,
    flags: flags,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkRect2D](regions),
  )

proc newVkPhysicalDeviceFaultFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceFaultFeaturesEXT, pNext: pointer = nil, deviceFault: VkBool32, deviceFaultVendorBinary: VkBool32): VkPhysicalDeviceFaultFeaturesEXT =
  result = VkPhysicalDeviceFaultFeaturesEXT(
    sType: sType,
    pNext: pNext,
    deviceFault: deviceFault,
    deviceFaultVendorBinary: deviceFaultVendorBinary,
  )

proc newVkDeviceFaultAddressInfoEXT*(addressType: VkDeviceFaultAddressTypeEXT, reportedAddress: VkDeviceAddress, addressPrecision: VkDeviceSize): VkDeviceFaultAddressInfoEXT =
  result = VkDeviceFaultAddressInfoEXT(
    addressType: addressType,
    reportedAddress: reportedAddress,
    addressPrecision: addressPrecision,
  )

proc newVkDeviceFaultVendorInfoEXT*(description: array[VK_MAX_DESCRIPTION_SIZE, char], vendorFaultCode: uint64, vendorFaultData: uint64): VkDeviceFaultVendorInfoEXT =
  result = VkDeviceFaultVendorInfoEXT(
    description: description,
    vendorFaultCode: vendorFaultCode,
    vendorFaultData: vendorFaultData,
  )

proc newVkDeviceFaultCountsEXT*(sType: VkStructureType = VkStructureType.DeviceFaultCountsEXT, pNext: pointer = nil, addressInfoCount: uint32, vendorInfoCount: uint32, vendorBinarySize: VkDeviceSize): VkDeviceFaultCountsEXT =
  result = VkDeviceFaultCountsEXT(
    sType: sType,
    pNext: pNext,
    addressInfoCount: addressInfoCount,
    vendorInfoCount: vendorInfoCount,
    vendorBinarySize: vendorBinarySize,
  )

proc newVkDeviceFaultInfoEXT*(sType: VkStructureType = VkStructureType.DeviceFaultInfoEXT, pNext: pointer = nil, description: array[VK_MAX_DESCRIPTION_SIZE, char], pAddressInfos: ptr VkDeviceFaultAddressInfoEXT, pVendorInfos: ptr VkDeviceFaultVendorInfoEXT, pVendorBinaryData: pointer = nil): VkDeviceFaultInfoEXT =
  result = VkDeviceFaultInfoEXT(
    sType: sType,
    pNext: pNext,
    description: description,
    pAddressInfos: pAddressInfos,
    pVendorInfos: pVendorInfos,
    pVendorBinaryData: pVendorBinaryData,
  )

proc newVkDeviceFaultVendorBinaryHeaderVersionOneEXT*(headerSize: uint32, headerVersion: VkDeviceFaultVendorBinaryHeaderVersionEXT, vendorID: uint32, deviceID: uint32, driverVersion: uint32, pipelineCacheUUID: array[VK_UUID_SIZE, uint8], applicationNameOffset: uint32, applicationVersion: uint32, engineNameOffset: uint32, engineVersion: uint32, apiVersion: uint32): VkDeviceFaultVendorBinaryHeaderVersionOneEXT =
  result = VkDeviceFaultVendorBinaryHeaderVersionOneEXT(
    headerSize: headerSize,
    headerVersion: headerVersion,
    vendorID: vendorID,
    deviceID: deviceID,
    driverVersion: driverVersion,
    pipelineCacheUUID: pipelineCacheUUID,
    applicationNameOffset: applicationNameOffset,
    applicationVersion: applicationVersion,
    engineNameOffset: engineNameOffset,
    engineVersion: engineVersion,
    apiVersion: apiVersion,
  )

proc newVkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, pNext: pointer = nil, pipelineLibraryGroupHandles: VkBool32): VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT =
  result = VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(
    sType: sType,
    pNext: pNext,
    pipelineLibraryGroupHandles: pipelineLibraryGroupHandles,
  )

proc newVkDepthBiasInfoEXT*(sType: VkStructureType = VkStructureType.DepthBiasInfoEXT, pNext: pointer = nil, depthBiasConstantFactor: float32, depthBiasClamp: float32, depthBiasSlopeFactor: float32): VkDepthBiasInfoEXT =
  result = VkDepthBiasInfoEXT(
    sType: sType,
    pNext: pNext,
    depthBiasConstantFactor: depthBiasConstantFactor,
    depthBiasClamp: depthBiasClamp,
    depthBiasSlopeFactor: depthBiasSlopeFactor,
  )

proc newVkDepthBiasRepresentationInfoEXT*(sType: VkStructureType = VkStructureType.DepthBiasRepresentationInfoEXT, pNext: pointer = nil, depthBiasRepresentation: VkDepthBiasRepresentationEXT, depthBiasExact: VkBool32): VkDepthBiasRepresentationInfoEXT =
  result = VkDepthBiasRepresentationInfoEXT(
    sType: sType,
    pNext: pNext,
    depthBiasRepresentation: depthBiasRepresentation,
    depthBiasExact: depthBiasExact,
  )

proc newVkDecompressMemoryRegionNV*(srcAddress: VkDeviceAddress, dstAddress: VkDeviceAddress, compressedSize: VkDeviceSize, decompressedSize: VkDeviceSize, decompressionMethod: VkMemoryDecompressionMethodFlagsNV): VkDecompressMemoryRegionNV =
  result = VkDecompressMemoryRegionNV(
    srcAddress: srcAddress,
    dstAddress: dstAddress,
    compressedSize: compressedSize,
    decompressedSize: decompressedSize,
    decompressionMethod: decompressionMethod,
  )

proc newVkDecompressMemoryRegionEXT*(srcAddress: VkDeviceAddress, dstAddress: VkDeviceAddress, compressedSize: VkDeviceSize, decompressedSize: VkDeviceSize): VkDecompressMemoryRegionEXT =
  result = VkDecompressMemoryRegionEXT(
    srcAddress: srcAddress,
    dstAddress: dstAddress,
    compressedSize: compressedSize,
    decompressedSize: decompressedSize,
  )

proc newVkDecompressMemoryInfoEXT*(sType: VkStructureType = VkStructureType.DecompressMemoryInfoEXT, pNext: pointer = nil, decompressionMethod: VkMemoryDecompressionMethodFlagsEXT, regions: openarray[VkDecompressMemoryRegionEXT]): VkDecompressMemoryInfoEXT =
  result = VkDecompressMemoryInfoEXT(
    sType: sType,
    pNext: pNext,
    decompressionMethod: decompressionMethod,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkDecompressMemoryRegionEXT](regions),
  )

proc newVkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderCoreBuiltinsPropertiesARM, pNext: pointer = nil, shaderCoreMask: uint64, shaderCoreCount: uint32, shaderWarpsPerCore: uint32): VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM =
  result = VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(
    sType: sType,
    pNext: pNext,
    shaderCoreMask: shaderCoreMask,
    shaderCoreCount: shaderCoreCount,
    shaderWarpsPerCore: shaderWarpsPerCore,
  )

proc newVkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderCoreBuiltinsFeaturesARM, pNext: pointer = nil, shaderCoreBuiltins: VkBool32): VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM =
  result = VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(
    sType: sType,
    pNext: pNext,
    shaderCoreBuiltins: shaderCoreBuiltins,
  )

proc newVkFrameBoundaryEXT*(sType: VkStructureType = VkStructureType.FrameBoundaryEXT, pNext: pointer = nil, flags: VkFrameBoundaryFlagsEXT = 0.VkFrameBoundaryFlagsEXT, frameID: uint64, images: openarray[VkImage], buffers: openarray[VkBuffer], tagName: uint64, tagSize: uint, pTag: pointer = nil): VkFrameBoundaryEXT =
  result = VkFrameBoundaryEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    frameID: frameID,
    imageCount: len(images).uint32,
    pImages: if len(images) == 0: nil else: cast[ptr VkImage](images),
    bufferCount: len(buffers).uint32,
    pBuffers: if len(buffers) == 0: nil else: cast[ptr VkBuffer](buffers),
    tagName: tagName,
    tagSize: tagSize,
    pTag: pTag,
  )

proc newVkPhysicalDeviceFrameBoundaryFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceFrameBoundaryFeaturesEXT, pNext: pointer = nil, frameBoundary: VkBool32): VkPhysicalDeviceFrameBoundaryFeaturesEXT =
  result = VkPhysicalDeviceFrameBoundaryFeaturesEXT(
    sType: sType,
    pNext: pNext,
    frameBoundary: frameBoundary,
  )

proc newVkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, pNext: pointer = nil, dynamicRenderingUnusedAttachments: VkBool32): VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT =
  result = VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(
    sType: sType,
    pNext: pNext,
    dynamicRenderingUnusedAttachments: dynamicRenderingUnusedAttachments,
  )

proc newVkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceInternallySynchronizedQueuesFeaturesKHR, pNext: pointer = nil, internallySynchronizedQueues: VkBool32): VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR =
  result = VkPhysicalDeviceInternallySynchronizedQueuesFeaturesKHR(
    sType: sType,
    pNext: pNext,
    internallySynchronizedQueues: internallySynchronizedQueues,
  )

proc newVkSurfacePresentModeKHR*(sType: VkStructureType = VkStructureType.SurfacePresentModeKHR, pNext: pointer = nil, presentMode: VkPresentModeKHR): VkSurfacePresentModeKHR =
  result = VkSurfacePresentModeKHR(
    sType: sType,
    pNext: pNext,
    presentMode: presentMode,
  )

proc newVkSurfacePresentScalingCapabilitiesKHR*(sType: VkStructureType = VkStructureType.SurfacePresentScalingCapabilitiesKHR, pNext: pointer = nil, supportedPresentScaling: VkPresentScalingFlagsKHR, supportedPresentGravityX: VkPresentGravityFlagsKHR, supportedPresentGravityY: VkPresentGravityFlagsKHR, minScaledImageExtent: VkExtent2D, maxScaledImageExtent: VkExtent2D): VkSurfacePresentScalingCapabilitiesKHR =
  result = VkSurfacePresentScalingCapabilitiesKHR(
    sType: sType,
    pNext: pNext,
    supportedPresentScaling: supportedPresentScaling,
    supportedPresentGravityX: supportedPresentGravityX,
    supportedPresentGravityY: supportedPresentGravityY,
    minScaledImageExtent: minScaledImageExtent,
    maxScaledImageExtent: maxScaledImageExtent,
  )

proc newVkSurfacePresentModeCompatibilityKHR*(sType: VkStructureType = VkStructureType.SurfacePresentModeCompatibilityKHR, pNext: pointer = nil, presentModes: openarray[VkPresentModeKHR]): VkSurfacePresentModeCompatibilityKHR =
  result = VkSurfacePresentModeCompatibilityKHR(
    sType: sType,
    pNext: pNext,
    presentModeCount: len(presentModes).uint32,
    pPresentModes: if len(presentModes) == 0: nil else: cast[ptr VkPresentModeKHR](presentModes),
  )

proc newVkPhysicalDeviceSwapchainMaintenance1FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceSwapchainMaintenance1FeaturesKHR, pNext: pointer = nil, swapchainMaintenance1: VkBool32): VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR =
  result = VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(
    sType: sType,
    pNext: pNext,
    swapchainMaintenance1: swapchainMaintenance1,
  )

proc newVkSwapchainPresentFenceInfoKHR*(sType: VkStructureType = VkStructureType.SwapchainPresentFenceInfoKHR, pNext: pointer = nil, fences: openarray[VkFence]): VkSwapchainPresentFenceInfoKHR =
  result = VkSwapchainPresentFenceInfoKHR(
    sType: sType,
    pNext: pNext,
    swapchainCount: len(fences).uint32,
    pFences: if len(fences) == 0: nil else: cast[ptr VkFence](fences),
  )

proc newVkSwapchainPresentModesCreateInfoKHR*(sType: VkStructureType = VkStructureType.SwapchainPresentModesCreateInfoKHR, pNext: pointer = nil, presentModes: openarray[VkPresentModeKHR]): VkSwapchainPresentModesCreateInfoKHR =
  result = VkSwapchainPresentModesCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    presentModeCount: len(presentModes).uint32,
    pPresentModes: if len(presentModes) == 0: nil else: cast[ptr VkPresentModeKHR](presentModes),
  )

proc newVkSwapchainPresentModeInfoKHR*(sType: VkStructureType = VkStructureType.SwapchainPresentModeInfoKHR, pNext: pointer = nil, presentModes: openarray[VkPresentModeKHR]): VkSwapchainPresentModeInfoKHR =
  result = VkSwapchainPresentModeInfoKHR(
    sType: sType,
    pNext: pNext,
    swapchainCount: len(presentModes).uint32,
    pPresentModes: if len(presentModes) == 0: nil else: cast[ptr VkPresentModeKHR](presentModes),
  )

proc newVkSwapchainPresentScalingCreateInfoKHR*(sType: VkStructureType = VkStructureType.SwapchainPresentScalingCreateInfoKHR, pNext: pointer = nil, scalingBehavior: VkPresentScalingFlagsKHR, presentGravityX: VkPresentGravityFlagsKHR, presentGravityY: VkPresentGravityFlagsKHR): VkSwapchainPresentScalingCreateInfoKHR =
  result = VkSwapchainPresentScalingCreateInfoKHR(
    sType: sType,
    pNext: pNext,
    scalingBehavior: scalingBehavior,
    presentGravityX: presentGravityX,
    presentGravityY: presentGravityY,
  )

proc newVkReleaseSwapchainImagesInfoKHR*(sType: VkStructureType = VkStructureType.ReleaseSwapchainImagesInfoKHR, pNext: pointer = nil, swapchain: VkSwapchainKHR, imageIndices: openarray[uint32]): VkReleaseSwapchainImagesInfoKHR =
  result = VkReleaseSwapchainImagesInfoKHR(
    sType: sType,
    pNext: pNext,
    swapchain: swapchain,
    imageIndexCount: len(imageIndices).uint32,
    pImageIndices: if len(imageIndices) == 0: nil else: cast[ptr uint32](imageIndices),
  )

proc newVkPhysicalDeviceDepthBiasControlFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDepthBiasControlFeaturesEXT, pNext: pointer = nil, depthBiasControl: VkBool32, leastRepresentableValueForceUnormRepresentation: VkBool32, floatRepresentation: VkBool32, depthBiasExact: VkBool32): VkPhysicalDeviceDepthBiasControlFeaturesEXT =
  result = VkPhysicalDeviceDepthBiasControlFeaturesEXT(
    sType: sType,
    pNext: pNext,
    depthBiasControl: depthBiasControl,
    leastRepresentableValueForceUnormRepresentation: leastRepresentableValueForceUnormRepresentation,
    floatRepresentation: floatRepresentation,
    depthBiasExact: depthBiasExact,
  )

proc newVkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingInvocationReorderFeaturesEXT, pNext: pointer = nil, rayTracingInvocationReorder: VkBool32): VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT =
  result = VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT(
    sType: sType,
    pNext: pNext,
    rayTracingInvocationReorder: rayTracingInvocationReorder,
  )

proc newVkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingInvocationReorderFeaturesNV, pNext: pointer = nil, rayTracingInvocationReorder: VkBool32): VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV =
  result = VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(
    sType: sType,
    pNext: pNext,
    rayTracingInvocationReorder: rayTracingInvocationReorder,
  )

proc newVkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingInvocationReorderPropertiesEXT, pNext: pointer = nil, rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeEXT, maxShaderBindingTableRecordIndex: uint32): VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT =
  result = VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT(
    sType: sType,
    pNext: pNext,
    rayTracingInvocationReorderReorderingHint: rayTracingInvocationReorderReorderingHint,
    maxShaderBindingTableRecordIndex: maxShaderBindingTableRecordIndex,
  )

proc newVkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingInvocationReorderPropertiesNV, pNext: pointer = nil, rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeEXT): VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV =
  result = VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(
    sType: sType,
    pNext: pNext,
    rayTracingInvocationReorderReorderingHint: rayTracingInvocationReorderReorderingHint,
  )

proc newVkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV, pNext: pointer = nil, extendedSparseAddressSpace: VkBool32): VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV =
  result = VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(
    sType: sType,
    pNext: pNext,
    extendedSparseAddressSpace: extendedSparseAddressSpace,
  )

proc newVkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceExtendedSparseAddressSpacePropertiesNV, pNext: pointer = nil, extendedSparseAddressSpaceSize: VkDeviceSize, extendedSparseImageUsageFlags: VkImageUsageFlags, extendedSparseBufferUsageFlags: VkBufferUsageFlags): VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV =
  result = VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(
    sType: sType,
    pNext: pNext,
    extendedSparseAddressSpaceSize: extendedSparseAddressSpaceSize,
    extendedSparseImageUsageFlags: extendedSparseImageUsageFlags,
    extendedSparseBufferUsageFlags: extendedSparseBufferUsageFlags,
  )

proc newVkDirectDriverLoadingInfoLUNARG*(sType: VkStructureType = VkStructureType.DirectDriverLoadingInfoLUNARG, pNext: pointer = nil, flags: VkDirectDriverLoadingFlagsLUNARG = 0.VkDirectDriverLoadingFlagsLUNARG, pfnGetInstanceProcAddr: PFN_vkGetInstanceProcAddrLUNARG): VkDirectDriverLoadingInfoLUNARG =
  result = VkDirectDriverLoadingInfoLUNARG(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pfnGetInstanceProcAddr: pfnGetInstanceProcAddr,
  )

proc newVkDirectDriverLoadingListLUNARG*(sType: VkStructureType = VkStructureType.DirectDriverLoadingListLUNARG, pNext: pointer = nil, mode: VkDirectDriverLoadingModeLUNARG, drivers: openarray[VkDirectDriverLoadingInfoLUNARG]): VkDirectDriverLoadingListLUNARG =
  result = VkDirectDriverLoadingListLUNARG(
    sType: sType,
    pNext: pNext,
    mode: mode,
    driverCount: len(drivers).uint32,
    pDrivers: if len(drivers) == 0: nil else: cast[ptr VkDirectDriverLoadingInfoLUNARG](drivers),
  )

proc newVkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM, pNext: pointer = nil, multiviewPerViewViewports: VkBool32): VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM =
  result = VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    multiviewPerViewViewports: multiviewPerViewViewports,
  )

proc newVkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceRayTracingPositionFetchFeaturesKHR, pNext: pointer = nil, rayTracingPositionFetch: VkBool32): VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR =
  result = VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(
    sType: sType,
    pNext: pNext,
    rayTracingPositionFetch: rayTracingPositionFetch,
  )

proc newVkDeviceImageSubresourceInfo*(sType: VkStructureType = VkStructureType.DeviceImageSubresourceInfo, pNext: pointer = nil, pCreateInfo: ptr VkImageCreateInfo, pSubresource: ptr VkImageSubresource2): VkDeviceImageSubresourceInfo =
  result = VkDeviceImageSubresourceInfo(
    sType: sType,
    pNext: pNext,
    pCreateInfo: pCreateInfo,
    pSubresource: pSubresource,
  )

proc newVkPhysicalDeviceShaderCorePropertiesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderCorePropertiesARM, pNext: pointer = nil, pixelRate: uint32, texelRate: uint32, fmaRate: uint32): VkPhysicalDeviceShaderCorePropertiesARM =
  result = VkPhysicalDeviceShaderCorePropertiesARM(
    sType: sType,
    pNext: pNext,
    pixelRate: pixelRate,
    texelRate: texelRate,
    fmaRate: fmaRate,
  )

proc newVkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM, pNext: pointer = nil, multiviewPerViewRenderAreas: VkBool32): VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM =
  result = VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    multiviewPerViewRenderAreas: multiviewPerViewRenderAreas,
  )

proc newVkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*(sType: VkStructureType = VkStructureType.MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM, pNext: pointer = nil, perViewRenderAreas: openarray[VkRect2D]): VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM =
  result = VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(
    sType: sType,
    pNext: pNext,
    perViewRenderAreaCount: len(perViewRenderAreas).uint32,
    pPerViewRenderAreas: if len(perViewRenderAreas) == 0: nil else: cast[ptr VkRect2D](perViewRenderAreas),
  )

proc newVkQueryLowLatencySupportNV*(sType: VkStructureType = VkStructureType.QueryLowLatencySupportNV, pNext: pointer = nil, pQueriedLowLatencyData: pointer = nil): VkQueryLowLatencySupportNV =
  result = VkQueryLowLatencySupportNV(
    sType: sType,
    pNext: pNext,
    pQueriedLowLatencyData: pQueriedLowLatencyData,
  )

proc newVkMemoryMapInfo*(sType: VkStructureType = VkStructureType.MemoryMapInfo, pNext: pointer = nil, flags: VkMemoryMapFlags = 0.VkMemoryMapFlags, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize): VkMemoryMapInfo =
  result = VkMemoryMapInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    memory: memory,
    offset: offset,
    size: size,
  )

proc newVkMemoryUnmapInfo*(sType: VkStructureType = VkStructureType.MemoryUnmapInfo, pNext: pointer = nil, flags: VkMemoryUnmapFlags = 0.VkMemoryUnmapFlags, memory: VkDeviceMemory): VkMemoryUnmapInfo =
  result = VkMemoryUnmapInfo(
    sType: sType,
    pNext: pNext,
    flags: flags,
    memory: memory,
  )

proc newVkPhysicalDeviceShaderObjectFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderObjectFeaturesEXT, pNext: pointer = nil, shaderObject: VkBool32): VkPhysicalDeviceShaderObjectFeaturesEXT =
  result = VkPhysicalDeviceShaderObjectFeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderObject: shaderObject,
  )

proc newVkPhysicalDeviceShaderObjectPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderObjectPropertiesEXT, pNext: pointer = nil, shaderBinaryUUID: array[VK_UUID_SIZE, uint8], shaderBinaryVersion: uint32): VkPhysicalDeviceShaderObjectPropertiesEXT =
  result = VkPhysicalDeviceShaderObjectPropertiesEXT(
    sType: sType,
    pNext: pNext,
    shaderBinaryUUID: shaderBinaryUUID,
    shaderBinaryVersion: shaderBinaryVersion,
  )

proc newVkShaderCreateInfoEXT*(sType: VkStructureType = VkStructureType.ShaderCreateInfoEXT, pNext: pointer = nil, flags: VkShaderCreateFlagsEXT = 0.VkShaderCreateFlagsEXT, stage: VkShaderStageFlagBits, nextStage: VkShaderStageFlags, codeType: VkShaderCodeTypeEXT, codeSize: uint, pCode: pointer = nil, pName: cstring, setLayouts: openarray[VkDescriptorSetLayout], pushConstantRanges: openarray[VkPushConstantRange], pSpecializationInfo: ptr VkSpecializationInfo): VkShaderCreateInfoEXT =
  result = VkShaderCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    flags: flags,
    stage: stage,
    nextStage: nextStage,
    codeType: codeType,
    codeSize: codeSize,
    pCode: pCode,
    pName: pName,
    setLayoutCount: len(setLayouts).uint32,
    pSetLayouts: if len(setLayouts) == 0: nil else: cast[ptr VkDescriptorSetLayout](setLayouts),
    pushConstantRangeCount: len(pushConstantRanges).uint32,
    pPushConstantRanges: if len(pushConstantRanges) == 0: nil else: cast[ptr VkPushConstantRange](pushConstantRanges),
    pSpecializationInfo: pSpecializationInfo,
  )

proc newVkPhysicalDeviceShaderTileImageFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderTileImageFeaturesEXT, pNext: pointer = nil, shaderTileImageColorReadAccess: VkBool32, shaderTileImageDepthReadAccess: VkBool32, shaderTileImageStencilReadAccess: VkBool32): VkPhysicalDeviceShaderTileImageFeaturesEXT =
  result = VkPhysicalDeviceShaderTileImageFeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderTileImageColorReadAccess: shaderTileImageColorReadAccess,
    shaderTileImageDepthReadAccess: shaderTileImageDepthReadAccess,
    shaderTileImageStencilReadAccess: shaderTileImageStencilReadAccess,
  )

proc newVkPhysicalDeviceShaderTileImagePropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderTileImagePropertiesEXT, pNext: pointer = nil, shaderTileImageCoherentReadAccelerated: VkBool32, shaderTileImageReadSampleFromPixelRateInvocation: VkBool32, shaderTileImageReadFromHelperInvocation: VkBool32): VkPhysicalDeviceShaderTileImagePropertiesEXT =
  result = VkPhysicalDeviceShaderTileImagePropertiesEXT(
    sType: sType,
    pNext: pNext,
    shaderTileImageCoherentReadAccelerated: shaderTileImageCoherentReadAccelerated,
    shaderTileImageReadSampleFromPixelRateInvocation: shaderTileImageReadSampleFromPixelRateInvocation,
    shaderTileImageReadFromHelperInvocation: shaderTileImageReadFromHelperInvocation,
  )

proc newVkImportScreenBufferInfoQNX*(sType: VkStructureType = VkStructureType.ImportScreenBufferInfoQNX, pNext: pointer = nil, buffer: ptr screen_buffer): VkImportScreenBufferInfoQNX =
  result = VkImportScreenBufferInfoQNX(
    sType: sType,
    pNext: pNext,
    buffer: buffer,
  )

proc newVkScreenBufferPropertiesQNX*(sType: VkStructureType = VkStructureType.ScreenBufferPropertiesQNX, pNext: pointer = nil, allocationSize: VkDeviceSize, memoryTypeBits: uint32): VkScreenBufferPropertiesQNX =
  result = VkScreenBufferPropertiesQNX(
    sType: sType,
    pNext: pNext,
    allocationSize: allocationSize,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkScreenBufferFormatPropertiesQNX*(sType: VkStructureType = VkStructureType.ScreenBufferFormatPropertiesQNX, pNext: pointer = nil, format: VkFormat, externalFormat: uint64, screenUsage: uint64, formatFeatures: VkFormatFeatureFlags, samplerYcbcrConversionComponents: VkComponentMapping, suggestedYcbcrModel: VkSamplerYcbcrModelConversion, suggestedYcbcrRange: VkSamplerYcbcrRange, suggestedXChromaOffset: VkChromaLocation, suggestedYChromaOffset: VkChromaLocation): VkScreenBufferFormatPropertiesQNX =
  result = VkScreenBufferFormatPropertiesQNX(
    sType: sType,
    pNext: pNext,
    format: format,
    externalFormat: externalFormat,
    screenUsage: screenUsage,
    formatFeatures: formatFeatures,
    samplerYcbcrConversionComponents: samplerYcbcrConversionComponents,
    suggestedYcbcrModel: suggestedYcbcrModel,
    suggestedYcbcrRange: suggestedYcbcrRange,
    suggestedXChromaOffset: suggestedXChromaOffset,
    suggestedYChromaOffset: suggestedYChromaOffset,
  )

proc newVkExternalFormatQNX*(sType: VkStructureType = VkStructureType.ExternalFormatQNX, pNext: pointer = nil, externalFormat: uint64): VkExternalFormatQNX =
  result = VkExternalFormatQNX(
    sType: sType,
    pNext: pNext,
    externalFormat: externalFormat,
  )

proc newVkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, pNext: pointer = nil, screenBufferImport: VkBool32): VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX =
  result = VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(
    sType: sType,
    pNext: pNext,
    screenBufferImport: screenBufferImport,
  )

proc newVkPhysicalDeviceCooperativeMatrixFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceCooperativeMatrixFeaturesKHR, pNext: pointer = nil, cooperativeMatrix: VkBool32, cooperativeMatrixRobustBufferAccess: VkBool32): VkPhysicalDeviceCooperativeMatrixFeaturesKHR =
  result = VkPhysicalDeviceCooperativeMatrixFeaturesKHR(
    sType: sType,
    pNext: pNext,
    cooperativeMatrix: cooperativeMatrix,
    cooperativeMatrixRobustBufferAccess: cooperativeMatrixRobustBufferAccess,
  )

proc newVkCooperativeMatrixPropertiesKHR*(sType: VkStructureType = VkStructureType.CooperativeMatrixPropertiesKHR, pNext: pointer = nil, MSize: uint32, NSize: uint32, KSize: uint32, AType: VkComponentTypeKHR, BType: VkComponentTypeKHR, CType: VkComponentTypeKHR, ResultType: VkComponentTypeKHR, saturatingAccumulation: VkBool32, scope: VkScopeKHR): VkCooperativeMatrixPropertiesKHR =
  result = VkCooperativeMatrixPropertiesKHR(
    sType: sType,
    pNext: pNext,
    MSize: MSize,
    NSize: NSize,
    KSize: KSize,
    AType: AType,
    BType: BType,
    CType: CType,
    ResultType: ResultType,
    saturatingAccumulation: saturatingAccumulation,
    scope: scope,
  )

proc newVkPhysicalDeviceCooperativeMatrixPropertiesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceCooperativeMatrixPropertiesKHR, pNext: pointer = nil, cooperativeMatrixSupportedStages: VkShaderStageFlags): VkPhysicalDeviceCooperativeMatrixPropertiesKHR =
  result = VkPhysicalDeviceCooperativeMatrixPropertiesKHR(
    sType: sType,
    pNext: pNext,
    cooperativeMatrixSupportedStages: cooperativeMatrixSupportedStages,
  )

proc newVkPhysicalDeviceCooperativeMatrixConversionFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceCooperativeMatrixConversionFeaturesQCOM, pNext: pointer = nil, cooperativeMatrixConversion: VkBool32): VkPhysicalDeviceCooperativeMatrixConversionFeaturesQCOM =
  result = VkPhysicalDeviceCooperativeMatrixConversionFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    cooperativeMatrixConversion: cooperativeMatrixConversion,
  )

proc newVkPhysicalDeviceShaderEnqueuePropertiesAMDX*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderEnqueuePropertiesAMDX, pNext: pointer = nil, maxExecutionGraphDepth: uint32, maxExecutionGraphShaderOutputNodes: uint32, maxExecutionGraphShaderPayloadSize: uint32, maxExecutionGraphShaderPayloadCount: uint32, executionGraphDispatchAddressAlignment: uint32, maxExecutionGraphWorkgroupCount: array[3, uint32], maxExecutionGraphWorkgroups: uint32): VkPhysicalDeviceShaderEnqueuePropertiesAMDX =
  result = VkPhysicalDeviceShaderEnqueuePropertiesAMDX(
    sType: sType,
    pNext: pNext,
    maxExecutionGraphDepth: maxExecutionGraphDepth,
    maxExecutionGraphShaderOutputNodes: maxExecutionGraphShaderOutputNodes,
    maxExecutionGraphShaderPayloadSize: maxExecutionGraphShaderPayloadSize,
    maxExecutionGraphShaderPayloadCount: maxExecutionGraphShaderPayloadCount,
    executionGraphDispatchAddressAlignment: executionGraphDispatchAddressAlignment,
    maxExecutionGraphWorkgroupCount: maxExecutionGraphWorkgroupCount,
    maxExecutionGraphWorkgroups: maxExecutionGraphWorkgroups,
  )

proc newVkPhysicalDeviceShaderEnqueueFeaturesAMDX*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderEnqueueFeaturesAMDX, pNext: pointer = nil, shaderEnqueue: VkBool32, shaderMeshEnqueue: VkBool32): VkPhysicalDeviceShaderEnqueueFeaturesAMDX =
  result = VkPhysicalDeviceShaderEnqueueFeaturesAMDX(
    sType: sType,
    pNext: pNext,
    shaderEnqueue: shaderEnqueue,
    shaderMeshEnqueue: shaderMeshEnqueue,
  )

proc newVkExecutionGraphPipelineCreateInfoAMDX*(sType: VkStructureType = VkStructureType.ExecutionGraphPipelineCreateInfoAMDX, pNext: pointer = nil, flags: VkPipelineCreateFlags = 0.VkPipelineCreateFlags, stages: openarray[VkPipelineShaderStageCreateInfo], pLibraryInfo: ptr VkPipelineLibraryCreateInfoKHR, layout: VkPipelineLayout, basePipelineHandle: VkPipeline, basePipelineIndex: int32): VkExecutionGraphPipelineCreateInfoAMDX =
  result = VkExecutionGraphPipelineCreateInfoAMDX(
    sType: sType,
    pNext: pNext,
    flags: flags,
    stageCount: len(stages).uint32,
    pStages: if len(stages) == 0: nil else: cast[ptr VkPipelineShaderStageCreateInfo](stages),
    pLibraryInfo: pLibraryInfo,
    layout: layout,
    basePipelineHandle: basePipelineHandle,
    basePipelineIndex: basePipelineIndex,
  )

proc newVkPipelineShaderStageNodeCreateInfoAMDX*(sType: VkStructureType = VkStructureType.PipelineShaderStageNodeCreateInfoAMDX, pNext: pointer = nil, pName: cstring, index: uint32): VkPipelineShaderStageNodeCreateInfoAMDX =
  result = VkPipelineShaderStageNodeCreateInfoAMDX(
    sType: sType,
    pNext: pNext,
    pName: pName,
    index: index,
  )

proc newVkExecutionGraphPipelineScratchSizeAMDX*(sType: VkStructureType = VkStructureType.ExecutionGraphPipelineScratchSizeAMDX, pNext: pointer = nil, minSize: VkDeviceSize, maxSize: VkDeviceSize, sizeGranularity: VkDeviceSize): VkExecutionGraphPipelineScratchSizeAMDX =
  result = VkExecutionGraphPipelineScratchSizeAMDX(
    sType: sType,
    pNext: pNext,
    minSize: minSize,
    maxSize: maxSize,
    sizeGranularity: sizeGranularity,
  )

proc newVkDispatchGraphInfoAMDX*(nodeIndex: uint32, payloadCount: uint32, payloads: VkDeviceOrHostAddressConstAMDX, payloadStride: uint64): VkDispatchGraphInfoAMDX =
  result = VkDispatchGraphInfoAMDX(
    nodeIndex: nodeIndex,
    payloadCount: payloadCount,
    payloads: payloads,
    payloadStride: payloadStride,
  )

proc newVkDispatchGraphCountInfoAMDX*(count: uint32, infos: VkDeviceOrHostAddressConstAMDX, stride: uint64): VkDispatchGraphCountInfoAMDX =
  result = VkDispatchGraphCountInfoAMDX(
    count: count,
    infos: infos,
    stride: stride,
  )

proc newVkPhysicalDeviceAntiLagFeaturesAMD*(sType: VkStructureType = VkStructureType.PhysicalDeviceAntiLagFeaturesAMD, pNext: pointer = nil, antiLag: VkBool32): VkPhysicalDeviceAntiLagFeaturesAMD =
  result = VkPhysicalDeviceAntiLagFeaturesAMD(
    sType: sType,
    pNext: pNext,
    antiLag: antiLag,
  )

proc newVkAntiLagDataAMD*(sType: VkStructureType = VkStructureType.AntiLagDataAMD, pNext: pointer = nil, mode: VkAntiLagModeAMD, maxFPS: uint32, pPresentationInfo: ptr VkAntiLagPresentationInfoAMD): VkAntiLagDataAMD =
  result = VkAntiLagDataAMD(
    sType: sType,
    pNext: pNext,
    mode: mode,
    maxFPS: maxFPS,
    pPresentationInfo: pPresentationInfo,
  )

proc newVkAntiLagPresentationInfoAMD*(sType: VkStructureType = VkStructureType.AntiLagPresentationInfoAMD, pNext: pointer = nil, stage: VkAntiLagStageAMD, frameIndex: uint64): VkAntiLagPresentationInfoAMD =
  result = VkAntiLagPresentationInfoAMD(
    sType: sType,
    pNext: pNext,
    stage: stage,
    frameIndex: frameIndex,
  )

proc newVkBindMemoryStatus*(sType: VkStructureType = VkStructureType.BindMemoryStatus, pNext: pointer = nil, pResult: ptr VkResult): VkBindMemoryStatus =
  result = VkBindMemoryStatus(
    sType: sType,
    pNext: pNext,
    pResult: pResult,
  )

proc newVkPhysicalDeviceTileMemoryHeapFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceTileMemoryHeapFeaturesQCOM, pNext: pointer = nil, tileMemoryHeap: VkBool32): VkPhysicalDeviceTileMemoryHeapFeaturesQCOM =
  result = VkPhysicalDeviceTileMemoryHeapFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    tileMemoryHeap: tileMemoryHeap,
  )

proc newVkPhysicalDeviceTileMemoryHeapPropertiesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceTileMemoryHeapPropertiesQCOM, pNext: pointer = nil, queueSubmitBoundary: VkBool32, tileBufferTransfers: VkBool32): VkPhysicalDeviceTileMemoryHeapPropertiesQCOM =
  result = VkPhysicalDeviceTileMemoryHeapPropertiesQCOM(
    sType: sType,
    pNext: pNext,
    queueSubmitBoundary: queueSubmitBoundary,
    tileBufferTransfers: tileBufferTransfers,
  )

proc newVkTileMemorySizeInfoQCOM*(sType: VkStructureType = VkStructureType.TileMemorySizeInfoQCOM, pNext: pointer = nil, size: VkDeviceSize): VkTileMemorySizeInfoQCOM =
  result = VkTileMemorySizeInfoQCOM(
    sType: sType,
    pNext: pNext,
    size: size,
  )

proc newVkTileMemoryRequirementsQCOM*(sType: VkStructureType = VkStructureType.TileMemoryRequirementsQCOM, pNext: pointer = nil, size: VkDeviceSize, alignment: VkDeviceSize): VkTileMemoryRequirementsQCOM =
  result = VkTileMemoryRequirementsQCOM(
    sType: sType,
    pNext: pNext,
    size: size,
    alignment: alignment,
  )

proc newVkBindDescriptorSetsInfo*(sType: VkStructureType = VkStructureType.BindDescriptorSetsInfo, pNext: pointer = nil, stageFlags: VkShaderStageFlags, layout: VkPipelineLayout, firstSet: uint32, descriptorSets: openarray[VkDescriptorSet], dynamicOffsets: openarray[uint32]): VkBindDescriptorSetsInfo =
  result = VkBindDescriptorSetsInfo(
    sType: sType,
    pNext: pNext,
    stageFlags: stageFlags,
    layout: layout,
    firstSet: firstSet,
    descriptorSetCount: len(descriptorSets).uint32,
    pDescriptorSets: if len(descriptorSets) == 0: nil else: cast[ptr VkDescriptorSet](descriptorSets),
    dynamicOffsetCount: len(dynamicOffsets).uint32,
    pDynamicOffsets: if len(dynamicOffsets) == 0: nil else: cast[ptr uint32](dynamicOffsets),
  )

proc newVkPushConstantsInfo*(sType: VkStructureType = VkStructureType.PushConstantsInfo, pNext: pointer = nil, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: uint32, size: uint32, pValues: pointer = nil): VkPushConstantsInfo =
  result = VkPushConstantsInfo(
    sType: sType,
    pNext: pNext,
    layout: layout,
    stageFlags: stageFlags,
    offset: offset,
    size: size,
    pValues: pValues,
  )

proc newVkPushDescriptorSetInfo*(sType: VkStructureType = VkStructureType.PushDescriptorSetInfo, pNext: pointer = nil, stageFlags: VkShaderStageFlags, layout: VkPipelineLayout, set: uint32, descriptorWrites: openarray[VkWriteDescriptorSet]): VkPushDescriptorSetInfo =
  result = VkPushDescriptorSetInfo(
    sType: sType,
    pNext: pNext,
    stageFlags: stageFlags,
    layout: layout,
    set: set,
    descriptorWriteCount: len(descriptorWrites).uint32,
    pDescriptorWrites: if len(descriptorWrites) == 0: nil else: cast[ptr VkWriteDescriptorSet](descriptorWrites),
  )

proc newVkPushDescriptorSetWithTemplateInfo*(sType: VkStructureType = VkStructureType.PushDescriptorSetWithTemplateInfo, pNext: pointer = nil, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: uint32, pData: pointer = nil): VkPushDescriptorSetWithTemplateInfo =
  result = VkPushDescriptorSetWithTemplateInfo(
    sType: sType,
    pNext: pNext,
    descriptorUpdateTemplate: descriptorUpdateTemplate,
    layout: layout,
    set: set,
    pData: pData,
  )

proc newVkSetDescriptorBufferOffsetsInfoEXT*(sType: VkStructureType = VkStructureType.SetDescriptorBufferOffsetsInfoEXT, pNext: pointer = nil, stageFlags: VkShaderStageFlags, layout: VkPipelineLayout, firstSet: uint32, bufferIndices: openarray[uint32], offsets: openarray[VkDeviceSize]): VkSetDescriptorBufferOffsetsInfoEXT =
  result = VkSetDescriptorBufferOffsetsInfoEXT(
    sType: sType,
    pNext: pNext,
    stageFlags: stageFlags,
    layout: layout,
    firstSet: firstSet,
    setCount: len(bufferIndices).uint32,
    pBufferIndices: if len(bufferIndices) == 0: nil else: cast[ptr uint32](bufferIndices),
    pOffsets: if len(offsets) == 0: nil else: cast[ptr VkDeviceSize](offsets),
  )

proc newVkBindDescriptorBufferEmbeddedSamplersInfoEXT*(sType: VkStructureType = VkStructureType.BindDescriptorBufferEmbeddedSamplersInfoEXT, pNext: pointer = nil, stageFlags: VkShaderStageFlags, layout: VkPipelineLayout, set: uint32): VkBindDescriptorBufferEmbeddedSamplersInfoEXT =
  result = VkBindDescriptorBufferEmbeddedSamplersInfoEXT(
    sType: sType,
    pNext: pNext,
    stageFlags: stageFlags,
    layout: layout,
    set: set,
  )

proc newVkPhysicalDeviceCubicClampFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceCubicClampFeaturesQCOM, pNext: pointer = nil, cubicRangeClamp: VkBool32): VkPhysicalDeviceCubicClampFeaturesQCOM =
  result = VkPhysicalDeviceCubicClampFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    cubicRangeClamp: cubicRangeClamp,
  )

proc newVkPhysicalDeviceYcbcrDegammaFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceYcbcrDegammaFeaturesQCOM, pNext: pointer = nil, ycbcrDegamma: VkBool32): VkPhysicalDeviceYcbcrDegammaFeaturesQCOM =
  result = VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    ycbcrDegamma: ycbcrDegamma,
  )

proc newVkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*(sType: VkStructureType = VkStructureType.SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM, pNext: pointer = nil, enableYDegamma: VkBool32, enableCbCrDegamma: VkBool32): VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM =
  result = VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(
    sType: sType,
    pNext: pNext,
    enableYDegamma: enableYDegamma,
    enableCbCrDegamma: enableCbCrDegamma,
  )

proc newVkPhysicalDeviceCubicWeightsFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceCubicWeightsFeaturesQCOM, pNext: pointer = nil, selectableCubicWeights: VkBool32): VkPhysicalDeviceCubicWeightsFeaturesQCOM =
  result = VkPhysicalDeviceCubicWeightsFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    selectableCubicWeights: selectableCubicWeights,
  )

proc newVkSamplerCubicWeightsCreateInfoQCOM*(sType: VkStructureType = VkStructureType.SamplerCubicWeightsCreateInfoQCOM, pNext: pointer = nil, cubicWeights: VkCubicFilterWeightsQCOM): VkSamplerCubicWeightsCreateInfoQCOM =
  result = VkSamplerCubicWeightsCreateInfoQCOM(
    sType: sType,
    pNext: pNext,
    cubicWeights: cubicWeights,
  )

proc newVkBlitImageCubicWeightsInfoQCOM*(sType: VkStructureType = VkStructureType.BlitImageCubicWeightsInfoQCOM, pNext: pointer = nil, cubicWeights: VkCubicFilterWeightsQCOM): VkBlitImageCubicWeightsInfoQCOM =
  result = VkBlitImageCubicWeightsInfoQCOM(
    sType: sType,
    pNext: pNext,
    cubicWeights: cubicWeights,
  )

proc newVkPhysicalDeviceImageProcessing2FeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageProcessing2FeaturesQCOM, pNext: pointer = nil, textureBlockMatch2: VkBool32): VkPhysicalDeviceImageProcessing2FeaturesQCOM =
  result = VkPhysicalDeviceImageProcessing2FeaturesQCOM(
    sType: sType,
    pNext: pNext,
    textureBlockMatch2: textureBlockMatch2,
  )

proc newVkPhysicalDeviceImageProcessing2PropertiesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageProcessing2PropertiesQCOM, pNext: pointer = nil, maxBlockMatchWindow: VkExtent2D): VkPhysicalDeviceImageProcessing2PropertiesQCOM =
  result = VkPhysicalDeviceImageProcessing2PropertiesQCOM(
    sType: sType,
    pNext: pNext,
    maxBlockMatchWindow: maxBlockMatchWindow,
  )

proc newVkSamplerBlockMatchWindowCreateInfoQCOM*(sType: VkStructureType = VkStructureType.SamplerBlockMatchWindowCreateInfoQCOM, pNext: pointer = nil, windowExtent: VkExtent2D, windowCompareMode: VkBlockMatchWindowCompareModeQCOM): VkSamplerBlockMatchWindowCreateInfoQCOM =
  result = VkSamplerBlockMatchWindowCreateInfoQCOM(
    sType: sType,
    pNext: pNext,
    windowExtent: windowExtent,
    windowCompareMode: windowCompareMode,
  )

proc newVkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorPoolOverallocationFeaturesNV, pNext: pointer = nil, descriptorPoolOverallocation: VkBool32): VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV =
  result = VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(
    sType: sType,
    pNext: pNext,
    descriptorPoolOverallocation: descriptorPoolOverallocation,
  )

proc newVkPhysicalDeviceLayeredDriverPropertiesMSFT*(sType: VkStructureType = VkStructureType.PhysicalDeviceLayeredDriverPropertiesMSFT, pNext: pointer = nil, underlyingAPI: VkLayeredDriverUnderlyingApiMSFT): VkPhysicalDeviceLayeredDriverPropertiesMSFT =
  result = VkPhysicalDeviceLayeredDriverPropertiesMSFT(
    sType: sType,
    pNext: pNext,
    underlyingAPI: underlyingAPI,
  )

proc newVkPhysicalDevicePerStageDescriptorSetFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDevicePerStageDescriptorSetFeaturesNV, pNext: pointer = nil, perStageDescriptorSet: VkBool32, dynamicPipelineLayout: VkBool32): VkPhysicalDevicePerStageDescriptorSetFeaturesNV =
  result = VkPhysicalDevicePerStageDescriptorSetFeaturesNV(
    sType: sType,
    pNext: pNext,
    perStageDescriptorSet: perStageDescriptorSet,
    dynamicPipelineLayout: dynamicPipelineLayout,
  )

proc newVkPhysicalDeviceExternalFormatResolveFeaturesANDROID*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalFormatResolveFeaturesANDROID, pNext: pointer = nil, externalFormatResolve: VkBool32): VkPhysicalDeviceExternalFormatResolveFeaturesANDROID =
  result = VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(
    sType: sType,
    pNext: pNext,
    externalFormatResolve: externalFormatResolve,
  )

proc newVkPhysicalDeviceExternalFormatResolvePropertiesANDROID*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalFormatResolvePropertiesANDROID, pNext: pointer = nil, nullColorAttachmentWithExternalFormatResolve: VkBool32, externalFormatResolveChromaOffsetX: VkChromaLocation, externalFormatResolveChromaOffsetY: VkChromaLocation): VkPhysicalDeviceExternalFormatResolvePropertiesANDROID =
  result = VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(
    sType: sType,
    pNext: pNext,
    nullColorAttachmentWithExternalFormatResolve: nullColorAttachmentWithExternalFormatResolve,
    externalFormatResolveChromaOffsetX: externalFormatResolveChromaOffsetX,
    externalFormatResolveChromaOffsetY: externalFormatResolveChromaOffsetY,
  )

proc newVkAndroidHardwareBufferFormatResolvePropertiesANDROID*(sType: VkStructureType = VkStructureType.AndroidHardwareBufferFormatResolvePropertiesANDROID, pNext: pointer = nil, colorAttachmentFormat: VkFormat): VkAndroidHardwareBufferFormatResolvePropertiesANDROID =
  result = VkAndroidHardwareBufferFormatResolvePropertiesANDROID(
    sType: sType,
    pNext: pNext,
    colorAttachmentFormat: colorAttachmentFormat,
  )

proc newVkLatencySleepModeInfoNV*(sType: VkStructureType = VkStructureType.LatencySleepModeInfoNV, pNext: pointer = nil, lowLatencyMode: VkBool32, lowLatencyBoost: VkBool32, minimumIntervalUs: uint32): VkLatencySleepModeInfoNV =
  result = VkLatencySleepModeInfoNV(
    sType: sType,
    pNext: pNext,
    lowLatencyMode: lowLatencyMode,
    lowLatencyBoost: lowLatencyBoost,
    minimumIntervalUs: minimumIntervalUs,
  )

proc newVkLatencySleepInfoNV*(sType: VkStructureType = VkStructureType.LatencySleepInfoNV, pNext: pointer = nil, signalSemaphore: VkSemaphore, value: uint64): VkLatencySleepInfoNV =
  result = VkLatencySleepInfoNV(
    sType: sType,
    pNext: pNext,
    signalSemaphore: signalSemaphore,
    value: value,
  )

proc newVkSetLatencyMarkerInfoNV*(sType: VkStructureType = VkStructureType.SetLatencyMarkerInfoNV, pNext: pointer = nil, presentID: uint64, marker: VkLatencyMarkerNV): VkSetLatencyMarkerInfoNV =
  result = VkSetLatencyMarkerInfoNV(
    sType: sType,
    pNext: pNext,
    presentID: presentID,
    marker: marker,
  )

proc newVkGetLatencyMarkerInfoNV*(sType: VkStructureType = VkStructureType.GetLatencyMarkerInfoNV, pNext: pointer = nil, timings: openarray[VkLatencyTimingsFrameReportNV]): VkGetLatencyMarkerInfoNV =
  result = VkGetLatencyMarkerInfoNV(
    sType: sType,
    pNext: pNext,
    timingCount: len(timings).uint32,
    pTimings: if len(timings) == 0: nil else: cast[ptr VkLatencyTimingsFrameReportNV](timings),
  )

proc newVkLatencyTimingsFrameReportNV*(sType: VkStructureType = VkStructureType.LatencyTimingsFrameReportNV, pNext: pointer = nil, presentID: uint64, inputSampleTimeUs: uint64, simStartTimeUs: uint64, simEndTimeUs: uint64, renderSubmitStartTimeUs: uint64, renderSubmitEndTimeUs: uint64, presentStartTimeUs: uint64, presentEndTimeUs: uint64, driverStartTimeUs: uint64, driverEndTimeUs: uint64, osRenderQueueStartTimeUs: uint64, osRenderQueueEndTimeUs: uint64, gpuRenderStartTimeUs: uint64, gpuRenderEndTimeUs: uint64): VkLatencyTimingsFrameReportNV =
  result = VkLatencyTimingsFrameReportNV(
    sType: sType,
    pNext: pNext,
    presentID: presentID,
    inputSampleTimeUs: inputSampleTimeUs,
    simStartTimeUs: simStartTimeUs,
    simEndTimeUs: simEndTimeUs,
    renderSubmitStartTimeUs: renderSubmitStartTimeUs,
    renderSubmitEndTimeUs: renderSubmitEndTimeUs,
    presentStartTimeUs: presentStartTimeUs,
    presentEndTimeUs: presentEndTimeUs,
    driverStartTimeUs: driverStartTimeUs,
    driverEndTimeUs: driverEndTimeUs,
    osRenderQueueStartTimeUs: osRenderQueueStartTimeUs,
    osRenderQueueEndTimeUs: osRenderQueueEndTimeUs,
    gpuRenderStartTimeUs: gpuRenderStartTimeUs,
    gpuRenderEndTimeUs: gpuRenderEndTimeUs,
  )

proc newVkOutOfBandQueueTypeInfoNV*(sType: VkStructureType = VkStructureType.OutOfBandQueueTypeInfoNV, pNext: pointer = nil, queueType: VkOutOfBandQueueTypeNV): VkOutOfBandQueueTypeInfoNV =
  result = VkOutOfBandQueueTypeInfoNV(
    sType: sType,
    pNext: pNext,
    queueType: queueType,
  )

proc newVkLatencySubmissionPresentIdNV*(sType: VkStructureType = VkStructureType.LatencySubmissionPresentIdNV, pNext: pointer = nil, presentID: uint64): VkLatencySubmissionPresentIdNV =
  result = VkLatencySubmissionPresentIdNV(
    sType: sType,
    pNext: pNext,
    presentID: presentID,
  )

proc newVkSwapchainLatencyCreateInfoNV*(sType: VkStructureType = VkStructureType.SwapchainLatencyCreateInfoNV, pNext: pointer = nil, latencyModeEnable: VkBool32): VkSwapchainLatencyCreateInfoNV =
  result = VkSwapchainLatencyCreateInfoNV(
    sType: sType,
    pNext: pNext,
    latencyModeEnable: latencyModeEnable,
  )

proc newVkLatencySurfaceCapabilitiesNV*(sType: VkStructureType = VkStructureType.LatencySurfaceCapabilitiesNV, pNext: pointer = nil, presentModes: openarray[VkPresentModeKHR]): VkLatencySurfaceCapabilitiesNV =
  result = VkLatencySurfaceCapabilitiesNV(
    sType: sType,
    pNext: pNext,
    presentModeCount: len(presentModes).uint32,
    pPresentModes: if len(presentModes) == 0: nil else: cast[ptr VkPresentModeKHR](presentModes),
  )

proc newVkPhysicalDeviceCudaKernelLaunchFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCudaKernelLaunchFeaturesNV, pNext: pointer = nil, cudaKernelLaunchFeatures: VkBool32): VkPhysicalDeviceCudaKernelLaunchFeaturesNV =
  result = VkPhysicalDeviceCudaKernelLaunchFeaturesNV(
    sType: sType,
    pNext: pNext,
    cudaKernelLaunchFeatures: cudaKernelLaunchFeatures,
  )

proc newVkPhysicalDeviceCudaKernelLaunchPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCudaKernelLaunchPropertiesNV, pNext: pointer = nil, computeCapabilityMinor: uint32, computeCapabilityMajor: uint32): VkPhysicalDeviceCudaKernelLaunchPropertiesNV =
  result = VkPhysicalDeviceCudaKernelLaunchPropertiesNV(
    sType: sType,
    pNext: pNext,
    computeCapabilityMinor: computeCapabilityMinor,
    computeCapabilityMajor: computeCapabilityMajor,
  )

proc newVkDeviceQueueShaderCoreControlCreateInfoARM*(sType: VkStructureType = VkStructureType.DeviceQueueShaderCoreControlCreateInfoARM, pNext: pointer = nil, shaderCoreCount: uint32): VkDeviceQueueShaderCoreControlCreateInfoARM =
  result = VkDeviceQueueShaderCoreControlCreateInfoARM(
    sType: sType,
    pNext: pNext,
    shaderCoreCount: shaderCoreCount,
  )

proc newVkPhysicalDeviceSchedulingControlsFeaturesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceSchedulingControlsFeaturesARM, pNext: pointer = nil, schedulingControls: VkBool32): VkPhysicalDeviceSchedulingControlsFeaturesARM =
  result = VkPhysicalDeviceSchedulingControlsFeaturesARM(
    sType: sType,
    pNext: pNext,
    schedulingControls: schedulingControls,
  )

proc newVkPhysicalDeviceSchedulingControlsPropertiesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceSchedulingControlsPropertiesARM, pNext: pointer = nil, schedulingControlsFlags: VkPhysicalDeviceSchedulingControlsFlagsARM): VkPhysicalDeviceSchedulingControlsPropertiesARM =
  result = VkPhysicalDeviceSchedulingControlsPropertiesARM(
    sType: sType,
    pNext: pNext,
    schedulingControlsFlags: schedulingControlsFlags,
  )

proc newVkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*(sType: VkStructureType = VkStructureType.PhysicalDeviceRelaxedLineRasterizationFeaturesIMG, pNext: pointer = nil, relaxedLineRasterization: VkBool32): VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG =
  result = VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(
    sType: sType,
    pNext: pNext,
    relaxedLineRasterization: relaxedLineRasterization,
  )

proc newVkPhysicalDeviceRenderPassStripedFeaturesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceRenderPassStripedFeaturesARM, pNext: pointer = nil, renderPassStriped: VkBool32): VkPhysicalDeviceRenderPassStripedFeaturesARM =
  result = VkPhysicalDeviceRenderPassStripedFeaturesARM(
    sType: sType,
    pNext: pNext,
    renderPassStriped: renderPassStriped,
  )

proc newVkPhysicalDeviceRenderPassStripedPropertiesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceRenderPassStripedPropertiesARM, pNext: pointer = nil, renderPassStripeGranularity: VkExtent2D, maxRenderPassStripes: uint32): VkPhysicalDeviceRenderPassStripedPropertiesARM =
  result = VkPhysicalDeviceRenderPassStripedPropertiesARM(
    sType: sType,
    pNext: pNext,
    renderPassStripeGranularity: renderPassStripeGranularity,
    maxRenderPassStripes: maxRenderPassStripes,
  )

proc newVkRenderPassStripeInfoARM*(sType: VkStructureType = VkStructureType.RenderPassStripeInfoARM, pNext: pointer = nil, stripeArea: VkRect2D): VkRenderPassStripeInfoARM =
  result = VkRenderPassStripeInfoARM(
    sType: sType,
    pNext: pNext,
    stripeArea: stripeArea,
  )

proc newVkRenderPassStripeBeginInfoARM*(sType: VkStructureType = VkStructureType.RenderPassStripeBeginInfoARM, pNext: pointer = nil, stripeInfos: openarray[VkRenderPassStripeInfoARM]): VkRenderPassStripeBeginInfoARM =
  result = VkRenderPassStripeBeginInfoARM(
    sType: sType,
    pNext: pNext,
    stripeInfoCount: len(stripeInfos).uint32,
    pStripeInfos: if len(stripeInfos) == 0: nil else: cast[ptr VkRenderPassStripeInfoARM](stripeInfos),
  )

proc newVkRenderPassStripeSubmitInfoARM*(sType: VkStructureType = VkStructureType.RenderPassStripeSubmitInfoARM, pNext: pointer = nil, stripeSemaphoreInfos: openarray[VkSemaphoreSubmitInfo]): VkRenderPassStripeSubmitInfoARM =
  result = VkRenderPassStripeSubmitInfoARM(
    sType: sType,
    pNext: pNext,
    stripeSemaphoreInfoCount: len(stripeSemaphoreInfos).uint32,
    pStripeSemaphoreInfos: if len(stripeSemaphoreInfos) == 0: nil else: cast[ptr VkSemaphoreSubmitInfo](stripeSemaphoreInfos),
  )

proc newVkPhysicalDevicePipelineOpacityMicromapFeaturesARM*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineOpacityMicromapFeaturesARM, pNext: pointer = nil, pipelineOpacityMicromap: VkBool32): VkPhysicalDevicePipelineOpacityMicromapFeaturesARM =
  result = VkPhysicalDevicePipelineOpacityMicromapFeaturesARM(
    sType: sType,
    pNext: pNext,
    pipelineOpacityMicromap: pipelineOpacityMicromap,
  )

proc newVkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR, pNext: pointer = nil, shaderMaximalReconvergence: VkBool32): VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR =
  result = VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(
    sType: sType,
    pNext: pNext,
    shaderMaximalReconvergence: shaderMaximalReconvergence,
  )

proc newVkPhysicalDeviceShaderSubgroupRotateFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderSubgroupRotateFeatures, pNext: pointer = nil, shaderSubgroupRotate: VkBool32, shaderSubgroupRotateClustered: VkBool32): VkPhysicalDeviceShaderSubgroupRotateFeatures =
  result = VkPhysicalDeviceShaderSubgroupRotateFeatures(
    sType: sType,
    pNext: pNext,
    shaderSubgroupRotate: shaderSubgroupRotate,
    shaderSubgroupRotateClustered: shaderSubgroupRotateClustered,
  )

proc newVkPhysicalDeviceShaderExpectAssumeFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderExpectAssumeFeatures, pNext: pointer = nil, shaderExpectAssume: VkBool32): VkPhysicalDeviceShaderExpectAssumeFeatures =
  result = VkPhysicalDeviceShaderExpectAssumeFeatures(
    sType: sType,
    pNext: pNext,
    shaderExpectAssume: shaderExpectAssume,
  )

proc newVkPhysicalDeviceShaderFloatControls2Features*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderFloatControls2Features, pNext: pointer = nil, shaderFloatControls2: VkBool32): VkPhysicalDeviceShaderFloatControls2Features =
  result = VkPhysicalDeviceShaderFloatControls2Features(
    sType: sType,
    pNext: pNext,
    shaderFloatControls2: shaderFloatControls2,
  )

proc newVkPhysicalDeviceDynamicRenderingLocalReadFeatures*(sType: VkStructureType = VkStructureType.PhysicalDeviceDynamicRenderingLocalReadFeatures, pNext: pointer = nil, dynamicRenderingLocalRead: VkBool32): VkPhysicalDeviceDynamicRenderingLocalReadFeatures =
  result = VkPhysicalDeviceDynamicRenderingLocalReadFeatures(
    sType: sType,
    pNext: pNext,
    dynamicRenderingLocalRead: dynamicRenderingLocalRead,
  )

proc newVkRenderingAttachmentLocationInfo*(sType: VkStructureType = VkStructureType.RenderingAttachmentLocationInfo, pNext: pointer = nil, colorAttachmentLocations: openarray[uint32]): VkRenderingAttachmentLocationInfo =
  result = VkRenderingAttachmentLocationInfo(
    sType: sType,
    pNext: pNext,
    colorAttachmentCount: len(colorAttachmentLocations).uint32,
    pColorAttachmentLocations: if len(colorAttachmentLocations) == 0: nil else: cast[ptr uint32](colorAttachmentLocations),
  )

proc newVkRenderingInputAttachmentIndexInfo*(sType: VkStructureType = VkStructureType.RenderingInputAttachmentIndexInfo, pNext: pointer = nil, colorAttachmentInputIndices: openarray[uint32], pDepthInputAttachmentIndex: ptr uint32, pStencilInputAttachmentIndex: ptr uint32): VkRenderingInputAttachmentIndexInfo =
  result = VkRenderingInputAttachmentIndexInfo(
    sType: sType,
    pNext: pNext,
    colorAttachmentCount: len(colorAttachmentInputIndices).uint32,
    pColorAttachmentInputIndices: if len(colorAttachmentInputIndices) == 0: nil else: cast[ptr uint32](colorAttachmentInputIndices),
    pDepthInputAttachmentIndex: pDepthInputAttachmentIndex,
    pStencilInputAttachmentIndex: pStencilInputAttachmentIndex,
  )

proc newVkPhysicalDeviceShaderQuadControlFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderQuadControlFeaturesKHR, pNext: pointer = nil, shaderQuadControl: VkBool32): VkPhysicalDeviceShaderQuadControlFeaturesKHR =
  result = VkPhysicalDeviceShaderQuadControlFeaturesKHR(
    sType: sType,
    pNext: pNext,
    shaderQuadControl: shaderQuadControl,
  )

proc newVkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV, pNext: pointer = nil, shaderFloat16VectorAtomics: VkBool32): VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV =
  result = VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(
    sType: sType,
    pNext: pNext,
    shaderFloat16VectorAtomics: shaderFloat16VectorAtomics,
  )

proc newVkPhysicalDeviceMapMemoryPlacedFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMapMemoryPlacedFeaturesEXT, pNext: pointer = nil, memoryMapPlaced: VkBool32, memoryMapRangePlaced: VkBool32, memoryUnmapReserve: VkBool32): VkPhysicalDeviceMapMemoryPlacedFeaturesEXT =
  result = VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(
    sType: sType,
    pNext: pNext,
    memoryMapPlaced: memoryMapPlaced,
    memoryMapRangePlaced: memoryMapRangePlaced,
    memoryUnmapReserve: memoryUnmapReserve,
  )

proc newVkPhysicalDeviceMapMemoryPlacedPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceMapMemoryPlacedPropertiesEXT, pNext: pointer = nil, minPlacedMemoryMapAlignment: VkDeviceSize): VkPhysicalDeviceMapMemoryPlacedPropertiesEXT =
  result = VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(
    sType: sType,
    pNext: pNext,
    minPlacedMemoryMapAlignment: minPlacedMemoryMapAlignment,
  )

proc newVkMemoryMapPlacedInfoEXT*(sType: VkStructureType = VkStructureType.MemoryMapPlacedInfoEXT, pNext: pointer = nil, pPlacedAddress: pointer = nil): VkMemoryMapPlacedInfoEXT =
  result = VkMemoryMapPlacedInfoEXT(
    sType: sType,
    pNext: pNext,
    pPlacedAddress: pPlacedAddress,
  )

proc newVkPhysicalDeviceShaderBfloat16FeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderBfloat16FeaturesKHR, pNext: pointer = nil, shaderBFloat16Type: VkBool32, shaderBFloat16DotProduct: VkBool32, shaderBFloat16CooperativeMatrix: VkBool32): VkPhysicalDeviceShaderBfloat16FeaturesKHR =
  result = VkPhysicalDeviceShaderBfloat16FeaturesKHR(
    sType: sType,
    pNext: pNext,
    shaderBFloat16Type: shaderBFloat16Type,
    shaderBFloat16DotProduct: shaderBFloat16DotProduct,
    shaderBFloat16CooperativeMatrix: shaderBFloat16CooperativeMatrix,
  )

proc newVkPhysicalDeviceRawAccessChainsFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceRawAccessChainsFeaturesNV, pNext: pointer = nil, shaderRawAccessChains: VkBool32): VkPhysicalDeviceRawAccessChainsFeaturesNV =
  result = VkPhysicalDeviceRawAccessChainsFeaturesNV(
    sType: sType,
    pNext: pNext,
    shaderRawAccessChains: shaderRawAccessChains,
  )

proc newVkPhysicalDeviceCommandBufferInheritanceFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCommandBufferInheritanceFeaturesNV, pNext: pointer = nil, commandBufferInheritance: VkBool32): VkPhysicalDeviceCommandBufferInheritanceFeaturesNV =
  result = VkPhysicalDeviceCommandBufferInheritanceFeaturesNV(
    sType: sType,
    pNext: pNext,
    commandBufferInheritance: commandBufferInheritance,
  )

proc newVkPhysicalDeviceImageAlignmentControlFeaturesMESA*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageAlignmentControlFeaturesMESA, pNext: pointer = nil, imageAlignmentControl: VkBool32): VkPhysicalDeviceImageAlignmentControlFeaturesMESA =
  result = VkPhysicalDeviceImageAlignmentControlFeaturesMESA(
    sType: sType,
    pNext: pNext,
    imageAlignmentControl: imageAlignmentControl,
  )

proc newVkPhysicalDeviceImageAlignmentControlPropertiesMESA*(sType: VkStructureType = VkStructureType.PhysicalDeviceImageAlignmentControlPropertiesMESA, pNext: pointer = nil, supportedImageAlignmentMask: uint32): VkPhysicalDeviceImageAlignmentControlPropertiesMESA =
  result = VkPhysicalDeviceImageAlignmentControlPropertiesMESA(
    sType: sType,
    pNext: pNext,
    supportedImageAlignmentMask: supportedImageAlignmentMask,
  )

proc newVkImageAlignmentControlCreateInfoMESA*(sType: VkStructureType = VkStructureType.ImageAlignmentControlCreateInfoMESA, pNext: pointer = nil, maximumRequestedAlignment: uint32): VkImageAlignmentControlCreateInfoMESA =
  result = VkImageAlignmentControlCreateInfoMESA(
    sType: sType,
    pNext: pNext,
    maximumRequestedAlignment: maximumRequestedAlignment,
  )

proc newVkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderReplicatedCompositesFeaturesEXT, pNext: pointer = nil, shaderReplicatedComposites: VkBool32): VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT =
  result = VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderReplicatedComposites: shaderReplicatedComposites,
  )

proc newVkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR, pNext: pointer = nil, presentModeFifoLatestReady: VkBool32): VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR =
  result = VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(
    sType: sType,
    pNext: pNext,
    presentModeFifoLatestReady: presentModeFifoLatestReady,
  )

proc newVkDepthClampRangeEXT*(minDepthClamp: float32, maxDepthClamp: float32): VkDepthClampRangeEXT =
  result = VkDepthClampRangeEXT(
    minDepthClamp: minDepthClamp,
    maxDepthClamp: maxDepthClamp,
  )

proc newVkPhysicalDeviceCooperativeMatrix2FeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCooperativeMatrix2FeaturesNV, pNext: pointer = nil, cooperativeMatrixWorkgroupScope: VkBool32, cooperativeMatrixFlexibleDimensions: VkBool32, cooperativeMatrixReductions: VkBool32, cooperativeMatrixConversions: VkBool32, cooperativeMatrixPerElementOperations: VkBool32, cooperativeMatrixTensorAddressing: VkBool32, cooperativeMatrixBlockLoads: VkBool32): VkPhysicalDeviceCooperativeMatrix2FeaturesNV =
  result = VkPhysicalDeviceCooperativeMatrix2FeaturesNV(
    sType: sType,
    pNext: pNext,
    cooperativeMatrixWorkgroupScope: cooperativeMatrixWorkgroupScope,
    cooperativeMatrixFlexibleDimensions: cooperativeMatrixFlexibleDimensions,
    cooperativeMatrixReductions: cooperativeMatrixReductions,
    cooperativeMatrixConversions: cooperativeMatrixConversions,
    cooperativeMatrixPerElementOperations: cooperativeMatrixPerElementOperations,
    cooperativeMatrixTensorAddressing: cooperativeMatrixTensorAddressing,
    cooperativeMatrixBlockLoads: cooperativeMatrixBlockLoads,
  )

proc newVkPhysicalDeviceCooperativeMatrix2PropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCooperativeMatrix2PropertiesNV, pNext: pointer = nil, cooperativeMatrixWorkgroupScopeMaxWorkgroupSize: uint32, cooperativeMatrixFlexibleDimensionsMaxDimension: uint32, cooperativeMatrixWorkgroupScopeReservedSharedMemory: uint32): VkPhysicalDeviceCooperativeMatrix2PropertiesNV =
  result = VkPhysicalDeviceCooperativeMatrix2PropertiesNV(
    sType: sType,
    pNext: pNext,
    cooperativeMatrixWorkgroupScopeMaxWorkgroupSize: cooperativeMatrixWorkgroupScopeMaxWorkgroupSize,
    cooperativeMatrixFlexibleDimensionsMaxDimension: cooperativeMatrixFlexibleDimensionsMaxDimension,
    cooperativeMatrixWorkgroupScopeReservedSharedMemory: cooperativeMatrixWorkgroupScopeReservedSharedMemory,
  )

proc newVkCooperativeMatrixFlexibleDimensionsPropertiesNV*(sType: VkStructureType = VkStructureType.CooperativeMatrixFlexibleDimensionsPropertiesNV, pNext: pointer = nil, MGranularity: uint32, NGranularity: uint32, KGranularity: uint32, AType: VkComponentTypeKHR, BType: VkComponentTypeKHR, CType: VkComponentTypeKHR, ResultType: VkComponentTypeKHR, saturatingAccumulation: VkBool32, scope: VkScopeKHR, workgroupInvocations: uint32): VkCooperativeMatrixFlexibleDimensionsPropertiesNV =
  result = VkCooperativeMatrixFlexibleDimensionsPropertiesNV(
    sType: sType,
    pNext: pNext,
    MGranularity: MGranularity,
    NGranularity: NGranularity,
    KGranularity: KGranularity,
    AType: AType,
    BType: BType,
    CType: CType,
    ResultType: ResultType,
    saturatingAccumulation: saturatingAccumulation,
    scope: scope,
    workgroupInvocations: workgroupInvocations,
  )

proc newVkPhysicalDeviceHdrVividFeaturesHUAWEI*(sType: VkStructureType = VkStructureType.PhysicalDeviceHdrVividFeaturesHUAWEI, pNext: pointer = nil, hdrVivid: VkBool32): VkPhysicalDeviceHdrVividFeaturesHUAWEI =
  result = VkPhysicalDeviceHdrVividFeaturesHUAWEI(
    sType: sType,
    pNext: pNext,
    hdrVivid: hdrVivid,
  )

proc newVkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceVertexAttributeRobustnessFeaturesEXT, pNext: pointer = nil, vertexAttributeRobustness: VkBool32): VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT =
  result = VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(
    sType: sType,
    pNext: pNext,
    vertexAttributeRobustness: vertexAttributeRobustness,
  )

proc newVkPhysicalDeviceDenseGeometryFormatFeaturesAMDX*(sType: VkStructureType = VkStructureType.PhysicalDeviceDenseGeometryFormatFeaturesAMDX, pNext: pointer = nil, denseGeometryFormat: VkBool32): VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX =
  result = VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX(
    sType: sType,
    pNext: pNext,
    denseGeometryFormat: denseGeometryFormat,
  )

proc newVkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX*(sType: VkStructureType = VkStructureType.AccelerationStructureDenseGeometryFormatTrianglesDataAMDX, pNext: pointer = nil, compressedData: VkDeviceOrHostAddressConstKHR, dataSize: VkDeviceSize, numTriangles: uint32, numVertices: uint32, maxPrimitiveIndex: uint32, maxGeometryIndex: uint32, format: VkCompressedTriangleFormatAMDX): VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX =
  result = VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX(
    sType: sType,
    pNext: pNext,
    compressedData: compressedData,
    dataSize: dataSize,
    numTriangles: numTriangles,
    numVertices: numVertices,
    maxPrimitiveIndex: maxPrimitiveIndex,
    maxGeometryIndex: maxGeometryIndex,
    format: format,
  )

proc newVkPhysicalDeviceDepthClampZeroOneFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceDepthClampZeroOneFeaturesKHR, pNext: pointer = nil, depthClampZeroOne: VkBool32): VkPhysicalDeviceDepthClampZeroOneFeaturesKHR =
  result = VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(
    sType: sType,
    pNext: pNext,
    depthClampZeroOne: depthClampZeroOne,
  )

proc newVkPhysicalDeviceCooperativeVectorFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCooperativeVectorFeaturesNV, pNext: pointer = nil, cooperativeVector: VkBool32, cooperativeVectorTraining: VkBool32): VkPhysicalDeviceCooperativeVectorFeaturesNV =
  result = VkPhysicalDeviceCooperativeVectorFeaturesNV(
    sType: sType,
    pNext: pNext,
    cooperativeVector: cooperativeVector,
    cooperativeVectorTraining: cooperativeVectorTraining,
  )

proc newVkCooperativeVectorPropertiesNV*(sType: VkStructureType = VkStructureType.CooperativeVectorPropertiesNV, pNext: pointer = nil, inputType: VkComponentTypeKHR, inputInterpretation: VkComponentTypeKHR, matrixInterpretation: VkComponentTypeKHR, biasInterpretation: VkComponentTypeKHR, resultType: VkComponentTypeKHR, transpose: VkBool32): VkCooperativeVectorPropertiesNV =
  result = VkCooperativeVectorPropertiesNV(
    sType: sType,
    pNext: pNext,
    inputType: inputType,
    inputInterpretation: inputInterpretation,
    matrixInterpretation: matrixInterpretation,
    biasInterpretation: biasInterpretation,
    resultType: resultType,
    transpose: transpose,
  )

proc newVkPhysicalDeviceCooperativeVectorPropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceCooperativeVectorPropertiesNV, pNext: pointer = nil, cooperativeVectorSupportedStages: VkShaderStageFlags, cooperativeVectorTrainingFloat16Accumulation: VkBool32, cooperativeVectorTrainingFloat32Accumulation: VkBool32, maxCooperativeVectorComponents: uint32): VkPhysicalDeviceCooperativeVectorPropertiesNV =
  result = VkPhysicalDeviceCooperativeVectorPropertiesNV(
    sType: sType,
    pNext: pNext,
    cooperativeVectorSupportedStages: cooperativeVectorSupportedStages,
    cooperativeVectorTrainingFloat16Accumulation: cooperativeVectorTrainingFloat16Accumulation,
    cooperativeVectorTrainingFloat32Accumulation: cooperativeVectorTrainingFloat32Accumulation,
    maxCooperativeVectorComponents: maxCooperativeVectorComponents,
  )

proc newVkConvertCooperativeVectorMatrixInfoNV*(sType: VkStructureType = VkStructureType.ConvertCooperativeVectorMatrixInfoNV, pNext: pointer = nil, srcSize: uint, srcData: VkDeviceOrHostAddressConstKHR, pDstSize: ptr uint, dstData: VkDeviceOrHostAddressKHR, srcComponentType: VkComponentTypeKHR, dstComponentType: VkComponentTypeKHR, numRows: uint32, numColumns: uint32, srcLayout: VkCooperativeVectorMatrixLayoutNV, srcStride: uint, dstLayout: VkCooperativeVectorMatrixLayoutNV, dstStride: uint): VkConvertCooperativeVectorMatrixInfoNV =
  result = VkConvertCooperativeVectorMatrixInfoNV(
    sType: sType,
    pNext: pNext,
    srcSize: srcSize,
    srcData: srcData,
    pDstSize: pDstSize,
    dstData: dstData,
    srcComponentType: srcComponentType,
    dstComponentType: dstComponentType,
    numRows: numRows,
    numColumns: numColumns,
    srcLayout: srcLayout,
    srcStride: srcStride,
    dstLayout: dstLayout,
    dstStride: dstStride,
  )

proc newVkPhysicalDeviceTileShadingFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceTileShadingFeaturesQCOM, pNext: pointer = nil, tileShading: VkBool32, tileShadingFragmentStage: VkBool32, tileShadingColorAttachments: VkBool32, tileShadingDepthAttachments: VkBool32, tileShadingStencilAttachments: VkBool32, tileShadingInputAttachments: VkBool32, tileShadingSampledAttachments: VkBool32, tileShadingPerTileDraw: VkBool32, tileShadingPerTileDispatch: VkBool32, tileShadingDispatchTile: VkBool32, tileShadingApron: VkBool32, tileShadingAnisotropicApron: VkBool32, tileShadingAtomicOps: VkBool32, tileShadingImageProcessing: VkBool32): VkPhysicalDeviceTileShadingFeaturesQCOM =
  result = VkPhysicalDeviceTileShadingFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    tileShading: tileShading,
    tileShadingFragmentStage: tileShadingFragmentStage,
    tileShadingColorAttachments: tileShadingColorAttachments,
    tileShadingDepthAttachments: tileShadingDepthAttachments,
    tileShadingStencilAttachments: tileShadingStencilAttachments,
    tileShadingInputAttachments: tileShadingInputAttachments,
    tileShadingSampledAttachments: tileShadingSampledAttachments,
    tileShadingPerTileDraw: tileShadingPerTileDraw,
    tileShadingPerTileDispatch: tileShadingPerTileDispatch,
    tileShadingDispatchTile: tileShadingDispatchTile,
    tileShadingApron: tileShadingApron,
    tileShadingAnisotropicApron: tileShadingAnisotropicApron,
    tileShadingAtomicOps: tileShadingAtomicOps,
    tileShadingImageProcessing: tileShadingImageProcessing,
  )

proc newVkPhysicalDeviceTileShadingPropertiesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceTileShadingPropertiesQCOM, pNext: pointer = nil, maxApronSize: uint32, preferNonCoherent: VkBool32, tileGranularity: VkExtent2D, maxTileShadingRate: VkExtent2D): VkPhysicalDeviceTileShadingPropertiesQCOM =
  result = VkPhysicalDeviceTileShadingPropertiesQCOM(
    sType: sType,
    pNext: pNext,
    maxApronSize: maxApronSize,
    preferNonCoherent: preferNonCoherent,
    tileGranularity: tileGranularity,
    maxTileShadingRate: maxTileShadingRate,
  )

proc newVkRenderPassTileShadingCreateInfoQCOM*(sType: VkStructureType = VkStructureType.RenderPassTileShadingCreateInfoQCOM, pNext: pointer = nil, flags: VkTileShadingRenderPassFlagsQCOM = 0.VkTileShadingRenderPassFlagsQCOM, tileApronSize: VkExtent2D): VkRenderPassTileShadingCreateInfoQCOM =
  result = VkRenderPassTileShadingCreateInfoQCOM(
    sType: sType,
    pNext: pNext,
    flags: flags,
    tileApronSize: tileApronSize,
  )

proc newVkPerTileBeginInfoQCOM*(sType: VkStructureType = VkStructureType.PerTileBeginInfoQCOM, pNext: pointer = nil): VkPerTileBeginInfoQCOM =
  result = VkPerTileBeginInfoQCOM(
    sType: sType,
    pNext: pNext,
  )

proc newVkPerTileEndInfoQCOM*(sType: VkStructureType = VkStructureType.PerTileEndInfoQCOM, pNext: pointer = nil): VkPerTileEndInfoQCOM =
  result = VkPerTileEndInfoQCOM(
    sType: sType,
    pNext: pNext,
  )

proc newVkDispatchTileInfoQCOM*(sType: VkStructureType = VkStructureType.DispatchTileInfoQCOM, pNext: pointer = nil): VkDispatchTileInfoQCOM =
  result = VkDispatchTileInfoQCOM(
    sType: sType,
    pNext: pNext,
  )

proc newVkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE, pNext: pointer = nil, maxFragmentDensityMapLayers: uint32): VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE =
  result = VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(
    sType: sType,
    pNext: pNext,
    maxFragmentDensityMapLayers: maxFragmentDensityMapLayers,
  )

proc newVkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE*(sType: VkStructureType = VkStructureType.PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE, pNext: pointer = nil, fragmentDensityMapLayered: VkBool32): VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE =
  result = VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(
    sType: sType,
    pNext: pNext,
    fragmentDensityMapLayered: fragmentDensityMapLayered,
  )

proc newVkPipelineFragmentDensityMapLayeredCreateInfoVALVE*(sType: VkStructureType = VkStructureType.PipelineFragmentDensityMapLayeredCreateInfoVALVE, pNext: pointer = nil, maxFragmentDensityMapLayers: uint32): VkPipelineFragmentDensityMapLayeredCreateInfoVALVE =
  result = VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(
    sType: sType,
    pNext: pNext,
    maxFragmentDensityMapLayers: maxFragmentDensityMapLayers,
  )

proc newVkSetPresentConfigNV*(sType: VkStructureType = VkStructureType.SetPresentConfigNV, pNext: pointer = nil, numFramesPerBatch: uint32, presentConfigFeedback: uint32): VkSetPresentConfigNV =
  result = VkSetPresentConfigNV(
    sType: sType,
    pNext: pNext,
    numFramesPerBatch: numFramesPerBatch,
    presentConfigFeedback: presentConfigFeedback,
  )

proc newVkPhysicalDevicePresentMeteringFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDevicePresentMeteringFeaturesNV, pNext: pointer = nil, presentMetering: VkBool32): VkPhysicalDevicePresentMeteringFeaturesNV =
  result = VkPhysicalDevicePresentMeteringFeaturesNV(
    sType: sType,
    pNext: pNext,
    presentMetering: presentMetering,
  )

proc newVkExternalComputeQueueDeviceCreateInfoNV*(sType: VkStructureType = VkStructureType.ExternalComputeQueueDeviceCreateInfoNV, pNext: pointer = nil, reservedExternalQueues: uint32): VkExternalComputeQueueDeviceCreateInfoNV =
  result = VkExternalComputeQueueDeviceCreateInfoNV(
    sType: sType,
    pNext: pNext,
    reservedExternalQueues: reservedExternalQueues,
  )

proc newVkExternalComputeQueueCreateInfoNV*(sType: VkStructureType = VkStructureType.ExternalComputeQueueCreateInfoNV, pNext: pointer = nil, preferredQueue: VkQueue): VkExternalComputeQueueCreateInfoNV =
  result = VkExternalComputeQueueCreateInfoNV(
    sType: sType,
    pNext: pNext,
    preferredQueue: preferredQueue,
  )

proc newVkExternalComputeQueueDataParamsNV*(sType: VkStructureType = VkStructureType.ExternalComputeQueueDataParamsNV, pNext: pointer = nil, deviceIndex: uint32): VkExternalComputeQueueDataParamsNV =
  result = VkExternalComputeQueueDataParamsNV(
    sType: sType,
    pNext: pNext,
    deviceIndex: deviceIndex,
  )

proc newVkPhysicalDeviceExternalComputeQueuePropertiesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalComputeQueuePropertiesNV, pNext: pointer = nil, externalDataSize: uint32, maxExternalQueues: uint32): VkPhysicalDeviceExternalComputeQueuePropertiesNV =
  result = VkPhysicalDeviceExternalComputeQueuePropertiesNV(
    sType: sType,
    pNext: pNext,
    externalDataSize: externalDataSize,
    maxExternalQueues: maxExternalQueues,
  )

proc newVkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT, pNext: pointer = nil, shaderUniformBufferUnsizedArray: VkBool32): VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT =
  result = VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderUniformBufferUnsizedArray: shaderUniformBufferUnsizedArray,
  )

proc newVkPhysicalDeviceShaderMixedFloatDotProductFeaturesVALVE*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderMixedFloatDotProductFeaturesVALVE, pNext: pointer = nil, shaderMixedFloatDotProductFloat16AccFloat32: VkBool32, shaderMixedFloatDotProductFloat16AccFloat16: VkBool32, shaderMixedFloatDotProductBFloat16Acc: VkBool32, shaderMixedFloatDotProductFloat8AccFloat32: VkBool32): VkPhysicalDeviceShaderMixedFloatDotProductFeaturesVALVE =
  result = VkPhysicalDeviceShaderMixedFloatDotProductFeaturesVALVE(
    sType: sType,
    pNext: pNext,
    shaderMixedFloatDotProductFloat16AccFloat32: shaderMixedFloatDotProductFloat16AccFloat32,
    shaderMixedFloatDotProductFloat16AccFloat16: shaderMixedFloatDotProductFloat16AccFloat16,
    shaderMixedFloatDotProductBFloat16Acc: shaderMixedFloatDotProductBFloat16Acc,
    shaderMixedFloatDotProductFloat8AccFloat32: shaderMixedFloatDotProductFloat8AccFloat32,
  )

proc newVkPhysicalDeviceFormatPackFeaturesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceFormatPackFeaturesARM, pNext: pointer = nil, formatPack: VkBool32): VkPhysicalDeviceFormatPackFeaturesARM =
  result = VkPhysicalDeviceFormatPackFeaturesARM(
    sType: sType,
    pNext: pNext,
    formatPack: formatPack,
  )

proc newVkTensorDescriptionARM*(sType: VkStructureType = VkStructureType.TensorDescriptionARM, pNext: pointer = nil, tiling: VkTensorTilingARM, format: VkFormat, dimensions: openarray[int64], strides: openarray[int64], usage: VkTensorUsageFlagsARM): VkTensorDescriptionARM =
  result = VkTensorDescriptionARM(
    sType: sType,
    pNext: pNext,
    tiling: tiling,
    format: format,
    dimensionCount: len(dimensions).uint32,
    pDimensions: if len(dimensions) == 0: nil else: cast[ptr int64](dimensions),
    pStrides: if len(strides) == 0: nil else: cast[ptr int64](strides),
    usage: usage,
  )

proc newVkTensorCreateInfoARM*(sType: VkStructureType = VkStructureType.TensorCreateInfoARM, pNext: pointer = nil, flags: VkTensorCreateFlagsARM = 0.VkTensorCreateFlagsARM, pDescription: ptr VkTensorDescriptionARM, sharingMode: VkSharingMode, queueFamilyIndices: openarray[uint32]): VkTensorCreateInfoARM =
  result = VkTensorCreateInfoARM(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pDescription: pDescription,
    sharingMode: sharingMode,
    queueFamilyIndexCount: len(queueFamilyIndices).uint32,
    pQueueFamilyIndices: if len(queueFamilyIndices) == 0: nil else: cast[ptr uint32](queueFamilyIndices),
  )

proc newVkTensorViewCreateInfoARM*(sType: VkStructureType = VkStructureType.TensorViewCreateInfoARM, pNext: pointer = nil, flags: VkTensorViewCreateFlagsARM = 0.VkTensorViewCreateFlagsARM, tensor: VkTensorARM, format: VkFormat): VkTensorViewCreateInfoARM =
  result = VkTensorViewCreateInfoARM(
    sType: sType,
    pNext: pNext,
    flags: flags,
    tensor: tensor,
    format: format,
  )

proc newVkTensorMemoryRequirementsInfoARM*(sType: VkStructureType = VkStructureType.TensorMemoryRequirementsInfoARM, pNext: pointer = nil, tensor: VkTensorARM): VkTensorMemoryRequirementsInfoARM =
  result = VkTensorMemoryRequirementsInfoARM(
    sType: sType,
    pNext: pNext,
    tensor: tensor,
  )

proc newVkBindTensorMemoryInfoARM*(sType: VkStructureType = VkStructureType.BindTensorMemoryInfoARM, pNext: pointer = nil, tensor: VkTensorARM, memory: VkDeviceMemory, memoryOffset: VkDeviceSize): VkBindTensorMemoryInfoARM =
  result = VkBindTensorMemoryInfoARM(
    sType: sType,
    pNext: pNext,
    tensor: tensor,
    memory: memory,
    memoryOffset: memoryOffset,
  )

proc newVkWriteDescriptorSetTensorARM*(sType: VkStructureType = VkStructureType.WriteDescriptorSetTensorARM, pNext: pointer = nil, tensorViews: openarray[VkTensorViewARM]): VkWriteDescriptorSetTensorARM =
  result = VkWriteDescriptorSetTensorARM(
    sType: sType,
    pNext: pNext,
    tensorViewCount: len(tensorViews).uint32,
    pTensorViews: if len(tensorViews) == 0: nil else: cast[ptr VkTensorViewARM](tensorViews),
  )

proc newVkTensorFormatPropertiesARM*(sType: VkStructureType = VkStructureType.TensorFormatPropertiesARM, pNext: pointer = nil, optimalTilingTensorFeatures: VkFormatFeatureFlags2, linearTilingTensorFeatures: VkFormatFeatureFlags2): VkTensorFormatPropertiesARM =
  result = VkTensorFormatPropertiesARM(
    sType: sType,
    pNext: pNext,
    optimalTilingTensorFeatures: optimalTilingTensorFeatures,
    linearTilingTensorFeatures: linearTilingTensorFeatures,
  )

proc newVkPhysicalDeviceTensorPropertiesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceTensorPropertiesARM, pNext: pointer = nil, maxTensorDimensionCount: uint32, maxTensorElements: uint64, maxPerDimensionTensorElements: uint64, maxTensorStride: int64, maxTensorSize: uint64, maxTensorShaderAccessArrayLength: uint32, maxTensorShaderAccessSize: uint32, maxDescriptorSetStorageTensors: uint32, maxPerStageDescriptorSetStorageTensors: uint32, maxDescriptorSetUpdateAfterBindStorageTensors: uint32, maxPerStageDescriptorUpdateAfterBindStorageTensors: uint32, shaderStorageTensorArrayNonUniformIndexingNative: VkBool32, shaderTensorSupportedStages: VkShaderStageFlags): VkPhysicalDeviceTensorPropertiesARM =
  result = VkPhysicalDeviceTensorPropertiesARM(
    sType: sType,
    pNext: pNext,
    maxTensorDimensionCount: maxTensorDimensionCount,
    maxTensorElements: maxTensorElements,
    maxPerDimensionTensorElements: maxPerDimensionTensorElements,
    maxTensorStride: maxTensorStride,
    maxTensorSize: maxTensorSize,
    maxTensorShaderAccessArrayLength: maxTensorShaderAccessArrayLength,
    maxTensorShaderAccessSize: maxTensorShaderAccessSize,
    maxDescriptorSetStorageTensors: maxDescriptorSetStorageTensors,
    maxPerStageDescriptorSetStorageTensors: maxPerStageDescriptorSetStorageTensors,
    maxDescriptorSetUpdateAfterBindStorageTensors: maxDescriptorSetUpdateAfterBindStorageTensors,
    maxPerStageDescriptorUpdateAfterBindStorageTensors: maxPerStageDescriptorUpdateAfterBindStorageTensors,
    shaderStorageTensorArrayNonUniformIndexingNative: shaderStorageTensorArrayNonUniformIndexingNative,
    shaderTensorSupportedStages: shaderTensorSupportedStages,
  )

proc newVkTensorMemoryBarrierARM*(sType: VkStructureType = VkStructureType.TensorMemoryBarrierARM, pNext: pointer = nil, srcStageMask: VkPipelineStageFlags2, srcAccessMask: VkAccessFlags2, dstStageMask: VkPipelineStageFlags2, dstAccessMask: VkAccessFlags2, srcQueueFamilyIndex: uint32, dstQueueFamilyIndex: uint32, tensor: VkTensorARM): VkTensorMemoryBarrierARM =
  result = VkTensorMemoryBarrierARM(
    sType: sType,
    pNext: pNext,
    srcStageMask: srcStageMask,
    srcAccessMask: srcAccessMask,
    dstStageMask: dstStageMask,
    dstAccessMask: dstAccessMask,
    srcQueueFamilyIndex: srcQueueFamilyIndex,
    dstQueueFamilyIndex: dstQueueFamilyIndex,
    tensor: tensor,
  )

proc newVkTensorDependencyInfoARM*(sType: VkStructureType = VkStructureType.TensorDependencyInfoARM, pNext: pointer = nil, tensorMemoryBarriers: openarray[VkTensorMemoryBarrierARM]): VkTensorDependencyInfoARM =
  result = VkTensorDependencyInfoARM(
    sType: sType,
    pNext: pNext,
    tensorMemoryBarrierCount: len(tensorMemoryBarriers).uint32,
    pTensorMemoryBarriers: if len(tensorMemoryBarriers) == 0: nil else: cast[ptr VkTensorMemoryBarrierARM](tensorMemoryBarriers),
  )

proc newVkPhysicalDeviceTensorFeaturesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceTensorFeaturesARM, pNext: pointer = nil, tensorNonPacked: VkBool32, shaderTensorAccess: VkBool32, shaderStorageTensorArrayDynamicIndexing: VkBool32, shaderStorageTensorArrayNonUniformIndexing: VkBool32, descriptorBindingStorageTensorUpdateAfterBind: VkBool32, tensors: VkBool32): VkPhysicalDeviceTensorFeaturesARM =
  result = VkPhysicalDeviceTensorFeaturesARM(
    sType: sType,
    pNext: pNext,
    tensorNonPacked: tensorNonPacked,
    shaderTensorAccess: shaderTensorAccess,
    shaderStorageTensorArrayDynamicIndexing: shaderStorageTensorArrayDynamicIndexing,
    shaderStorageTensorArrayNonUniformIndexing: shaderStorageTensorArrayNonUniformIndexing,
    descriptorBindingStorageTensorUpdateAfterBind: descriptorBindingStorageTensorUpdateAfterBind,
    tensors: tensors,
  )

proc newVkDeviceTensorMemoryRequirementsARM*(sType: VkStructureType = VkStructureType.DeviceTensorMemoryRequirementsARM, pNext: pointer = nil, pCreateInfo: ptr VkTensorCreateInfoARM): VkDeviceTensorMemoryRequirementsARM =
  result = VkDeviceTensorMemoryRequirementsARM(
    sType: sType,
    pNext: pNext,
    pCreateInfo: pCreateInfo,
  )

proc newVkCopyTensorInfoARM*(sType: VkStructureType = VkStructureType.CopyTensorInfoARM, pNext: pointer = nil, srcTensor: VkTensorARM, dstTensor: VkTensorARM, regions: openarray[VkTensorCopyARM]): VkCopyTensorInfoARM =
  result = VkCopyTensorInfoARM(
    sType: sType,
    pNext: pNext,
    srcTensor: srcTensor,
    dstTensor: dstTensor,
    regionCount: len(regions).uint32,
    pRegions: if len(regions) == 0: nil else: cast[ptr VkTensorCopyARM](regions),
  )

proc newVkTensorCopyARM*(sType: VkStructureType = VkStructureType.TensorCopyARM, pNext: pointer = nil, dimensionCount: uint32, pSrcOffset: ptr uint64, pDstOffset: ptr uint64, pExtent: ptr uint64): VkTensorCopyARM =
  result = VkTensorCopyARM(
    sType: sType,
    pNext: pNext,
    dimensionCount: dimensionCount,
    pSrcOffset: pSrcOffset,
    pDstOffset: pDstOffset,
    pExtent: pExtent,
  )

proc newVkMemoryDedicatedAllocateInfoTensorARM*(sType: VkStructureType = VkStructureType.MemoryDedicatedAllocateInfoTensorARM, pNext: pointer = nil, tensor: VkTensorARM): VkMemoryDedicatedAllocateInfoTensorARM =
  result = VkMemoryDedicatedAllocateInfoTensorARM(
    sType: sType,
    pNext: pNext,
    tensor: tensor,
  )

proc newVkPhysicalDeviceDescriptorBufferTensorPropertiesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorBufferTensorPropertiesARM, pNext: pointer = nil, tensorCaptureReplayDescriptorDataSize: uint, tensorViewCaptureReplayDescriptorDataSize: uint, tensorDescriptorSize: uint): VkPhysicalDeviceDescriptorBufferTensorPropertiesARM =
  result = VkPhysicalDeviceDescriptorBufferTensorPropertiesARM(
    sType: sType,
    pNext: pNext,
    tensorCaptureReplayDescriptorDataSize: tensorCaptureReplayDescriptorDataSize,
    tensorViewCaptureReplayDescriptorDataSize: tensorViewCaptureReplayDescriptorDataSize,
    tensorDescriptorSize: tensorDescriptorSize,
  )

proc newVkPhysicalDeviceDescriptorBufferTensorFeaturesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorBufferTensorFeaturesARM, pNext: pointer = nil, descriptorBufferTensorDescriptors: VkBool32): VkPhysicalDeviceDescriptorBufferTensorFeaturesARM =
  result = VkPhysicalDeviceDescriptorBufferTensorFeaturesARM(
    sType: sType,
    pNext: pNext,
    descriptorBufferTensorDescriptors: descriptorBufferTensorDescriptors,
  )

proc newVkTensorCaptureDescriptorDataInfoARM*(sType: VkStructureType = VkStructureType.TensorCaptureDescriptorDataInfoARM, pNext: pointer = nil, tensor: VkTensorARM): VkTensorCaptureDescriptorDataInfoARM =
  result = VkTensorCaptureDescriptorDataInfoARM(
    sType: sType,
    pNext: pNext,
    tensor: tensor,
  )

proc newVkTensorViewCaptureDescriptorDataInfoARM*(sType: VkStructureType = VkStructureType.TensorViewCaptureDescriptorDataInfoARM, pNext: pointer = nil, tensorView: VkTensorViewARM): VkTensorViewCaptureDescriptorDataInfoARM =
  result = VkTensorViewCaptureDescriptorDataInfoARM(
    sType: sType,
    pNext: pNext,
    tensorView: tensorView,
  )

proc newVkDescriptorGetTensorInfoARM*(sType: VkStructureType = VkStructureType.DescriptorGetTensorInfoARM, pNext: pointer = nil, tensorView: VkTensorViewARM): VkDescriptorGetTensorInfoARM =
  result = VkDescriptorGetTensorInfoARM(
    sType: sType,
    pNext: pNext,
    tensorView: tensorView,
  )

proc newVkFrameBoundaryTensorsARM*(sType: VkStructureType = VkStructureType.FrameBoundaryTensorsARM, pNext: pointer = nil, tensors: openarray[VkTensorARM]): VkFrameBoundaryTensorsARM =
  result = VkFrameBoundaryTensorsARM(
    sType: sType,
    pNext: pNext,
    tensorCount: len(tensors).uint32,
    pTensors: if len(tensors) == 0: nil else: cast[ptr VkTensorARM](tensors),
  )

proc newVkPhysicalDeviceExternalTensorInfoARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceExternalTensorInfoARM, pNext: pointer = nil, flags: VkTensorCreateFlagsARM = 0.VkTensorCreateFlagsARM, pDescription: ptr VkTensorDescriptionARM, handleType: VkExternalMemoryHandleTypeFlagBits): VkPhysicalDeviceExternalTensorInfoARM =
  result = VkPhysicalDeviceExternalTensorInfoARM(
    sType: sType,
    pNext: pNext,
    flags: flags,
    pDescription: pDescription,
    handleType: handleType,
  )

proc newVkExternalTensorPropertiesARM*(sType: VkStructureType = VkStructureType.ExternalTensorPropertiesARM, pNext: pointer = nil, externalMemoryProperties: VkExternalMemoryProperties): VkExternalTensorPropertiesARM =
  result = VkExternalTensorPropertiesARM(
    sType: sType,
    pNext: pNext,
    externalMemoryProperties: externalMemoryProperties,
  )

proc newVkExternalMemoryTensorCreateInfoARM*(sType: VkStructureType = VkStructureType.ExternalMemoryTensorCreateInfoARM, pNext: pointer = nil, handleTypes: VkExternalMemoryHandleTypeFlags): VkExternalMemoryTensorCreateInfoARM =
  result = VkExternalMemoryTensorCreateInfoARM(
    sType: sType,
    pNext: pNext,
    handleTypes: handleTypes,
  )

proc newVkPhysicalDeviceShaderFloat8FeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderFloat8FeaturesEXT, pNext: pointer = nil, shaderFloat8: VkBool32, shaderFloat8CooperativeMatrix: VkBool32): VkPhysicalDeviceShaderFloat8FeaturesEXT =
  result = VkPhysicalDeviceShaderFloat8FeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderFloat8: shaderFloat8,
    shaderFloat8CooperativeMatrix: shaderFloat8CooperativeMatrix,
  )

proc newVkSurfaceCreateInfoOHOS*(sType: VkStructureType = VkStructureType.SurfaceCreateInfoOHOS, pNext: pointer = nil, flags: VkSurfaceCreateFlagsOHOS = 0.VkSurfaceCreateFlagsOHOS, window: ptr OHNativeWindow): VkSurfaceCreateInfoOHOS =
  result = VkSurfaceCreateInfoOHOS(
    sType: sType,
    pNext: pNext,
    flags: flags,
    window: window,
  )

proc newVkPhysicalDeviceDataGraphFeaturesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceDataGraphFeaturesARM, pNext: pointer = nil, dataGraph: VkBool32, dataGraphUpdateAfterBind: VkBool32, dataGraphSpecializationConstants: VkBool32, dataGraphDescriptorBuffer: VkBool32, dataGraphShaderModule: VkBool32): VkPhysicalDeviceDataGraphFeaturesARM =
  result = VkPhysicalDeviceDataGraphFeaturesARM(
    sType: sType,
    pNext: pNext,
    dataGraph: dataGraph,
    dataGraphUpdateAfterBind: dataGraphUpdateAfterBind,
    dataGraphSpecializationConstants: dataGraphSpecializationConstants,
    dataGraphDescriptorBuffer: dataGraphDescriptorBuffer,
    dataGraphShaderModule: dataGraphShaderModule,
  )

proc newVkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM, pNext: pointer = nil, dimension: uint32, zeroCount: uint32, groupSize: uint32): VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM =
  result = VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM(
    sType: sType,
    pNext: pNext,
    dimension: dimension,
    zeroCount: zeroCount,
    groupSize: groupSize,
  )

proc newVkDataGraphPipelineConstantARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineConstantARM, pNext: pointer = nil, id: uint32, pConstantData: pointer = nil): VkDataGraphPipelineConstantARM =
  result = VkDataGraphPipelineConstantARM(
    sType: sType,
    pNext: pNext,
    id: id,
    pConstantData: pConstantData,
  )

proc newVkDataGraphPipelineResourceInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineResourceInfoARM, pNext: pointer = nil, descriptorSet: uint32, binding: uint32, arrayElement: uint32): VkDataGraphPipelineResourceInfoARM =
  result = VkDataGraphPipelineResourceInfoARM(
    sType: sType,
    pNext: pNext,
    descriptorSet: descriptorSet,
    binding: binding,
    arrayElement: arrayElement,
  )

proc newVkDataGraphPipelineCompilerControlCreateInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineCompilerControlCreateInfoARM, pNext: pointer = nil, pVendorOptions: cstring): VkDataGraphPipelineCompilerControlCreateInfoARM =
  result = VkDataGraphPipelineCompilerControlCreateInfoARM(
    sType: sType,
    pNext: pNext,
    pVendorOptions: pVendorOptions,
  )

proc newVkDataGraphPipelineCreateInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineCreateInfoARM, pNext: pointer = nil, flags: VkPipelineCreateFlags2KHR = 0.VkPipelineCreateFlags2KHR, layout: VkPipelineLayout, resourceInfos: openarray[VkDataGraphPipelineResourceInfoARM]): VkDataGraphPipelineCreateInfoARM =
  result = VkDataGraphPipelineCreateInfoARM(
    sType: sType,
    pNext: pNext,
    flags: flags,
    layout: layout,
    resourceInfoCount: len(resourceInfos).uint32,
    pResourceInfos: if len(resourceInfos) == 0: nil else: cast[ptr VkDataGraphPipelineResourceInfoARM](resourceInfos),
  )

proc newVkDataGraphPipelineShaderModuleCreateInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineShaderModuleCreateInfoARM, pNext: pointer = nil, module: VkShaderModule, pName: cstring, pSpecializationInfo: ptr VkSpecializationInfo, constants: openarray[VkDataGraphPipelineConstantARM]): VkDataGraphPipelineShaderModuleCreateInfoARM =
  result = VkDataGraphPipelineShaderModuleCreateInfoARM(
    sType: sType,
    pNext: pNext,
    module: module,
    pName: pName,
    pSpecializationInfo: pSpecializationInfo,
    constantCount: len(constants).uint32,
    pConstants: if len(constants) == 0: nil else: cast[ptr VkDataGraphPipelineConstantARM](constants),
  )

proc newVkDataGraphPipelineSessionCreateInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineSessionCreateInfoARM, pNext: pointer = nil, flags: VkDataGraphPipelineSessionCreateFlagsARM = 0.VkDataGraphPipelineSessionCreateFlagsARM, dataGraphPipeline: VkPipeline): VkDataGraphPipelineSessionCreateInfoARM =
  result = VkDataGraphPipelineSessionCreateInfoARM(
    sType: sType,
    pNext: pNext,
    flags: flags,
    dataGraphPipeline: dataGraphPipeline,
  )

proc newVkDataGraphPipelineSessionBindPointRequirementsInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineSessionBindPointRequirementsInfoARM, pNext: pointer = nil, session: VkDataGraphPipelineSessionARM): VkDataGraphPipelineSessionBindPointRequirementsInfoARM =
  result = VkDataGraphPipelineSessionBindPointRequirementsInfoARM(
    sType: sType,
    pNext: pNext,
    session: session,
  )

proc newVkDataGraphPipelineSessionBindPointRequirementARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineSessionBindPointRequirementARM, pNext: pointer = nil, bindPoint: VkDataGraphPipelineSessionBindPointARM, bindPointType: VkDataGraphPipelineSessionBindPointTypeARM, numObjects: uint32): VkDataGraphPipelineSessionBindPointRequirementARM =
  result = VkDataGraphPipelineSessionBindPointRequirementARM(
    sType: sType,
    pNext: pNext,
    bindPoint: bindPoint,
    bindPointType: bindPointType,
    numObjects: numObjects,
  )

proc newVkDataGraphPipelineSessionMemoryRequirementsInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineSessionMemoryRequirementsInfoARM, pNext: pointer = nil, session: VkDataGraphPipelineSessionARM, bindPoint: VkDataGraphPipelineSessionBindPointARM, objectIndex: uint32): VkDataGraphPipelineSessionMemoryRequirementsInfoARM =
  result = VkDataGraphPipelineSessionMemoryRequirementsInfoARM(
    sType: sType,
    pNext: pNext,
    session: session,
    bindPoint: bindPoint,
    objectIndex: objectIndex,
  )

proc newVkBindDataGraphPipelineSessionMemoryInfoARM*(sType: VkStructureType = VkStructureType.BindDataGraphPipelineSessionMemoryInfoARM, pNext: pointer = nil, session: VkDataGraphPipelineSessionARM, bindPoint: VkDataGraphPipelineSessionBindPointARM, objectIndex: uint32, memory: VkDeviceMemory, memoryOffset: VkDeviceSize): VkBindDataGraphPipelineSessionMemoryInfoARM =
  result = VkBindDataGraphPipelineSessionMemoryInfoARM(
    sType: sType,
    pNext: pNext,
    session: session,
    bindPoint: bindPoint,
    objectIndex: objectIndex,
    memory: memory,
    memoryOffset: memoryOffset,
  )

proc newVkDataGraphPipelineInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineInfoARM, pNext: pointer = nil, dataGraphPipeline: VkPipeline): VkDataGraphPipelineInfoARM =
  result = VkDataGraphPipelineInfoARM(
    sType: sType,
    pNext: pNext,
    dataGraphPipeline: dataGraphPipeline,
  )

proc newVkDataGraphPipelinePropertyQueryResultARM*(sType: VkStructureType = VkStructureType.DataGraphPipelinePropertyQueryResultARM, pNext: pointer = nil, property: VkDataGraphPipelinePropertyARM, isText: VkBool32, dataSize: uint, pData: pointer = nil): VkDataGraphPipelinePropertyQueryResultARM =
  result = VkDataGraphPipelinePropertyQueryResultARM(
    sType: sType,
    pNext: pNext,
    property: property,
    isText: isText,
    dataSize: dataSize,
    pData: pData,
  )

proc newVkDataGraphPipelineIdentifierCreateInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineIdentifierCreateInfoARM, pNext: pointer = nil, identifierSize: uint32, pIdentifier: ptr uint8): VkDataGraphPipelineIdentifierCreateInfoARM =
  result = VkDataGraphPipelineIdentifierCreateInfoARM(
    sType: sType,
    pNext: pNext,
    identifierSize: identifierSize,
    pIdentifier: pIdentifier,
  )

proc newVkDataGraphPipelineDispatchInfoARM*(sType: VkStructureType = VkStructureType.DataGraphPipelineDispatchInfoARM, pNext: pointer = nil, flags: VkDataGraphPipelineDispatchFlagsARM = 0.VkDataGraphPipelineDispatchFlagsARM): VkDataGraphPipelineDispatchInfoARM =
  result = VkDataGraphPipelineDispatchInfoARM(
    sType: sType,
    pNext: pNext,
    flags: flags,
  )

proc newVkPhysicalDeviceDataGraphProcessingEngineARM*(`type`: VkPhysicalDeviceDataGraphProcessingEngineTypeARM, isForeign: VkBool32): VkPhysicalDeviceDataGraphProcessingEngineARM =
  result = VkPhysicalDeviceDataGraphProcessingEngineARM(
    `type`: `type`,
    isForeign: isForeign,
  )

proc newVkPhysicalDeviceDataGraphOperationSupportARM*(operationType: VkPhysicalDeviceDataGraphOperationTypeARM, name: array[VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM, char], version: uint32): VkPhysicalDeviceDataGraphOperationSupportARM =
  result = VkPhysicalDeviceDataGraphOperationSupportARM(
    operationType: operationType,
    name: name,
    version: version,
  )

proc newVkQueueFamilyDataGraphPropertiesARM*(sType: VkStructureType = VkStructureType.QueueFamilyDataGraphPropertiesARM, pNext: pointer = nil, engine: VkPhysicalDeviceDataGraphProcessingEngineARM, operation: VkPhysicalDeviceDataGraphOperationSupportARM): VkQueueFamilyDataGraphPropertiesARM =
  result = VkQueueFamilyDataGraphPropertiesARM(
    sType: sType,
    pNext: pNext,
    engine: engine,
    operation: operation,
  )

proc newVkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, pNext: pointer = nil, queueFamilyIndex: uint32, engineType: VkPhysicalDeviceDataGraphProcessingEngineTypeARM): VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM =
  result = VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM(
    sType: sType,
    pNext: pNext,
    queueFamilyIndex: queueFamilyIndex,
    engineType: engineType,
  )

proc newVkQueueFamilyDataGraphProcessingEnginePropertiesARM*(sType: VkStructureType = VkStructureType.QueueFamilyDataGraphProcessingEnginePropertiesARM, pNext: pointer = nil, foreignSemaphoreHandleTypes: VkExternalSemaphoreHandleTypeFlags, foreignMemoryHandleTypes: VkExternalMemoryHandleTypeFlags): VkQueueFamilyDataGraphProcessingEnginePropertiesARM =
  result = VkQueueFamilyDataGraphProcessingEnginePropertiesARM(
    sType: sType,
    pNext: pNext,
    foreignSemaphoreHandleTypes: foreignSemaphoreHandleTypes,
    foreignMemoryHandleTypes: foreignMemoryHandleTypes,
  )

proc newVkDataGraphProcessingEngineCreateInfoARM*(sType: VkStructureType = VkStructureType.DataGraphProcessingEngineCreateInfoARM, pNext: pointer = nil, processingEngines: openarray[VkPhysicalDeviceDataGraphProcessingEngineARM]): VkDataGraphProcessingEngineCreateInfoARM =
  result = VkDataGraphProcessingEngineCreateInfoARM(
    sType: sType,
    pNext: pNext,
    processingEngineCount: len(processingEngines).uint32,
    pProcessingEngines: if len(processingEngines) == 0: nil else: cast[ptr VkPhysicalDeviceDataGraphProcessingEngineARM](processingEngines),
  )

proc newVkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC*(sType: VkStructureType = VkStructureType.PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC, pNext: pointer = nil, pipelineCacheIncrementalMode: VkBool32): VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC =
  result = VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC(
    sType: sType,
    pNext: pNext,
    pipelineCacheIncrementalMode: pipelineCacheIncrementalMode,
  )

proc newVkDataGraphPipelineBuiltinModelCreateInfoQCOM*(sType: VkStructureType = VkStructureType.DataGraphPipelineBuiltinModelCreateInfoQCOM, pNext: pointer = nil, pOperation: ptr VkPhysicalDeviceDataGraphOperationSupportARM): VkDataGraphPipelineBuiltinModelCreateInfoQCOM =
  result = VkDataGraphPipelineBuiltinModelCreateInfoQCOM(
    sType: sType,
    pNext: pNext,
    pOperation: pOperation,
  )

proc newVkPhysicalDeviceDataGraphModelFeaturesQCOM*(sType: VkStructureType = VkStructureType.PhysicalDeviceDataGraphModelFeaturesQCOM, pNext: pointer = nil, dataGraphModel: VkBool32): VkPhysicalDeviceDataGraphModelFeaturesQCOM =
  result = VkPhysicalDeviceDataGraphModelFeaturesQCOM(
    sType: sType,
    pNext: pNext,
    dataGraphModel: dataGraphModel,
  )

proc newVkPhysicalDeviceShaderUntypedPointersFeaturesKHR*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderUntypedPointersFeaturesKHR, pNext: pointer = nil, shaderUntypedPointers: VkBool32): VkPhysicalDeviceShaderUntypedPointersFeaturesKHR =
  result = VkPhysicalDeviceShaderUntypedPointersFeaturesKHR(
    sType: sType,
    pNext: pNext,
    shaderUntypedPointers: shaderUntypedPointers,
  )

proc newVkNativeBufferOHOS*(sType: VkStructureType, pNext: pointer = nil, handle: ptr OHBufferHandle): VkNativeBufferOHOS =
  result = VkNativeBufferOHOS(
    sType: sType,
    pNext: pNext,
    handle: handle,
  )

proc newVkSwapchainImageCreateInfoOHOS*(sType: VkStructureType, pNext: pointer = nil, usage: VkSwapchainImageUsageFlagsOHOS): VkSwapchainImageCreateInfoOHOS =
  result = VkSwapchainImageCreateInfoOHOS(
    sType: sType,
    pNext: pNext,
    usage: usage,
  )

proc newVkPhysicalDevicePresentationPropertiesOHOS*(sType: VkStructureType, pNext: pointer = nil, sharedImage: VkBool32): VkPhysicalDevicePresentationPropertiesOHOS =
  result = VkPhysicalDevicePresentationPropertiesOHOS(
    sType: sType,
    pNext: pNext,
    sharedImage: sharedImage,
  )

proc newVkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE*(sType: VkStructureType = VkStructureType.PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE, pNext: pointer = nil, videoEncodeRgbConversion: VkBool32): VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE =
  result = VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE(
    sType: sType,
    pNext: pNext,
    videoEncodeRgbConversion: videoEncodeRgbConversion,
  )

proc newVkVideoEncodeRgbConversionCapabilitiesVALVE*(sType: VkStructureType = VkStructureType.VideoEncodeRgbConversionCapabilitiesVALVE, pNext: pointer = nil, rgbModels: VkVideoEncodeRgbModelConversionFlagsVALVE, rgbRanges: VkVideoEncodeRgbRangeCompressionFlagsVALVE, xChromaOffsets: VkVideoEncodeRgbChromaOffsetFlagsVALVE, yChromaOffsets: VkVideoEncodeRgbChromaOffsetFlagsVALVE): VkVideoEncodeRgbConversionCapabilitiesVALVE =
  result = VkVideoEncodeRgbConversionCapabilitiesVALVE(
    sType: sType,
    pNext: pNext,
    rgbModels: rgbModels,
    rgbRanges: rgbRanges,
    xChromaOffsets: xChromaOffsets,
    yChromaOffsets: yChromaOffsets,
  )

proc newVkVideoEncodeProfileRgbConversionInfoVALVE*(sType: VkStructureType = VkStructureType.VideoEncodeProfileRgbConversionInfoVALVE, pNext: pointer = nil, performEncodeRgbConversion: VkBool32): VkVideoEncodeProfileRgbConversionInfoVALVE =
  result = VkVideoEncodeProfileRgbConversionInfoVALVE(
    sType: sType,
    pNext: pNext,
    performEncodeRgbConversion: performEncodeRgbConversion,
  )

proc newVkVideoEncodeSessionRgbConversionCreateInfoVALVE*(sType: VkStructureType = VkStructureType.VideoEncodeSessionRgbConversionCreateInfoVALVE, pNext: pointer = nil, rgbModel: VkVideoEncodeRgbModelConversionFlagBitsVALVE, rgbRange: VkVideoEncodeRgbRangeCompressionFlagBitsVALVE, xChromaOffset: VkVideoEncodeRgbChromaOffsetFlagBitsVALVE, yChromaOffset: VkVideoEncodeRgbChromaOffsetFlagBitsVALVE): VkVideoEncodeSessionRgbConversionCreateInfoVALVE =
  result = VkVideoEncodeSessionRgbConversionCreateInfoVALVE(
    sType: sType,
    pNext: pNext,
    rgbModel: rgbModel,
    rgbRange: rgbRange,
    xChromaOffset: xChromaOffset,
    yChromaOffset: yChromaOffset,
  )

proc newVkPhysicalDeviceShader64BitIndexingFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShader64BitIndexingFeaturesEXT, pNext: pointer = nil, shader64BitIndexing: VkBool32): VkPhysicalDeviceShader64BitIndexingFeaturesEXT =
  result = VkPhysicalDeviceShader64BitIndexingFeaturesEXT(
    sType: sType,
    pNext: pNext,
    shader64BitIndexing: shader64BitIndexing,
  )

proc newVkNativeBufferUsageOHOS*(sType: VkStructureType = VkStructureType.NativeBufferUsageOHOS, pNext: pointer = nil, OHOSNativeBufferUsage: uint64): VkNativeBufferUsageOHOS =
  result = VkNativeBufferUsageOHOS(
    sType: sType,
    pNext: pNext,
    OHOSNativeBufferUsage: OHOSNativeBufferUsage,
  )

proc newVkNativeBufferPropertiesOHOS*(sType: VkStructureType = VkStructureType.NativeBufferPropertiesOHOS, pNext: pointer = nil, allocationSize: VkDeviceSize, memoryTypeBits: uint32): VkNativeBufferPropertiesOHOS =
  result = VkNativeBufferPropertiesOHOS(
    sType: sType,
    pNext: pNext,
    allocationSize: allocationSize,
    memoryTypeBits: memoryTypeBits,
  )

proc newVkNativeBufferFormatPropertiesOHOS*(sType: VkStructureType = VkStructureType.NativeBufferFormatPropertiesOHOS, pNext: pointer = nil, format: VkFormat, externalFormat: uint64, formatFeatures: VkFormatFeatureFlags, samplerYcbcrConversionComponents: VkComponentMapping, suggestedYcbcrModel: VkSamplerYcbcrModelConversion, suggestedYcbcrRange: VkSamplerYcbcrRange, suggestedXChromaOffset: VkChromaLocation, suggestedYChromaOffset: VkChromaLocation): VkNativeBufferFormatPropertiesOHOS =
  result = VkNativeBufferFormatPropertiesOHOS(
    sType: sType,
    pNext: pNext,
    format: format,
    externalFormat: externalFormat,
    formatFeatures: formatFeatures,
    samplerYcbcrConversionComponents: samplerYcbcrConversionComponents,
    suggestedYcbcrModel: suggestedYcbcrModel,
    suggestedYcbcrRange: suggestedYcbcrRange,
    suggestedXChromaOffset: suggestedXChromaOffset,
    suggestedYChromaOffset: suggestedYChromaOffset,
  )

proc newVkImportNativeBufferInfoOHOS*(sType: VkStructureType = VkStructureType.ImportNativeBufferInfoOHOS, pNext: pointer = nil, buffer: ptr OH_NativeBuffer): VkImportNativeBufferInfoOHOS =
  result = VkImportNativeBufferInfoOHOS(
    sType: sType,
    pNext: pNext,
    buffer: buffer,
  )

proc newVkMemoryGetNativeBufferInfoOHOS*(sType: VkStructureType = VkStructureType.MemoryGetNativeBufferInfoOHOS, pNext: pointer = nil, memory: VkDeviceMemory): VkMemoryGetNativeBufferInfoOHOS =
  result = VkMemoryGetNativeBufferInfoOHOS(
    sType: sType,
    pNext: pNext,
    memory: memory,
  )

proc newVkExternalFormatOHOS*(sType: VkStructureType = VkStructureType.ExternalFormatOHOS, pNext: pointer = nil, externalFormat: uint64): VkExternalFormatOHOS =
  result = VkExternalFormatOHOS(
    sType: sType,
    pNext: pNext,
    externalFormat: externalFormat,
  )

proc newVkPhysicalDevicePerformanceCountersByRegionFeaturesARM*(sType: VkStructureType = VkStructureType.PhysicalDevicePerformanceCountersByRegionFeaturesARM, pNext: pointer = nil, performanceCountersByRegion: VkBool32): VkPhysicalDevicePerformanceCountersByRegionFeaturesARM =
  result = VkPhysicalDevicePerformanceCountersByRegionFeaturesARM(
    sType: sType,
    pNext: pNext,
    performanceCountersByRegion: performanceCountersByRegion,
  )

proc newVkPhysicalDevicePerformanceCountersByRegionPropertiesARM*(sType: VkStructureType = VkStructureType.PhysicalDevicePerformanceCountersByRegionPropertiesARM, pNext: pointer = nil, maxPerRegionPerformanceCounters: uint32, performanceCounterRegionSize: VkExtent2D, rowStrideAlignment: uint32, regionAlignment: uint32, identityTransformOrder: VkBool32): VkPhysicalDevicePerformanceCountersByRegionPropertiesARM =
  result = VkPhysicalDevicePerformanceCountersByRegionPropertiesARM(
    sType: sType,
    pNext: pNext,
    maxPerRegionPerformanceCounters: maxPerRegionPerformanceCounters,
    performanceCounterRegionSize: performanceCounterRegionSize,
    rowStrideAlignment: rowStrideAlignment,
    regionAlignment: regionAlignment,
    identityTransformOrder: identityTransformOrder,
  )

proc newVkPerformanceCounterARM*(sType: VkStructureType = VkStructureType.PerformanceCounterARM, pNext: pointer = nil, counterID: uint32): VkPerformanceCounterARM =
  result = VkPerformanceCounterARM(
    sType: sType,
    pNext: pNext,
    counterID: counterID,
  )

proc newVkPerformanceCounterDescriptionARM*(sType: VkStructureType = VkStructureType.PerformanceCounterDescriptionARM, pNext: pointer = nil, flags: VkPerformanceCounterDescriptionFlagsARM = 0.VkPerformanceCounterDescriptionFlagsARM, name: array[VK_MAX_DESCRIPTION_SIZE, char]): VkPerformanceCounterDescriptionARM =
  result = VkPerformanceCounterDescriptionARM(
    sType: sType,
    pNext: pNext,
    flags: flags,
    name: name,
  )

proc newVkRenderPassPerformanceCountersByRegionBeginInfoARM*(sType: VkStructureType = VkStructureType.RenderPassPerformanceCountersByRegionBeginInfoARM, pNext: pointer = nil, counterAddresses: openarray[VkDeviceAddress], serializeRegions: VkBool32, counterIndices: openarray[uint32]): VkRenderPassPerformanceCountersByRegionBeginInfoARM =
  result = VkRenderPassPerformanceCountersByRegionBeginInfoARM(
    sType: sType,
    pNext: pNext,
    counterAddressCount: len(counterAddresses).uint32,
    pCounterAddresses: if len(counterAddresses) == 0: nil else: cast[ptr VkDeviceAddress](counterAddresses),
    serializeRegions: serializeRegions,
    counterIndexCount: len(counterIndices).uint32,
    pCounterIndices: if len(counterIndices) == 0: nil else: cast[ptr uint32](counterIndices),
  )

proc newVkComputeOccupancyPriorityParametersNV*(sType: VkStructureType = VkStructureType.ComputeOccupancyPriorityParametersNV, pNext: pointer = nil, occupancyPriority: float32, occupancyThrottling: float32): VkComputeOccupancyPriorityParametersNV =
  result = VkComputeOccupancyPriorityParametersNV(
    sType: sType,
    pNext: pNext,
    occupancyPriority: occupancyPriority,
    occupancyThrottling: occupancyThrottling,
  )

proc newVkPhysicalDeviceComputeOccupancyPriorityFeaturesNV*(sType: VkStructureType = VkStructureType.PhysicalDeviceComputeOccupancyPriorityFeaturesNV, pNext: pointer = nil, computeOccupancyPriority: VkBool32): VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV =
  result = VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV(
    sType: sType,
    pNext: pNext,
    computeOccupancyPriority: computeOccupancyPriority,
  )

proc newVkPhysicalDeviceShaderLongVectorFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderLongVectorFeaturesEXT, pNext: pointer = nil, longVector: VkBool32): VkPhysicalDeviceShaderLongVectorFeaturesEXT =
  result = VkPhysicalDeviceShaderLongVectorFeaturesEXT(
    sType: sType,
    pNext: pNext,
    longVector: longVector,
  )

proc newVkPhysicalDeviceShaderLongVectorPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderLongVectorPropertiesEXT, pNext: pointer = nil, maxVectorComponents: uint32): VkPhysicalDeviceShaderLongVectorPropertiesEXT =
  result = VkPhysicalDeviceShaderLongVectorPropertiesEXT(
    sType: sType,
    pNext: pNext,
    maxVectorComponents: maxVectorComponents,
  )

proc newVkPhysicalDeviceTextureCompressionASTC3DFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceTextureCompressionASTC3DFeaturesEXT, pNext: pointer = nil, textureCompressionASTC_3D: VkBool32): VkPhysicalDeviceTextureCompressionASTC3DFeaturesEXT =
  result = VkPhysicalDeviceTextureCompressionASTC3DFeaturesEXT(
    sType: sType,
    pNext: pNext,
    textureCompressionASTC_3D: textureCompressionASTC_3D,
  )

proc newVkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceShaderSubgroupPartitionedFeaturesEXT, pNext: pointer = nil, shaderSubgroupPartitioned: VkBool32): VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT =
  result = VkPhysicalDeviceShaderSubgroupPartitionedFeaturesEXT(
    sType: sType,
    pNext: pNext,
    shaderSubgroupPartitioned: shaderSubgroupPartitioned,
  )

proc newVkHostAddressRangeEXT*(address: pointer = nil, size: uint): VkHostAddressRangeEXT =
  result = VkHostAddressRangeEXT(
    address: address,
    size: size,
  )

proc newVkHostAddressRangeConstEXT*(address: pointer = nil, size: uint): VkHostAddressRangeConstEXT =
  result = VkHostAddressRangeConstEXT(
    address: address,
    size: size,
  )

proc newVkDeviceAddressRangeEXT*(address: VkDeviceAddress, size: VkDeviceSize): VkDeviceAddressRangeEXT =
  result = VkDeviceAddressRangeEXT(
    address: address,
    size: size,
  )

proc newVkTexelBufferDescriptorInfoEXT*(sType: VkStructureType = VkStructureType.TexelBufferDescriptorInfoEXT, pNext: pointer = nil, format: VkFormat, addressRange: VkDeviceAddressRangeEXT): VkTexelBufferDescriptorInfoEXT =
  result = VkTexelBufferDescriptorInfoEXT(
    sType: sType,
    pNext: pNext,
    format: format,
    addressRange: addressRange,
  )

proc newVkImageDescriptorInfoEXT*(sType: VkStructureType = VkStructureType.ImageDescriptorInfoEXT, pNext: pointer = nil, pView: ptr VkImageViewCreateInfo, layout: VkImageLayout): VkImageDescriptorInfoEXT =
  result = VkImageDescriptorInfoEXT(
    sType: sType,
    pNext: pNext,
    pView: pView,
    layout: layout,
  )

proc newVkResourceDescriptorInfoEXT*(sType: VkStructureType = VkStructureType.ResourceDescriptorInfoEXT, pNext: pointer = nil, `type`: VkDescriptorType, data: VkResourceDescriptorDataEXT): VkResourceDescriptorInfoEXT =
  result = VkResourceDescriptorInfoEXT(
    sType: sType,
    pNext: pNext,
    `type`: `type`,
    data: data,
  )

proc newVkBindHeapInfoEXT*(sType: VkStructureType = VkStructureType.BindHeapInfoEXT, pNext: pointer = nil, heapRange: VkDeviceAddressRangeEXT, reservedRangeOffset: VkDeviceSize, reservedRangeSize: VkDeviceSize): VkBindHeapInfoEXT =
  result = VkBindHeapInfoEXT(
    sType: sType,
    pNext: pNext,
    heapRange: heapRange,
    reservedRangeOffset: reservedRangeOffset,
    reservedRangeSize: reservedRangeSize,
  )

proc newVkPushDataInfoEXT*(sType: VkStructureType = VkStructureType.PushDataInfoEXT, pNext: pointer = nil, offset: uint32, data: VkHostAddressRangeConstEXT): VkPushDataInfoEXT =
  result = VkPushDataInfoEXT(
    sType: sType,
    pNext: pNext,
    offset: offset,
    data: data,
  )

proc newVkDescriptorMappingSourceConstantOffsetEXT*(heapOffset: uint32, heapArrayStride: uint32, pEmbeddedSampler: ptr VkSamplerCreateInfo, samplerHeapOffset: uint32, samplerHeapArrayStride: uint32): VkDescriptorMappingSourceConstantOffsetEXT =
  result = VkDescriptorMappingSourceConstantOffsetEXT(
    heapOffset: heapOffset,
    heapArrayStride: heapArrayStride,
    pEmbeddedSampler: pEmbeddedSampler,
    samplerHeapOffset: samplerHeapOffset,
    samplerHeapArrayStride: samplerHeapArrayStride,
  )

proc newVkDescriptorMappingSourcePushIndexEXT*(heapOffset: uint32, pushOffset: uint32, heapIndexStride: uint32, heapArrayStride: uint32, pEmbeddedSampler: ptr VkSamplerCreateInfo, useCombinedImageSamplerIndex: VkBool32, samplerHeapOffset: uint32, samplerPushOffset: uint32, samplerHeapIndexStride: uint32, samplerHeapArrayStride: uint32): VkDescriptorMappingSourcePushIndexEXT =
  result = VkDescriptorMappingSourcePushIndexEXT(
    heapOffset: heapOffset,
    pushOffset: pushOffset,
    heapIndexStride: heapIndexStride,
    heapArrayStride: heapArrayStride,
    pEmbeddedSampler: pEmbeddedSampler,
    useCombinedImageSamplerIndex: useCombinedImageSamplerIndex,
    samplerHeapOffset: samplerHeapOffset,
    samplerPushOffset: samplerPushOffset,
    samplerHeapIndexStride: samplerHeapIndexStride,
    samplerHeapArrayStride: samplerHeapArrayStride,
  )

proc newVkDescriptorMappingSourceIndirectIndexEXT*(heapOffset: uint32, pushOffset: uint32, addressOffset: uint32, heapIndexStride: uint32, heapArrayStride: uint32, pEmbeddedSampler: ptr VkSamplerCreateInfo, useCombinedImageSamplerIndex: VkBool32, samplerHeapOffset: uint32, samplerPushOffset: uint32, samplerAddressOffset: uint32, samplerHeapIndexStride: uint32, samplerHeapArrayStride: uint32): VkDescriptorMappingSourceIndirectIndexEXT =
  result = VkDescriptorMappingSourceIndirectIndexEXT(
    heapOffset: heapOffset,
    pushOffset: pushOffset,
    addressOffset: addressOffset,
    heapIndexStride: heapIndexStride,
    heapArrayStride: heapArrayStride,
    pEmbeddedSampler: pEmbeddedSampler,
    useCombinedImageSamplerIndex: useCombinedImageSamplerIndex,
    samplerHeapOffset: samplerHeapOffset,
    samplerPushOffset: samplerPushOffset,
    samplerAddressOffset: samplerAddressOffset,
    samplerHeapIndexStride: samplerHeapIndexStride,
    samplerHeapArrayStride: samplerHeapArrayStride,
  )

proc newVkDescriptorMappingSourceIndirectIndexArrayEXT*(heapOffset: uint32, pushOffset: uint32, addressOffset: uint32, heapIndexStride: uint32, pEmbeddedSampler: ptr VkSamplerCreateInfo, useCombinedImageSamplerIndex: VkBool32, samplerHeapOffset: uint32, samplerPushOffset: uint32, samplerAddressOffset: uint32, samplerHeapIndexStride: uint32): VkDescriptorMappingSourceIndirectIndexArrayEXT =
  result = VkDescriptorMappingSourceIndirectIndexArrayEXT(
    heapOffset: heapOffset,
    pushOffset: pushOffset,
    addressOffset: addressOffset,
    heapIndexStride: heapIndexStride,
    pEmbeddedSampler: pEmbeddedSampler,
    useCombinedImageSamplerIndex: useCombinedImageSamplerIndex,
    samplerHeapOffset: samplerHeapOffset,
    samplerPushOffset: samplerPushOffset,
    samplerAddressOffset: samplerAddressOffset,
    samplerHeapIndexStride: samplerHeapIndexStride,
  )

proc newVkDescriptorMappingSourceHeapDataEXT*(heapOffset: uint32, pushOffset: uint32): VkDescriptorMappingSourceHeapDataEXT =
  result = VkDescriptorMappingSourceHeapDataEXT(
    heapOffset: heapOffset,
    pushOffset: pushOffset,
  )

proc newVkDescriptorMappingSourceShaderRecordIndexEXT*(heapOffset: uint32, shaderRecordOffset: uint32, heapIndexStride: uint32, heapArrayStride: uint32, pEmbeddedSampler: ptr VkSamplerCreateInfo, useCombinedImageSamplerIndex: VkBool32, samplerHeapOffset: uint32, samplerShaderRecordOffset: uint32, samplerHeapIndexStride: uint32, samplerHeapArrayStride: uint32): VkDescriptorMappingSourceShaderRecordIndexEXT =
  result = VkDescriptorMappingSourceShaderRecordIndexEXT(
    heapOffset: heapOffset,
    shaderRecordOffset: shaderRecordOffset,
    heapIndexStride: heapIndexStride,
    heapArrayStride: heapArrayStride,
    pEmbeddedSampler: pEmbeddedSampler,
    useCombinedImageSamplerIndex: useCombinedImageSamplerIndex,
    samplerHeapOffset: samplerHeapOffset,
    samplerShaderRecordOffset: samplerShaderRecordOffset,
    samplerHeapIndexStride: samplerHeapIndexStride,
    samplerHeapArrayStride: samplerHeapArrayStride,
  )

proc newVkDescriptorMappingSourceIndirectAddressEXT*(pushOffset: uint32, addressOffset: uint32): VkDescriptorMappingSourceIndirectAddressEXT =
  result = VkDescriptorMappingSourceIndirectAddressEXT(
    pushOffset: pushOffset,
    addressOffset: addressOffset,
  )

proc newVkDescriptorSetAndBindingMappingEXT*(sType: VkStructureType = VkStructureType.DescriptorSetAndBindingMappingEXT, pNext: pointer = nil, descriptorSet: uint32, firstBinding: uint32, bindingCount: uint32, resourceMask: VkSpirvResourceTypeFlagsEXT, source: VkDescriptorMappingSourceEXT, sourceData: VkDescriptorMappingSourceDataEXT): VkDescriptorSetAndBindingMappingEXT =
  result = VkDescriptorSetAndBindingMappingEXT(
    sType: sType,
    pNext: pNext,
    descriptorSet: descriptorSet,
    firstBinding: firstBinding,
    bindingCount: bindingCount,
    resourceMask: resourceMask,
    source: source,
    sourceData: sourceData,
  )

proc newVkShaderDescriptorSetAndBindingMappingInfoEXT*(sType: VkStructureType = VkStructureType.ShaderDescriptorSetAndBindingMappingInfoEXT, pNext: pointer = nil, mappings: openarray[VkDescriptorSetAndBindingMappingEXT]): VkShaderDescriptorSetAndBindingMappingInfoEXT =
  result = VkShaderDescriptorSetAndBindingMappingInfoEXT(
    sType: sType,
    pNext: pNext,
    mappingCount: len(mappings).uint32,
    pMappings: if len(mappings) == 0: nil else: cast[ptr VkDescriptorSetAndBindingMappingEXT](mappings),
  )

proc newVkSamplerCustomBorderColorIndexCreateInfoEXT*(sType: VkStructureType = VkStructureType.SamplerCustomBorderColorIndexCreateInfoEXT, pNext: pointer = nil, index: uint32): VkSamplerCustomBorderColorIndexCreateInfoEXT =
  result = VkSamplerCustomBorderColorIndexCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    index: index,
  )

proc newVkOpaqueCaptureDataCreateInfoEXT*(sType: VkStructureType = VkStructureType.OpaqueCaptureDataCreateInfoEXT, pNext: pointer = nil, pData: ptr VkHostAddressRangeConstEXT): VkOpaqueCaptureDataCreateInfoEXT =
  result = VkOpaqueCaptureDataCreateInfoEXT(
    sType: sType,
    pNext: pNext,
    pData: pData,
  )

proc newVkIndirectCommandsLayoutPushDataTokenNV*(sType: VkStructureType = VkStructureType.IndirectCommandsLayoutPushDataTokenNV, pNext: pointer = nil, pushDataOffset: uint32, pushDataSize: uint32): VkIndirectCommandsLayoutPushDataTokenNV =
  result = VkIndirectCommandsLayoutPushDataTokenNV(
    sType: sType,
    pNext: pNext,
    pushDataOffset: pushDataOffset,
    pushDataSize: pushDataSize,
  )

proc newVkSubsampledImageFormatPropertiesEXT*(sType: VkStructureType = VkStructureType.SubsampledImageFormatPropertiesEXT, pNext: pointer = nil, subsampledImageDescriptorCount: uint32): VkSubsampledImageFormatPropertiesEXT =
  result = VkSubsampledImageFormatPropertiesEXT(
    sType: sType,
    pNext: pNext,
    subsampledImageDescriptorCount: subsampledImageDescriptorCount,
  )

proc newVkPhysicalDeviceDescriptorHeapFeaturesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorHeapFeaturesEXT, pNext: pointer = nil, descriptorHeap: VkBool32, descriptorHeapCaptureReplay: VkBool32): VkPhysicalDeviceDescriptorHeapFeaturesEXT =
  result = VkPhysicalDeviceDescriptorHeapFeaturesEXT(
    sType: sType,
    pNext: pNext,
    descriptorHeap: descriptorHeap,
    descriptorHeapCaptureReplay: descriptorHeapCaptureReplay,
  )

proc newVkPhysicalDeviceDescriptorHeapPropertiesEXT*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorHeapPropertiesEXT, pNext: pointer = nil, samplerHeapAlignment: VkDeviceSize, resourceHeapAlignment: VkDeviceSize, maxSamplerHeapSize: VkDeviceSize, maxResourceHeapSize: VkDeviceSize, minSamplerHeapReservedRange: VkDeviceSize, minSamplerHeapReservedRangeWithEmbedded: VkDeviceSize, minResourceHeapReservedRange: VkDeviceSize, samplerDescriptorSize: VkDeviceSize, imageDescriptorSize: VkDeviceSize, bufferDescriptorSize: VkDeviceSize, samplerDescriptorAlignment: VkDeviceSize, imageDescriptorAlignment: VkDeviceSize, bufferDescriptorAlignment: VkDeviceSize, maxPushDataSize: VkDeviceSize, imageCaptureReplayOpaqueDataSize: uint, maxDescriptorHeapEmbeddedSamplers: uint32, samplerYcbcrConversionCount: uint32, sparseDescriptorHeaps: VkBool32, protectedDescriptorHeaps: VkBool32): VkPhysicalDeviceDescriptorHeapPropertiesEXT =
  result = VkPhysicalDeviceDescriptorHeapPropertiesEXT(
    sType: sType,
    pNext: pNext,
    samplerHeapAlignment: samplerHeapAlignment,
    resourceHeapAlignment: resourceHeapAlignment,
    maxSamplerHeapSize: maxSamplerHeapSize,
    maxResourceHeapSize: maxResourceHeapSize,
    minSamplerHeapReservedRange: minSamplerHeapReservedRange,
    minSamplerHeapReservedRangeWithEmbedded: minSamplerHeapReservedRangeWithEmbedded,
    minResourceHeapReservedRange: minResourceHeapReservedRange,
    samplerDescriptorSize: samplerDescriptorSize,
    imageDescriptorSize: imageDescriptorSize,
    bufferDescriptorSize: bufferDescriptorSize,
    samplerDescriptorAlignment: samplerDescriptorAlignment,
    imageDescriptorAlignment: imageDescriptorAlignment,
    bufferDescriptorAlignment: bufferDescriptorAlignment,
    maxPushDataSize: maxPushDataSize,
    imageCaptureReplayOpaqueDataSize: imageCaptureReplayOpaqueDataSize,
    maxDescriptorHeapEmbeddedSamplers: maxDescriptorHeapEmbeddedSamplers,
    samplerYcbcrConversionCount: samplerYcbcrConversionCount,
    sparseDescriptorHeaps: sparseDescriptorHeaps,
    protectedDescriptorHeaps: protectedDescriptorHeaps,
  )

proc newVkCommandBufferInheritanceDescriptorHeapInfoEXT*(sType: VkStructureType = VkStructureType.CommandBufferInheritanceDescriptorHeapInfoEXT, pNext: pointer = nil, pSamplerHeapBindInfo: ptr VkBindHeapInfoEXT, pResourceHeapBindInfo: ptr VkBindHeapInfoEXT): VkCommandBufferInheritanceDescriptorHeapInfoEXT =
  result = VkCommandBufferInheritanceDescriptorHeapInfoEXT(
    sType: sType,
    pNext: pNext,
    pSamplerHeapBindInfo: pSamplerHeapBindInfo,
    pResourceHeapBindInfo: pResourceHeapBindInfo,
  )

proc newVkPhysicalDeviceDescriptorHeapTensorPropertiesARM*(sType: VkStructureType = VkStructureType.PhysicalDeviceDescriptorHeapTensorPropertiesARM, pNext: pointer = nil, tensorDescriptorSize: VkDeviceSize, tensorDescriptorAlignment: VkDeviceSize, tensorCaptureReplayOpaqueDataSize: uint): VkPhysicalDeviceDescriptorHeapTensorPropertiesARM =
  result = VkPhysicalDeviceDescriptorHeapTensorPropertiesARM(
    sType: sType,
    pNext: pNext,
    tensorDescriptorSize: tensorDescriptorSize,
    tensorDescriptorAlignment: tensorDescriptorAlignment,
    tensorCaptureReplayOpaqueDataSize: tensorCaptureReplayOpaqueDataSize,
  )

# Procs
var
  vkDestroyInstance*: proc (instance: VkInstance, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkEnumeratePhysicalDevices*: proc (instance: VkInstance, pPhysicalDeviceCount: ptr uint32, pPhysicalDevices: ptr VkPhysicalDevice): VkResult {.stdcall.}
  vkGetDeviceProcAddr*: proc (device: VkDevice, pName: cstring): PFN_vkVoidFunction {.stdcall.}
  vkGetInstanceProcAddr*: proc (instance: VkInstance, pName: cstring): PFN_vkVoidFunction {.stdcall.}
  vkGetPhysicalDeviceProperties*: proc (physicalDevice: VkPhysicalDevice, pProperties: ptr VkPhysicalDeviceProperties) {.stdcall.}
  vkGetPhysicalDeviceQueueFamilyProperties*: proc (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: ptr uint32, pQueueFamilyProperties: ptr VkQueueFamilyProperties) {.stdcall.}
  vkGetPhysicalDeviceMemoryProperties*: proc (physicalDevice: VkPhysicalDevice, pMemoryProperties: ptr VkPhysicalDeviceMemoryProperties) {.stdcall.}
  vkGetPhysicalDeviceFeatures*: proc (physicalDevice: VkPhysicalDevice, pFeatures: ptr VkPhysicalDeviceFeatures) {.stdcall.}
  vkGetPhysicalDeviceFormatProperties*: proc (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: ptr VkFormatProperties) {.stdcall.}
  vkGetPhysicalDeviceImageFormatProperties*: proc (physicalDevice: VkPhysicalDevice, format: VkFormat, `type`: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: ptr VkImageFormatProperties): VkResult {.stdcall.}
  vkCreateDevice*: proc (physicalDevice: VkPhysicalDevice, pCreateInfo: ptr VkDeviceCreateInfo, pAllocator: ptr VkAllocationCallbacks, pDevice: ptr VkDevice): VkResult {.stdcall.}
  vkDestroyDevice*: proc (device: VkDevice, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkEnumerateDeviceLayerProperties*: proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkLayerProperties): VkResult {.stdcall.}
  vkEnumerateDeviceExtensionProperties*: proc (physicalDevice: VkPhysicalDevice, pLayerName: cstring, pPropertyCount: ptr uint32, pProperties: ptr VkExtensionProperties): VkResult {.stdcall.}
  vkGetDeviceQueue*: proc (device: VkDevice, queueFamilyIndex: uint32, queueIndex: uint32, pQueue: ptr VkQueue) {.stdcall.}
  vkQueueSubmit*: proc (queue: VkQueue, submitCount: uint32, pSubmits: ptr VkSubmitInfo, fence: VkFence): VkResult {.stdcall.}
  vkQueueWaitIdle*: proc (queue: VkQueue): VkResult {.stdcall.}
  vkDeviceWaitIdle*: proc (device: VkDevice): VkResult {.stdcall.}
  vkAllocateMemory*: proc (device: VkDevice, pAllocateInfo: ptr VkMemoryAllocateInfo, pAllocator: ptr VkAllocationCallbacks, pMemory: ptr VkDeviceMemory): VkResult {.stdcall.}
  vkFreeMemory*: proc (device: VkDevice, memory: VkDeviceMemory, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkMapMemory*: proc (device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: ptr pointer): VkResult {.stdcall.}
  vkUnmapMemory*: proc (device: VkDevice, memory: VkDeviceMemory) {.stdcall.}
  vkFlushMappedMemoryRanges*: proc (device: VkDevice, memoryRangeCount: uint32, pMemoryRanges: ptr VkMappedMemoryRange): VkResult {.stdcall.}
  vkInvalidateMappedMemoryRanges*: proc (device: VkDevice, memoryRangeCount: uint32, pMemoryRanges: ptr VkMappedMemoryRange): VkResult {.stdcall.}
  vkGetDeviceMemoryCommitment*: proc (device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: ptr VkDeviceSize) {.stdcall.}
  vkGetBufferMemoryRequirements*: proc (device: VkDevice, buffer: VkBuffer, pMemoryRequirements: ptr VkMemoryRequirements) {.stdcall.}
  vkBindBufferMemory*: proc (device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize): VkResult {.stdcall.}
  vkGetImageMemoryRequirements*: proc (device: VkDevice, image: VkImage, pMemoryRequirements: ptr VkMemoryRequirements) {.stdcall.}
  vkBindImageMemory*: proc (device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize): VkResult {.stdcall.}
  vkGetImageSparseMemoryRequirements*: proc (device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: ptr uint32, pSparseMemoryRequirements: ptr VkSparseImageMemoryRequirements) {.stdcall.}
  vkGetPhysicalDeviceSparseImageFormatProperties*: proc (physicalDevice: VkPhysicalDevice, format: VkFormat, `type`: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: ptr uint32, pProperties: ptr VkSparseImageFormatProperties) {.stdcall.}
  vkQueueBindSparse*: proc (queue: VkQueue, bindInfoCount: uint32, pBindInfo: ptr VkBindSparseInfo, fence: VkFence): VkResult {.stdcall.}
  vkCreateFence*: proc (device: VkDevice, pCreateInfo: ptr VkFenceCreateInfo, pAllocator: ptr VkAllocationCallbacks, pFence: ptr VkFence): VkResult {.stdcall.}
  vkDestroyFence*: proc (device: VkDevice, fence: VkFence, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkResetFences*: proc (device: VkDevice, fenceCount: uint32, pFences: ptr VkFence): VkResult {.stdcall.}
  vkGetFenceStatus*: proc (device: VkDevice, fence: VkFence): VkResult {.stdcall.}
  vkWaitForFences*: proc (device: VkDevice, fenceCount: uint32, pFences: ptr VkFence, waitAll: VkBool32, timeout: uint64): VkResult {.stdcall.}
  vkCreateSemaphore*: proc (device: VkDevice, pCreateInfo: ptr VkSemaphoreCreateInfo, pAllocator: ptr VkAllocationCallbacks, pSemaphore: ptr VkSemaphore): VkResult {.stdcall.}
  vkDestroySemaphore*: proc (device: VkDevice, semaphore: VkSemaphore, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateEvent*: proc (device: VkDevice, pCreateInfo: ptr VkEventCreateInfo, pAllocator: ptr VkAllocationCallbacks, pEvent: ptr VkEvent): VkResult {.stdcall.}
  vkDestroyEvent*: proc (device: VkDevice, event: VkEvent, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetEventStatus*: proc (device: VkDevice, event: VkEvent): VkResult {.stdcall.}
  vkSetEvent*: proc (device: VkDevice, event: VkEvent): VkResult {.stdcall.}
  vkResetEvent*: proc (device: VkDevice, event: VkEvent): VkResult {.stdcall.}
  vkCreateQueryPool*: proc (device: VkDevice, pCreateInfo: ptr VkQueryPoolCreateInfo, pAllocator: ptr VkAllocationCallbacks, pQueryPool: ptr VkQueryPool): VkResult {.stdcall.}
  vkDestroyQueryPool*: proc (device: VkDevice, queryPool: VkQueryPool, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetQueryPoolResults*: proc (device: VkDevice, queryPool: VkQueryPool, firstQuery: uint32, queryCount: uint32, dataSize: uint, pData: pointer, stride: VkDeviceSize, flags: VkQueryResultFlags): VkResult {.stdcall.}
  vkResetQueryPool*: proc (device: VkDevice, queryPool: VkQueryPool, firstQuery: uint32, queryCount: uint32) {.stdcall.}
  vkCreateBuffer*: proc (device: VkDevice, pCreateInfo: ptr VkBufferCreateInfo, pAllocator: ptr VkAllocationCallbacks, pBuffer: ptr VkBuffer): VkResult {.stdcall.}
  vkDestroyBuffer*: proc (device: VkDevice, buffer: VkBuffer, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateBufferView*: proc (device: VkDevice, pCreateInfo: ptr VkBufferViewCreateInfo, pAllocator: ptr VkAllocationCallbacks, pView: ptr VkBufferView): VkResult {.stdcall.}
  vkDestroyBufferView*: proc (device: VkDevice, bufferView: VkBufferView, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateImage*: proc (device: VkDevice, pCreateInfo: ptr VkImageCreateInfo, pAllocator: ptr VkAllocationCallbacks, pImage: ptr VkImage): VkResult {.stdcall.}
  vkDestroyImage*: proc (device: VkDevice, image: VkImage, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetImageSubresourceLayout*: proc (device: VkDevice, image: VkImage, pSubresource: ptr VkImageSubresource, pLayout: ptr VkSubresourceLayout) {.stdcall.}
  vkCreateImageView*: proc (device: VkDevice, pCreateInfo: ptr VkImageViewCreateInfo, pAllocator: ptr VkAllocationCallbacks, pView: ptr VkImageView): VkResult {.stdcall.}
  vkDestroyImageView*: proc (device: VkDevice, imageView: VkImageView, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateShaderModule*: proc (device: VkDevice, pCreateInfo: ptr VkShaderModuleCreateInfo, pAllocator: ptr VkAllocationCallbacks, pShaderModule: ptr VkShaderModule): VkResult {.stdcall.}
  vkDestroyShaderModule*: proc (device: VkDevice, shaderModule: VkShaderModule, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreatePipelineCache*: proc (device: VkDevice, pCreateInfo: ptr VkPipelineCacheCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPipelineCache: ptr VkPipelineCache): VkResult {.stdcall.}
  vkDestroyPipelineCache*: proc (device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetPipelineCacheData*: proc (device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: ptr uint, pData: pointer): VkResult {.stdcall.}
  vkMergePipelineCaches*: proc (device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: uint32, pSrcCaches: ptr VkPipelineCache): VkResult {.stdcall.}
  vkCreatePipelineBinariesKHR*: proc (device: VkDevice, pCreateInfo: ptr VkPipelineBinaryCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pBinaries: ptr VkPipelineBinaryHandlesInfoKHR): VkResult {.stdcall.}
  vkDestroyPipelineBinaryKHR*: proc (device: VkDevice, pipelineBinary: VkPipelineBinaryKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetPipelineKeyKHR*: proc (device: VkDevice, pPipelineCreateInfo: ptr VkPipelineCreateInfoKHR, pPipelineKey: ptr VkPipelineBinaryKeyKHR): VkResult {.stdcall.}
  vkGetPipelineBinaryDataKHR*: proc (device: VkDevice, pInfo: ptr VkPipelineBinaryDataInfoKHR, pPipelineBinaryKey: ptr VkPipelineBinaryKeyKHR, pPipelineBinaryDataSize: ptr uint, pPipelineBinaryData: pointer): VkResult {.stdcall.}
  vkReleaseCapturedPipelineDataKHR*: proc (device: VkDevice, pInfo: ptr VkReleaseCapturedPipelineDataInfoKHR, pAllocator: ptr VkAllocationCallbacks): VkResult {.stdcall.}
  vkCreateGraphicsPipelines*: proc (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkGraphicsPipelineCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}
  vkCreateComputePipelines*: proc (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkComputePipelineCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}
  vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI*: proc (device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: ptr VkExtent2D): VkResult {.stdcall.}
  vkDestroyPipeline*: proc (device: VkDevice, pipeline: VkPipeline, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreatePipelineLayout*: proc (device: VkDevice, pCreateInfo: ptr VkPipelineLayoutCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPipelineLayout: ptr VkPipelineLayout): VkResult {.stdcall.}
  vkDestroyPipelineLayout*: proc (device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateSampler*: proc (device: VkDevice, pCreateInfo: ptr VkSamplerCreateInfo, pAllocator: ptr VkAllocationCallbacks, pSampler: ptr VkSampler): VkResult {.stdcall.}
  vkDestroySampler*: proc (device: VkDevice, sampler: VkSampler, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateDescriptorSetLayout*: proc (device: VkDevice, pCreateInfo: ptr VkDescriptorSetLayoutCreateInfo, pAllocator: ptr VkAllocationCallbacks, pSetLayout: ptr VkDescriptorSetLayout): VkResult {.stdcall.}
  vkDestroyDescriptorSetLayout*: proc (device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateDescriptorPool*: proc (device: VkDevice, pCreateInfo: ptr VkDescriptorPoolCreateInfo, pAllocator: ptr VkAllocationCallbacks, pDescriptorPool: ptr VkDescriptorPool): VkResult {.stdcall.}
  vkDestroyDescriptorPool*: proc (device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkResetDescriptorPool*: proc (device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags): VkResult {.stdcall.}
  vkAllocateDescriptorSets*: proc (device: VkDevice, pAllocateInfo: ptr VkDescriptorSetAllocateInfo, pDescriptorSets: ptr VkDescriptorSet): VkResult {.stdcall.}
  vkFreeDescriptorSets*: proc (device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: uint32, pDescriptorSets: ptr VkDescriptorSet): VkResult {.stdcall.}
  vkUpdateDescriptorSets*: proc (device: VkDevice, descriptorWriteCount: uint32, pDescriptorWrites: ptr VkWriteDescriptorSet, descriptorCopyCount: uint32, pDescriptorCopies: ptr VkCopyDescriptorSet) {.stdcall.}
  vkCreateFramebuffer*: proc (device: VkDevice, pCreateInfo: ptr VkFramebufferCreateInfo, pAllocator: ptr VkAllocationCallbacks, pFramebuffer: ptr VkFramebuffer): VkResult {.stdcall.}
  vkDestroyFramebuffer*: proc (device: VkDevice, framebuffer: VkFramebuffer, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateRenderPass*: proc (device: VkDevice, pCreateInfo: ptr VkRenderPassCreateInfo, pAllocator: ptr VkAllocationCallbacks, pRenderPass: ptr VkRenderPass): VkResult {.stdcall.}
  vkDestroyRenderPass*: proc (device: VkDevice, renderPass: VkRenderPass, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetRenderAreaGranularity*: proc (device: VkDevice, renderPass: VkRenderPass, pGranularity: ptr VkExtent2D) {.stdcall.}
  vkGetRenderingAreaGranularity*: proc (device: VkDevice, pRenderingAreaInfo: ptr VkRenderingAreaInfo, pGranularity: ptr VkExtent2D) {.stdcall.}
  vkCreateCommandPool*: proc (device: VkDevice, pCreateInfo: ptr VkCommandPoolCreateInfo, pAllocator: ptr VkAllocationCallbacks, pCommandPool: ptr VkCommandPool): VkResult {.stdcall.}
  vkDestroyCommandPool*: proc (device: VkDevice, commandPool: VkCommandPool, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkResetCommandPool*: proc (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags): VkResult {.stdcall.}
  vkAllocateCommandBuffers*: proc (device: VkDevice, pAllocateInfo: ptr VkCommandBufferAllocateInfo, pCommandBuffers: ptr VkCommandBuffer): VkResult {.stdcall.}
  vkFreeCommandBuffers*: proc (device: VkDevice, commandPool: VkCommandPool, commandBufferCount: uint32, pCommandBuffers: ptr VkCommandBuffer) {.stdcall.}
  vkBeginCommandBuffer*: proc (commandBuffer: VkCommandBuffer, pBeginInfo: ptr VkCommandBufferBeginInfo): VkResult {.stdcall.}
  vkEndCommandBuffer*: proc (commandBuffer: VkCommandBuffer): VkResult {.stdcall.}
  vkResetCommandBuffer*: proc (commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags): VkResult {.stdcall.}
  vkCmdBindPipeline*: proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) {.stdcall.}
  vkCmdSetAttachmentFeedbackLoopEnableEXT*: proc (commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags) {.stdcall.}
  vkCmdSetViewport*: proc (commandBuffer: VkCommandBuffer, firstViewport: uint32, viewportCount: uint32, pViewports: ptr VkViewport) {.stdcall.}
  vkCmdSetScissor*: proc (commandBuffer: VkCommandBuffer, firstScissor: uint32, scissorCount: uint32, pScissors: ptr VkRect2D) {.stdcall.}
  vkCmdSetLineWidth*: proc (commandBuffer: VkCommandBuffer, lineWidth: float32) {.stdcall.}
  vkCmdSetDepthBias*: proc (commandBuffer: VkCommandBuffer, depthBiasConstantFactor: float32, depthBiasClamp: float32, depthBiasSlopeFactor: float32) {.stdcall.}
  vkCmdSetBlendConstants*: proc (commandBuffer: VkCommandBuffer, blendConstants: array[4, float32]) {.stdcall.}
  vkCmdSetDepthBounds*: proc (commandBuffer: VkCommandBuffer, minDepthBounds: float32, maxDepthBounds: float32) {.stdcall.}
  vkCmdSetStencilCompareMask*: proc (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: uint32) {.stdcall.}
  vkCmdSetStencilWriteMask*: proc (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: uint32) {.stdcall.}
  vkCmdSetStencilReference*: proc (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: uint32) {.stdcall.}
  vkCmdBindDescriptorSets*: proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: uint32, descriptorSetCount: uint32, pDescriptorSets: ptr VkDescriptorSet, dynamicOffsetCount: uint32, pDynamicOffsets: ptr uint32) {.stdcall.}
  vkCmdBindIndexBuffer*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) {.stdcall.}
  vkCmdBindVertexBuffers*: proc (commandBuffer: VkCommandBuffer, firstBinding: uint32, bindingCount: uint32, pBuffers: ptr VkBuffer, pOffsets: ptr VkDeviceSize) {.stdcall.}
  vkCmdDraw*: proc (commandBuffer: VkCommandBuffer, vertexCount: uint32, instanceCount: uint32, firstVertex: uint32, firstInstance: uint32) {.stdcall.}
  vkCmdDrawIndexed*: proc (commandBuffer: VkCommandBuffer, indexCount: uint32, instanceCount: uint32, firstIndex: uint32, vertexOffset: int32, firstInstance: uint32) {.stdcall.}
  vkCmdDrawMultiEXT*: proc (commandBuffer: VkCommandBuffer, drawCount: uint32, pVertexInfo: ptr VkMultiDrawInfoEXT, instanceCount: uint32, firstInstance: uint32, stride: uint32) {.stdcall.}
  vkCmdDrawMultiIndexedEXT*: proc (commandBuffer: VkCommandBuffer, drawCount: uint32, pIndexInfo: ptr VkMultiDrawIndexedInfoEXT, instanceCount: uint32, firstInstance: uint32, stride: uint32, pVertexOffset: ptr int32) {.stdcall.}
  vkCmdDrawIndirect*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: uint32, stride: uint32) {.stdcall.}
  vkCmdDrawIndexedIndirect*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: uint32, stride: uint32) {.stdcall.}
  vkCmdDispatch*: proc (commandBuffer: VkCommandBuffer, groupCountX: uint32, groupCountY: uint32, groupCountZ: uint32) {.stdcall.}
  vkCmdDispatchIndirect*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) {.stdcall.}
  vkCmdSubpassShadingHUAWEI*: proc (commandBuffer: VkCommandBuffer) {.stdcall.}
  vkCmdDrawClusterHUAWEI*: proc (commandBuffer: VkCommandBuffer, groupCountX: uint32, groupCountY: uint32, groupCountZ: uint32) {.stdcall.}
  vkCmdDrawClusterIndirectHUAWEI*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) {.stdcall.}
  vkCmdUpdatePipelineIndirectBufferNV*: proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) {.stdcall.}
  vkCmdCopyBuffer*: proc (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: uint32, pRegions: ptr VkBufferCopy) {.stdcall.}
  vkCmdCopyImage*: proc (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: uint32, pRegions: ptr VkImageCopy) {.stdcall.}
  vkCmdBlitImage*: proc (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: uint32, pRegions: ptr VkImageBlit, filter: VkFilter) {.stdcall.}
  vkCmdCopyBufferToImage*: proc (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: uint32, pRegions: ptr VkBufferImageCopy) {.stdcall.}
  vkCmdCopyImageToBuffer*: proc (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: uint32, pRegions: ptr VkBufferImageCopy) {.stdcall.}
  vkCmdCopyMemoryIndirectNV*: proc (commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: uint32, stride: uint32) {.stdcall.}
  vkCmdCopyMemoryIndirectKHR*: proc (commandBuffer: VkCommandBuffer, pCopyMemoryIndirectInfo: ptr VkCopyMemoryIndirectInfoKHR) {.stdcall.}
  vkCmdCopyMemoryToImageIndirectNV*: proc (commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: uint32, stride: uint32, dstImage: VkImage, dstImageLayout: VkImageLayout, pImageSubresources: ptr VkImageSubresourceLayers) {.stdcall.}
  vkCmdCopyMemoryToImageIndirectKHR*: proc (commandBuffer: VkCommandBuffer, pCopyMemoryToImageIndirectInfo: ptr VkCopyMemoryToImageIndirectInfoKHR) {.stdcall.}
  vkCmdUpdateBuffer*: proc (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: pointer) {.stdcall.}
  vkCmdFillBuffer*: proc (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: uint32) {.stdcall.}
  vkCmdClearColorImage*: proc (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: ptr VkClearColorValue, rangeCount: uint32, pRanges: ptr VkImageSubresourceRange) {.stdcall.}
  vkCmdClearDepthStencilImage*: proc (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: ptr VkClearDepthStencilValue, rangeCount: uint32, pRanges: ptr VkImageSubresourceRange) {.stdcall.}
  vkCmdClearAttachments*: proc (commandBuffer: VkCommandBuffer, attachmentCount: uint32, pAttachments: ptr VkClearAttachment, rectCount: uint32, pRects: ptr VkClearRect) {.stdcall.}
  vkCmdResolveImage*: proc (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: uint32, pRegions: ptr VkImageResolve) {.stdcall.}
  vkCmdSetEvent*: proc (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) {.stdcall.}
  vkCmdResetEvent*: proc (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) {.stdcall.}
  vkCmdWaitEvents*: proc (commandBuffer: VkCommandBuffer, eventCount: uint32, pEvents: ptr VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: uint32, pMemoryBarriers: ptr VkMemoryBarrier, bufferMemoryBarrierCount: uint32, pBufferMemoryBarriers: ptr VkBufferMemoryBarrier, imageMemoryBarrierCount: uint32, pImageMemoryBarriers: ptr VkImageMemoryBarrier) {.stdcall.}
  vkCmdPipelineBarrier*: proc (commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: uint32, pMemoryBarriers: ptr VkMemoryBarrier, bufferMemoryBarrierCount: uint32, pBufferMemoryBarriers: ptr VkBufferMemoryBarrier, imageMemoryBarrierCount: uint32, pImageMemoryBarriers: ptr VkImageMemoryBarrier) {.stdcall.}
  vkCmdBeginQuery*: proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32, flags: VkQueryControlFlags) {.stdcall.}
  vkCmdEndQuery*: proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32) {.stdcall.}
  vkCmdBeginConditionalRenderingEXT*: proc (commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: ptr VkConditionalRenderingBeginInfoEXT) {.stdcall.}
  vkCmdEndConditionalRenderingEXT*: proc (commandBuffer: VkCommandBuffer) {.stdcall.}
  vkCmdBeginCustomResolveEXT*: proc (commandBuffer: VkCommandBuffer, pBeginCustomResolveInfo: ptr VkBeginCustomResolveInfoEXT) {.stdcall.}
  vkCmdResetQueryPool*: proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: uint32, queryCount: uint32) {.stdcall.}
  vkCmdWriteTimestamp*: proc (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: uint32) {.stdcall.}
  vkCmdCopyQueryPoolResults*: proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: uint32, queryCount: uint32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) {.stdcall.}
  vkCmdPushConstants*: proc (commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: uint32, size: uint32, pValues: pointer) {.stdcall.}
  vkCmdBeginRenderPass*: proc (commandBuffer: VkCommandBuffer, pRenderPassBegin: ptr VkRenderPassBeginInfo, contents: VkSubpassContents) {.stdcall.}
  vkCmdNextSubpass*: proc (commandBuffer: VkCommandBuffer, contents: VkSubpassContents) {.stdcall.}
  vkCmdEndRenderPass*: proc (commandBuffer: VkCommandBuffer) {.stdcall.}
  vkCmdExecuteCommands*: proc (commandBuffer: VkCommandBuffer, commandBufferCount: uint32, pCommandBuffers: ptr VkCommandBuffer) {.stdcall.}
  vkCreateAndroidSurfaceKHR*: proc (instance: VkInstance, pCreateInfo: ptr VkAndroidSurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkCreateSurfaceOHOS*: proc (instance: VkInstance, pCreateInfo: ptr VkSurfaceCreateInfoOHOS, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceDisplayPropertiesKHR*: proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayPropertiesKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceDisplayPlanePropertiesKHR*: proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayPlanePropertiesKHR): VkResult {.stdcall.}
  vkGetDisplayPlaneSupportedDisplaysKHR*: proc (physicalDevice: VkPhysicalDevice, planeIndex: uint32, pDisplayCount: ptr uint32, pDisplays: ptr VkDisplayKHR): VkResult {.stdcall.}
  vkGetDisplayModePropertiesKHR*: proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayModePropertiesKHR): VkResult {.stdcall.}
  vkCreateDisplayModeKHR*: proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pCreateInfo: ptr VkDisplayModeCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pMode: ptr VkDisplayModeKHR): VkResult {.stdcall.}
  vkGetDisplayPlaneCapabilitiesKHR*: proc (physicalDevice: VkPhysicalDevice, mode: VkDisplayModeKHR, planeIndex: uint32, pCapabilities: ptr VkDisplayPlaneCapabilitiesKHR): VkResult {.stdcall.}
  vkCreateDisplayPlaneSurfaceKHR*: proc (instance: VkInstance, pCreateInfo: ptr VkDisplaySurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkCreateSharedSwapchainsKHR*: proc (device: VkDevice, swapchainCount: uint32, pCreateInfos: ptr VkSwapchainCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSwapchains: ptr VkSwapchainKHR): VkResult {.stdcall.}
  vkDestroySurfaceKHR*: proc (instance: VkInstance, surface: VkSurfaceKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetPhysicalDeviceSurfaceSupportKHR*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, surface: VkSurfaceKHR, pSupported: ptr VkBool32): VkResult {.stdcall.}
  vkGetPhysicalDeviceSurfaceCapabilitiesKHR*: proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: ptr VkSurfaceCapabilitiesKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceSurfaceFormatsKHR*: proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceFormatCount: ptr uint32, pSurfaceFormats: ptr VkSurfaceFormatKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceSurfacePresentModesKHR*: proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pPresentModeCount: ptr uint32, pPresentModes: ptr VkPresentModeKHR): VkResult {.stdcall.}
  vkCreateSwapchainKHR*: proc (device: VkDevice, pCreateInfo: ptr VkSwapchainCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSwapchain: ptr VkSwapchainKHR): VkResult {.stdcall.}
  vkDestroySwapchainKHR*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetSwapchainImagesKHR*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainImageCount: ptr uint32, pSwapchainImages: ptr VkImage): VkResult {.stdcall.}
  vkAcquireNextImageKHR*: proc (device: VkDevice, swapchain: VkSwapchainKHR, timeout: uint64, semaphore: VkSemaphore, fence: VkFence, pImageIndex: ptr uint32): VkResult {.stdcall.}
  vkQueuePresentKHR*: proc (queue: VkQueue, pPresentInfo: ptr VkPresentInfoKHR): VkResult {.stdcall.}
  vkCreateViSurfaceNN*: proc (instance: VkInstance, pCreateInfo: ptr VkViSurfaceCreateInfoNN, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkCreateWaylandSurfaceKHR*: proc (instance: VkInstance, pCreateInfo: ptr VkWaylandSurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceWaylandPresentationSupportKHR*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, display: ptr wl_display): VkBool32 {.stdcall.}
  vkCreateUbmSurfaceSEC*: proc (instance: VkInstance, pCreateInfo: ptr VkUbmSurfaceCreateInfoSEC, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceUbmPresentationSupportSEC*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, device: ptr ubm_device): VkBool32 {.stdcall.}
  vkCreateWin32SurfaceKHR*: proc (instance: VkInstance, pCreateInfo: ptr VkWin32SurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceWin32PresentationSupportKHR*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32): VkBool32 {.stdcall.}
  vkCreateXlibSurfaceKHR*: proc (instance: VkInstance, pCreateInfo: ptr VkXlibSurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceXlibPresentationSupportKHR*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, dpy: ptr Display, visualID: VisualID): VkBool32 {.stdcall.}
  vkCreateXcbSurfaceKHR*: proc (instance: VkInstance, pCreateInfo: ptr VkXcbSurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceXcbPresentationSupportKHR*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, connection: ptr xcb_connection_t, visual_id: xcb_visualid_t): VkBool32 {.stdcall.}
  vkCreateDirectFBSurfaceEXT*: proc (instance: VkInstance, pCreateInfo: ptr VkDirectFBSurfaceCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceDirectFBPresentationSupportEXT*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, dfb: ptr IDirectFB): VkBool32 {.stdcall.}
  vkCreateImagePipeSurfaceFUCHSIA*: proc (instance: VkInstance, pCreateInfo: ptr VkImagePipeSurfaceCreateInfoFUCHSIA, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkCreateStreamDescriptorSurfaceGGP*: proc (instance: VkInstance, pCreateInfo: ptr VkStreamDescriptorSurfaceCreateInfoGGP, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkCreateScreenSurfaceQNX*: proc (instance: VkInstance, pCreateInfo: ptr VkScreenSurfaceCreateInfoQNX, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceScreenPresentationSupportQNX*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, window: ptr screen_window): VkBool32 {.stdcall.}
  vkCreateDebugReportCallbackEXT*: proc (instance: VkInstance, pCreateInfo: ptr VkDebugReportCallbackCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pCallback: ptr VkDebugReportCallbackEXT): VkResult {.stdcall.}
  vkDestroyDebugReportCallbackEXT*: proc (instance: VkInstance, callback: VkDebugReportCallbackEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkDebugReportMessageEXT*: proc (instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, `object`: uint64, location: uint, messageCode: int32, pLayerPrefix: cstring, pMessage: cstring) {.stdcall.}
  vkDebugMarkerSetObjectNameEXT*: proc (device: VkDevice, pNameInfo: ptr VkDebugMarkerObjectNameInfoEXT): VkResult {.stdcall.}
  vkDebugMarkerSetObjectTagEXT*: proc (device: VkDevice, pTagInfo: ptr VkDebugMarkerObjectTagInfoEXT): VkResult {.stdcall.}
  vkCmdDebugMarkerBeginEXT*: proc (commandBuffer: VkCommandBuffer, pMarkerInfo: ptr VkDebugMarkerMarkerInfoEXT) {.stdcall.}
  vkCmdDebugMarkerEndEXT*: proc (commandBuffer: VkCommandBuffer) {.stdcall.}
  vkCmdDebugMarkerInsertEXT*: proc (commandBuffer: VkCommandBuffer, pMarkerInfo: ptr VkDebugMarkerMarkerInfoEXT) {.stdcall.}
  vkGetPhysicalDeviceExternalImageFormatPropertiesNV*: proc (physicalDevice: VkPhysicalDevice, format: VkFormat, `type`: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: ptr VkExternalImageFormatPropertiesNV): VkResult {.stdcall.}
  vkGetMemoryWin32HandleNV*: proc (device: VkDevice, memory: VkDeviceMemory, handleType: VkExternalMemoryHandleTypeFlagsNV, pHandle: ptr HANDLE): VkResult {.stdcall.}
  vkCmdExecuteGeneratedCommandsNV*: proc (commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: ptr VkGeneratedCommandsInfoNV) {.stdcall.}
  vkCmdPreprocessGeneratedCommandsNV*: proc (commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: ptr VkGeneratedCommandsInfoNV) {.stdcall.}
  vkCmdBindPipelineShaderGroupNV*: proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline, groupIndex: uint32) {.stdcall.}
  vkGetGeneratedCommandsMemoryRequirementsNV*: proc (device: VkDevice, pInfo: ptr VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkCreateIndirectCommandsLayoutNV*: proc (device: VkDevice, pCreateInfo: ptr VkIndirectCommandsLayoutCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pIndirectCommandsLayout: ptr VkIndirectCommandsLayoutNV): VkResult {.stdcall.}
  vkDestroyIndirectCommandsLayoutNV*: proc (device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCmdExecuteGeneratedCommandsEXT*: proc (commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: ptr VkGeneratedCommandsInfoEXT) {.stdcall.}
  vkCmdPreprocessGeneratedCommandsEXT*: proc (commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: ptr VkGeneratedCommandsInfoEXT, stateCommandBuffer: VkCommandBuffer) {.stdcall.}
  vkGetGeneratedCommandsMemoryRequirementsEXT*: proc (device: VkDevice, pInfo: ptr VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkCreateIndirectCommandsLayoutEXT*: proc (device: VkDevice, pCreateInfo: ptr VkIndirectCommandsLayoutCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pIndirectCommandsLayout: ptr VkIndirectCommandsLayoutEXT): VkResult {.stdcall.}
  vkDestroyIndirectCommandsLayoutEXT*: proc (device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateIndirectExecutionSetEXT*: proc (device: VkDevice, pCreateInfo: ptr VkIndirectExecutionSetCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pIndirectExecutionSet: ptr VkIndirectExecutionSetEXT): VkResult {.stdcall.}
  vkDestroyIndirectExecutionSetEXT*: proc (device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkUpdateIndirectExecutionSetPipelineEXT*: proc (device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: uint32, pExecutionSetWrites: ptr VkWriteIndirectExecutionSetPipelineEXT) {.stdcall.}
  vkUpdateIndirectExecutionSetShaderEXT*: proc (device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: uint32, pExecutionSetWrites: ptr VkWriteIndirectExecutionSetShaderEXT) {.stdcall.}
  vkGetPhysicalDeviceFeatures2*: proc (physicalDevice: VkPhysicalDevice, pFeatures: ptr VkPhysicalDeviceFeatures2) {.stdcall.}
  vkGetPhysicalDeviceProperties2*: proc (physicalDevice: VkPhysicalDevice, pProperties: ptr VkPhysicalDeviceProperties2) {.stdcall.}
  vkGetPhysicalDeviceFormatProperties2*: proc (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: ptr VkFormatProperties2) {.stdcall.}
  vkGetPhysicalDeviceImageFormatProperties2*: proc (physicalDevice: VkPhysicalDevice, pImageFormatInfo: ptr VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: ptr VkImageFormatProperties2): VkResult {.stdcall.}
  vkGetPhysicalDeviceQueueFamilyProperties2*: proc (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: ptr uint32, pQueueFamilyProperties: ptr VkQueueFamilyProperties2) {.stdcall.}
  vkGetPhysicalDeviceMemoryProperties2*: proc (physicalDevice: VkPhysicalDevice, pMemoryProperties: ptr VkPhysicalDeviceMemoryProperties2) {.stdcall.}
  vkGetPhysicalDeviceSparseImageFormatProperties2*: proc (physicalDevice: VkPhysicalDevice, pFormatInfo: ptr VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: ptr uint32, pProperties: ptr VkSparseImageFormatProperties2) {.stdcall.}
  vkCmdPushDescriptorSet*: proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: uint32, descriptorWriteCount: uint32, pDescriptorWrites: ptr VkWriteDescriptorSet) {.stdcall.}
  vkTrimCommandPool*: proc (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) {.stdcall.}
  vkGetPhysicalDeviceExternalBufferProperties*: proc (physicalDevice: VkPhysicalDevice, pExternalBufferInfo: ptr VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: ptr VkExternalBufferProperties) {.stdcall.}
  vkGetMemoryWin32HandleKHR*: proc (device: VkDevice, pGetWin32HandleInfo: ptr VkMemoryGetWin32HandleInfoKHR, pHandle: ptr HANDLE): VkResult {.stdcall.}
  vkGetMemoryWin32HandlePropertiesKHR*: proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, handle: HANDLE, pMemoryWin32HandleProperties: ptr VkMemoryWin32HandlePropertiesKHR): VkResult {.stdcall.}
  vkGetMemoryFdKHR*: proc (device: VkDevice, pGetFdInfo: ptr VkMemoryGetFdInfoKHR, pFd: ptr int): VkResult {.stdcall.}
  vkGetMemoryFdPropertiesKHR*: proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, fd: int, pMemoryFdProperties: ptr VkMemoryFdPropertiesKHR): VkResult {.stdcall.}
  vkGetMemoryZirconHandleFUCHSIA*: proc (device: VkDevice, pGetZirconHandleInfo: ptr VkMemoryGetZirconHandleInfoFUCHSIA, pZirconHandle: ptr zx_handle_t): VkResult {.stdcall.}
  vkGetMemoryZirconHandlePropertiesFUCHSIA*: proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, zirconHandle: zx_handle_t, pMemoryZirconHandleProperties: ptr VkMemoryZirconHandlePropertiesFUCHSIA): VkResult {.stdcall.}
  vkGetMemoryRemoteAddressNV*: proc (device: VkDevice, pMemoryGetRemoteAddressInfo: ptr VkMemoryGetRemoteAddressInfoNV, pAddress: ptr VkRemoteAddressNV): VkResult {.stdcall.}
  vkGetMemorySciBufNV*: proc (device: VkDevice, pGetSciBufInfo: ptr VkMemoryGetSciBufInfoNV, pHandle: ptr NvSciBufObj): VkResult {.stdcall.}
  vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV*: proc (physicalDevice: VkPhysicalDevice, handleType: VkExternalMemoryHandleTypeFlagBits, handle: NvSciBufObj, pMemorySciBufProperties: ptr VkMemorySciBufPropertiesNV): VkResult {.stdcall.}
  vkGetPhysicalDeviceSciBufAttributesNV*: proc (physicalDevice: VkPhysicalDevice, pAttributes: NvSciBufAttrList): VkResult {.stdcall.}
  vkGetPhysicalDeviceExternalSemaphoreProperties*: proc (physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: ptr VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: ptr VkExternalSemaphoreProperties) {.stdcall.}
  vkGetSemaphoreWin32HandleKHR*: proc (device: VkDevice, pGetWin32HandleInfo: ptr VkSemaphoreGetWin32HandleInfoKHR, pHandle: ptr HANDLE): VkResult {.stdcall.}
  vkImportSemaphoreWin32HandleKHR*: proc (device: VkDevice, pImportSemaphoreWin32HandleInfo: ptr VkImportSemaphoreWin32HandleInfoKHR): VkResult {.stdcall.}
  vkGetSemaphoreFdKHR*: proc (device: VkDevice, pGetFdInfo: ptr VkSemaphoreGetFdInfoKHR, pFd: ptr int): VkResult {.stdcall.}
  vkImportSemaphoreFdKHR*: proc (device: VkDevice, pImportSemaphoreFdInfo: ptr VkImportSemaphoreFdInfoKHR): VkResult {.stdcall.}
  vkGetSemaphoreZirconHandleFUCHSIA*: proc (device: VkDevice, pGetZirconHandleInfo: ptr VkSemaphoreGetZirconHandleInfoFUCHSIA, pZirconHandle: ptr zx_handle_t): VkResult {.stdcall.}
  vkImportSemaphoreZirconHandleFUCHSIA*: proc (device: VkDevice, pImportSemaphoreZirconHandleInfo: ptr VkImportSemaphoreZirconHandleInfoFUCHSIA): VkResult {.stdcall.}
  vkGetPhysicalDeviceExternalFenceProperties*: proc (physicalDevice: VkPhysicalDevice, pExternalFenceInfo: ptr VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: ptr VkExternalFenceProperties) {.stdcall.}
  vkGetFenceWin32HandleKHR*: proc (device: VkDevice, pGetWin32HandleInfo: ptr VkFenceGetWin32HandleInfoKHR, pHandle: ptr HANDLE): VkResult {.stdcall.}
  vkImportFenceWin32HandleKHR*: proc (device: VkDevice, pImportFenceWin32HandleInfo: ptr VkImportFenceWin32HandleInfoKHR): VkResult {.stdcall.}
  vkGetFenceFdKHR*: proc (device: VkDevice, pGetFdInfo: ptr VkFenceGetFdInfoKHR, pFd: ptr int): VkResult {.stdcall.}
  vkImportFenceFdKHR*: proc (device: VkDevice, pImportFenceFdInfo: ptr VkImportFenceFdInfoKHR): VkResult {.stdcall.}
  vkGetFenceSciSyncFenceNV*: proc (device: VkDevice, pGetSciSyncHandleInfo: ptr VkFenceGetSciSyncInfoNV, pHandle: pointer): VkResult {.stdcall.}
  vkGetFenceSciSyncObjNV*: proc (device: VkDevice, pGetSciSyncHandleInfo: ptr VkFenceGetSciSyncInfoNV, pHandle: pointer): VkResult {.stdcall.}
  vkImportFenceSciSyncFenceNV*: proc (device: VkDevice, pImportFenceSciSyncInfo: ptr VkImportFenceSciSyncInfoNV): VkResult {.stdcall.}
  vkImportFenceSciSyncObjNV*: proc (device: VkDevice, pImportFenceSciSyncInfo: ptr VkImportFenceSciSyncInfoNV): VkResult {.stdcall.}
  vkGetSemaphoreSciSyncObjNV*: proc (device: VkDevice, pGetSciSyncInfo: ptr VkSemaphoreGetSciSyncInfoNV, pHandle: pointer): VkResult {.stdcall.}
  vkImportSemaphoreSciSyncObjNV*: proc (device: VkDevice, pImportSemaphoreSciSyncInfo: ptr VkImportSemaphoreSciSyncInfoNV): VkResult {.stdcall.}
  vkGetPhysicalDeviceSciSyncAttributesNV*: proc (physicalDevice: VkPhysicalDevice, pSciSyncAttributesInfo: ptr VkSciSyncAttributesInfoNV, pAttributes: NvSciSyncAttrList): VkResult {.stdcall.}
  vkCreateSemaphoreSciSyncPoolNV*: proc (device: VkDevice, pCreateInfo: ptr VkSemaphoreSciSyncPoolCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pSemaphorePool: ptr VkSemaphoreSciSyncPoolNV): VkResult {.stdcall.}
  vkDestroySemaphoreSciSyncPoolNV*: proc (device: VkDevice, semaphorePool: VkSemaphoreSciSyncPoolNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkReleaseDisplayEXT*: proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR): VkResult {.stdcall.}
  vkAcquireXlibDisplayEXT*: proc (physicalDevice: VkPhysicalDevice, dpy: ptr Display, display: VkDisplayKHR): VkResult {.stdcall.}
  vkGetRandROutputDisplayEXT*: proc (physicalDevice: VkPhysicalDevice, dpy: ptr Display, rrOutput: RROutput, pDisplay: ptr VkDisplayKHR): VkResult {.stdcall.}
  vkAcquireWinrtDisplayNV*: proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR): VkResult {.stdcall.}
  vkGetWinrtDisplayNV*: proc (physicalDevice: VkPhysicalDevice, deviceRelativeId: uint32, pDisplay: ptr VkDisplayKHR): VkResult {.stdcall.}
  vkDisplayPowerControlEXT*: proc (device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: ptr VkDisplayPowerInfoEXT): VkResult {.stdcall.}
  vkRegisterDeviceEventEXT*: proc (device: VkDevice, pDeviceEventInfo: ptr VkDeviceEventInfoEXT, pAllocator: ptr VkAllocationCallbacks, pFence: ptr VkFence): VkResult {.stdcall.}
  vkRegisterDisplayEventEXT*: proc (device: VkDevice, display: VkDisplayKHR, pDisplayEventInfo: ptr VkDisplayEventInfoEXT, pAllocator: ptr VkAllocationCallbacks, pFence: ptr VkFence): VkResult {.stdcall.}
  vkGetSwapchainCounterEXT*: proc (device: VkDevice, swapchain: VkSwapchainKHR, counter: VkSurfaceCounterFlagBitsEXT, pCounterValue: ptr uint64): VkResult {.stdcall.}
  vkGetPhysicalDeviceSurfaceCapabilities2EXT*: proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: ptr VkSurfaceCapabilities2EXT): VkResult {.stdcall.}
  vkEnumeratePhysicalDeviceGroups*: proc (instance: VkInstance, pPhysicalDeviceGroupCount: ptr uint32, pPhysicalDeviceGroupProperties: ptr VkPhysicalDeviceGroupProperties): VkResult {.stdcall.}
  vkGetDeviceGroupPeerMemoryFeatures*: proc (device: VkDevice, heapIndex: uint32, localDeviceIndex: uint32, remoteDeviceIndex: uint32, pPeerMemoryFeatures: ptr VkPeerMemoryFeatureFlags) {.stdcall.}
  vkBindBufferMemory2*: proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindBufferMemoryInfo): VkResult {.stdcall.}
  vkBindImageMemory2*: proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindImageMemoryInfo): VkResult {.stdcall.}
  vkCmdSetDeviceMask*: proc (commandBuffer: VkCommandBuffer, deviceMask: uint32) {.stdcall.}
  vkGetDeviceGroupPresentCapabilitiesKHR*: proc (device: VkDevice, pDeviceGroupPresentCapabilities: ptr VkDeviceGroupPresentCapabilitiesKHR): VkResult {.stdcall.}
  vkGetDeviceGroupSurfacePresentModesKHR*: proc (device: VkDevice, surface: VkSurfaceKHR, pModes: ptr VkDeviceGroupPresentModeFlagsKHR): VkResult {.stdcall.}
  vkAcquireNextImage2KHR*: proc (device: VkDevice, pAcquireInfo: ptr VkAcquireNextImageInfoKHR, pImageIndex: ptr uint32): VkResult {.stdcall.}
  vkCmdDispatchBase*: proc (commandBuffer: VkCommandBuffer, baseGroupX: uint32, baseGroupY: uint32, baseGroupZ: uint32, groupCountX: uint32, groupCountY: uint32, groupCountZ: uint32) {.stdcall.}
  vkGetPhysicalDevicePresentRectanglesKHR*: proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pRectCount: ptr uint32, pRects: ptr VkRect2D): VkResult {.stdcall.}
  vkCreateDescriptorUpdateTemplate*: proc (device: VkDevice, pCreateInfo: ptr VkDescriptorUpdateTemplateCreateInfo, pAllocator: ptr VkAllocationCallbacks, pDescriptorUpdateTemplate: ptr VkDescriptorUpdateTemplate): VkResult {.stdcall.}
  vkDestroyDescriptorUpdateTemplate*: proc (device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkUpdateDescriptorSetWithTemplate*: proc (device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: pointer) {.stdcall.}
  vkCmdPushDescriptorSetWithTemplate*: proc (commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: uint32, pData: pointer) {.stdcall.}
  vkSetHdrMetadataEXT*: proc (device: VkDevice, swapchainCount: uint32, pSwapchains: ptr VkSwapchainKHR, pMetadata: ptr VkHdrMetadataEXT) {.stdcall.}
  vkGetSwapchainStatusKHR*: proc (device: VkDevice, swapchain: VkSwapchainKHR): VkResult {.stdcall.}
  vkGetRefreshCycleDurationGOOGLE*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: ptr VkRefreshCycleDurationGOOGLE): VkResult {.stdcall.}
  vkGetPastPresentationTimingGOOGLE*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pPresentationTimingCount: ptr uint32, pPresentationTimings: ptr VkPastPresentationTimingGOOGLE): VkResult {.stdcall.}
  vkCreateIOSSurfaceMVK*: proc (instance: VkInstance, pCreateInfo: ptr VkIOSSurfaceCreateInfoMVK, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkCreateMacOSSurfaceMVK*: proc (instance: VkInstance, pCreateInfo: ptr VkMacOSSurfaceCreateInfoMVK, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkCreateMetalSurfaceEXT*: proc (instance: VkInstance, pCreateInfo: ptr VkMetalSurfaceCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkCmdSetViewportWScalingNV*: proc (commandBuffer: VkCommandBuffer, firstViewport: uint32, viewportCount: uint32, pViewportWScalings: ptr VkViewportWScalingNV) {.stdcall.}
  vkCmdSetDiscardRectangleEXT*: proc (commandBuffer: VkCommandBuffer, firstDiscardRectangle: uint32, discardRectangleCount: uint32, pDiscardRectangles: ptr VkRect2D) {.stdcall.}
  vkCmdSetDiscardRectangleEnableEXT*: proc (commandBuffer: VkCommandBuffer, discardRectangleEnable: VkBool32) {.stdcall.}
  vkCmdSetDiscardRectangleModeEXT*: proc (commandBuffer: VkCommandBuffer, discardRectangleMode: VkDiscardRectangleModeEXT) {.stdcall.}
  vkCmdSetSampleLocationsEXT*: proc (commandBuffer: VkCommandBuffer, pSampleLocationsInfo: ptr VkSampleLocationsInfoEXT) {.stdcall.}
  vkGetPhysicalDeviceMultisamplePropertiesEXT*: proc (physicalDevice: VkPhysicalDevice, samples: VkSampleCountFlagBits, pMultisampleProperties: ptr VkMultisamplePropertiesEXT) {.stdcall.}
  vkGetPhysicalDeviceSurfaceCapabilities2KHR*: proc (physicalDevice: VkPhysicalDevice, pSurfaceInfo: ptr VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: ptr VkSurfaceCapabilities2KHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceSurfaceFormats2KHR*: proc (physicalDevice: VkPhysicalDevice, pSurfaceInfo: ptr VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: ptr uint32, pSurfaceFormats: ptr VkSurfaceFormat2KHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceDisplayProperties2KHR*: proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayProperties2KHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceDisplayPlaneProperties2KHR*: proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayPlaneProperties2KHR): VkResult {.stdcall.}
  vkGetDisplayModeProperties2KHR*: proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayModeProperties2KHR): VkResult {.stdcall.}
  vkGetDisplayPlaneCapabilities2KHR*: proc (physicalDevice: VkPhysicalDevice, pDisplayPlaneInfo: ptr VkDisplayPlaneInfo2KHR, pCapabilities: ptr VkDisplayPlaneCapabilities2KHR): VkResult {.stdcall.}
  vkGetBufferMemoryRequirements2*: proc (device: VkDevice, pInfo: ptr VkBufferMemoryRequirementsInfo2, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkGetImageMemoryRequirements2*: proc (device: VkDevice, pInfo: ptr VkImageMemoryRequirementsInfo2, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkGetImageSparseMemoryRequirements2*: proc (device: VkDevice, pInfo: ptr VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: ptr uint32, pSparseMemoryRequirements: ptr VkSparseImageMemoryRequirements2) {.stdcall.}
  vkGetDeviceBufferMemoryRequirements*: proc (device: VkDevice, pInfo: ptr VkDeviceBufferMemoryRequirements, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkGetDeviceImageMemoryRequirements*: proc (device: VkDevice, pInfo: ptr VkDeviceImageMemoryRequirements, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkGetDeviceImageSparseMemoryRequirements*: proc (device: VkDevice, pInfo: ptr VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: ptr uint32, pSparseMemoryRequirements: ptr VkSparseImageMemoryRequirements2) {.stdcall.}
  vkCreateSamplerYcbcrConversion*: proc (device: VkDevice, pCreateInfo: ptr VkSamplerYcbcrConversionCreateInfo, pAllocator: ptr VkAllocationCallbacks, pYcbcrConversion: ptr VkSamplerYcbcrConversion): VkResult {.stdcall.}
  vkDestroySamplerYcbcrConversion*: proc (device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetDeviceQueue2*: proc (device: VkDevice, pQueueInfo: ptr VkDeviceQueueInfo2, pQueue: ptr VkQueue) {.stdcall.}
  vkCreateValidationCacheEXT*: proc (device: VkDevice, pCreateInfo: ptr VkValidationCacheCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pValidationCache: ptr VkValidationCacheEXT): VkResult {.stdcall.}
  vkDestroyValidationCacheEXT*: proc (device: VkDevice, validationCache: VkValidationCacheEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetValidationCacheDataEXT*: proc (device: VkDevice, validationCache: VkValidationCacheEXT, pDataSize: ptr uint, pData: pointer): VkResult {.stdcall.}
  vkMergeValidationCachesEXT*: proc (device: VkDevice, dstCache: VkValidationCacheEXT, srcCacheCount: uint32, pSrcCaches: ptr VkValidationCacheEXT): VkResult {.stdcall.}
  vkGetDescriptorSetLayoutSupport*: proc (device: VkDevice, pCreateInfo: ptr VkDescriptorSetLayoutCreateInfo, pSupport: ptr VkDescriptorSetLayoutSupport) {.stdcall.}
  vkGetSwapchainGrallocUsageANDROID*: proc (device: VkDevice, format: VkFormat, imageUsage: VkImageUsageFlags, grallocUsage: ptr int): VkResult {.stdcall.}
  vkGetSwapchainGrallocUsage2ANDROID*: proc (device: VkDevice, format: VkFormat, imageUsage: VkImageUsageFlags, swapchainImageUsage: VkSwapchainImageUsageFlagsANDROID, grallocConsumerUsage: ptr uint64, grallocProducerUsage: ptr uint64): VkResult {.stdcall.}
  vkAcquireImageANDROID*: proc (device: VkDevice, image: VkImage, nativeFenceFd: int, semaphore: VkSemaphore, fence: VkFence): VkResult {.stdcall.}
  vkQueueSignalReleaseImageANDROID*: proc (queue: VkQueue, waitSemaphoreCount: uint32, pWaitSemaphores: ptr VkSemaphore, image: VkImage, pNativeFenceFd: ptr int): VkResult {.stdcall.}
  vkGetShaderInfoAMD*: proc (device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: ptr uint, pInfo: pointer): VkResult {.stdcall.}
  vkSetLocalDimmingAMD*: proc (device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) {.stdcall.}
  vkGetPhysicalDeviceCalibrateableTimeDomainsKHR*: proc (physicalDevice: VkPhysicalDevice, pTimeDomainCount: ptr uint32, pTimeDomains: ptr VkTimeDomainKHR): VkResult {.stdcall.}
  vkGetCalibratedTimestampsKHR*: proc (device: VkDevice, timestampCount: uint32, pTimestampInfos: ptr VkCalibratedTimestampInfoKHR, pTimestamps: ptr uint64, pMaxDeviation: ptr uint64): VkResult {.stdcall.}
  vkSetDebugUtilsObjectNameEXT*: proc (device: VkDevice, pNameInfo: ptr VkDebugUtilsObjectNameInfoEXT): VkResult {.stdcall.}
  vkSetDebugUtilsObjectTagEXT*: proc (device: VkDevice, pTagInfo: ptr VkDebugUtilsObjectTagInfoEXT): VkResult {.stdcall.}
  vkQueueBeginDebugUtilsLabelEXT*: proc (queue: VkQueue, pLabelInfo: ptr VkDebugUtilsLabelEXT) {.stdcall.}
  vkQueueEndDebugUtilsLabelEXT*: proc (queue: VkQueue) {.stdcall.}
  vkQueueInsertDebugUtilsLabelEXT*: proc (queue: VkQueue, pLabelInfo: ptr VkDebugUtilsLabelEXT) {.stdcall.}
  vkCmdBeginDebugUtilsLabelEXT*: proc (commandBuffer: VkCommandBuffer, pLabelInfo: ptr VkDebugUtilsLabelEXT) {.stdcall.}
  vkCmdEndDebugUtilsLabelEXT*: proc (commandBuffer: VkCommandBuffer) {.stdcall.}
  vkCmdInsertDebugUtilsLabelEXT*: proc (commandBuffer: VkCommandBuffer, pLabelInfo: ptr VkDebugUtilsLabelEXT) {.stdcall.}
  vkCreateDebugUtilsMessengerEXT*: proc (instance: VkInstance, pCreateInfo: ptr VkDebugUtilsMessengerCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pMessenger: ptr VkDebugUtilsMessengerEXT): VkResult {.stdcall.}
  vkDestroyDebugUtilsMessengerEXT*: proc (instance: VkInstance, messenger: VkDebugUtilsMessengerEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkSubmitDebugUtilsMessageEXT*: proc (instance: VkInstance, messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: ptr VkDebugUtilsMessengerCallbackDataEXT) {.stdcall.}
  vkGetMemoryHostPointerPropertiesEXT*: proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: pointer, pMemoryHostPointerProperties: ptr VkMemoryHostPointerPropertiesEXT): VkResult {.stdcall.}
  vkCmdWriteBufferMarkerAMD*: proc (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: uint32) {.stdcall.}
  vkCreateRenderPass2*: proc (device: VkDevice, pCreateInfo: ptr VkRenderPassCreateInfo2, pAllocator: ptr VkAllocationCallbacks, pRenderPass: ptr VkRenderPass): VkResult {.stdcall.}
  vkCmdBeginRenderPass2*: proc (commandBuffer: VkCommandBuffer, pRenderPassBegin: ptr VkRenderPassBeginInfo, pSubpassBeginInfo: ptr VkSubpassBeginInfo) {.stdcall.}
  vkCmdNextSubpass2*: proc (commandBuffer: VkCommandBuffer, pSubpassBeginInfo: ptr VkSubpassBeginInfo, pSubpassEndInfo: ptr VkSubpassEndInfo) {.stdcall.}
  vkCmdEndRenderPass2*: proc (commandBuffer: VkCommandBuffer, pSubpassEndInfo: ptr VkSubpassEndInfo) {.stdcall.}
  vkGetSemaphoreCounterValue*: proc (device: VkDevice, semaphore: VkSemaphore, pValue: ptr uint64): VkResult {.stdcall.}
  vkWaitSemaphores*: proc (device: VkDevice, pWaitInfo: ptr VkSemaphoreWaitInfo, timeout: uint64): VkResult {.stdcall.}
  vkSignalSemaphore*: proc (device: VkDevice, pSignalInfo: ptr VkSemaphoreSignalInfo): VkResult {.stdcall.}
  vkGetAndroidHardwareBufferPropertiesANDROID*: proc (device: VkDevice, buffer: ptr AHardwareBuffer, pProperties: ptr VkAndroidHardwareBufferPropertiesANDROID): VkResult {.stdcall.}
  vkGetMemoryAndroidHardwareBufferANDROID*: proc (device: VkDevice, pInfo: ptr VkMemoryGetAndroidHardwareBufferInfoANDROID, pBuffer: ptr ptr AHardwareBuffer): VkResult {.stdcall.}
  vkCmdDrawIndirectCount*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: uint32, stride: uint32) {.stdcall.}
  vkCmdDrawIndexedIndirectCount*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: uint32, stride: uint32) {.stdcall.}
  vkCmdSetCheckpointNV*: proc (commandBuffer: VkCommandBuffer, pCheckpointMarker: pointer) {.stdcall.}
  vkGetQueueCheckpointDataNV*: proc (queue: VkQueue, pCheckpointDataCount: ptr uint32, pCheckpointData: ptr VkCheckpointDataNV) {.stdcall.}
  vkCmdBindTransformFeedbackBuffersEXT*: proc (commandBuffer: VkCommandBuffer, firstBinding: uint32, bindingCount: uint32, pBuffers: ptr VkBuffer, pOffsets: ptr VkDeviceSize, pSizes: ptr VkDeviceSize) {.stdcall.}
  vkCmdBeginTransformFeedbackEXT*: proc (commandBuffer: VkCommandBuffer, firstCounterBuffer: uint32, counterBufferCount: uint32, pCounterBuffers: ptr VkBuffer, pCounterBufferOffsets: ptr VkDeviceSize) {.stdcall.}
  vkCmdEndTransformFeedbackEXT*: proc (commandBuffer: VkCommandBuffer, firstCounterBuffer: uint32, counterBufferCount: uint32, pCounterBuffers: ptr VkBuffer, pCounterBufferOffsets: ptr VkDeviceSize) {.stdcall.}
  vkCmdBeginQueryIndexedEXT*: proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32, flags: VkQueryControlFlags, index: uint32) {.stdcall.}
  vkCmdEndQueryIndexedEXT*: proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32, index: uint32) {.stdcall.}
  vkCmdDrawIndirectByteCountEXT*: proc (commandBuffer: VkCommandBuffer, instanceCount: uint32, firstInstance: uint32, counterBuffer: VkBuffer, counterBufferOffset: VkDeviceSize, counterOffset: uint32, vertexStride: uint32) {.stdcall.}
  vkCmdSetExclusiveScissorNV*: proc (commandBuffer: VkCommandBuffer, firstExclusiveScissor: uint32, exclusiveScissorCount: uint32, pExclusiveScissors: ptr VkRect2D) {.stdcall.}
  vkCmdSetExclusiveScissorEnableNV*: proc (commandBuffer: VkCommandBuffer, firstExclusiveScissor: uint32, exclusiveScissorCount: uint32, pExclusiveScissorEnables: ptr VkBool32) {.stdcall.}
  vkCmdBindShadingRateImageNV*: proc (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) {.stdcall.}
  vkCmdSetViewportShadingRatePaletteNV*: proc (commandBuffer: VkCommandBuffer, firstViewport: uint32, viewportCount: uint32, pShadingRatePalettes: ptr VkShadingRatePaletteNV) {.stdcall.}
  vkCmdSetCoarseSampleOrderNV*: proc (commandBuffer: VkCommandBuffer, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrderCount: uint32, pCustomSampleOrders: ptr VkCoarseSampleOrderCustomNV) {.stdcall.}
  vkCmdDrawMeshTasksNV*: proc (commandBuffer: VkCommandBuffer, taskCount: uint32, firstTask: uint32) {.stdcall.}
  vkCmdDrawMeshTasksIndirectNV*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: uint32, stride: uint32) {.stdcall.}
  vkCmdDrawMeshTasksIndirectCountNV*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: uint32, stride: uint32) {.stdcall.}
  vkCmdDrawMeshTasksEXT*: proc (commandBuffer: VkCommandBuffer, groupCountX: uint32, groupCountY: uint32, groupCountZ: uint32) {.stdcall.}
  vkCmdDrawMeshTasksIndirectEXT*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: uint32, stride: uint32) {.stdcall.}
  vkCmdDrawMeshTasksIndirectCountEXT*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: uint32, stride: uint32) {.stdcall.}
  vkCompileDeferredNV*: proc (device: VkDevice, pipeline: VkPipeline, shader: uint32): VkResult {.stdcall.}
  vkCreateAccelerationStructureNV*: proc (device: VkDevice, pCreateInfo: ptr VkAccelerationStructureCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pAccelerationStructure: ptr VkAccelerationStructureNV): VkResult {.stdcall.}
  vkCmdBindInvocationMaskHUAWEI*: proc (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) {.stdcall.}
  vkDestroyAccelerationStructureKHR*: proc (device: VkDevice, accelerationStructure: VkAccelerationStructureKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkDestroyAccelerationStructureNV*: proc (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetAccelerationStructureMemoryRequirementsNV*: proc (device: VkDevice, pInfo: ptr VkAccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: ptr VkMemoryRequirements2KHR) {.stdcall.}
  vkBindAccelerationStructureMemoryNV*: proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindAccelerationStructureMemoryInfoNV): VkResult {.stdcall.}
  vkCmdCopyAccelerationStructureNV*: proc (commandBuffer: VkCommandBuffer, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, mode: VkCopyAccelerationStructureModeKHR) {.stdcall.}
  vkCmdCopyAccelerationStructureKHR*: proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyAccelerationStructureInfoKHR) {.stdcall.}
  vkCopyAccelerationStructureKHR*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyAccelerationStructureInfoKHR): VkResult {.stdcall.}
  vkCmdCopyAccelerationStructureToMemoryKHR*: proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyAccelerationStructureToMemoryInfoKHR) {.stdcall.}
  vkCopyAccelerationStructureToMemoryKHR*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyAccelerationStructureToMemoryInfoKHR): VkResult {.stdcall.}
  vkCmdCopyMemoryToAccelerationStructureKHR*: proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyMemoryToAccelerationStructureInfoKHR) {.stdcall.}
  vkCopyMemoryToAccelerationStructureKHR*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyMemoryToAccelerationStructureInfoKHR): VkResult {.stdcall.}
  vkCmdWriteAccelerationStructuresPropertiesKHR*: proc (commandBuffer: VkCommandBuffer, accelerationStructureCount: uint32, pAccelerationStructures: ptr VkAccelerationStructureKHR, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: uint32) {.stdcall.}
  vkCmdWriteAccelerationStructuresPropertiesNV*: proc (commandBuffer: VkCommandBuffer, accelerationStructureCount: uint32, pAccelerationStructures: ptr VkAccelerationStructureNV, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: uint32) {.stdcall.}
  vkCmdBuildAccelerationStructureNV*: proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkAccelerationStructureInfoNV, instanceData: VkBuffer, instanceOffset: VkDeviceSize, update: VkBool32, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, scratch: VkBuffer, scratchOffset: VkDeviceSize) {.stdcall.}
  vkWriteAccelerationStructuresPropertiesKHR*: proc (device: VkDevice, accelerationStructureCount: uint32, pAccelerationStructures: ptr VkAccelerationStructureKHR, queryType: VkQueryType, dataSize: uint, pData: pointer, stride: uint): VkResult {.stdcall.}
  vkCmdTraceRaysKHR*: proc (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, width: uint32, height: uint32, depth: uint32) {.stdcall.}
  vkCmdTraceRaysNV*: proc (commandBuffer: VkCommandBuffer, raygenShaderBindingTableBuffer: VkBuffer, raygenShaderBindingOffset: VkDeviceSize, missShaderBindingTableBuffer: VkBuffer, missShaderBindingOffset: VkDeviceSize, missShaderBindingStride: VkDeviceSize, hitShaderBindingTableBuffer: VkBuffer, hitShaderBindingOffset: VkDeviceSize, hitShaderBindingStride: VkDeviceSize, callableShaderBindingTableBuffer: VkBuffer, callableShaderBindingOffset: VkDeviceSize, callableShaderBindingStride: VkDeviceSize, width: uint32, height: uint32, depth: uint32) {.stdcall.}
  vkGetRayTracingShaderGroupHandlesKHR*: proc (device: VkDevice, pipeline: VkPipeline, firstGroup: uint32, groupCount: uint32, dataSize: uint, pData: pointer): VkResult {.stdcall.}
  vkGetRayTracingCaptureReplayShaderGroupHandlesKHR*: proc (device: VkDevice, pipeline: VkPipeline, firstGroup: uint32, groupCount: uint32, dataSize: uint, pData: pointer): VkResult {.stdcall.}
  vkGetAccelerationStructureHandleNV*: proc (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, dataSize: uint, pData: pointer): VkResult {.stdcall.}
  vkCreateRayTracingPipelinesNV*: proc (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkRayTracingPipelineCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}
  vkCreateRayTracingPipelinesKHR*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkRayTracingPipelineCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}
  vkGetPhysicalDeviceCooperativeMatrixPropertiesNV*: proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkCooperativeMatrixPropertiesNV): VkResult {.stdcall.}
  vkCmdTraceRaysIndirectKHR*: proc (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, indirectDeviceAddress: VkDeviceAddress) {.stdcall.}
  vkCmdTraceRaysIndirect2KHR*: proc (commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) {.stdcall.}
  vkGetClusterAccelerationStructureBuildSizesNV*: proc (device: VkDevice, pInfo: ptr VkClusterAccelerationStructureInputInfoNV, pSizeInfo: ptr VkAccelerationStructureBuildSizesInfoKHR) {.stdcall.}
  vkCmdBuildClusterAccelerationStructureIndirectNV*: proc (commandBuffer: VkCommandBuffer, pCommandInfos: ptr VkClusterAccelerationStructureCommandsInfoNV) {.stdcall.}
  vkGetDeviceAccelerationStructureCompatibilityKHR*: proc (device: VkDevice, pVersionInfo: ptr VkAccelerationStructureVersionInfoKHR, pCompatibility: ptr VkAccelerationStructureCompatibilityKHR) {.stdcall.}
  vkGetRayTracingShaderGroupStackSizeKHR*: proc (device: VkDevice, pipeline: VkPipeline, group: uint32, groupShader: VkShaderGroupShaderKHR): VkDeviceSize {.stdcall.}
  vkCmdSetRayTracingPipelineStackSizeKHR*: proc (commandBuffer: VkCommandBuffer, pipelineStackSize: uint32) {.stdcall.}
  vkGetImageViewHandleNVX*: proc (device: VkDevice, pInfo: ptr VkImageViewHandleInfoNVX): uint32 {.stdcall.}
  vkGetImageViewHandle64NVX*: proc (device: VkDevice, pInfo: ptr VkImageViewHandleInfoNVX): uint64 {.stdcall.}
  vkGetImageViewAddressNVX*: proc (device: VkDevice, imageView: VkImageView, pProperties: ptr VkImageViewAddressPropertiesNVX): VkResult {.stdcall.}
  vkGetDeviceCombinedImageSamplerIndexNVX*: proc (device: VkDevice, imageViewIndex: uint64, samplerIndex: uint64): uint64 {.stdcall.}
  vkGetPhysicalDeviceSurfacePresentModes2EXT*: proc (physicalDevice: VkPhysicalDevice, pSurfaceInfo: ptr VkPhysicalDeviceSurfaceInfo2KHR, pPresentModeCount: ptr uint32, pPresentModes: ptr VkPresentModeKHR): VkResult {.stdcall.}
  vkGetDeviceGroupSurfacePresentModes2EXT*: proc (device: VkDevice, pSurfaceInfo: ptr VkPhysicalDeviceSurfaceInfo2KHR, pModes: ptr VkDeviceGroupPresentModeFlagsKHR): VkResult {.stdcall.}
  vkAcquireFullScreenExclusiveModeEXT*: proc (device: VkDevice, swapchain: VkSwapchainKHR): VkResult {.stdcall.}
  vkReleaseFullScreenExclusiveModeEXT*: proc (device: VkDevice, swapchain: VkSwapchainKHR): VkResult {.stdcall.}
  vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, pCounterCount: ptr uint32, pCounters: ptr VkPerformanceCounterKHR, pCounterDescriptions: ptr VkPerformanceCounterDescriptionKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR*: proc (physicalDevice: VkPhysicalDevice, pPerformanceQueryCreateInfo: ptr VkQueryPoolPerformanceCreateInfoKHR, pNumPasses: ptr uint32) {.stdcall.}
  vkAcquireProfilingLockKHR*: proc (device: VkDevice, pInfo: ptr VkAcquireProfilingLockInfoKHR): VkResult {.stdcall.}
  vkReleaseProfilingLockKHR*: proc (device: VkDevice) {.stdcall.}
  vkGetImageDrmFormatModifierPropertiesEXT*: proc (device: VkDevice, image: VkImage, pProperties: ptr VkImageDrmFormatModifierPropertiesEXT): VkResult {.stdcall.}
  vkGetBufferOpaqueCaptureAddress*: proc (device: VkDevice, pInfo: ptr VkBufferDeviceAddressInfo): uint64 {.stdcall.}
  vkGetBufferDeviceAddress*: proc (device: VkDevice, pInfo: ptr VkBufferDeviceAddressInfo): VkDeviceAddress {.stdcall.}
  vkCreateHeadlessSurfaceEXT*: proc (instance: VkInstance, pCreateInfo: ptr VkHeadlessSurfaceCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV*: proc (physicalDevice: VkPhysicalDevice, pCombinationCount: ptr uint32, pCombinations: ptr VkFramebufferMixedSamplesCombinationNV): VkResult {.stdcall.}
  vkInitializePerformanceApiINTEL*: proc (device: VkDevice, pInitializeInfo: ptr VkInitializePerformanceApiInfoINTEL): VkResult {.stdcall.}
  vkUninitializePerformanceApiINTEL*: proc (device: VkDevice) {.stdcall.}
  vkCmdSetPerformanceMarkerINTEL*: proc (commandBuffer: VkCommandBuffer, pMarkerInfo: ptr VkPerformanceMarkerInfoINTEL): VkResult {.stdcall.}
  vkCmdSetPerformanceStreamMarkerINTEL*: proc (commandBuffer: VkCommandBuffer, pMarkerInfo: ptr VkPerformanceStreamMarkerInfoINTEL): VkResult {.stdcall.}
  vkCmdSetPerformanceOverrideINTEL*: proc (commandBuffer: VkCommandBuffer, pOverrideInfo: ptr VkPerformanceOverrideInfoINTEL): VkResult {.stdcall.}
  vkAcquirePerformanceConfigurationINTEL*: proc (device: VkDevice, pAcquireInfo: ptr VkPerformanceConfigurationAcquireInfoINTEL, pConfiguration: ptr VkPerformanceConfigurationINTEL): VkResult {.stdcall.}
  vkReleasePerformanceConfigurationINTEL*: proc (device: VkDevice, configuration: VkPerformanceConfigurationINTEL): VkResult {.stdcall.}
  vkQueueSetPerformanceConfigurationINTEL*: proc (queue: VkQueue, configuration: VkPerformanceConfigurationINTEL): VkResult {.stdcall.}
  vkGetPerformanceParameterINTEL*: proc (device: VkDevice, parameter: VkPerformanceParameterTypeINTEL, pValue: ptr VkPerformanceValueINTEL): VkResult {.stdcall.}
  vkGetDeviceMemoryOpaqueCaptureAddress*: proc (device: VkDevice, pInfo: ptr VkDeviceMemoryOpaqueCaptureAddressInfo): uint64 {.stdcall.}
  vkGetPipelineExecutablePropertiesKHR*: proc (device: VkDevice, pPipelineInfo: ptr VkPipelineInfoKHR, pExecutableCount: ptr uint32, pProperties: ptr VkPipelineExecutablePropertiesKHR): VkResult {.stdcall.}
  vkGetPipelineExecutableStatisticsKHR*: proc (device: VkDevice, pExecutableInfo: ptr VkPipelineExecutableInfoKHR, pStatisticCount: ptr uint32, pStatistics: ptr VkPipelineExecutableStatisticKHR): VkResult {.stdcall.}
  vkGetPipelineExecutableInternalRepresentationsKHR*: proc (device: VkDevice, pExecutableInfo: ptr VkPipelineExecutableInfoKHR, pInternalRepresentationCount: ptr uint32, pInternalRepresentations: ptr VkPipelineExecutableInternalRepresentationKHR): VkResult {.stdcall.}
  vkCmdSetLineStipple*: proc (commandBuffer: VkCommandBuffer, lineStippleFactor: uint32, lineStipplePattern: uint16) {.stdcall.}
  vkGetFaultData*: proc (device: VkDevice, faultQueryBehavior: VkFaultQueryBehavior, pUnrecordedFaults: ptr VkBool32, pFaultCount: ptr uint32, pFaults: ptr VkFaultData): VkResult {.stdcall.}
  vkGetPhysicalDeviceToolProperties*: proc (physicalDevice: VkPhysicalDevice, pToolCount: ptr uint32, pToolProperties: ptr VkPhysicalDeviceToolProperties): VkResult {.stdcall.}
  vkCreateAccelerationStructureKHR*: proc (device: VkDevice, pCreateInfo: ptr VkAccelerationStructureCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pAccelerationStructure: ptr VkAccelerationStructureKHR): VkResult {.stdcall.}
  vkCmdBuildAccelerationStructuresKHR*: proc (commandBuffer: VkCommandBuffer, infoCount: uint32, pInfos: ptr VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: ptr ptr VkAccelerationStructureBuildRangeInfoKHR) {.stdcall.}
  vkCmdBuildAccelerationStructuresIndirectKHR*: proc (commandBuffer: VkCommandBuffer, infoCount: uint32, pInfos: ptr VkAccelerationStructureBuildGeometryInfoKHR, pIndirectDeviceAddresses: ptr VkDeviceAddress, pIndirectStrides: ptr uint32, ppMaxPrimitiveCounts: ptr ptr uint32) {.stdcall.}
  vkBuildAccelerationStructuresKHR*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: uint32, pInfos: ptr VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: ptr ptr VkAccelerationStructureBuildRangeInfoKHR): VkResult {.stdcall.}
  vkGetAccelerationStructureDeviceAddressKHR*: proc (device: VkDevice, pInfo: ptr VkAccelerationStructureDeviceAddressInfoKHR): VkDeviceAddress {.stdcall.}
  vkCreateDeferredOperationKHR*: proc (device: VkDevice, pAllocator: ptr VkAllocationCallbacks, pDeferredOperation: ptr VkDeferredOperationKHR): VkResult {.stdcall.}
  vkDestroyDeferredOperationKHR*: proc (device: VkDevice, operation: VkDeferredOperationKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetDeferredOperationMaxConcurrencyKHR*: proc (device: VkDevice, operation: VkDeferredOperationKHR): uint32 {.stdcall.}
  vkGetDeferredOperationResultKHR*: proc (device: VkDevice, operation: VkDeferredOperationKHR): VkResult {.stdcall.}
  vkDeferredOperationJoinKHR*: proc (device: VkDevice, operation: VkDeferredOperationKHR): VkResult {.stdcall.}
  vkGetPipelineIndirectMemoryRequirementsNV*: proc (device: VkDevice, pCreateInfo: ptr VkComputePipelineCreateInfo, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkGetPipelineIndirectDeviceAddressNV*: proc (device: VkDevice, pInfo: ptr VkPipelineIndirectDeviceAddressInfoNV): VkDeviceAddress {.stdcall.}
  vkAntiLagUpdateAMD*: proc (device: VkDevice, pData: ptr VkAntiLagDataAMD) {.stdcall.}
  vkCmdSetCullMode*: proc (commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) {.stdcall.}
  vkCmdSetFrontFace*: proc (commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) {.stdcall.}
  vkCmdSetPrimitiveTopology*: proc (commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) {.stdcall.}
  vkCmdSetViewportWithCount*: proc (commandBuffer: VkCommandBuffer, viewportCount: uint32, pViewports: ptr VkViewport) {.stdcall.}
  vkCmdSetScissorWithCount*: proc (commandBuffer: VkCommandBuffer, scissorCount: uint32, pScissors: ptr VkRect2D) {.stdcall.}
  vkCmdBindIndexBuffer2*: proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) {.stdcall.}
  vkCmdBindVertexBuffers2*: proc (commandBuffer: VkCommandBuffer, firstBinding: uint32, bindingCount: uint32, pBuffers: ptr VkBuffer, pOffsets: ptr VkDeviceSize, pSizes: ptr VkDeviceSize, pStrides: ptr VkDeviceSize) {.stdcall.}
  vkCmdSetDepthTestEnable*: proc (commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) {.stdcall.}
  vkCmdSetDepthWriteEnable*: proc (commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) {.stdcall.}
  vkCmdSetDepthCompareOp*: proc (commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) {.stdcall.}
  vkCmdSetDepthBoundsTestEnable*: proc (commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) {.stdcall.}
  vkCmdSetStencilTestEnable*: proc (commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) {.stdcall.}
  vkCmdSetStencilOp*: proc (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) {.stdcall.}
  vkCmdSetPatchControlPointsEXT*: proc (commandBuffer: VkCommandBuffer, patchControlPoints: uint32) {.stdcall.}
  vkCmdSetRasterizerDiscardEnable*: proc (commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) {.stdcall.}
  vkCmdSetDepthBiasEnable*: proc (commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) {.stdcall.}
  vkCmdSetLogicOpEXT*: proc (commandBuffer: VkCommandBuffer, logicOp: VkLogicOp) {.stdcall.}
  vkCmdSetPrimitiveRestartEnable*: proc (commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) {.stdcall.}
  vkCmdSetTessellationDomainOriginEXT*: proc (commandBuffer: VkCommandBuffer, domainOrigin: VkTessellationDomainOrigin) {.stdcall.}
  vkCmdSetDepthClampEnableEXT*: proc (commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) {.stdcall.}
  vkCmdSetPolygonModeEXT*: proc (commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode) {.stdcall.}
  vkCmdSetRasterizationSamplesEXT*: proc (commandBuffer: VkCommandBuffer, rasterizationSamples: VkSampleCountFlagBits) {.stdcall.}
  vkCmdSetSampleMaskEXT*: proc (commandBuffer: VkCommandBuffer, samples: VkSampleCountFlagBits, pSampleMask: ptr VkSampleMask) {.stdcall.}
  vkCmdSetAlphaToCoverageEnableEXT*: proc (commandBuffer: VkCommandBuffer, alphaToCoverageEnable: VkBool32) {.stdcall.}
  vkCmdSetAlphaToOneEnableEXT*: proc (commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32) {.stdcall.}
  vkCmdSetLogicOpEnableEXT*: proc (commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32) {.stdcall.}
  vkCmdSetColorBlendEnableEXT*: proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorBlendEnables: ptr VkBool32) {.stdcall.}
  vkCmdSetColorBlendEquationEXT*: proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorBlendEquations: ptr VkColorBlendEquationEXT) {.stdcall.}
  vkCmdSetColorWriteMaskEXT*: proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorWriteMasks: ptr VkColorComponentFlags) {.stdcall.}
  vkCmdSetRasterizationStreamEXT*: proc (commandBuffer: VkCommandBuffer, rasterizationStream: uint32) {.stdcall.}
  vkCmdSetConservativeRasterizationModeEXT*: proc (commandBuffer: VkCommandBuffer, conservativeRasterizationMode: VkConservativeRasterizationModeEXT) {.stdcall.}
  vkCmdSetExtraPrimitiveOverestimationSizeEXT*: proc (commandBuffer: VkCommandBuffer, extraPrimitiveOverestimationSize: float32) {.stdcall.}
  vkCmdSetDepthClipEnableEXT*: proc (commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32) {.stdcall.}
  vkCmdSetSampleLocationsEnableEXT*: proc (commandBuffer: VkCommandBuffer, sampleLocationsEnable: VkBool32) {.stdcall.}
  vkCmdSetColorBlendAdvancedEXT*: proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorBlendAdvanced: ptr VkColorBlendAdvancedEXT) {.stdcall.}
  vkCmdSetProvokingVertexModeEXT*: proc (commandBuffer: VkCommandBuffer, provokingVertexMode: VkProvokingVertexModeEXT) {.stdcall.}
  vkCmdSetLineRasterizationModeEXT*: proc (commandBuffer: VkCommandBuffer, lineRasterizationMode: VkLineRasterizationModeEXT) {.stdcall.}
  vkCmdSetLineStippleEnableEXT*: proc (commandBuffer: VkCommandBuffer, stippledLineEnable: VkBool32) {.stdcall.}
  vkCmdSetDepthClipNegativeOneToOneEXT*: proc (commandBuffer: VkCommandBuffer, negativeOneToOne: VkBool32) {.stdcall.}
  vkCmdSetViewportWScalingEnableNV*: proc (commandBuffer: VkCommandBuffer, viewportWScalingEnable: VkBool32) {.stdcall.}
  vkCmdSetViewportSwizzleNV*: proc (commandBuffer: VkCommandBuffer, firstViewport: uint32, viewportCount: uint32, pViewportSwizzles: ptr VkViewportSwizzleNV) {.stdcall.}
  vkCmdSetCoverageToColorEnableNV*: proc (commandBuffer: VkCommandBuffer, coverageToColorEnable: VkBool32) {.stdcall.}
  vkCmdSetCoverageToColorLocationNV*: proc (commandBuffer: VkCommandBuffer, coverageToColorLocation: uint32) {.stdcall.}
  vkCmdSetCoverageModulationModeNV*: proc (commandBuffer: VkCommandBuffer, coverageModulationMode: VkCoverageModulationModeNV) {.stdcall.}
  vkCmdSetCoverageModulationTableEnableNV*: proc (commandBuffer: VkCommandBuffer, coverageModulationTableEnable: VkBool32) {.stdcall.}
  vkCmdSetCoverageModulationTableNV*: proc (commandBuffer: VkCommandBuffer, coverageModulationTableCount: uint32, pCoverageModulationTable: ptr float32) {.stdcall.}
  vkCmdSetShadingRateImageEnableNV*: proc (commandBuffer: VkCommandBuffer, shadingRateImageEnable: VkBool32) {.stdcall.}
  vkCmdSetCoverageReductionModeNV*: proc (commandBuffer: VkCommandBuffer, coverageReductionMode: VkCoverageReductionModeNV) {.stdcall.}
  vkCmdSetRepresentativeFragmentTestEnableNV*: proc (commandBuffer: VkCommandBuffer, representativeFragmentTestEnable: VkBool32) {.stdcall.}
  vkCreatePrivateDataSlot*: proc (device: VkDevice, pCreateInfo: ptr VkPrivateDataSlotCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPrivateDataSlot: ptr VkPrivateDataSlot): VkResult {.stdcall.}
  vkDestroyPrivateDataSlot*: proc (device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkSetPrivateData*: proc (device: VkDevice, objectType: VkObjectType, objectHandle: uint64, privateDataSlot: VkPrivateDataSlot, data: uint64): VkResult {.stdcall.}
  vkGetPrivateData*: proc (device: VkDevice, objectType: VkObjectType, objectHandle: uint64, privateDataSlot: VkPrivateDataSlot, pData: ptr uint64) {.stdcall.}
  vkCmdCopyBuffer2*: proc (commandBuffer: VkCommandBuffer, pCopyBufferInfo: ptr VkCopyBufferInfo2) {.stdcall.}
  vkCmdCopyImage2*: proc (commandBuffer: VkCommandBuffer, pCopyImageInfo: ptr VkCopyImageInfo2) {.stdcall.}
  vkCmdBlitImage2*: proc (commandBuffer: VkCommandBuffer, pBlitImageInfo: ptr VkBlitImageInfo2) {.stdcall.}
  vkCmdCopyBufferToImage2*: proc (commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: ptr VkCopyBufferToImageInfo2) {.stdcall.}
  vkCmdCopyImageToBuffer2*: proc (commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: ptr VkCopyImageToBufferInfo2) {.stdcall.}
  vkCmdResolveImage2*: proc (commandBuffer: VkCommandBuffer, pResolveImageInfo: ptr VkResolveImageInfo2) {.stdcall.}
  vkCmdRefreshObjectsKHR*: proc (commandBuffer: VkCommandBuffer, pRefreshObjects: ptr VkRefreshObjectListKHR) {.stdcall.}
  vkGetPhysicalDeviceRefreshableObjectTypesKHR*: proc (physicalDevice: VkPhysicalDevice, pRefreshableObjectTypeCount: ptr uint32, pRefreshableObjectTypes: ptr VkObjectType): VkResult {.stdcall.}
  vkCmdSetFragmentShadingRateKHR*: proc (commandBuffer: VkCommandBuffer, pFragmentSize: ptr VkExtent2D, combinerOps: array[2, VkFragmentShadingRateCombinerOpKHR]) {.stdcall.}
  vkGetPhysicalDeviceFragmentShadingRatesKHR*: proc (physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: ptr uint32, pFragmentShadingRates: ptr VkPhysicalDeviceFragmentShadingRateKHR): VkResult {.stdcall.}
  vkCmdSetFragmentShadingRateEnumNV*: proc (commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: array[2, VkFragmentShadingRateCombinerOpKHR]) {.stdcall.}
  vkGetAccelerationStructureBuildSizesKHR*: proc (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: ptr VkAccelerationStructureBuildGeometryInfoKHR, pMaxPrimitiveCounts: ptr uint32, pSizeInfo: ptr VkAccelerationStructureBuildSizesInfoKHR) {.stdcall.}
  vkCmdSetVertexInputEXT*: proc (commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: uint32, pVertexBindingDescriptions: ptr VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: uint32, pVertexAttributeDescriptions: ptr VkVertexInputAttributeDescription2EXT) {.stdcall.}
  vkCmdSetColorWriteEnableEXT*: proc (commandBuffer: VkCommandBuffer, attachmentCount: uint32, pColorWriteEnables: ptr VkBool32) {.stdcall.}
  vkCmdSetEvent2*: proc (commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: ptr VkDependencyInfo) {.stdcall.}
  vkCmdResetEvent2*: proc (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) {.stdcall.}
  vkCmdWaitEvents2*: proc (commandBuffer: VkCommandBuffer, eventCount: uint32, pEvents: ptr VkEvent, pDependencyInfos: ptr VkDependencyInfo) {.stdcall.}
  vkCmdPipelineBarrier2*: proc (commandBuffer: VkCommandBuffer, pDependencyInfo: ptr VkDependencyInfo) {.stdcall.}
  vkQueueSubmit2*: proc (queue: VkQueue, submitCount: uint32, pSubmits: ptr VkSubmitInfo2, fence: VkFence): VkResult {.stdcall.}
  vkCmdWriteTimestamp2*: proc (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: uint32) {.stdcall.}
  vkCmdWriteBufferMarker2AMD*: proc (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: uint32) {.stdcall.}
  vkGetQueueCheckpointData2NV*: proc (queue: VkQueue, pCheckpointDataCount: ptr uint32, pCheckpointData: ptr VkCheckpointData2NV) {.stdcall.}
  vkCopyMemoryToImage*: proc (device: VkDevice, pCopyMemoryToImageInfo: ptr VkCopyMemoryToImageInfo): VkResult {.stdcall.}
  vkCopyImageToMemory*: proc (device: VkDevice, pCopyImageToMemoryInfo: ptr VkCopyImageToMemoryInfo): VkResult {.stdcall.}
  vkCopyImageToImage*: proc (device: VkDevice, pCopyImageToImageInfo: ptr VkCopyImageToImageInfo): VkResult {.stdcall.}
  vkTransitionImageLayout*: proc (device: VkDevice, transitionCount: uint32, pTransitions: ptr VkHostImageLayoutTransitionInfo): VkResult {.stdcall.}
  vkGetCommandPoolMemoryConsumption*: proc (device: VkDevice, commandPool: VkCommandPool, commandBuffer: VkCommandBuffer, pConsumption: ptr VkCommandPoolMemoryConsumption) {.stdcall.}
  vkGetPhysicalDeviceVideoCapabilitiesKHR*: proc (physicalDevice: VkPhysicalDevice, pVideoProfile: ptr VkVideoProfileInfoKHR, pCapabilities: ptr VkVideoCapabilitiesKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceVideoFormatPropertiesKHR*: proc (physicalDevice: VkPhysicalDevice, pVideoFormatInfo: ptr VkPhysicalDeviceVideoFormatInfoKHR, pVideoFormatPropertyCount: ptr uint32, pVideoFormatProperties: ptr VkVideoFormatPropertiesKHR): VkResult {.stdcall.}
  vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR*: proc (physicalDevice: VkPhysicalDevice, pQualityLevelInfo: ptr VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: ptr VkVideoEncodeQualityLevelPropertiesKHR): VkResult {.stdcall.}
  vkCreateVideoSessionKHR*: proc (device: VkDevice, pCreateInfo: ptr VkVideoSessionCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pVideoSession: ptr VkVideoSessionKHR): VkResult {.stdcall.}
  vkDestroyVideoSessionKHR*: proc (device: VkDevice, videoSession: VkVideoSessionKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateVideoSessionParametersKHR*: proc (device: VkDevice, pCreateInfo: ptr VkVideoSessionParametersCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pVideoSessionParameters: ptr VkVideoSessionParametersKHR): VkResult {.stdcall.}
  vkUpdateVideoSessionParametersKHR*: proc (device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pUpdateInfo: ptr VkVideoSessionParametersUpdateInfoKHR): VkResult {.stdcall.}
  vkGetEncodedVideoSessionParametersKHR*: proc (device: VkDevice, pVideoSessionParametersInfo: ptr VkVideoEncodeSessionParametersGetInfoKHR, pFeedbackInfo: ptr VkVideoEncodeSessionParametersFeedbackInfoKHR, pDataSize: ptr uint, pData: pointer): VkResult {.stdcall.}
  vkDestroyVideoSessionParametersKHR*: proc (device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetVideoSessionMemoryRequirementsKHR*: proc (device: VkDevice, videoSession: VkVideoSessionKHR, pMemoryRequirementsCount: ptr uint32, pMemoryRequirements: ptr VkVideoSessionMemoryRequirementsKHR): VkResult {.stdcall.}
  vkBindVideoSessionMemoryKHR*: proc (device: VkDevice, videoSession: VkVideoSessionKHR, bindSessionMemoryInfoCount: uint32, pBindSessionMemoryInfos: ptr VkBindVideoSessionMemoryInfoKHR): VkResult {.stdcall.}
  vkCmdDecodeVideoKHR*: proc (commandBuffer: VkCommandBuffer, pDecodeInfo: ptr VkVideoDecodeInfoKHR) {.stdcall.}
  vkCmdBeginVideoCodingKHR*: proc (commandBuffer: VkCommandBuffer, pBeginInfo: ptr VkVideoBeginCodingInfoKHR) {.stdcall.}
  vkCmdControlVideoCodingKHR*: proc (commandBuffer: VkCommandBuffer, pCodingControlInfo: ptr VkVideoCodingControlInfoKHR) {.stdcall.}
  vkCmdEndVideoCodingKHR*: proc (commandBuffer: VkCommandBuffer, pEndCodingInfo: ptr VkVideoEndCodingInfoKHR) {.stdcall.}
  vkCmdEncodeVideoKHR*: proc (commandBuffer: VkCommandBuffer, pEncodeInfo: ptr VkVideoEncodeInfoKHR) {.stdcall.}
  vkCmdDecompressMemoryNV*: proc (commandBuffer: VkCommandBuffer, decompressRegionCount: uint32, pDecompressMemoryRegions: ptr VkDecompressMemoryRegionNV) {.stdcall.}
  vkCmdDecompressMemoryIndirectCountNV*: proc (commandBuffer: VkCommandBuffer, indirectCommandsAddress: VkDeviceAddress, indirectCommandsCountAddress: VkDeviceAddress, stride: uint32) {.stdcall.}
  vkGetPartitionedAccelerationStructuresBuildSizesNV*: proc (device: VkDevice, pInfo: ptr VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: ptr VkAccelerationStructureBuildSizesInfoKHR) {.stdcall.}
  vkCmdBuildPartitionedAccelerationStructuresNV*: proc (commandBuffer: VkCommandBuffer, pBuildInfo: ptr VkBuildPartitionedAccelerationStructureInfoNV) {.stdcall.}
  vkCmdDecompressMemoryEXT*: proc (commandBuffer: VkCommandBuffer, pDecompressMemoryInfoEXT: ptr VkDecompressMemoryInfoEXT) {.stdcall.}
  vkCmdDecompressMemoryIndirectCountEXT*: proc (commandBuffer: VkCommandBuffer, decompressionMethod: VkMemoryDecompressionMethodFlagsEXT, indirectCommandsAddress: VkDeviceAddress, indirectCommandsCountAddress: VkDeviceAddress, maxDecompressionCount: uint32, stride: uint32) {.stdcall.}
  vkCreateCuModuleNVX*: proc (device: VkDevice, pCreateInfo: ptr VkCuModuleCreateInfoNVX, pAllocator: ptr VkAllocationCallbacks, pModule: ptr VkCuModuleNVX): VkResult {.stdcall.}
  vkCreateCuFunctionNVX*: proc (device: VkDevice, pCreateInfo: ptr VkCuFunctionCreateInfoNVX, pAllocator: ptr VkAllocationCallbacks, pFunction: ptr VkCuFunctionNVX): VkResult {.stdcall.}
  vkDestroyCuModuleNVX*: proc (device: VkDevice, module: VkCuModuleNVX, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkDestroyCuFunctionNVX*: proc (device: VkDevice, function: VkCuFunctionNVX, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCmdCuLaunchKernelNVX*: proc (commandBuffer: VkCommandBuffer, pLaunchInfo: ptr VkCuLaunchInfoNVX) {.stdcall.}
  vkGetDescriptorSetLayoutSizeEXT*: proc (device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: ptr VkDeviceSize) {.stdcall.}
  vkGetDescriptorSetLayoutBindingOffsetEXT*: proc (device: VkDevice, layout: VkDescriptorSetLayout, binding: uint32, pOffset: ptr VkDeviceSize) {.stdcall.}
  vkGetDescriptorEXT*: proc (device: VkDevice, pDescriptorInfo: ptr VkDescriptorGetInfoEXT, dataSize: uint, pDescriptor: pointer) {.stdcall.}
  vkCmdBindDescriptorBuffersEXT*: proc (commandBuffer: VkCommandBuffer, bufferCount: uint32, pBindingInfos: ptr VkDescriptorBufferBindingInfoEXT) {.stdcall.}
  vkCmdSetDescriptorBufferOffsetsEXT*: proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: uint32, setCount: uint32, pBufferIndices: ptr uint32, pOffsets: ptr VkDeviceSize) {.stdcall.}
  vkCmdBindDescriptorBufferEmbeddedSamplersEXT*: proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: uint32) {.stdcall.}
  vkGetBufferOpaqueCaptureDescriptorDataEXT*: proc (device: VkDevice, pInfo: ptr VkBufferCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}
  vkGetImageOpaqueCaptureDescriptorDataEXT*: proc (device: VkDevice, pInfo: ptr VkImageCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}
  vkGetImageViewOpaqueCaptureDescriptorDataEXT*: proc (device: VkDevice, pInfo: ptr VkImageViewCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}
  vkGetSamplerOpaqueCaptureDescriptorDataEXT*: proc (device: VkDevice, pInfo: ptr VkSamplerCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}
  vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT*: proc (device: VkDevice, pInfo: ptr VkAccelerationStructureCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}
  vkSetDeviceMemoryPriorityEXT*: proc (device: VkDevice, memory: VkDeviceMemory, priority: float32) {.stdcall.}
  vkAcquireDrmDisplayEXT*: proc (physicalDevice: VkPhysicalDevice, drmFd: int32, display: VkDisplayKHR): VkResult {.stdcall.}
  vkGetDrmDisplayEXT*: proc (physicalDevice: VkPhysicalDevice, drmFd: int32, connectorId: uint32, display: ptr VkDisplayKHR): VkResult {.stdcall.}
  vkWaitForPresent2KHR*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: ptr VkPresentWait2InfoKHR): VkResult {.stdcall.}
  vkWaitForPresentKHR*: proc (device: VkDevice, swapchain: VkSwapchainKHR, presentId: uint64, timeout: uint64): VkResult {.stdcall.}
  vkCreateBufferCollectionFUCHSIA*: proc (device: VkDevice, pCreateInfo: ptr VkBufferCollectionCreateInfoFUCHSIA, pAllocator: ptr VkAllocationCallbacks, pCollection: ptr VkBufferCollectionFUCHSIA): VkResult {.stdcall.}
  vkSetBufferCollectionBufferConstraintsFUCHSIA*: proc (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pBufferConstraintsInfo: ptr VkBufferConstraintsInfoFUCHSIA): VkResult {.stdcall.}
  vkSetBufferCollectionImageConstraintsFUCHSIA*: proc (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pImageConstraintsInfo: ptr VkImageConstraintsInfoFUCHSIA): VkResult {.stdcall.}
  vkDestroyBufferCollectionFUCHSIA*: proc (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetBufferCollectionPropertiesFUCHSIA*: proc (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pProperties: ptr VkBufferCollectionPropertiesFUCHSIA): VkResult {.stdcall.}
  vkCreateCudaModuleNV*: proc (device: VkDevice, pCreateInfo: ptr VkCudaModuleCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pModule: ptr VkCudaModuleNV): VkResult {.stdcall.}
  vkGetCudaModuleCacheNV*: proc (device: VkDevice, module: VkCudaModuleNV, pCacheSize: ptr uint, pCacheData: pointer): VkResult {.stdcall.}
  vkCreateCudaFunctionNV*: proc (device: VkDevice, pCreateInfo: ptr VkCudaFunctionCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pFunction: ptr VkCudaFunctionNV): VkResult {.stdcall.}
  vkDestroyCudaModuleNV*: proc (device: VkDevice, module: VkCudaModuleNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkDestroyCudaFunctionNV*: proc (device: VkDevice, function: VkCudaFunctionNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCmdCudaLaunchKernelNV*: proc (commandBuffer: VkCommandBuffer, pLaunchInfo: ptr VkCudaLaunchInfoNV) {.stdcall.}
  vkCmdBeginRendering*: proc (commandBuffer: VkCommandBuffer, pRenderingInfo: ptr VkRenderingInfo) {.stdcall.}
  vkCmdEndRendering*: proc (commandBuffer: VkCommandBuffer) {.stdcall.}
  vkCmdEndRendering2KHR*: proc (commandBuffer: VkCommandBuffer, pRenderingEndInfo: ptr VkRenderingEndInfoKHR) {.stdcall.}
  vkGetDescriptorSetLayoutHostMappingInfoVALVE*: proc (device: VkDevice, pBindingReference: ptr VkDescriptorSetBindingReferenceVALVE, pHostMapping: ptr VkDescriptorSetLayoutHostMappingInfoVALVE) {.stdcall.}
  vkGetDescriptorSetHostMappingVALVE*: proc (device: VkDevice, descriptorSet: VkDescriptorSet, ppData: ptr pointer) {.stdcall.}
  vkCreateMicromapEXT*: proc (device: VkDevice, pCreateInfo: ptr VkMicromapCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pMicromap: ptr VkMicromapEXT): VkResult {.stdcall.}
  vkCmdBuildMicromapsEXT*: proc (commandBuffer: VkCommandBuffer, infoCount: uint32, pInfos: ptr VkMicromapBuildInfoEXT) {.stdcall.}
  vkBuildMicromapsEXT*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: uint32, pInfos: ptr VkMicromapBuildInfoEXT): VkResult {.stdcall.}
  vkDestroyMicromapEXT*: proc (device: VkDevice, micromap: VkMicromapEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCmdCopyMicromapEXT*: proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyMicromapInfoEXT) {.stdcall.}
  vkCopyMicromapEXT*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyMicromapInfoEXT): VkResult {.stdcall.}
  vkCmdCopyMicromapToMemoryEXT*: proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyMicromapToMemoryInfoEXT) {.stdcall.}
  vkCopyMicromapToMemoryEXT*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyMicromapToMemoryInfoEXT): VkResult {.stdcall.}
  vkCmdCopyMemoryToMicromapEXT*: proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyMemoryToMicromapInfoEXT) {.stdcall.}
  vkCopyMemoryToMicromapEXT*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyMemoryToMicromapInfoEXT): VkResult {.stdcall.}
  vkCmdWriteMicromapsPropertiesEXT*: proc (commandBuffer: VkCommandBuffer, micromapCount: uint32, pMicromaps: ptr VkMicromapEXT, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: uint32) {.stdcall.}
  vkWriteMicromapsPropertiesEXT*: proc (device: VkDevice, micromapCount: uint32, pMicromaps: ptr VkMicromapEXT, queryType: VkQueryType, dataSize: uint, pData: pointer, stride: uint): VkResult {.stdcall.}
  vkGetDeviceMicromapCompatibilityEXT*: proc (device: VkDevice, pVersionInfo: ptr VkMicromapVersionInfoEXT, pCompatibility: ptr VkAccelerationStructureCompatibilityKHR) {.stdcall.}
  vkGetMicromapBuildSizesEXT*: proc (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: ptr VkMicromapBuildInfoEXT, pSizeInfo: ptr VkMicromapBuildSizesInfoEXT) {.stdcall.}
  vkGetShaderModuleIdentifierEXT*: proc (device: VkDevice, shaderModule: VkShaderModule, pIdentifier: ptr VkShaderModuleIdentifierEXT) {.stdcall.}
  vkGetShaderModuleCreateInfoIdentifierEXT*: proc (device: VkDevice, pCreateInfo: ptr VkShaderModuleCreateInfo, pIdentifier: ptr VkShaderModuleIdentifierEXT) {.stdcall.}
  vkGetImageSubresourceLayout2*: proc (device: VkDevice, image: VkImage, pSubresource: ptr VkImageSubresource2, pLayout: ptr VkSubresourceLayout2) {.stdcall.}
  vkGetPipelinePropertiesEXT*: proc (device: VkDevice, pPipelineInfo: ptr VkPipelineInfoEXT, pPipelineProperties: ptr VkBaseOutStructure): VkResult {.stdcall.}
  vkExportMetalObjectsEXT*: proc (device: VkDevice, pMetalObjectsInfo: ptr VkExportMetalObjectsInfoEXT) {.stdcall.}
  vkCmdBindTileMemoryQCOM*: proc (commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: ptr VkTileMemoryBindInfoQCOM) {.stdcall.}
  vkGetFramebufferTilePropertiesQCOM*: proc (device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: ptr uint32, pProperties: ptr VkTilePropertiesQCOM): VkResult {.stdcall.}
  vkGetDynamicRenderingTilePropertiesQCOM*: proc (device: VkDevice, pRenderingInfo: ptr VkRenderingInfo, pProperties: ptr VkTilePropertiesQCOM): VkResult {.stdcall.}
  vkGetPhysicalDeviceOpticalFlowImageFormatsNV*: proc (physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: ptr VkOpticalFlowImageFormatInfoNV, pFormatCount: ptr uint32, pImageFormatProperties: ptr VkOpticalFlowImageFormatPropertiesNV): VkResult {.stdcall.}
  vkCreateOpticalFlowSessionNV*: proc (device: VkDevice, pCreateInfo: ptr VkOpticalFlowSessionCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pSession: ptr VkOpticalFlowSessionNV): VkResult {.stdcall.}
  vkDestroyOpticalFlowSessionNV*: proc (device: VkDevice, session: VkOpticalFlowSessionNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkBindOpticalFlowSessionImageNV*: proc (device: VkDevice, session: VkOpticalFlowSessionNV, bindingPoint: VkOpticalFlowSessionBindingPointNV, view: VkImageView, layout: VkImageLayout): VkResult {.stdcall.}
  vkCmdOpticalFlowExecuteNV*: proc (commandBuffer: VkCommandBuffer, session: VkOpticalFlowSessionNV, pExecuteInfo: ptr VkOpticalFlowExecuteInfoNV) {.stdcall.}
  vkGetDeviceFaultInfoEXT*: proc (device: VkDevice, pFaultCounts: ptr VkDeviceFaultCountsEXT, pFaultInfo: ptr VkDeviceFaultInfoEXT): VkResult {.stdcall.}
  vkCmdSetDepthBias2EXT*: proc (commandBuffer: VkCommandBuffer, pDepthBiasInfo: ptr VkDepthBiasInfoEXT) {.stdcall.}
  vkReleaseSwapchainImagesKHR*: proc (device: VkDevice, pReleaseInfo: ptr VkReleaseSwapchainImagesInfoKHR): VkResult {.stdcall.}
  vkGetDeviceImageSubresourceLayout*: proc (device: VkDevice, pInfo: ptr VkDeviceImageSubresourceInfo, pLayout: ptr VkSubresourceLayout2) {.stdcall.}
  vkMapMemory2*: proc (device: VkDevice, pMemoryMapInfo: ptr VkMemoryMapInfo, ppData: ptr pointer): VkResult {.stdcall.}
  vkUnmapMemory2*: proc (device: VkDevice, pMemoryUnmapInfo: ptr VkMemoryUnmapInfo): VkResult {.stdcall.}
  vkCreateShadersEXT*: proc (device: VkDevice, createInfoCount: uint32, pCreateInfos: ptr VkShaderCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pShaders: ptr VkShaderEXT): VkResult {.stdcall.}
  vkDestroyShaderEXT*: proc (device: VkDevice, shader: VkShaderEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetShaderBinaryDataEXT*: proc (device: VkDevice, shader: VkShaderEXT, pDataSize: ptr uint, pData: pointer): VkResult {.stdcall.}
  vkCmdBindShadersEXT*: proc (commandBuffer: VkCommandBuffer, stageCount: uint32, pStages: ptr VkShaderStageFlagBits, pShaders: ptr VkShaderEXT) {.stdcall.}
  vkSetSwapchainPresentTimingQueueSizeEXT*: proc (device: VkDevice, swapchain: VkSwapchainKHR, size: uint32): VkResult {.stdcall.}
  vkGetSwapchainTimingPropertiesEXT*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainTimingProperties: ptr VkSwapchainTimingPropertiesEXT, pSwapchainTimingPropertiesCounter: ptr uint64): VkResult {.stdcall.}
  vkGetSwapchainTimeDomainPropertiesEXT*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainTimeDomainProperties: ptr VkSwapchainTimeDomainPropertiesEXT, pTimeDomainsCounter: ptr uint64): VkResult {.stdcall.}
  vkGetPastPresentationTimingEXT*: proc (device: VkDevice, pPastPresentationTimingInfo: ptr VkPastPresentationTimingInfoEXT, pPastPresentationTimingProperties: ptr VkPastPresentationTimingPropertiesEXT): VkResult {.stdcall.}
  vkGetScreenBufferPropertiesQNX*: proc (device: VkDevice, buffer: ptr screen_buffer, pProperties: ptr VkScreenBufferPropertiesQNX): VkResult {.stdcall.}
  vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR*: proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkCooperativeMatrixPropertiesKHR): VkResult {.stdcall.}
  vkGetExecutionGraphPipelineScratchSizeAMDX*: proc (device: VkDevice, executionGraph: VkPipeline, pSizeInfo: ptr VkExecutionGraphPipelineScratchSizeAMDX): VkResult {.stdcall.}
  vkGetExecutionGraphPipelineNodeIndexAMDX*: proc (device: VkDevice, executionGraph: VkPipeline, pNodeInfo: ptr VkPipelineShaderStageNodeCreateInfoAMDX, pNodeIndex: ptr uint32): VkResult {.stdcall.}
  vkCreateExecutionGraphPipelinesAMDX*: proc (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkExecutionGraphPipelineCreateInfoAMDX, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}
  vkCmdInitializeGraphScratchMemoryAMDX*: proc (commandBuffer: VkCommandBuffer, executionGraph: VkPipeline, scratch: VkDeviceAddress, scratchSize: VkDeviceSize) {.stdcall.}
  vkCmdDispatchGraphAMDX*: proc (commandBuffer: VkCommandBuffer, scratch: VkDeviceAddress, scratchSize: VkDeviceSize, pCountInfo: ptr VkDispatchGraphCountInfoAMDX) {.stdcall.}
  vkCmdDispatchGraphIndirectAMDX*: proc (commandBuffer: VkCommandBuffer, scratch: VkDeviceAddress, scratchSize: VkDeviceSize, pCountInfo: ptr VkDispatchGraphCountInfoAMDX) {.stdcall.}
  vkCmdDispatchGraphIndirectCountAMDX*: proc (commandBuffer: VkCommandBuffer, scratch: VkDeviceAddress, scratchSize: VkDeviceSize, countInfo: VkDeviceAddress) {.stdcall.}
  vkCmdBindDescriptorSets2*: proc (commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: ptr VkBindDescriptorSetsInfo) {.stdcall.}
  vkCmdPushConstants2*: proc (commandBuffer: VkCommandBuffer, pPushConstantsInfo: ptr VkPushConstantsInfo) {.stdcall.}
  vkCmdPushDescriptorSet2*: proc (commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: ptr VkPushDescriptorSetInfo) {.stdcall.}
  vkCmdPushDescriptorSetWithTemplate2*: proc (commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: ptr VkPushDescriptorSetWithTemplateInfo) {.stdcall.}
  vkCmdSetDescriptorBufferOffsets2EXT*: proc (commandBuffer: VkCommandBuffer, pSetDescriptorBufferOffsetsInfo: ptr VkSetDescriptorBufferOffsetsInfoEXT) {.stdcall.}
  vkCmdBindDescriptorBufferEmbeddedSamplers2EXT*: proc (commandBuffer: VkCommandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo: ptr VkBindDescriptorBufferEmbeddedSamplersInfoEXT) {.stdcall.}
  vkSetLatencySleepModeNV*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: ptr VkLatencySleepModeInfoNV): VkResult {.stdcall.}
  vkLatencySleepNV*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pSleepInfo: ptr VkLatencySleepInfoNV): VkResult {.stdcall.}
  vkSetLatencyMarkerNV*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: ptr VkSetLatencyMarkerInfoNV) {.stdcall.}
  vkGetLatencyTimingsNV*: proc (device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: ptr VkGetLatencyMarkerInfoNV) {.stdcall.}
  vkQueueNotifyOutOfBandNV*: proc (queue: VkQueue, pQueueTypeInfo: ptr VkOutOfBandQueueTypeInfoNV) {.stdcall.}
  vkCmdSetRenderingAttachmentLocations*: proc (commandBuffer: VkCommandBuffer, pLocationInfo: ptr VkRenderingAttachmentLocationInfo) {.stdcall.}
  vkCmdSetRenderingInputAttachmentIndices*: proc (commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: ptr VkRenderingInputAttachmentIndexInfo) {.stdcall.}
  vkCmdSetDepthClampRangeEXT*: proc (commandBuffer: VkCommandBuffer, depthClampMode: VkDepthClampModeEXT, pDepthClampRange: ptr VkDepthClampRangeEXT) {.stdcall.}
  vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV*: proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkCooperativeMatrixFlexibleDimensionsPropertiesNV): VkResult {.stdcall.}
  vkGetMemoryMetalHandleEXT*: proc (device: VkDevice, pGetMetalHandleInfo: ptr VkMemoryGetMetalHandleInfoEXT, pHandle: ptr pointer): VkResult {.stdcall.}
  vkGetMemoryMetalHandlePropertiesEXT*: proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHandle: pointer, pMemoryMetalHandleProperties: ptr VkMemoryMetalHandlePropertiesEXT): VkResult {.stdcall.}
  vkGetPhysicalDeviceCooperativeVectorPropertiesNV*: proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkCooperativeVectorPropertiesNV): VkResult {.stdcall.}
  vkConvertCooperativeVectorMatrixNV*: proc (device: VkDevice, pInfo: ptr VkConvertCooperativeVectorMatrixInfoNV): VkResult {.stdcall.}
  vkCmdConvertCooperativeVectorMatrixNV*: proc (commandBuffer: VkCommandBuffer, infoCount: uint32, pInfos: ptr VkConvertCooperativeVectorMatrixInfoNV) {.stdcall.}
  vkCmdDispatchTileQCOM*: proc (commandBuffer: VkCommandBuffer, pDispatchTileInfo: ptr VkDispatchTileInfoQCOM) {.stdcall.}
  vkCmdBeginPerTileExecutionQCOM*: proc (commandBuffer: VkCommandBuffer, pPerTileBeginInfo: ptr VkPerTileBeginInfoQCOM) {.stdcall.}
  vkCmdEndPerTileExecutionQCOM*: proc (commandBuffer: VkCommandBuffer, pPerTileEndInfo: ptr VkPerTileEndInfoQCOM) {.stdcall.}
  vkCreateExternalComputeQueueNV*: proc (device: VkDevice, pCreateInfo: ptr VkExternalComputeQueueCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pExternalQueue: ptr VkExternalComputeQueueNV): VkResult {.stdcall.}
  vkDestroyExternalComputeQueueNV*: proc (device: VkDevice, externalQueue: VkExternalComputeQueueNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetExternalComputeQueueDataNV*: proc (externalQueue: VkExternalComputeQueueNV, params: ptr VkExternalComputeQueueDataParamsNV, pData: pointer) {.stdcall.}
  vkCreateTensorARM*: proc (device: VkDevice, pCreateInfo: ptr VkTensorCreateInfoARM, pAllocator: ptr VkAllocationCallbacks, pTensor: ptr VkTensorARM): VkResult {.stdcall.}
  vkDestroyTensorARM*: proc (device: VkDevice, tensor: VkTensorARM, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCreateTensorViewARM*: proc (device: VkDevice, pCreateInfo: ptr VkTensorViewCreateInfoARM, pAllocator: ptr VkAllocationCallbacks, pView: ptr VkTensorViewARM): VkResult {.stdcall.}
  vkDestroyTensorViewARM*: proc (device: VkDevice, tensorView: VkTensorViewARM, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkGetTensorMemoryRequirementsARM*: proc (device: VkDevice, pInfo: ptr VkTensorMemoryRequirementsInfoARM, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkBindTensorMemoryARM*: proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindTensorMemoryInfoARM): VkResult {.stdcall.}
  vkGetDeviceTensorMemoryRequirementsARM*: proc (device: VkDevice, pInfo: ptr VkDeviceTensorMemoryRequirementsARM, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkCmdCopyTensorARM*: proc (commandBuffer: VkCommandBuffer, pCopyTensorInfo: ptr VkCopyTensorInfoARM) {.stdcall.}
  vkGetTensorOpaqueCaptureDescriptorDataARM*: proc (device: VkDevice, pInfo: ptr VkTensorCaptureDescriptorDataInfoARM, pData: pointer): VkResult {.stdcall.}
  vkGetTensorViewOpaqueCaptureDescriptorDataARM*: proc (device: VkDevice, pInfo: ptr VkTensorViewCaptureDescriptorDataInfoARM, pData: pointer): VkResult {.stdcall.}
  vkGetPhysicalDeviceExternalTensorPropertiesARM*: proc (physicalDevice: VkPhysicalDevice, pExternalTensorInfo: ptr VkPhysicalDeviceExternalTensorInfoARM, pExternalTensorProperties: ptr VkExternalTensorPropertiesARM) {.stdcall.}
  vkCreateDataGraphPipelinesARM*: proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkDataGraphPipelineCreateInfoARM, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}
  vkCreateDataGraphPipelineSessionARM*: proc (device: VkDevice, pCreateInfo: ptr VkDataGraphPipelineSessionCreateInfoARM, pAllocator: ptr VkAllocationCallbacks, pSession: ptr VkDataGraphPipelineSessionARM): VkResult {.stdcall.}
  vkGetDataGraphPipelineSessionBindPointRequirementsARM*: proc (device: VkDevice, pInfo: ptr VkDataGraphPipelineSessionBindPointRequirementsInfoARM, pBindPointRequirementCount: ptr uint32, pBindPointRequirements: ptr VkDataGraphPipelineSessionBindPointRequirementARM): VkResult {.stdcall.}
  vkGetDataGraphPipelineSessionMemoryRequirementsARM*: proc (device: VkDevice, pInfo: ptr VkDataGraphPipelineSessionMemoryRequirementsInfoARM, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}
  vkBindDataGraphPipelineSessionMemoryARM*: proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindDataGraphPipelineSessionMemoryInfoARM): VkResult {.stdcall.}
  vkDestroyDataGraphPipelineSessionARM*: proc (device: VkDevice, session: VkDataGraphPipelineSessionARM, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}
  vkCmdDispatchDataGraphARM*: proc (commandBuffer: VkCommandBuffer, session: VkDataGraphPipelineSessionARM, pInfo: ptr VkDataGraphPipelineDispatchInfoARM) {.stdcall.}
  vkGetDataGraphPipelineAvailablePropertiesARM*: proc (device: VkDevice, pPipelineInfo: ptr VkDataGraphPipelineInfoARM, pPropertiesCount: ptr uint32, pProperties: ptr VkDataGraphPipelinePropertyARM): VkResult {.stdcall.}
  vkGetDataGraphPipelinePropertiesARM*: proc (device: VkDevice, pPipelineInfo: ptr VkDataGraphPipelineInfoARM, propertiesCount: uint32, pProperties: ptr VkDataGraphPipelinePropertyQueryResultARM): VkResult {.stdcall.}
  vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, pQueueFamilyDataGraphPropertyCount: ptr uint32, pQueueFamilyDataGraphProperties: ptr VkQueueFamilyDataGraphPropertiesARM): VkResult {.stdcall.}
  vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM*: proc (physicalDevice: VkPhysicalDevice, pQueueFamilyDataGraphProcessingEngineInfo: ptr VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, pQueueFamilyDataGraphProcessingEngineProperties: ptr VkQueueFamilyDataGraphProcessingEnginePropertiesARM) {.stdcall.}
  vkGetNativeBufferPropertiesOHOS*: proc (device: VkDevice, buffer: ptr OH_NativeBuffer, pProperties: ptr VkNativeBufferPropertiesOHOS): VkResult {.stdcall.}
  vkGetMemoryNativeBufferOHOS*: proc (device: VkDevice, pInfo: ptr VkMemoryGetNativeBufferInfoOHOS, pBuffer: ptr ptr OH_NativeBuffer): VkResult {.stdcall.}
  vkGetSwapchainGrallocUsageOHOS*: proc (device: VkDevice, format: VkFormat, imageUsage: VkImageUsageFlags, grallocUsage: ptr uint64): VkResult {.stdcall.}
  vkAcquireImageOHOS*: proc (device: VkDevice, image: VkImage, nativeFenceFd: int32, semaphore: VkSemaphore, fence: VkFence): VkResult {.stdcall.}
  vkQueueSignalReleaseImageOHOS*: proc (queue: VkQueue, waitSemaphoreCount: uint32, pWaitSemaphores: ptr VkSemaphore, image: VkImage, pNativeFenceFd: ptr int32): VkResult {.stdcall.}
  vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM*: proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, pCounterCount: ptr uint32, pCounters: ptr VkPerformanceCounterARM, pCounterDescriptions: ptr VkPerformanceCounterDescriptionARM): VkResult {.stdcall.}
  vkCmdSetComputeOccupancyPriorityNV*: proc (commandBuffer: VkCommandBuffer, pParameters: ptr VkComputeOccupancyPriorityParametersNV) {.stdcall.}
  vkWriteSamplerDescriptorsEXT*: proc (device: VkDevice, samplerCount: uint32, pSamplers: ptr VkSamplerCreateInfo, pDescriptors: ptr VkHostAddressRangeEXT): VkResult {.stdcall.}
  vkWriteResourceDescriptorsEXT*: proc (device: VkDevice, resourceCount: uint32, pResources: ptr VkResourceDescriptorInfoEXT, pDescriptors: ptr VkHostAddressRangeEXT): VkResult {.stdcall.}
  vkCmdBindSamplerHeapEXT*: proc (commandBuffer: VkCommandBuffer, pBindInfo: ptr VkBindHeapInfoEXT) {.stdcall.}
  vkCmdBindResourceHeapEXT*: proc (commandBuffer: VkCommandBuffer, pBindInfo: ptr VkBindHeapInfoEXT) {.stdcall.}
  vkCmdPushDataEXT*: proc (commandBuffer: VkCommandBuffer, pPushDataInfo: ptr VkPushDataInfoEXT) {.stdcall.}
  vkRegisterCustomBorderColorEXT*: proc (device: VkDevice, pBorderColor: ptr VkSamplerCustomBorderColorCreateInfoEXT, requestIndex: VkBool32, pIndex: ptr uint32): VkResult {.stdcall.}
  vkUnregisterCustomBorderColorEXT*: proc (device: VkDevice, index: uint32) {.stdcall.}
  vkGetImageOpaqueCaptureDataEXT*: proc (device: VkDevice, imageCount: uint32, pImages: ptr VkImage, pDatas: ptr VkHostAddressRangeEXT): VkResult {.stdcall.}
  vkGetPhysicalDeviceDescriptorSizeEXT*: proc (physicalDevice: VkPhysicalDevice, descriptorType: VkDescriptorType): VkDeviceSize {.stdcall.}
  vkGetTensorOpaqueCaptureDataARM*: proc (device: VkDevice, tensorCount: uint32, pTensors: ptr VkTensorARM, pDatas: ptr VkHostAddressRangeEXT): VkResult {.stdcall.}

# Vulkan 1_0
proc vkLoad1_0*() =
  vkDestroyInstance = cast[proc (instance: VkInstance, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyInstance"))
  vkEnumeratePhysicalDevices = cast[proc (instance: VkInstance, pPhysicalDeviceCount: ptr uint32, pPhysicalDevices: ptr VkPhysicalDevice): VkResult {.stdcall.}](vkGetProc("vkEnumeratePhysicalDevices"))
  vkGetPhysicalDeviceFeatures = cast[proc (physicalDevice: VkPhysicalDevice, pFeatures: ptr VkPhysicalDeviceFeatures) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceFeatures"))
  vkGetPhysicalDeviceFormatProperties = cast[proc (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: ptr VkFormatProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceFormatProperties"))
  vkGetPhysicalDeviceImageFormatProperties = cast[proc (physicalDevice: VkPhysicalDevice, format: VkFormat, `type`: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: ptr VkImageFormatProperties): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceImageFormatProperties"))
  vkGetPhysicalDeviceProperties = cast[proc (physicalDevice: VkPhysicalDevice, pProperties: ptr VkPhysicalDeviceProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceProperties"))
  vkGetPhysicalDeviceQueueFamilyProperties = cast[proc (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: ptr uint32, pQueueFamilyProperties: ptr VkQueueFamilyProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceQueueFamilyProperties"))
  vkGetPhysicalDeviceMemoryProperties = cast[proc (physicalDevice: VkPhysicalDevice, pMemoryProperties: ptr VkPhysicalDeviceMemoryProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceMemoryProperties"))
  vkGetInstanceProcAddr = cast[proc (instance: VkInstance, pName: cstring): PFN_vkVoidFunction {.stdcall.}](vkGetProc("vkGetInstanceProcAddr"))
  vkGetDeviceProcAddr = cast[proc (device: VkDevice, pName: cstring): PFN_vkVoidFunction {.stdcall.}](vkGetProc("vkGetDeviceProcAddr"))
  vkCreateDevice = cast[proc (physicalDevice: VkPhysicalDevice, pCreateInfo: ptr VkDeviceCreateInfo, pAllocator: ptr VkAllocationCallbacks, pDevice: ptr VkDevice): VkResult {.stdcall.}](vkGetProc("vkCreateDevice"))
  vkDestroyDevice = cast[proc (device: VkDevice, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyDevice"))
  vkEnumerateDeviceExtensionProperties = cast[proc (physicalDevice: VkPhysicalDevice, pLayerName: cstring, pPropertyCount: ptr uint32, pProperties: ptr VkExtensionProperties): VkResult {.stdcall.}](vkGetProc("vkEnumerateDeviceExtensionProperties"))
  vkEnumerateDeviceLayerProperties = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkLayerProperties): VkResult {.stdcall.}](vkGetProc("vkEnumerateDeviceLayerProperties"))
  vkEnumerateDeviceLayerProperties = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkLayerProperties): VkResult {.stdcall.}](vkGetProc("vkEnumerateDeviceLayerProperties"))
  vkGetDeviceQueue = cast[proc (device: VkDevice, queueFamilyIndex: uint32, queueIndex: uint32, pQueue: ptr VkQueue) {.stdcall.}](vkGetProc("vkGetDeviceQueue"))
  vkQueueSubmit = cast[proc (queue: VkQueue, submitCount: uint32, pSubmits: ptr VkSubmitInfo, fence: VkFence): VkResult {.stdcall.}](vkGetProc("vkQueueSubmit"))
  vkQueueWaitIdle = cast[proc (queue: VkQueue): VkResult {.stdcall.}](vkGetProc("vkQueueWaitIdle"))
  vkDeviceWaitIdle = cast[proc (device: VkDevice): VkResult {.stdcall.}](vkGetProc("vkDeviceWaitIdle"))
  vkAllocateMemory = cast[proc (device: VkDevice, pAllocateInfo: ptr VkMemoryAllocateInfo, pAllocator: ptr VkAllocationCallbacks, pMemory: ptr VkDeviceMemory): VkResult {.stdcall.}](vkGetProc("vkAllocateMemory"))
  vkFreeMemory = cast[proc (device: VkDevice, memory: VkDeviceMemory, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkFreeMemory"))
  vkMapMemory = cast[proc (device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: ptr pointer): VkResult {.stdcall.}](vkGetProc("vkMapMemory"))
  vkUnmapMemory = cast[proc (device: VkDevice, memory: VkDeviceMemory) {.stdcall.}](vkGetProc("vkUnmapMemory"))
  vkFlushMappedMemoryRanges = cast[proc (device: VkDevice, memoryRangeCount: uint32, pMemoryRanges: ptr VkMappedMemoryRange): VkResult {.stdcall.}](vkGetProc("vkFlushMappedMemoryRanges"))
  vkInvalidateMappedMemoryRanges = cast[proc (device: VkDevice, memoryRangeCount: uint32, pMemoryRanges: ptr VkMappedMemoryRange): VkResult {.stdcall.}](vkGetProc("vkInvalidateMappedMemoryRanges"))
  vkGetDeviceMemoryCommitment = cast[proc (device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: ptr VkDeviceSize) {.stdcall.}](vkGetProc("vkGetDeviceMemoryCommitment"))
  vkBindBufferMemory = cast[proc (device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize): VkResult {.stdcall.}](vkGetProc("vkBindBufferMemory"))
  vkBindImageMemory = cast[proc (device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize): VkResult {.stdcall.}](vkGetProc("vkBindImageMemory"))
  vkGetBufferMemoryRequirements = cast[proc (device: VkDevice, buffer: VkBuffer, pMemoryRequirements: ptr VkMemoryRequirements) {.stdcall.}](vkGetProc("vkGetBufferMemoryRequirements"))
  vkGetImageMemoryRequirements = cast[proc (device: VkDevice, image: VkImage, pMemoryRequirements: ptr VkMemoryRequirements) {.stdcall.}](vkGetProc("vkGetImageMemoryRequirements"))
  vkGetImageSparseMemoryRequirements = cast[proc (device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: ptr uint32, pSparseMemoryRequirements: ptr VkSparseImageMemoryRequirements) {.stdcall.}](vkGetProc("vkGetImageSparseMemoryRequirements"))
  vkGetPhysicalDeviceSparseImageFormatProperties = cast[proc (physicalDevice: VkPhysicalDevice, format: VkFormat, `type`: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: ptr uint32, pProperties: ptr VkSparseImageFormatProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSparseImageFormatProperties"))
  vkQueueBindSparse = cast[proc (queue: VkQueue, bindInfoCount: uint32, pBindInfo: ptr VkBindSparseInfo, fence: VkFence): VkResult {.stdcall.}](vkGetProc("vkQueueBindSparse"))
  vkCreateFence = cast[proc (device: VkDevice, pCreateInfo: ptr VkFenceCreateInfo, pAllocator: ptr VkAllocationCallbacks, pFence: ptr VkFence): VkResult {.stdcall.}](vkGetProc("vkCreateFence"))
  vkDestroyFence = cast[proc (device: VkDevice, fence: VkFence, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyFence"))
  vkResetFences = cast[proc (device: VkDevice, fenceCount: uint32, pFences: ptr VkFence): VkResult {.stdcall.}](vkGetProc("vkResetFences"))
  vkGetFenceStatus = cast[proc (device: VkDevice, fence: VkFence): VkResult {.stdcall.}](vkGetProc("vkGetFenceStatus"))
  vkWaitForFences = cast[proc (device: VkDevice, fenceCount: uint32, pFences: ptr VkFence, waitAll: VkBool32, timeout: uint64): VkResult {.stdcall.}](vkGetProc("vkWaitForFences"))
  vkCreateSemaphore = cast[proc (device: VkDevice, pCreateInfo: ptr VkSemaphoreCreateInfo, pAllocator: ptr VkAllocationCallbacks, pSemaphore: ptr VkSemaphore): VkResult {.stdcall.}](vkGetProc("vkCreateSemaphore"))
  vkDestroySemaphore = cast[proc (device: VkDevice, semaphore: VkSemaphore, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroySemaphore"))
  vkCreateQueryPool = cast[proc (device: VkDevice, pCreateInfo: ptr VkQueryPoolCreateInfo, pAllocator: ptr VkAllocationCallbacks, pQueryPool: ptr VkQueryPool): VkResult {.stdcall.}](vkGetProc("vkCreateQueryPool"))
  vkDestroyQueryPool = cast[proc (device: VkDevice, queryPool: VkQueryPool, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyQueryPool"))
  vkGetQueryPoolResults = cast[proc (device: VkDevice, queryPool: VkQueryPool, firstQuery: uint32, queryCount: uint32, dataSize: uint, pData: pointer, stride: VkDeviceSize, flags: VkQueryResultFlags): VkResult {.stdcall.}](vkGetProc("vkGetQueryPoolResults"))
  vkCreateBuffer = cast[proc (device: VkDevice, pCreateInfo: ptr VkBufferCreateInfo, pAllocator: ptr VkAllocationCallbacks, pBuffer: ptr VkBuffer): VkResult {.stdcall.}](vkGetProc("vkCreateBuffer"))
  vkDestroyBuffer = cast[proc (device: VkDevice, buffer: VkBuffer, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyBuffer"))
  vkCreateImage = cast[proc (device: VkDevice, pCreateInfo: ptr VkImageCreateInfo, pAllocator: ptr VkAllocationCallbacks, pImage: ptr VkImage): VkResult {.stdcall.}](vkGetProc("vkCreateImage"))
  vkDestroyImage = cast[proc (device: VkDevice, image: VkImage, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyImage"))
  vkGetImageSubresourceLayout = cast[proc (device: VkDevice, image: VkImage, pSubresource: ptr VkImageSubresource, pLayout: ptr VkSubresourceLayout) {.stdcall.}](vkGetProc("vkGetImageSubresourceLayout"))
  vkCreateImageView = cast[proc (device: VkDevice, pCreateInfo: ptr VkImageViewCreateInfo, pAllocator: ptr VkAllocationCallbacks, pView: ptr VkImageView): VkResult {.stdcall.}](vkGetProc("vkCreateImageView"))
  vkDestroyImageView = cast[proc (device: VkDevice, imageView: VkImageView, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyImageView"))
  vkCreateCommandPool = cast[proc (device: VkDevice, pCreateInfo: ptr VkCommandPoolCreateInfo, pAllocator: ptr VkAllocationCallbacks, pCommandPool: ptr VkCommandPool): VkResult {.stdcall.}](vkGetProc("vkCreateCommandPool"))
  vkDestroyCommandPool = cast[proc (device: VkDevice, commandPool: VkCommandPool, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyCommandPool"))
  vkResetCommandPool = cast[proc (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags): VkResult {.stdcall.}](vkGetProc("vkResetCommandPool"))
  vkAllocateCommandBuffers = cast[proc (device: VkDevice, pAllocateInfo: ptr VkCommandBufferAllocateInfo, pCommandBuffers: ptr VkCommandBuffer): VkResult {.stdcall.}](vkGetProc("vkAllocateCommandBuffers"))
  vkFreeCommandBuffers = cast[proc (device: VkDevice, commandPool: VkCommandPool, commandBufferCount: uint32, pCommandBuffers: ptr VkCommandBuffer) {.stdcall.}](vkGetProc("vkFreeCommandBuffers"))
  vkBeginCommandBuffer = cast[proc (commandBuffer: VkCommandBuffer, pBeginInfo: ptr VkCommandBufferBeginInfo): VkResult {.stdcall.}](vkGetProc("vkBeginCommandBuffer"))
  vkEndCommandBuffer = cast[proc (commandBuffer: VkCommandBuffer): VkResult {.stdcall.}](vkGetProc("vkEndCommandBuffer"))
  vkResetCommandBuffer = cast[proc (commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags): VkResult {.stdcall.}](vkGetProc("vkResetCommandBuffer"))
  vkCmdCopyBuffer = cast[proc (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: uint32, pRegions: ptr VkBufferCopy) {.stdcall.}](vkGetProc("vkCmdCopyBuffer"))
  vkCmdCopyImage = cast[proc (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: uint32, pRegions: ptr VkImageCopy) {.stdcall.}](vkGetProc("vkCmdCopyImage"))
  vkCmdCopyBufferToImage = cast[proc (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: uint32, pRegions: ptr VkBufferImageCopy) {.stdcall.}](vkGetProc("vkCmdCopyBufferToImage"))
  vkCmdCopyImageToBuffer = cast[proc (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: uint32, pRegions: ptr VkBufferImageCopy) {.stdcall.}](vkGetProc("vkCmdCopyImageToBuffer"))
  vkCmdUpdateBuffer = cast[proc (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: pointer) {.stdcall.}](vkGetProc("vkCmdUpdateBuffer"))
  vkCmdFillBuffer = cast[proc (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: uint32) {.stdcall.}](vkGetProc("vkCmdFillBuffer"))
  vkCmdPipelineBarrier = cast[proc (commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: uint32, pMemoryBarriers: ptr VkMemoryBarrier, bufferMemoryBarrierCount: uint32, pBufferMemoryBarriers: ptr VkBufferMemoryBarrier, imageMemoryBarrierCount: uint32, pImageMemoryBarriers: ptr VkImageMemoryBarrier) {.stdcall.}](vkGetProc("vkCmdPipelineBarrier"))
  vkCmdBeginQuery = cast[proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32, flags: VkQueryControlFlags) {.stdcall.}](vkGetProc("vkCmdBeginQuery"))
  vkCmdEndQuery = cast[proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32) {.stdcall.}](vkGetProc("vkCmdEndQuery"))
  vkCmdResetQueryPool = cast[proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: uint32, queryCount: uint32) {.stdcall.}](vkGetProc("vkCmdResetQueryPool"))
  vkCmdWriteTimestamp = cast[proc (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: uint32) {.stdcall.}](vkGetProc("vkCmdWriteTimestamp"))
  vkCmdCopyQueryPoolResults = cast[proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: uint32, queryCount: uint32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) {.stdcall.}](vkGetProc("vkCmdCopyQueryPoolResults"))
  vkCmdExecuteCommands = cast[proc (commandBuffer: VkCommandBuffer, commandBufferCount: uint32, pCommandBuffers: ptr VkCommandBuffer) {.stdcall.}](vkGetProc("vkCmdExecuteCommands"))
  vkCreateEvent = cast[proc (device: VkDevice, pCreateInfo: ptr VkEventCreateInfo, pAllocator: ptr VkAllocationCallbacks, pEvent: ptr VkEvent): VkResult {.stdcall.}](vkGetProc("vkCreateEvent"))
  vkDestroyEvent = cast[proc (device: VkDevice, event: VkEvent, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyEvent"))
  vkGetEventStatus = cast[proc (device: VkDevice, event: VkEvent): VkResult {.stdcall.}](vkGetProc("vkGetEventStatus"))
  vkSetEvent = cast[proc (device: VkDevice, event: VkEvent): VkResult {.stdcall.}](vkGetProc("vkSetEvent"))
  vkResetEvent = cast[proc (device: VkDevice, event: VkEvent): VkResult {.stdcall.}](vkGetProc("vkResetEvent"))
  vkCreateBufferView = cast[proc (device: VkDevice, pCreateInfo: ptr VkBufferViewCreateInfo, pAllocator: ptr VkAllocationCallbacks, pView: ptr VkBufferView): VkResult {.stdcall.}](vkGetProc("vkCreateBufferView"))
  vkDestroyBufferView = cast[proc (device: VkDevice, bufferView: VkBufferView, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyBufferView"))
  vkCreateShaderModule = cast[proc (device: VkDevice, pCreateInfo: ptr VkShaderModuleCreateInfo, pAllocator: ptr VkAllocationCallbacks, pShaderModule: ptr VkShaderModule): VkResult {.stdcall.}](vkGetProc("vkCreateShaderModule"))
  vkDestroyShaderModule = cast[proc (device: VkDevice, shaderModule: VkShaderModule, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyShaderModule"))
  vkCreatePipelineCache = cast[proc (device: VkDevice, pCreateInfo: ptr VkPipelineCacheCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPipelineCache: ptr VkPipelineCache): VkResult {.stdcall.}](vkGetProc("vkCreatePipelineCache"))
  vkDestroyPipelineCache = cast[proc (device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyPipelineCache"))
  vkGetPipelineCacheData = cast[proc (device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: ptr uint, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetPipelineCacheData"))
  vkMergePipelineCaches = cast[proc (device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: uint32, pSrcCaches: ptr VkPipelineCache): VkResult {.stdcall.}](vkGetProc("vkMergePipelineCaches"))
  vkCreateComputePipelines = cast[proc (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkComputePipelineCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}](vkGetProc("vkCreateComputePipelines"))
  vkDestroyPipeline = cast[proc (device: VkDevice, pipeline: VkPipeline, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyPipeline"))
  vkCreatePipelineLayout = cast[proc (device: VkDevice, pCreateInfo: ptr VkPipelineLayoutCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPipelineLayout: ptr VkPipelineLayout): VkResult {.stdcall.}](vkGetProc("vkCreatePipelineLayout"))
  vkDestroyPipelineLayout = cast[proc (device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyPipelineLayout"))
  vkCreateSampler = cast[proc (device: VkDevice, pCreateInfo: ptr VkSamplerCreateInfo, pAllocator: ptr VkAllocationCallbacks, pSampler: ptr VkSampler): VkResult {.stdcall.}](vkGetProc("vkCreateSampler"))
  vkDestroySampler = cast[proc (device: VkDevice, sampler: VkSampler, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroySampler"))
  vkCreateDescriptorSetLayout = cast[proc (device: VkDevice, pCreateInfo: ptr VkDescriptorSetLayoutCreateInfo, pAllocator: ptr VkAllocationCallbacks, pSetLayout: ptr VkDescriptorSetLayout): VkResult {.stdcall.}](vkGetProc("vkCreateDescriptorSetLayout"))
  vkDestroyDescriptorSetLayout = cast[proc (device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyDescriptorSetLayout"))
  vkCreateDescriptorPool = cast[proc (device: VkDevice, pCreateInfo: ptr VkDescriptorPoolCreateInfo, pAllocator: ptr VkAllocationCallbacks, pDescriptorPool: ptr VkDescriptorPool): VkResult {.stdcall.}](vkGetProc("vkCreateDescriptorPool"))
  vkDestroyDescriptorPool = cast[proc (device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyDescriptorPool"))
  vkResetDescriptorPool = cast[proc (device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags): VkResult {.stdcall.}](vkGetProc("vkResetDescriptorPool"))
  vkAllocateDescriptorSets = cast[proc (device: VkDevice, pAllocateInfo: ptr VkDescriptorSetAllocateInfo, pDescriptorSets: ptr VkDescriptorSet): VkResult {.stdcall.}](vkGetProc("vkAllocateDescriptorSets"))
  vkFreeDescriptorSets = cast[proc (device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: uint32, pDescriptorSets: ptr VkDescriptorSet): VkResult {.stdcall.}](vkGetProc("vkFreeDescriptorSets"))
  vkUpdateDescriptorSets = cast[proc (device: VkDevice, descriptorWriteCount: uint32, pDescriptorWrites: ptr VkWriteDescriptorSet, descriptorCopyCount: uint32, pDescriptorCopies: ptr VkCopyDescriptorSet) {.stdcall.}](vkGetProc("vkUpdateDescriptorSets"))
  vkCmdBindPipeline = cast[proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) {.stdcall.}](vkGetProc("vkCmdBindPipeline"))
  vkCmdBindDescriptorSets = cast[proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: uint32, descriptorSetCount: uint32, pDescriptorSets: ptr VkDescriptorSet, dynamicOffsetCount: uint32, pDynamicOffsets: ptr uint32) {.stdcall.}](vkGetProc("vkCmdBindDescriptorSets"))
  vkCmdClearColorImage = cast[proc (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: ptr VkClearColorValue, rangeCount: uint32, pRanges: ptr VkImageSubresourceRange) {.stdcall.}](vkGetProc("vkCmdClearColorImage"))
  vkCmdDispatch = cast[proc (commandBuffer: VkCommandBuffer, groupCountX: uint32, groupCountY: uint32, groupCountZ: uint32) {.stdcall.}](vkGetProc("vkCmdDispatch"))
  vkCmdDispatchIndirect = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdDispatchIndirect"))
  vkCmdSetEvent = cast[proc (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) {.stdcall.}](vkGetProc("vkCmdSetEvent"))
  vkCmdResetEvent = cast[proc (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) {.stdcall.}](vkGetProc("vkCmdResetEvent"))
  vkCmdWaitEvents = cast[proc (commandBuffer: VkCommandBuffer, eventCount: uint32, pEvents: ptr VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: uint32, pMemoryBarriers: ptr VkMemoryBarrier, bufferMemoryBarrierCount: uint32, pBufferMemoryBarriers: ptr VkBufferMemoryBarrier, imageMemoryBarrierCount: uint32, pImageMemoryBarriers: ptr VkImageMemoryBarrier) {.stdcall.}](vkGetProc("vkCmdWaitEvents"))
  vkCmdPushConstants = cast[proc (commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: uint32, size: uint32, pValues: pointer) {.stdcall.}](vkGetProc("vkCmdPushConstants"))
  vkCreateGraphicsPipelines = cast[proc (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkGraphicsPipelineCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}](vkGetProc("vkCreateGraphicsPipelines"))
  vkCreateFramebuffer = cast[proc (device: VkDevice, pCreateInfo: ptr VkFramebufferCreateInfo, pAllocator: ptr VkAllocationCallbacks, pFramebuffer: ptr VkFramebuffer): VkResult {.stdcall.}](vkGetProc("vkCreateFramebuffer"))
  vkDestroyFramebuffer = cast[proc (device: VkDevice, framebuffer: VkFramebuffer, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyFramebuffer"))
  vkCreateRenderPass = cast[proc (device: VkDevice, pCreateInfo: ptr VkRenderPassCreateInfo, pAllocator: ptr VkAllocationCallbacks, pRenderPass: ptr VkRenderPass): VkResult {.stdcall.}](vkGetProc("vkCreateRenderPass"))
  vkDestroyRenderPass = cast[proc (device: VkDevice, renderPass: VkRenderPass, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyRenderPass"))
  vkGetRenderAreaGranularity = cast[proc (device: VkDevice, renderPass: VkRenderPass, pGranularity: ptr VkExtent2D) {.stdcall.}](vkGetProc("vkGetRenderAreaGranularity"))
  vkCmdSetViewport = cast[proc (commandBuffer: VkCommandBuffer, firstViewport: uint32, viewportCount: uint32, pViewports: ptr VkViewport) {.stdcall.}](vkGetProc("vkCmdSetViewport"))
  vkCmdSetScissor = cast[proc (commandBuffer: VkCommandBuffer, firstScissor: uint32, scissorCount: uint32, pScissors: ptr VkRect2D) {.stdcall.}](vkGetProc("vkCmdSetScissor"))
  vkCmdSetLineWidth = cast[proc (commandBuffer: VkCommandBuffer, lineWidth: float32) {.stdcall.}](vkGetProc("vkCmdSetLineWidth"))
  vkCmdSetDepthBias = cast[proc (commandBuffer: VkCommandBuffer, depthBiasConstantFactor: float32, depthBiasClamp: float32, depthBiasSlopeFactor: float32) {.stdcall.}](vkGetProc("vkCmdSetDepthBias"))
  vkCmdSetBlendConstants = cast[proc (commandBuffer: VkCommandBuffer, blendConstants: array[4, float32]) {.stdcall.}](vkGetProc("vkCmdSetBlendConstants"))
  vkCmdSetDepthBounds = cast[proc (commandBuffer: VkCommandBuffer, minDepthBounds: float32, maxDepthBounds: float32) {.stdcall.}](vkGetProc("vkCmdSetDepthBounds"))
  vkCmdSetStencilCompareMask = cast[proc (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: uint32) {.stdcall.}](vkGetProc("vkCmdSetStencilCompareMask"))
  vkCmdSetStencilWriteMask = cast[proc (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: uint32) {.stdcall.}](vkGetProc("vkCmdSetStencilWriteMask"))
  vkCmdSetStencilReference = cast[proc (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: uint32) {.stdcall.}](vkGetProc("vkCmdSetStencilReference"))
  vkCmdBindIndexBuffer = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) {.stdcall.}](vkGetProc("vkCmdBindIndexBuffer"))
  vkCmdBindVertexBuffers = cast[proc (commandBuffer: VkCommandBuffer, firstBinding: uint32, bindingCount: uint32, pBuffers: ptr VkBuffer, pOffsets: ptr VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdBindVertexBuffers"))
  vkCmdDraw = cast[proc (commandBuffer: VkCommandBuffer, vertexCount: uint32, instanceCount: uint32, firstVertex: uint32, firstInstance: uint32) {.stdcall.}](vkGetProc("vkCmdDraw"))
  vkCmdDrawIndexed = cast[proc (commandBuffer: VkCommandBuffer, indexCount: uint32, instanceCount: uint32, firstIndex: uint32, vertexOffset: int32, firstInstance: uint32) {.stdcall.}](vkGetProc("vkCmdDrawIndexed"))
  vkCmdDrawIndirect = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawIndirect"))
  vkCmdDrawIndexedIndirect = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawIndexedIndirect"))
  vkCmdBlitImage = cast[proc (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: uint32, pRegions: ptr VkImageBlit, filter: VkFilter) {.stdcall.}](vkGetProc("vkCmdBlitImage"))
  vkCmdClearDepthStencilImage = cast[proc (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: ptr VkClearDepthStencilValue, rangeCount: uint32, pRanges: ptr VkImageSubresourceRange) {.stdcall.}](vkGetProc("vkCmdClearDepthStencilImage"))
  vkCmdClearAttachments = cast[proc (commandBuffer: VkCommandBuffer, attachmentCount: uint32, pAttachments: ptr VkClearAttachment, rectCount: uint32, pRects: ptr VkClearRect) {.stdcall.}](vkGetProc("vkCmdClearAttachments"))
  vkCmdResolveImage = cast[proc (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: uint32, pRegions: ptr VkImageResolve) {.stdcall.}](vkGetProc("vkCmdResolveImage"))
  vkCmdBeginRenderPass = cast[proc (commandBuffer: VkCommandBuffer, pRenderPassBegin: ptr VkRenderPassBeginInfo, contents: VkSubpassContents) {.stdcall.}](vkGetProc("vkCmdBeginRenderPass"))
  vkCmdNextSubpass = cast[proc (commandBuffer: VkCommandBuffer, contents: VkSubpassContents) {.stdcall.}](vkGetProc("vkCmdNextSubpass"))
  vkCmdEndRenderPass = cast[proc (commandBuffer: VkCommandBuffer) {.stdcall.}](vkGetProc("vkCmdEndRenderPass"))

# Vulkan 1_1
proc vkLoad1_1*() =
  vkBindBufferMemory2 = cast[proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindBufferMemoryInfo): VkResult {.stdcall.}](vkGetProc("vkBindBufferMemory2"))
  vkBindImageMemory2 = cast[proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindImageMemoryInfo): VkResult {.stdcall.}](vkGetProc("vkBindImageMemory2"))
  vkGetDeviceGroupPeerMemoryFeatures = cast[proc (device: VkDevice, heapIndex: uint32, localDeviceIndex: uint32, remoteDeviceIndex: uint32, pPeerMemoryFeatures: ptr VkPeerMemoryFeatureFlags) {.stdcall.}](vkGetProc("vkGetDeviceGroupPeerMemoryFeatures"))
  vkCmdSetDeviceMask = cast[proc (commandBuffer: VkCommandBuffer, deviceMask: uint32) {.stdcall.}](vkGetProc("vkCmdSetDeviceMask"))
  vkEnumeratePhysicalDeviceGroups = cast[proc (instance: VkInstance, pPhysicalDeviceGroupCount: ptr uint32, pPhysicalDeviceGroupProperties: ptr VkPhysicalDeviceGroupProperties): VkResult {.stdcall.}](vkGetProc("vkEnumeratePhysicalDeviceGroups"))
  vkGetImageMemoryRequirements2 = cast[proc (device: VkDevice, pInfo: ptr VkImageMemoryRequirementsInfo2, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetImageMemoryRequirements2"))
  vkGetBufferMemoryRequirements2 = cast[proc (device: VkDevice, pInfo: ptr VkBufferMemoryRequirementsInfo2, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetBufferMemoryRequirements2"))
  vkGetImageSparseMemoryRequirements2 = cast[proc (device: VkDevice, pInfo: ptr VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: ptr uint32, pSparseMemoryRequirements: ptr VkSparseImageMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetImageSparseMemoryRequirements2"))
  vkGetPhysicalDeviceFeatures2 = cast[proc (physicalDevice: VkPhysicalDevice, pFeatures: ptr VkPhysicalDeviceFeatures2) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceFeatures2"))
  vkGetPhysicalDeviceProperties2 = cast[proc (physicalDevice: VkPhysicalDevice, pProperties: ptr VkPhysicalDeviceProperties2) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceProperties2"))
  vkGetPhysicalDeviceFormatProperties2 = cast[proc (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: ptr VkFormatProperties2) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceFormatProperties2"))
  vkGetPhysicalDeviceImageFormatProperties2 = cast[proc (physicalDevice: VkPhysicalDevice, pImageFormatInfo: ptr VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: ptr VkImageFormatProperties2): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceImageFormatProperties2"))
  vkGetPhysicalDeviceQueueFamilyProperties2 = cast[proc (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: ptr uint32, pQueueFamilyProperties: ptr VkQueueFamilyProperties2) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceQueueFamilyProperties2"))
  vkGetPhysicalDeviceMemoryProperties2 = cast[proc (physicalDevice: VkPhysicalDevice, pMemoryProperties: ptr VkPhysicalDeviceMemoryProperties2) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceMemoryProperties2"))
  vkGetPhysicalDeviceSparseImageFormatProperties2 = cast[proc (physicalDevice: VkPhysicalDevice, pFormatInfo: ptr VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: ptr uint32, pProperties: ptr VkSparseImageFormatProperties2) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSparseImageFormatProperties2"))
  vkTrimCommandPool = cast[proc (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) {.stdcall.}](vkGetProc("vkTrimCommandPool"))
  vkGetDeviceQueue2 = cast[proc (device: VkDevice, pQueueInfo: ptr VkDeviceQueueInfo2, pQueue: ptr VkQueue) {.stdcall.}](vkGetProc("vkGetDeviceQueue2"))
  vkGetPhysicalDeviceExternalBufferProperties = cast[proc (physicalDevice: VkPhysicalDevice, pExternalBufferInfo: ptr VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: ptr VkExternalBufferProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceExternalBufferProperties"))
  vkGetPhysicalDeviceExternalFenceProperties = cast[proc (physicalDevice: VkPhysicalDevice, pExternalFenceInfo: ptr VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: ptr VkExternalFenceProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceExternalFenceProperties"))
  vkGetPhysicalDeviceExternalSemaphoreProperties = cast[proc (physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: ptr VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: ptr VkExternalSemaphoreProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceExternalSemaphoreProperties"))
  vkGetPhysicalDeviceFeatures = cast[proc (physicalDevice: VkPhysicalDevice, pFeatures: ptr VkPhysicalDeviceFeatures) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceFeatures"))
  vkGetPhysicalDeviceProperties = cast[proc (physicalDevice: VkPhysicalDevice, pProperties: ptr VkPhysicalDeviceProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceProperties"))
  vkGetPhysicalDeviceFormatProperties = cast[proc (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: ptr VkFormatProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceFormatProperties"))
  vkGetPhysicalDeviceImageFormatProperties = cast[proc (physicalDevice: VkPhysicalDevice, format: VkFormat, `type`: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: ptr VkImageFormatProperties): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceImageFormatProperties"))
  vkGetPhysicalDeviceQueueFamilyProperties = cast[proc (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: ptr uint32, pQueueFamilyProperties: ptr VkQueueFamilyProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceQueueFamilyProperties"))
  vkGetPhysicalDeviceMemoryProperties = cast[proc (physicalDevice: VkPhysicalDevice, pMemoryProperties: ptr VkPhysicalDeviceMemoryProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceMemoryProperties"))
  vkGetPhysicalDeviceSparseImageFormatProperties = cast[proc (physicalDevice: VkPhysicalDevice, format: VkFormat, `type`: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: ptr uint32, pProperties: ptr VkSparseImageFormatProperties) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSparseImageFormatProperties"))
  vkCmdDispatchBase = cast[proc (commandBuffer: VkCommandBuffer, baseGroupX: uint32, baseGroupY: uint32, baseGroupZ: uint32, groupCountX: uint32, groupCountY: uint32, groupCountZ: uint32) {.stdcall.}](vkGetProc("vkCmdDispatchBase"))
  vkCreateDescriptorUpdateTemplate = cast[proc (device: VkDevice, pCreateInfo: ptr VkDescriptorUpdateTemplateCreateInfo, pAllocator: ptr VkAllocationCallbacks, pDescriptorUpdateTemplate: ptr VkDescriptorUpdateTemplate): VkResult {.stdcall.}](vkGetProc("vkCreateDescriptorUpdateTemplate"))
  vkDestroyDescriptorUpdateTemplate = cast[proc (device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyDescriptorUpdateTemplate"))
  vkUpdateDescriptorSetWithTemplate = cast[proc (device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: pointer) {.stdcall.}](vkGetProc("vkUpdateDescriptorSetWithTemplate"))
  vkGetDescriptorSetLayoutSupport = cast[proc (device: VkDevice, pCreateInfo: ptr VkDescriptorSetLayoutCreateInfo, pSupport: ptr VkDescriptorSetLayoutSupport) {.stdcall.}](vkGetProc("vkGetDescriptorSetLayoutSupport"))
  vkCreateSamplerYcbcrConversion = cast[proc (device: VkDevice, pCreateInfo: ptr VkSamplerYcbcrConversionCreateInfo, pAllocator: ptr VkAllocationCallbacks, pYcbcrConversion: ptr VkSamplerYcbcrConversion): VkResult {.stdcall.}](vkGetProc("vkCreateSamplerYcbcrConversion"))
  vkDestroySamplerYcbcrConversion = cast[proc (device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroySamplerYcbcrConversion"))

# Vulkan 1_2
proc vkLoad1_2*() =
  vkResetQueryPool = cast[proc (device: VkDevice, queryPool: VkQueryPool, firstQuery: uint32, queryCount: uint32) {.stdcall.}](vkGetProc("vkResetQueryPool"))
  vkGetSemaphoreCounterValue = cast[proc (device: VkDevice, semaphore: VkSemaphore, pValue: ptr uint64): VkResult {.stdcall.}](vkGetProc("vkGetSemaphoreCounterValue"))
  vkWaitSemaphores = cast[proc (device: VkDevice, pWaitInfo: ptr VkSemaphoreWaitInfo, timeout: uint64): VkResult {.stdcall.}](vkGetProc("vkWaitSemaphores"))
  vkSignalSemaphore = cast[proc (device: VkDevice, pSignalInfo: ptr VkSemaphoreSignalInfo): VkResult {.stdcall.}](vkGetProc("vkSignalSemaphore"))
  vkGetBufferDeviceAddress = cast[proc (device: VkDevice, pInfo: ptr VkBufferDeviceAddressInfo): VkDeviceAddress {.stdcall.}](vkGetProc("vkGetBufferDeviceAddress"))
  vkGetBufferOpaqueCaptureAddress = cast[proc (device: VkDevice, pInfo: ptr VkBufferDeviceAddressInfo): uint64 {.stdcall.}](vkGetProc("vkGetBufferOpaqueCaptureAddress"))
  vkGetDeviceMemoryOpaqueCaptureAddress = cast[proc (device: VkDevice, pInfo: ptr VkDeviceMemoryOpaqueCaptureAddressInfo): uint64 {.stdcall.}](vkGetProc("vkGetDeviceMemoryOpaqueCaptureAddress"))
  vkCmdDrawIndirectCount = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawIndirectCount"))
  vkCmdDrawIndexedIndirectCount = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawIndexedIndirectCount"))
  vkCreateRenderPass2 = cast[proc (device: VkDevice, pCreateInfo: ptr VkRenderPassCreateInfo2, pAllocator: ptr VkAllocationCallbacks, pRenderPass: ptr VkRenderPass): VkResult {.stdcall.}](vkGetProc("vkCreateRenderPass2"))
  vkCmdBeginRenderPass2 = cast[proc (commandBuffer: VkCommandBuffer, pRenderPassBegin: ptr VkRenderPassBeginInfo, pSubpassBeginInfo: ptr VkSubpassBeginInfo) {.stdcall.}](vkGetProc("vkCmdBeginRenderPass2"))
  vkCmdNextSubpass2 = cast[proc (commandBuffer: VkCommandBuffer, pSubpassBeginInfo: ptr VkSubpassBeginInfo, pSubpassEndInfo: ptr VkSubpassEndInfo) {.stdcall.}](vkGetProc("vkCmdNextSubpass2"))
  vkCmdEndRenderPass2 = cast[proc (commandBuffer: VkCommandBuffer, pSubpassEndInfo: ptr VkSubpassEndInfo) {.stdcall.}](vkGetProc("vkCmdEndRenderPass2"))
  vkCreateRenderPass = cast[proc (device: VkDevice, pCreateInfo: ptr VkRenderPassCreateInfo, pAllocator: ptr VkAllocationCallbacks, pRenderPass: ptr VkRenderPass): VkResult {.stdcall.}](vkGetProc("vkCreateRenderPass"))
  vkCmdBeginRenderPass = cast[proc (commandBuffer: VkCommandBuffer, pRenderPassBegin: ptr VkRenderPassBeginInfo, contents: VkSubpassContents) {.stdcall.}](vkGetProc("vkCmdBeginRenderPass"))
  vkCmdNextSubpass = cast[proc (commandBuffer: VkCommandBuffer, contents: VkSubpassContents) {.stdcall.}](vkGetProc("vkCmdNextSubpass"))
  vkCmdEndRenderPass = cast[proc (commandBuffer: VkCommandBuffer) {.stdcall.}](vkGetProc("vkCmdEndRenderPass"))

# Vulkan 1_3
proc vkLoad1_3*() =
  vkGetPhysicalDeviceToolProperties = cast[proc (physicalDevice: VkPhysicalDevice, pToolCount: ptr uint32, pToolProperties: ptr VkPhysicalDeviceToolProperties): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceToolProperties"))
  vkCreatePrivateDataSlot = cast[proc (device: VkDevice, pCreateInfo: ptr VkPrivateDataSlotCreateInfo, pAllocator: ptr VkAllocationCallbacks, pPrivateDataSlot: ptr VkPrivateDataSlot): VkResult {.stdcall.}](vkGetProc("vkCreatePrivateDataSlot"))
  vkDestroyPrivateDataSlot = cast[proc (device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyPrivateDataSlot"))
  vkSetPrivateData = cast[proc (device: VkDevice, objectType: VkObjectType, objectHandle: uint64, privateDataSlot: VkPrivateDataSlot, data: uint64): VkResult {.stdcall.}](vkGetProc("vkSetPrivateData"))
  vkGetPrivateData = cast[proc (device: VkDevice, objectType: VkObjectType, objectHandle: uint64, privateDataSlot: VkPrivateDataSlot, pData: ptr uint64) {.stdcall.}](vkGetProc("vkGetPrivateData"))
  vkCmdPipelineBarrier2 = cast[proc (commandBuffer: VkCommandBuffer, pDependencyInfo: ptr VkDependencyInfo) {.stdcall.}](vkGetProc("vkCmdPipelineBarrier2"))
  vkCmdWriteTimestamp2 = cast[proc (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: uint32) {.stdcall.}](vkGetProc("vkCmdWriteTimestamp2"))
  vkQueueSubmit2 = cast[proc (queue: VkQueue, submitCount: uint32, pSubmits: ptr VkSubmitInfo2, fence: VkFence): VkResult {.stdcall.}](vkGetProc("vkQueueSubmit2"))
  vkCmdCopyBuffer2 = cast[proc (commandBuffer: VkCommandBuffer, pCopyBufferInfo: ptr VkCopyBufferInfo2) {.stdcall.}](vkGetProc("vkCmdCopyBuffer2"))
  vkCmdCopyImage2 = cast[proc (commandBuffer: VkCommandBuffer, pCopyImageInfo: ptr VkCopyImageInfo2) {.stdcall.}](vkGetProc("vkCmdCopyImage2"))
  vkCmdCopyBufferToImage2 = cast[proc (commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: ptr VkCopyBufferToImageInfo2) {.stdcall.}](vkGetProc("vkCmdCopyBufferToImage2"))
  vkCmdCopyImageToBuffer2 = cast[proc (commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: ptr VkCopyImageToBufferInfo2) {.stdcall.}](vkGetProc("vkCmdCopyImageToBuffer2"))
  vkGetDeviceBufferMemoryRequirements = cast[proc (device: VkDevice, pInfo: ptr VkDeviceBufferMemoryRequirements, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetDeviceBufferMemoryRequirements"))
  vkGetDeviceImageMemoryRequirements = cast[proc (device: VkDevice, pInfo: ptr VkDeviceImageMemoryRequirements, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetDeviceImageMemoryRequirements"))
  vkGetDeviceImageSparseMemoryRequirements = cast[proc (device: VkDevice, pInfo: ptr VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: ptr uint32, pSparseMemoryRequirements: ptr VkSparseImageMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetDeviceImageSparseMemoryRequirements"))
  vkCmdSetEvent2 = cast[proc (commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: ptr VkDependencyInfo) {.stdcall.}](vkGetProc("vkCmdSetEvent2"))
  vkCmdResetEvent2 = cast[proc (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) {.stdcall.}](vkGetProc("vkCmdResetEvent2"))
  vkCmdWaitEvents2 = cast[proc (commandBuffer: VkCommandBuffer, eventCount: uint32, pEvents: ptr VkEvent, pDependencyInfos: ptr VkDependencyInfo) {.stdcall.}](vkGetProc("vkCmdWaitEvents2"))
  vkCmdBlitImage2 = cast[proc (commandBuffer: VkCommandBuffer, pBlitImageInfo: ptr VkBlitImageInfo2) {.stdcall.}](vkGetProc("vkCmdBlitImage2"))
  vkCmdResolveImage2 = cast[proc (commandBuffer: VkCommandBuffer, pResolveImageInfo: ptr VkResolveImageInfo2) {.stdcall.}](vkGetProc("vkCmdResolveImage2"))
  vkCmdBeginRendering = cast[proc (commandBuffer: VkCommandBuffer, pRenderingInfo: ptr VkRenderingInfo) {.stdcall.}](vkGetProc("vkCmdBeginRendering"))
  vkCmdEndRendering = cast[proc (commandBuffer: VkCommandBuffer) {.stdcall.}](vkGetProc("vkCmdEndRendering"))
  vkCmdSetCullMode = cast[proc (commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) {.stdcall.}](vkGetProc("vkCmdSetCullMode"))
  vkCmdSetFrontFace = cast[proc (commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) {.stdcall.}](vkGetProc("vkCmdSetFrontFace"))
  vkCmdSetPrimitiveTopology = cast[proc (commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) {.stdcall.}](vkGetProc("vkCmdSetPrimitiveTopology"))
  vkCmdSetViewportWithCount = cast[proc (commandBuffer: VkCommandBuffer, viewportCount: uint32, pViewports: ptr VkViewport) {.stdcall.}](vkGetProc("vkCmdSetViewportWithCount"))
  vkCmdSetScissorWithCount = cast[proc (commandBuffer: VkCommandBuffer, scissorCount: uint32, pScissors: ptr VkRect2D) {.stdcall.}](vkGetProc("vkCmdSetScissorWithCount"))
  vkCmdBindVertexBuffers2 = cast[proc (commandBuffer: VkCommandBuffer, firstBinding: uint32, bindingCount: uint32, pBuffers: ptr VkBuffer, pOffsets: ptr VkDeviceSize, pSizes: ptr VkDeviceSize, pStrides: ptr VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdBindVertexBuffers2"))
  vkCmdSetDepthTestEnable = cast[proc (commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthTestEnable"))
  vkCmdSetDepthWriteEnable = cast[proc (commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthWriteEnable"))
  vkCmdSetDepthCompareOp = cast[proc (commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) {.stdcall.}](vkGetProc("vkCmdSetDepthCompareOp"))
  vkCmdSetDepthBoundsTestEnable = cast[proc (commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthBoundsTestEnable"))
  vkCmdSetStencilTestEnable = cast[proc (commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetStencilTestEnable"))
  vkCmdSetStencilOp = cast[proc (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) {.stdcall.}](vkGetProc("vkCmdSetStencilOp"))
  vkCmdSetRasterizerDiscardEnable = cast[proc (commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetRasterizerDiscardEnable"))
  vkCmdSetDepthBiasEnable = cast[proc (commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthBiasEnable"))
  vkCmdSetPrimitiveRestartEnable = cast[proc (commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetPrimitiveRestartEnable"))

# Vulkan 1_4
proc vkLoad1_4*() =
  vkMapMemory2 = cast[proc (device: VkDevice, pMemoryMapInfo: ptr VkMemoryMapInfo, ppData: ptr pointer): VkResult {.stdcall.}](vkGetProc("vkMapMemory2"))
  vkUnmapMemory2 = cast[proc (device: VkDevice, pMemoryUnmapInfo: ptr VkMemoryUnmapInfo): VkResult {.stdcall.}](vkGetProc("vkUnmapMemory2"))
  vkGetDeviceImageSubresourceLayout = cast[proc (device: VkDevice, pInfo: ptr VkDeviceImageSubresourceInfo, pLayout: ptr VkSubresourceLayout2) {.stdcall.}](vkGetProc("vkGetDeviceImageSubresourceLayout"))
  vkGetImageSubresourceLayout2 = cast[proc (device: VkDevice, image: VkImage, pSubresource: ptr VkImageSubresource2, pLayout: ptr VkSubresourceLayout2) {.stdcall.}](vkGetProc("vkGetImageSubresourceLayout2"))
  vkCopyMemoryToImage = cast[proc (device: VkDevice, pCopyMemoryToImageInfo: ptr VkCopyMemoryToImageInfo): VkResult {.stdcall.}](vkGetProc("vkCopyMemoryToImage"))
  vkCopyImageToMemory = cast[proc (device: VkDevice, pCopyImageToMemoryInfo: ptr VkCopyImageToMemoryInfo): VkResult {.stdcall.}](vkGetProc("vkCopyImageToMemory"))
  vkCopyImageToImage = cast[proc (device: VkDevice, pCopyImageToImageInfo: ptr VkCopyImageToImageInfo): VkResult {.stdcall.}](vkGetProc("vkCopyImageToImage"))
  vkTransitionImageLayout = cast[proc (device: VkDevice, transitionCount: uint32, pTransitions: ptr VkHostImageLayoutTransitionInfo): VkResult {.stdcall.}](vkGetProc("vkTransitionImageLayout"))
  vkCmdPushDescriptorSet = cast[proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: uint32, descriptorWriteCount: uint32, pDescriptorWrites: ptr VkWriteDescriptorSet) {.stdcall.}](vkGetProc("vkCmdPushDescriptorSet"))
  vkCmdPushDescriptorSetWithTemplate = cast[proc (commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: uint32, pData: pointer) {.stdcall.}](vkGetProc("vkCmdPushDescriptorSetWithTemplate"))
  vkCmdBindDescriptorSets2 = cast[proc (commandBuffer: VkCommandBuffer, pBindDescriptorSetsInfo: ptr VkBindDescriptorSetsInfo) {.stdcall.}](vkGetProc("vkCmdBindDescriptorSets2"))
  vkCmdPushConstants2 = cast[proc (commandBuffer: VkCommandBuffer, pPushConstantsInfo: ptr VkPushConstantsInfo) {.stdcall.}](vkGetProc("vkCmdPushConstants2"))
  vkCmdPushDescriptorSet2 = cast[proc (commandBuffer: VkCommandBuffer, pPushDescriptorSetInfo: ptr VkPushDescriptorSetInfo) {.stdcall.}](vkGetProc("vkCmdPushDescriptorSet2"))
  vkCmdPushDescriptorSetWithTemplate2 = cast[proc (commandBuffer: VkCommandBuffer, pPushDescriptorSetWithTemplateInfo: ptr VkPushDescriptorSetWithTemplateInfo) {.stdcall.}](vkGetProc("vkCmdPushDescriptorSetWithTemplate2"))
  vkCmdSetLineStipple = cast[proc (commandBuffer: VkCommandBuffer, lineStippleFactor: uint32, lineStipplePattern: uint16) {.stdcall.}](vkGetProc("vkCmdSetLineStipple"))
  vkCmdBindIndexBuffer2 = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, size: VkDeviceSize, indexType: VkIndexType) {.stdcall.}](vkGetProc("vkCmdBindIndexBuffer2"))
  vkGetRenderingAreaGranularity = cast[proc (device: VkDevice, pRenderingAreaInfo: ptr VkRenderingAreaInfo, pGranularity: ptr VkExtent2D) {.stdcall.}](vkGetProc("vkGetRenderingAreaGranularity"))
  vkCmdSetRenderingAttachmentLocations = cast[proc (commandBuffer: VkCommandBuffer, pLocationInfo: ptr VkRenderingAttachmentLocationInfo) {.stdcall.}](vkGetProc("vkCmdSetRenderingAttachmentLocations"))
  vkCmdSetRenderingInputAttachmentIndices = cast[proc (commandBuffer: VkCommandBuffer, pInputAttachmentIndexInfo: ptr VkRenderingInputAttachmentIndexInfo) {.stdcall.}](vkGetProc("vkCmdSetRenderingInputAttachmentIndices"))
  vkCreateRenderPass2 = cast[proc (device: VkDevice, pCreateInfo: ptr VkRenderPassCreateInfo2, pAllocator: ptr VkAllocationCallbacks, pRenderPass: ptr VkRenderPass): VkResult {.stdcall.}](vkGetProc("vkCreateRenderPass2"))
  vkDestroyRenderPass = cast[proc (device: VkDevice, renderPass: VkRenderPass, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyRenderPass"))
  vkCreateFramebuffer = cast[proc (device: VkDevice, pCreateInfo: ptr VkFramebufferCreateInfo, pAllocator: ptr VkAllocationCallbacks, pFramebuffer: ptr VkFramebuffer): VkResult {.stdcall.}](vkGetProc("vkCreateFramebuffer"))
  vkDestroyFramebuffer = cast[proc (device: VkDevice, framebuffer: VkFramebuffer, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyFramebuffer"))
  vkGetRenderAreaGranularity = cast[proc (device: VkDevice, renderPass: VkRenderPass, pGranularity: ptr VkExtent2D) {.stdcall.}](vkGetProc("vkGetRenderAreaGranularity"))
  vkCmdBeginRenderPass2 = cast[proc (commandBuffer: VkCommandBuffer, pRenderPassBegin: ptr VkRenderPassBeginInfo, pSubpassBeginInfo: ptr VkSubpassBeginInfo) {.stdcall.}](vkGetProc("vkCmdBeginRenderPass2"))
  vkCmdNextSubpass2 = cast[proc (commandBuffer: VkCommandBuffer, pSubpassBeginInfo: ptr VkSubpassBeginInfo, pSubpassEndInfo: ptr VkSubpassEndInfo) {.stdcall.}](vkGetProc("vkCmdNextSubpass2"))
  vkCmdEndRenderPass2 = cast[proc (commandBuffer: VkCommandBuffer, pSubpassEndInfo: ptr VkSubpassEndInfo) {.stdcall.}](vkGetProc("vkCmdEndRenderPass2"))

# Load VK_KHR_surface
proc loadVK_KHR_surface*() =
  vkDestroySurfaceKHR = cast[proc (instance: VkInstance, surface: VkSurfaceKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroySurfaceKHR"))
  vkGetPhysicalDeviceSurfaceSupportKHR = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, surface: VkSurfaceKHR, pSupported: ptr VkBool32): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSurfaceSupportKHR"))
  vkGetPhysicalDeviceSurfaceCapabilitiesKHR = cast[proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: ptr VkSurfaceCapabilitiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSurfaceCapabilitiesKHR"))
  vkGetPhysicalDeviceSurfaceFormatsKHR = cast[proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceFormatCount: ptr uint32, pSurfaceFormats: ptr VkSurfaceFormatKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSurfaceFormatsKHR"))
  vkGetPhysicalDeviceSurfacePresentModesKHR = cast[proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pPresentModeCount: ptr uint32, pPresentModes: ptr VkPresentModeKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSurfacePresentModesKHR"))

# Load VK_KHR_swapchain
proc loadVK_KHR_swapchain*() =
  vkCreateSwapchainKHR = cast[proc (device: VkDevice, pCreateInfo: ptr VkSwapchainCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSwapchain: ptr VkSwapchainKHR): VkResult {.stdcall.}](vkGetProc("vkCreateSwapchainKHR"))
  vkDestroySwapchainKHR = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroySwapchainKHR"))
  vkGetSwapchainImagesKHR = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainImageCount: ptr uint32, pSwapchainImages: ptr VkImage): VkResult {.stdcall.}](vkGetProc("vkGetSwapchainImagesKHR"))
  vkAcquireNextImageKHR = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, timeout: uint64, semaphore: VkSemaphore, fence: VkFence, pImageIndex: ptr uint32): VkResult {.stdcall.}](vkGetProc("vkAcquireNextImageKHR"))
  vkQueuePresentKHR = cast[proc (queue: VkQueue, pPresentInfo: ptr VkPresentInfoKHR): VkResult {.stdcall.}](vkGetProc("vkQueuePresentKHR"))
  vkGetDeviceGroupPresentCapabilitiesKHR = cast[proc (device: VkDevice, pDeviceGroupPresentCapabilities: ptr VkDeviceGroupPresentCapabilitiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetDeviceGroupPresentCapabilitiesKHR"))
  vkGetDeviceGroupSurfacePresentModesKHR = cast[proc (device: VkDevice, surface: VkSurfaceKHR, pModes: ptr VkDeviceGroupPresentModeFlagsKHR): VkResult {.stdcall.}](vkGetProc("vkGetDeviceGroupSurfacePresentModesKHR"))
  vkGetPhysicalDevicePresentRectanglesKHR = cast[proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pRectCount: ptr uint32, pRects: ptr VkRect2D): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDevicePresentRectanglesKHR"))
  vkAcquireNextImage2KHR = cast[proc (device: VkDevice, pAcquireInfo: ptr VkAcquireNextImageInfoKHR, pImageIndex: ptr uint32): VkResult {.stdcall.}](vkGetProc("vkAcquireNextImage2KHR"))

# Load VK_KHR_display
proc loadVK_KHR_display*() =
  vkGetPhysicalDeviceDisplayPropertiesKHR = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayPropertiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceDisplayPropertiesKHR"))
  vkGetPhysicalDeviceDisplayPlanePropertiesKHR = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayPlanePropertiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceDisplayPlanePropertiesKHR"))
  vkGetDisplayPlaneSupportedDisplaysKHR = cast[proc (physicalDevice: VkPhysicalDevice, planeIndex: uint32, pDisplayCount: ptr uint32, pDisplays: ptr VkDisplayKHR): VkResult {.stdcall.}](vkGetProc("vkGetDisplayPlaneSupportedDisplaysKHR"))
  vkGetDisplayModePropertiesKHR = cast[proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayModePropertiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetDisplayModePropertiesKHR"))
  vkCreateDisplayModeKHR = cast[proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pCreateInfo: ptr VkDisplayModeCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pMode: ptr VkDisplayModeKHR): VkResult {.stdcall.}](vkGetProc("vkCreateDisplayModeKHR"))
  vkGetDisplayPlaneCapabilitiesKHR = cast[proc (physicalDevice: VkPhysicalDevice, mode: VkDisplayModeKHR, planeIndex: uint32, pCapabilities: ptr VkDisplayPlaneCapabilitiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetDisplayPlaneCapabilitiesKHR"))
  vkCreateDisplayPlaneSurfaceKHR = cast[proc (instance: VkInstance, pCreateInfo: ptr VkDisplaySurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateDisplayPlaneSurfaceKHR"))

# Load VK_KHR_display_swapchain
proc loadVK_KHR_display_swapchain*() =
  vkCreateSharedSwapchainsKHR = cast[proc (device: VkDevice, swapchainCount: uint32, pCreateInfos: ptr VkSwapchainCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSwapchains: ptr VkSwapchainKHR): VkResult {.stdcall.}](vkGetProc("vkCreateSharedSwapchainsKHR"))

# Load VK_KHR_xlib_surface
proc loadVK_KHR_xlib_surface*() =
  vkCreateXlibSurfaceKHR = cast[proc (instance: VkInstance, pCreateInfo: ptr VkXlibSurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateXlibSurfaceKHR"))
  vkGetPhysicalDeviceXlibPresentationSupportKHR = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, dpy: ptr Display, visualID: VisualID): VkBool32 {.stdcall.}](vkGetProc("vkGetPhysicalDeviceXlibPresentationSupportKHR"))

# Load VK_KHR_xcb_surface
proc loadVK_KHR_xcb_surface*() =
  vkCreateXcbSurfaceKHR = cast[proc (instance: VkInstance, pCreateInfo: ptr VkXcbSurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateXcbSurfaceKHR"))
  vkGetPhysicalDeviceXcbPresentationSupportKHR = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, connection: ptr xcb_connection_t, visual_id: xcb_visualid_t): VkBool32 {.stdcall.}](vkGetProc("vkGetPhysicalDeviceXcbPresentationSupportKHR"))

# Load VK_KHR_wayland_surface
proc loadVK_KHR_wayland_surface*() =
  vkCreateWaylandSurfaceKHR = cast[proc (instance: VkInstance, pCreateInfo: ptr VkWaylandSurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateWaylandSurfaceKHR"))
  vkGetPhysicalDeviceWaylandPresentationSupportKHR = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, display: ptr wl_display): VkBool32 {.stdcall.}](vkGetProc("vkGetPhysicalDeviceWaylandPresentationSupportKHR"))

# Load VK_KHR_android_surface
proc loadVK_KHR_android_surface*() =
  vkCreateAndroidSurfaceKHR = cast[proc (instance: VkInstance, pCreateInfo: ptr VkAndroidSurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateAndroidSurfaceKHR"))

# Load VK_KHR_win32_surface
proc loadVK_KHR_win32_surface*() =
  vkCreateWin32SurfaceKHR = cast[proc (instance: VkInstance, pCreateInfo: ptr VkWin32SurfaceCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateWin32SurfaceKHR"))
  vkGetPhysicalDeviceWin32PresentationSupportKHR = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32): VkBool32 {.stdcall.}](vkGetProc("vkGetPhysicalDeviceWin32PresentationSupportKHR"))

# Load VK_ANDROID_native_buffer
proc loadVK_ANDROID_native_buffer*() =
  vkGetSwapchainGrallocUsageANDROID = cast[proc (device: VkDevice, format: VkFormat, imageUsage: VkImageUsageFlags, grallocUsage: ptr int): VkResult {.stdcall.}](vkGetProc("vkGetSwapchainGrallocUsageANDROID"))
  vkAcquireImageANDROID = cast[proc (device: VkDevice, image: VkImage, nativeFenceFd: int, semaphore: VkSemaphore, fence: VkFence): VkResult {.stdcall.}](vkGetProc("vkAcquireImageANDROID"))
  vkQueueSignalReleaseImageANDROID = cast[proc (queue: VkQueue, waitSemaphoreCount: uint32, pWaitSemaphores: ptr VkSemaphore, image: VkImage, pNativeFenceFd: ptr int): VkResult {.stdcall.}](vkGetProc("vkQueueSignalReleaseImageANDROID"))
  vkGetSwapchainGrallocUsage2ANDROID = cast[proc (device: VkDevice, format: VkFormat, imageUsage: VkImageUsageFlags, swapchainImageUsage: VkSwapchainImageUsageFlagsANDROID, grallocConsumerUsage: ptr uint64, grallocProducerUsage: ptr uint64): VkResult {.stdcall.}](vkGetProc("vkGetSwapchainGrallocUsage2ANDROID"))

# Load VK_EXT_debug_report
proc loadVK_EXT_debug_report*() =
  vkCreateDebugReportCallbackEXT = cast[proc (instance: VkInstance, pCreateInfo: ptr VkDebugReportCallbackCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pCallback: ptr VkDebugReportCallbackEXT): VkResult {.stdcall.}](vkGetProc("vkCreateDebugReportCallbackEXT"))
  vkDestroyDebugReportCallbackEXT = cast[proc (instance: VkInstance, callback: VkDebugReportCallbackEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyDebugReportCallbackEXT"))
  vkDebugReportMessageEXT = cast[proc (instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, `object`: uint64, location: uint, messageCode: int32, pLayerPrefix: cstring, pMessage: cstring) {.stdcall.}](vkGetProc("vkDebugReportMessageEXT"))

# Load VK_EXT_debug_marker
proc loadVK_EXT_debug_marker*() =
  vkDebugMarkerSetObjectTagEXT = cast[proc (device: VkDevice, pTagInfo: ptr VkDebugMarkerObjectTagInfoEXT): VkResult {.stdcall.}](vkGetProc("vkDebugMarkerSetObjectTagEXT"))
  vkDebugMarkerSetObjectNameEXT = cast[proc (device: VkDevice, pNameInfo: ptr VkDebugMarkerObjectNameInfoEXT): VkResult {.stdcall.}](vkGetProc("vkDebugMarkerSetObjectNameEXT"))
  vkCmdDebugMarkerBeginEXT = cast[proc (commandBuffer: VkCommandBuffer, pMarkerInfo: ptr VkDebugMarkerMarkerInfoEXT) {.stdcall.}](vkGetProc("vkCmdDebugMarkerBeginEXT"))
  vkCmdDebugMarkerEndEXT = cast[proc (commandBuffer: VkCommandBuffer) {.stdcall.}](vkGetProc("vkCmdDebugMarkerEndEXT"))
  vkCmdDebugMarkerInsertEXT = cast[proc (commandBuffer: VkCommandBuffer, pMarkerInfo: ptr VkDebugMarkerMarkerInfoEXT) {.stdcall.}](vkGetProc("vkCmdDebugMarkerInsertEXT"))

# Load VK_KHR_video_queue
proc loadVK_KHR_video_queue*() =
  vkGetPhysicalDeviceVideoCapabilitiesKHR = cast[proc (physicalDevice: VkPhysicalDevice, pVideoProfile: ptr VkVideoProfileInfoKHR, pCapabilities: ptr VkVideoCapabilitiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceVideoCapabilitiesKHR"))
  vkGetPhysicalDeviceVideoFormatPropertiesKHR = cast[proc (physicalDevice: VkPhysicalDevice, pVideoFormatInfo: ptr VkPhysicalDeviceVideoFormatInfoKHR, pVideoFormatPropertyCount: ptr uint32, pVideoFormatProperties: ptr VkVideoFormatPropertiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceVideoFormatPropertiesKHR"))
  vkCreateVideoSessionKHR = cast[proc (device: VkDevice, pCreateInfo: ptr VkVideoSessionCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pVideoSession: ptr VkVideoSessionKHR): VkResult {.stdcall.}](vkGetProc("vkCreateVideoSessionKHR"))
  vkDestroyVideoSessionKHR = cast[proc (device: VkDevice, videoSession: VkVideoSessionKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyVideoSessionKHR"))
  vkGetVideoSessionMemoryRequirementsKHR = cast[proc (device: VkDevice, videoSession: VkVideoSessionKHR, pMemoryRequirementsCount: ptr uint32, pMemoryRequirements: ptr VkVideoSessionMemoryRequirementsKHR): VkResult {.stdcall.}](vkGetProc("vkGetVideoSessionMemoryRequirementsKHR"))
  vkBindVideoSessionMemoryKHR = cast[proc (device: VkDevice, videoSession: VkVideoSessionKHR, bindSessionMemoryInfoCount: uint32, pBindSessionMemoryInfos: ptr VkBindVideoSessionMemoryInfoKHR): VkResult {.stdcall.}](vkGetProc("vkBindVideoSessionMemoryKHR"))
  vkCreateVideoSessionParametersKHR = cast[proc (device: VkDevice, pCreateInfo: ptr VkVideoSessionParametersCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pVideoSessionParameters: ptr VkVideoSessionParametersKHR): VkResult {.stdcall.}](vkGetProc("vkCreateVideoSessionParametersKHR"))
  vkUpdateVideoSessionParametersKHR = cast[proc (device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pUpdateInfo: ptr VkVideoSessionParametersUpdateInfoKHR): VkResult {.stdcall.}](vkGetProc("vkUpdateVideoSessionParametersKHR"))
  vkDestroyVideoSessionParametersKHR = cast[proc (device: VkDevice, videoSessionParameters: VkVideoSessionParametersKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyVideoSessionParametersKHR"))
  vkCmdBeginVideoCodingKHR = cast[proc (commandBuffer: VkCommandBuffer, pBeginInfo: ptr VkVideoBeginCodingInfoKHR) {.stdcall.}](vkGetProc("vkCmdBeginVideoCodingKHR"))
  vkCmdEndVideoCodingKHR = cast[proc (commandBuffer: VkCommandBuffer, pEndCodingInfo: ptr VkVideoEndCodingInfoKHR) {.stdcall.}](vkGetProc("vkCmdEndVideoCodingKHR"))
  vkCmdControlVideoCodingKHR = cast[proc (commandBuffer: VkCommandBuffer, pCodingControlInfo: ptr VkVideoCodingControlInfoKHR) {.stdcall.}](vkGetProc("vkCmdControlVideoCodingKHR"))

# Load VK_KHR_video_decode_queue
proc loadVK_KHR_video_decode_queue*() =
  vkCmdDecodeVideoKHR = cast[proc (commandBuffer: VkCommandBuffer, pDecodeInfo: ptr VkVideoDecodeInfoKHR) {.stdcall.}](vkGetProc("vkCmdDecodeVideoKHR"))

# Load VK_EXT_transform_feedback
proc loadVK_EXT_transform_feedback*() =
  vkCmdBindTransformFeedbackBuffersEXT = cast[proc (commandBuffer: VkCommandBuffer, firstBinding: uint32, bindingCount: uint32, pBuffers: ptr VkBuffer, pOffsets: ptr VkDeviceSize, pSizes: ptr VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdBindTransformFeedbackBuffersEXT"))
  vkCmdBeginTransformFeedbackEXT = cast[proc (commandBuffer: VkCommandBuffer, firstCounterBuffer: uint32, counterBufferCount: uint32, pCounterBuffers: ptr VkBuffer, pCounterBufferOffsets: ptr VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdBeginTransformFeedbackEXT"))
  vkCmdEndTransformFeedbackEXT = cast[proc (commandBuffer: VkCommandBuffer, firstCounterBuffer: uint32, counterBufferCount: uint32, pCounterBuffers: ptr VkBuffer, pCounterBufferOffsets: ptr VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdEndTransformFeedbackEXT"))
  vkCmdBeginQueryIndexedEXT = cast[proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32, flags: VkQueryControlFlags, index: uint32) {.stdcall.}](vkGetProc("vkCmdBeginQueryIndexedEXT"))
  vkCmdEndQueryIndexedEXT = cast[proc (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32, index: uint32) {.stdcall.}](vkGetProc("vkCmdEndQueryIndexedEXT"))
  vkCmdDrawIndirectByteCountEXT = cast[proc (commandBuffer: VkCommandBuffer, instanceCount: uint32, firstInstance: uint32, counterBuffer: VkBuffer, counterBufferOffset: VkDeviceSize, counterOffset: uint32, vertexStride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawIndirectByteCountEXT"))

# Load VK_NVX_binary_import
proc loadVK_NVX_binary_import*() =
  vkCreateCuModuleNVX = cast[proc (device: VkDevice, pCreateInfo: ptr VkCuModuleCreateInfoNVX, pAllocator: ptr VkAllocationCallbacks, pModule: ptr VkCuModuleNVX): VkResult {.stdcall.}](vkGetProc("vkCreateCuModuleNVX"))
  vkCreateCuFunctionNVX = cast[proc (device: VkDevice, pCreateInfo: ptr VkCuFunctionCreateInfoNVX, pAllocator: ptr VkAllocationCallbacks, pFunction: ptr VkCuFunctionNVX): VkResult {.stdcall.}](vkGetProc("vkCreateCuFunctionNVX"))
  vkDestroyCuModuleNVX = cast[proc (device: VkDevice, module: VkCuModuleNVX, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyCuModuleNVX"))
  vkDestroyCuFunctionNVX = cast[proc (device: VkDevice, function: VkCuFunctionNVX, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyCuFunctionNVX"))
  vkCmdCuLaunchKernelNVX = cast[proc (commandBuffer: VkCommandBuffer, pLaunchInfo: ptr VkCuLaunchInfoNVX) {.stdcall.}](vkGetProc("vkCmdCuLaunchKernelNVX"))

# Load VK_NVX_image_view_handle
proc loadVK_NVX_image_view_handle*() =
  vkGetImageViewHandleNVX = cast[proc (device: VkDevice, pInfo: ptr VkImageViewHandleInfoNVX): uint32 {.stdcall.}](vkGetProc("vkGetImageViewHandleNVX"))
  vkGetImageViewHandle64NVX = cast[proc (device: VkDevice, pInfo: ptr VkImageViewHandleInfoNVX): uint64 {.stdcall.}](vkGetProc("vkGetImageViewHandle64NVX"))
  vkGetImageViewAddressNVX = cast[proc (device: VkDevice, imageView: VkImageView, pProperties: ptr VkImageViewAddressPropertiesNVX): VkResult {.stdcall.}](vkGetProc("vkGetImageViewAddressNVX"))
  vkGetDeviceCombinedImageSamplerIndexNVX = cast[proc (device: VkDevice, imageViewIndex: uint64, samplerIndex: uint64): uint64 {.stdcall.}](vkGetProc("vkGetDeviceCombinedImageSamplerIndexNVX"))

# Load VK_AMD_shader_info
proc loadVK_AMD_shader_info*() =
  vkGetShaderInfoAMD = cast[proc (device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: ptr uint, pInfo: pointer): VkResult {.stdcall.}](vkGetProc("vkGetShaderInfoAMD"))

# Load VK_GGP_stream_descriptor_surface
proc loadVK_GGP_stream_descriptor_surface*() =
  vkCreateStreamDescriptorSurfaceGGP = cast[proc (instance: VkInstance, pCreateInfo: ptr VkStreamDescriptorSurfaceCreateInfoGGP, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateStreamDescriptorSurfaceGGP"))

# Load VK_NV_external_memory_capabilities
proc loadVK_NV_external_memory_capabilities*() =
  vkGetPhysicalDeviceExternalImageFormatPropertiesNV = cast[proc (physicalDevice: VkPhysicalDevice, format: VkFormat, `type`: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: ptr VkExternalImageFormatPropertiesNV): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceExternalImageFormatPropertiesNV"))

# Load VK_NV_external_memory_win32
proc loadVK_NV_external_memory_win32*() =
  vkGetMemoryWin32HandleNV = cast[proc (device: VkDevice, memory: VkDeviceMemory, handleType: VkExternalMemoryHandleTypeFlagsNV, pHandle: ptr HANDLE): VkResult {.stdcall.}](vkGetProc("vkGetMemoryWin32HandleNV"))

# Load VK_KHR_device_group
proc loadVK_KHR_device_group*() =
  vkGetDeviceGroupPresentCapabilitiesKHR = cast[proc (device: VkDevice, pDeviceGroupPresentCapabilities: ptr VkDeviceGroupPresentCapabilitiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetDeviceGroupPresentCapabilitiesKHR"))
  vkGetDeviceGroupSurfacePresentModesKHR = cast[proc (device: VkDevice, surface: VkSurfaceKHR, pModes: ptr VkDeviceGroupPresentModeFlagsKHR): VkResult {.stdcall.}](vkGetProc("vkGetDeviceGroupSurfacePresentModesKHR"))
  vkGetPhysicalDevicePresentRectanglesKHR = cast[proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pRectCount: ptr uint32, pRects: ptr VkRect2D): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDevicePresentRectanglesKHR"))
  vkAcquireNextImage2KHR = cast[proc (device: VkDevice, pAcquireInfo: ptr VkAcquireNextImageInfoKHR, pImageIndex: ptr uint32): VkResult {.stdcall.}](vkGetProc("vkAcquireNextImage2KHR"))

# Load VK_NN_vi_surface
proc loadVK_NN_vi_surface*() =
  vkCreateViSurfaceNN = cast[proc (instance: VkInstance, pCreateInfo: ptr VkViSurfaceCreateInfoNN, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateViSurfaceNN"))

# Load VK_KHR_external_memory_win32
proc loadVK_KHR_external_memory_win32*() =
  vkGetMemoryWin32HandleKHR = cast[proc (device: VkDevice, pGetWin32HandleInfo: ptr VkMemoryGetWin32HandleInfoKHR, pHandle: ptr HANDLE): VkResult {.stdcall.}](vkGetProc("vkGetMemoryWin32HandleKHR"))
  vkGetMemoryWin32HandlePropertiesKHR = cast[proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, handle: HANDLE, pMemoryWin32HandleProperties: ptr VkMemoryWin32HandlePropertiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetMemoryWin32HandlePropertiesKHR"))

# Load VK_KHR_external_memory_fd
proc loadVK_KHR_external_memory_fd*() =
  vkGetMemoryFdKHR = cast[proc (device: VkDevice, pGetFdInfo: ptr VkMemoryGetFdInfoKHR, pFd: ptr int): VkResult {.stdcall.}](vkGetProc("vkGetMemoryFdKHR"))
  vkGetMemoryFdPropertiesKHR = cast[proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, fd: int, pMemoryFdProperties: ptr VkMemoryFdPropertiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetMemoryFdPropertiesKHR"))

# Load VK_KHR_external_semaphore_win32
proc loadVK_KHR_external_semaphore_win32*() =
  vkImportSemaphoreWin32HandleKHR = cast[proc (device: VkDevice, pImportSemaphoreWin32HandleInfo: ptr VkImportSemaphoreWin32HandleInfoKHR): VkResult {.stdcall.}](vkGetProc("vkImportSemaphoreWin32HandleKHR"))
  vkGetSemaphoreWin32HandleKHR = cast[proc (device: VkDevice, pGetWin32HandleInfo: ptr VkSemaphoreGetWin32HandleInfoKHR, pHandle: ptr HANDLE): VkResult {.stdcall.}](vkGetProc("vkGetSemaphoreWin32HandleKHR"))

# Load VK_KHR_external_semaphore_fd
proc loadVK_KHR_external_semaphore_fd*() =
  vkImportSemaphoreFdKHR = cast[proc (device: VkDevice, pImportSemaphoreFdInfo: ptr VkImportSemaphoreFdInfoKHR): VkResult {.stdcall.}](vkGetProc("vkImportSemaphoreFdKHR"))
  vkGetSemaphoreFdKHR = cast[proc (device: VkDevice, pGetFdInfo: ptr VkSemaphoreGetFdInfoKHR, pFd: ptr int): VkResult {.stdcall.}](vkGetProc("vkGetSemaphoreFdKHR"))

# Load VK_EXT_conditional_rendering
proc loadVK_EXT_conditional_rendering*() =
  vkCmdBeginConditionalRenderingEXT = cast[proc (commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: ptr VkConditionalRenderingBeginInfoEXT) {.stdcall.}](vkGetProc("vkCmdBeginConditionalRenderingEXT"))
  vkCmdEndConditionalRenderingEXT = cast[proc (commandBuffer: VkCommandBuffer) {.stdcall.}](vkGetProc("vkCmdEndConditionalRenderingEXT"))

# Load VK_NV_clip_space_w_scaling
proc loadVK_NV_clip_space_w_scaling*() =
  vkCmdSetViewportWScalingNV = cast[proc (commandBuffer: VkCommandBuffer, firstViewport: uint32, viewportCount: uint32, pViewportWScalings: ptr VkViewportWScalingNV) {.stdcall.}](vkGetProc("vkCmdSetViewportWScalingNV"))

# Load VK_EXT_direct_mode_display
proc loadVK_EXT_direct_mode_display*() =
  vkReleaseDisplayEXT = cast[proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR): VkResult {.stdcall.}](vkGetProc("vkReleaseDisplayEXT"))

# Load VK_EXT_acquire_xlib_display
proc loadVK_EXT_acquire_xlib_display*() =
  vkAcquireXlibDisplayEXT = cast[proc (physicalDevice: VkPhysicalDevice, dpy: ptr Display, display: VkDisplayKHR): VkResult {.stdcall.}](vkGetProc("vkAcquireXlibDisplayEXT"))
  vkGetRandROutputDisplayEXT = cast[proc (physicalDevice: VkPhysicalDevice, dpy: ptr Display, rrOutput: RROutput, pDisplay: ptr VkDisplayKHR): VkResult {.stdcall.}](vkGetProc("vkGetRandROutputDisplayEXT"))

# Load VK_EXT_display_surface_counter
proc loadVK_EXT_display_surface_counter*() =
  vkGetPhysicalDeviceSurfaceCapabilities2EXT = cast[proc (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: ptr VkSurfaceCapabilities2EXT): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSurfaceCapabilities2EXT"))

# Load VK_EXT_display_control
proc loadVK_EXT_display_control*() =
  vkDisplayPowerControlEXT = cast[proc (device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: ptr VkDisplayPowerInfoEXT): VkResult {.stdcall.}](vkGetProc("vkDisplayPowerControlEXT"))
  vkRegisterDeviceEventEXT = cast[proc (device: VkDevice, pDeviceEventInfo: ptr VkDeviceEventInfoEXT, pAllocator: ptr VkAllocationCallbacks, pFence: ptr VkFence): VkResult {.stdcall.}](vkGetProc("vkRegisterDeviceEventEXT"))
  vkRegisterDisplayEventEXT = cast[proc (device: VkDevice, display: VkDisplayKHR, pDisplayEventInfo: ptr VkDisplayEventInfoEXT, pAllocator: ptr VkAllocationCallbacks, pFence: ptr VkFence): VkResult {.stdcall.}](vkGetProc("vkRegisterDisplayEventEXT"))
  vkGetSwapchainCounterEXT = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, counter: VkSurfaceCounterFlagBitsEXT, pCounterValue: ptr uint64): VkResult {.stdcall.}](vkGetProc("vkGetSwapchainCounterEXT"))

# Load VK_GOOGLE_display_timing
proc loadVK_GOOGLE_display_timing*() =
  vkGetRefreshCycleDurationGOOGLE = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: ptr VkRefreshCycleDurationGOOGLE): VkResult {.stdcall.}](vkGetProc("vkGetRefreshCycleDurationGOOGLE"))
  vkGetPastPresentationTimingGOOGLE = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pPresentationTimingCount: ptr uint32, pPresentationTimings: ptr VkPastPresentationTimingGOOGLE): VkResult {.stdcall.}](vkGetProc("vkGetPastPresentationTimingGOOGLE"))

# Load VK_EXT_discard_rectangles
proc loadVK_EXT_discard_rectangles*() =
  vkCmdSetDiscardRectangleEXT = cast[proc (commandBuffer: VkCommandBuffer, firstDiscardRectangle: uint32, discardRectangleCount: uint32, pDiscardRectangles: ptr VkRect2D) {.stdcall.}](vkGetProc("vkCmdSetDiscardRectangleEXT"))
  vkCmdSetDiscardRectangleEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, discardRectangleEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDiscardRectangleEnableEXT"))
  vkCmdSetDiscardRectangleModeEXT = cast[proc (commandBuffer: VkCommandBuffer, discardRectangleMode: VkDiscardRectangleModeEXT) {.stdcall.}](vkGetProc("vkCmdSetDiscardRectangleModeEXT"))

# Load VK_EXT_hdr_metadata
proc loadVK_EXT_hdr_metadata*() =
  vkSetHdrMetadataEXT = cast[proc (device: VkDevice, swapchainCount: uint32, pSwapchains: ptr VkSwapchainKHR, pMetadata: ptr VkHdrMetadataEXT) {.stdcall.}](vkGetProc("vkSetHdrMetadataEXT"))

# Load VK_KHR_shared_presentable_image
proc loadVK_KHR_shared_presentable_image*() =
  vkGetSwapchainStatusKHR = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR): VkResult {.stdcall.}](vkGetProc("vkGetSwapchainStatusKHR"))

# Load VK_KHR_external_fence_win32
proc loadVK_KHR_external_fence_win32*() =
  vkImportFenceWin32HandleKHR = cast[proc (device: VkDevice, pImportFenceWin32HandleInfo: ptr VkImportFenceWin32HandleInfoKHR): VkResult {.stdcall.}](vkGetProc("vkImportFenceWin32HandleKHR"))
  vkGetFenceWin32HandleKHR = cast[proc (device: VkDevice, pGetWin32HandleInfo: ptr VkFenceGetWin32HandleInfoKHR, pHandle: ptr HANDLE): VkResult {.stdcall.}](vkGetProc("vkGetFenceWin32HandleKHR"))

# Load VK_KHR_external_fence_fd
proc loadVK_KHR_external_fence_fd*() =
  vkImportFenceFdKHR = cast[proc (device: VkDevice, pImportFenceFdInfo: ptr VkImportFenceFdInfoKHR): VkResult {.stdcall.}](vkGetProc("vkImportFenceFdKHR"))
  vkGetFenceFdKHR = cast[proc (device: VkDevice, pGetFdInfo: ptr VkFenceGetFdInfoKHR, pFd: ptr int): VkResult {.stdcall.}](vkGetProc("vkGetFenceFdKHR"))

# Load VK_KHR_performance_query
proc loadVK_KHR_performance_query*() =
  vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, pCounterCount: ptr uint32, pCounters: ptr VkPerformanceCounterKHR, pCounterDescriptions: ptr VkPerformanceCounterDescriptionKHR): VkResult {.stdcall.}](vkGetProc("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"))
  vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = cast[proc (physicalDevice: VkPhysicalDevice, pPerformanceQueryCreateInfo: ptr VkQueryPoolPerformanceCreateInfoKHR, pNumPasses: ptr uint32) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"))
  vkAcquireProfilingLockKHR = cast[proc (device: VkDevice, pInfo: ptr VkAcquireProfilingLockInfoKHR): VkResult {.stdcall.}](vkGetProc("vkAcquireProfilingLockKHR"))
  vkReleaseProfilingLockKHR = cast[proc (device: VkDevice) {.stdcall.}](vkGetProc("vkReleaseProfilingLockKHR"))

# Load VK_KHR_get_surface_capabilities2
proc loadVK_KHR_get_surface_capabilities2*() =
  vkGetPhysicalDeviceSurfaceCapabilities2KHR = cast[proc (physicalDevice: VkPhysicalDevice, pSurfaceInfo: ptr VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: ptr VkSurfaceCapabilities2KHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSurfaceCapabilities2KHR"))
  vkGetPhysicalDeviceSurfaceFormats2KHR = cast[proc (physicalDevice: VkPhysicalDevice, pSurfaceInfo: ptr VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: ptr uint32, pSurfaceFormats: ptr VkSurfaceFormat2KHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSurfaceFormats2KHR"))

# Load VK_KHR_get_display_properties2
proc loadVK_KHR_get_display_properties2*() =
  vkGetPhysicalDeviceDisplayProperties2KHR = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayProperties2KHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceDisplayProperties2KHR"))
  vkGetPhysicalDeviceDisplayPlaneProperties2KHR = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayPlaneProperties2KHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceDisplayPlaneProperties2KHR"))
  vkGetDisplayModeProperties2KHR = cast[proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: ptr uint32, pProperties: ptr VkDisplayModeProperties2KHR): VkResult {.stdcall.}](vkGetProc("vkGetDisplayModeProperties2KHR"))
  vkGetDisplayPlaneCapabilities2KHR = cast[proc (physicalDevice: VkPhysicalDevice, pDisplayPlaneInfo: ptr VkDisplayPlaneInfo2KHR, pCapabilities: ptr VkDisplayPlaneCapabilities2KHR): VkResult {.stdcall.}](vkGetProc("vkGetDisplayPlaneCapabilities2KHR"))

# Load VK_MVK_ios_surface
proc loadVK_MVK_ios_surface*() =
  vkCreateIOSSurfaceMVK = cast[proc (instance: VkInstance, pCreateInfo: ptr VkIOSSurfaceCreateInfoMVK, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateIOSSurfaceMVK"))

# Load VK_MVK_macos_surface
proc loadVK_MVK_macos_surface*() =
  vkCreateMacOSSurfaceMVK = cast[proc (instance: VkInstance, pCreateInfo: ptr VkMacOSSurfaceCreateInfoMVK, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateMacOSSurfaceMVK"))

# Load VK_EXT_debug_utils
proc loadVK_EXT_debug_utils*() =
  vkSetDebugUtilsObjectNameEXT = cast[proc (device: VkDevice, pNameInfo: ptr VkDebugUtilsObjectNameInfoEXT): VkResult {.stdcall.}](vkGetProc("vkSetDebugUtilsObjectNameEXT"))
  vkSetDebugUtilsObjectTagEXT = cast[proc (device: VkDevice, pTagInfo: ptr VkDebugUtilsObjectTagInfoEXT): VkResult {.stdcall.}](vkGetProc("vkSetDebugUtilsObjectTagEXT"))
  vkQueueBeginDebugUtilsLabelEXT = cast[proc (queue: VkQueue, pLabelInfo: ptr VkDebugUtilsLabelEXT) {.stdcall.}](vkGetProc("vkQueueBeginDebugUtilsLabelEXT"))
  vkQueueEndDebugUtilsLabelEXT = cast[proc (queue: VkQueue) {.stdcall.}](vkGetProc("vkQueueEndDebugUtilsLabelEXT"))
  vkQueueInsertDebugUtilsLabelEXT = cast[proc (queue: VkQueue, pLabelInfo: ptr VkDebugUtilsLabelEXT) {.stdcall.}](vkGetProc("vkQueueInsertDebugUtilsLabelEXT"))
  vkCmdBeginDebugUtilsLabelEXT = cast[proc (commandBuffer: VkCommandBuffer, pLabelInfo: ptr VkDebugUtilsLabelEXT) {.stdcall.}](vkGetProc("vkCmdBeginDebugUtilsLabelEXT"))
  vkCmdEndDebugUtilsLabelEXT = cast[proc (commandBuffer: VkCommandBuffer) {.stdcall.}](vkGetProc("vkCmdEndDebugUtilsLabelEXT"))
  vkCmdInsertDebugUtilsLabelEXT = cast[proc (commandBuffer: VkCommandBuffer, pLabelInfo: ptr VkDebugUtilsLabelEXT) {.stdcall.}](vkGetProc("vkCmdInsertDebugUtilsLabelEXT"))
  vkCreateDebugUtilsMessengerEXT = cast[proc (instance: VkInstance, pCreateInfo: ptr VkDebugUtilsMessengerCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pMessenger: ptr VkDebugUtilsMessengerEXT): VkResult {.stdcall.}](vkGetProc("vkCreateDebugUtilsMessengerEXT"))
  vkDestroyDebugUtilsMessengerEXT = cast[proc (instance: VkInstance, messenger: VkDebugUtilsMessengerEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyDebugUtilsMessengerEXT"))
  vkSubmitDebugUtilsMessageEXT = cast[proc (instance: VkInstance, messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: ptr VkDebugUtilsMessengerCallbackDataEXT) {.stdcall.}](vkGetProc("vkSubmitDebugUtilsMessageEXT"))

# Load VK_ANDROID_external_memory_android_hardware_buffer
proc loadVK_ANDROID_external_memory_android_hardware_buffer*() =
  vkGetAndroidHardwareBufferPropertiesANDROID = cast[proc (device: VkDevice, buffer: ptr AHardwareBuffer, pProperties: ptr VkAndroidHardwareBufferPropertiesANDROID): VkResult {.stdcall.}](vkGetProc("vkGetAndroidHardwareBufferPropertiesANDROID"))
  vkGetMemoryAndroidHardwareBufferANDROID = cast[proc (device: VkDevice, pInfo: ptr VkMemoryGetAndroidHardwareBufferInfoANDROID, pBuffer: ptr ptr AHardwareBuffer): VkResult {.stdcall.}](vkGetProc("vkGetMemoryAndroidHardwareBufferANDROID"))

# Load VK_AMDX_shader_enqueue
proc loadVK_AMDX_shader_enqueue*() =
  vkCreateExecutionGraphPipelinesAMDX = cast[proc (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkExecutionGraphPipelineCreateInfoAMDX, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}](vkGetProc("vkCreateExecutionGraphPipelinesAMDX"))
  vkGetExecutionGraphPipelineScratchSizeAMDX = cast[proc (device: VkDevice, executionGraph: VkPipeline, pSizeInfo: ptr VkExecutionGraphPipelineScratchSizeAMDX): VkResult {.stdcall.}](vkGetProc("vkGetExecutionGraphPipelineScratchSizeAMDX"))
  vkGetExecutionGraphPipelineNodeIndexAMDX = cast[proc (device: VkDevice, executionGraph: VkPipeline, pNodeInfo: ptr VkPipelineShaderStageNodeCreateInfoAMDX, pNodeIndex: ptr uint32): VkResult {.stdcall.}](vkGetProc("vkGetExecutionGraphPipelineNodeIndexAMDX"))
  vkCmdInitializeGraphScratchMemoryAMDX = cast[proc (commandBuffer: VkCommandBuffer, executionGraph: VkPipeline, scratch: VkDeviceAddress, scratchSize: VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdInitializeGraphScratchMemoryAMDX"))
  vkCmdDispatchGraphAMDX = cast[proc (commandBuffer: VkCommandBuffer, scratch: VkDeviceAddress, scratchSize: VkDeviceSize, pCountInfo: ptr VkDispatchGraphCountInfoAMDX) {.stdcall.}](vkGetProc("vkCmdDispatchGraphAMDX"))
  vkCmdDispatchGraphIndirectAMDX = cast[proc (commandBuffer: VkCommandBuffer, scratch: VkDeviceAddress, scratchSize: VkDeviceSize, pCountInfo: ptr VkDispatchGraphCountInfoAMDX) {.stdcall.}](vkGetProc("vkCmdDispatchGraphIndirectAMDX"))
  vkCmdDispatchGraphIndirectCountAMDX = cast[proc (commandBuffer: VkCommandBuffer, scratch: VkDeviceAddress, scratchSize: VkDeviceSize, countInfo: VkDeviceAddress) {.stdcall.}](vkGetProc("vkCmdDispatchGraphIndirectCountAMDX"))

# Load VK_EXT_descriptor_heap
proc loadVK_EXT_descriptor_heap*() =
  vkWriteSamplerDescriptorsEXT = cast[proc (device: VkDevice, samplerCount: uint32, pSamplers: ptr VkSamplerCreateInfo, pDescriptors: ptr VkHostAddressRangeEXT): VkResult {.stdcall.}](vkGetProc("vkWriteSamplerDescriptorsEXT"))
  vkWriteResourceDescriptorsEXT = cast[proc (device: VkDevice, resourceCount: uint32, pResources: ptr VkResourceDescriptorInfoEXT, pDescriptors: ptr VkHostAddressRangeEXT): VkResult {.stdcall.}](vkGetProc("vkWriteResourceDescriptorsEXT"))
  vkCmdBindSamplerHeapEXT = cast[proc (commandBuffer: VkCommandBuffer, pBindInfo: ptr VkBindHeapInfoEXT) {.stdcall.}](vkGetProc("vkCmdBindSamplerHeapEXT"))
  vkCmdBindResourceHeapEXT = cast[proc (commandBuffer: VkCommandBuffer, pBindInfo: ptr VkBindHeapInfoEXT) {.stdcall.}](vkGetProc("vkCmdBindResourceHeapEXT"))
  vkCmdPushDataEXT = cast[proc (commandBuffer: VkCommandBuffer, pPushDataInfo: ptr VkPushDataInfoEXT) {.stdcall.}](vkGetProc("vkCmdPushDataEXT"))
  vkGetImageOpaqueCaptureDataEXT = cast[proc (device: VkDevice, imageCount: uint32, pImages: ptr VkImage, pDatas: ptr VkHostAddressRangeEXT): VkResult {.stdcall.}](vkGetProc("vkGetImageOpaqueCaptureDataEXT"))
  vkGetPhysicalDeviceDescriptorSizeEXT = cast[proc (physicalDevice: VkPhysicalDevice, descriptorType: VkDescriptorType): VkDeviceSize {.stdcall.}](vkGetProc("vkGetPhysicalDeviceDescriptorSizeEXT"))
  vkRegisterCustomBorderColorEXT = cast[proc (device: VkDevice, pBorderColor: ptr VkSamplerCustomBorderColorCreateInfoEXT, requestIndex: VkBool32, pIndex: ptr uint32): VkResult {.stdcall.}](vkGetProc("vkRegisterCustomBorderColorEXT"))
  vkUnregisterCustomBorderColorEXT = cast[proc (device: VkDevice, index: uint32) {.stdcall.}](vkGetProc("vkUnregisterCustomBorderColorEXT"))
  vkGetTensorOpaqueCaptureDataARM = cast[proc (device: VkDevice, tensorCount: uint32, pTensors: ptr VkTensorARM, pDatas: ptr VkHostAddressRangeEXT): VkResult {.stdcall.}](vkGetProc("vkGetTensorOpaqueCaptureDataARM"))

# Load VK_EXT_sample_locations
proc loadVK_EXT_sample_locations*() =
  vkCmdSetSampleLocationsEXT = cast[proc (commandBuffer: VkCommandBuffer, pSampleLocationsInfo: ptr VkSampleLocationsInfoEXT) {.stdcall.}](vkGetProc("vkCmdSetSampleLocationsEXT"))
  vkGetPhysicalDeviceMultisamplePropertiesEXT = cast[proc (physicalDevice: VkPhysicalDevice, samples: VkSampleCountFlagBits, pMultisampleProperties: ptr VkMultisamplePropertiesEXT) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceMultisamplePropertiesEXT"))

# Load VK_KHR_acceleration_structure
proc loadVK_KHR_acceleration_structure*() =
  vkCreateAccelerationStructureKHR = cast[proc (device: VkDevice, pCreateInfo: ptr VkAccelerationStructureCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pAccelerationStructure: ptr VkAccelerationStructureKHR): VkResult {.stdcall.}](vkGetProc("vkCreateAccelerationStructureKHR"))
  vkDestroyAccelerationStructureKHR = cast[proc (device: VkDevice, accelerationStructure: VkAccelerationStructureKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyAccelerationStructureKHR"))
  vkCmdBuildAccelerationStructuresKHR = cast[proc (commandBuffer: VkCommandBuffer, infoCount: uint32, pInfos: ptr VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: ptr ptr VkAccelerationStructureBuildRangeInfoKHR) {.stdcall.}](vkGetProc("vkCmdBuildAccelerationStructuresKHR"))
  vkCmdBuildAccelerationStructuresIndirectKHR = cast[proc (commandBuffer: VkCommandBuffer, infoCount: uint32, pInfos: ptr VkAccelerationStructureBuildGeometryInfoKHR, pIndirectDeviceAddresses: ptr VkDeviceAddress, pIndirectStrides: ptr uint32, ppMaxPrimitiveCounts: ptr ptr uint32) {.stdcall.}](vkGetProc("vkCmdBuildAccelerationStructuresIndirectKHR"))
  vkBuildAccelerationStructuresKHR = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: uint32, pInfos: ptr VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: ptr ptr VkAccelerationStructureBuildRangeInfoKHR): VkResult {.stdcall.}](vkGetProc("vkBuildAccelerationStructuresKHR"))
  vkCopyAccelerationStructureKHR = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyAccelerationStructureInfoKHR): VkResult {.stdcall.}](vkGetProc("vkCopyAccelerationStructureKHR"))
  vkCopyAccelerationStructureToMemoryKHR = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyAccelerationStructureToMemoryInfoKHR): VkResult {.stdcall.}](vkGetProc("vkCopyAccelerationStructureToMemoryKHR"))
  vkCopyMemoryToAccelerationStructureKHR = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyMemoryToAccelerationStructureInfoKHR): VkResult {.stdcall.}](vkGetProc("vkCopyMemoryToAccelerationStructureKHR"))
  vkWriteAccelerationStructuresPropertiesKHR = cast[proc (device: VkDevice, accelerationStructureCount: uint32, pAccelerationStructures: ptr VkAccelerationStructureKHR, queryType: VkQueryType, dataSize: uint, pData: pointer, stride: uint): VkResult {.stdcall.}](vkGetProc("vkWriteAccelerationStructuresPropertiesKHR"))
  vkCmdCopyAccelerationStructureKHR = cast[proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyAccelerationStructureInfoKHR) {.stdcall.}](vkGetProc("vkCmdCopyAccelerationStructureKHR"))
  vkCmdCopyAccelerationStructureToMemoryKHR = cast[proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyAccelerationStructureToMemoryInfoKHR) {.stdcall.}](vkGetProc("vkCmdCopyAccelerationStructureToMemoryKHR"))
  vkCmdCopyMemoryToAccelerationStructureKHR = cast[proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyMemoryToAccelerationStructureInfoKHR) {.stdcall.}](vkGetProc("vkCmdCopyMemoryToAccelerationStructureKHR"))
  vkGetAccelerationStructureDeviceAddressKHR = cast[proc (device: VkDevice, pInfo: ptr VkAccelerationStructureDeviceAddressInfoKHR): VkDeviceAddress {.stdcall.}](vkGetProc("vkGetAccelerationStructureDeviceAddressKHR"))
  vkCmdWriteAccelerationStructuresPropertiesKHR = cast[proc (commandBuffer: VkCommandBuffer, accelerationStructureCount: uint32, pAccelerationStructures: ptr VkAccelerationStructureKHR, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: uint32) {.stdcall.}](vkGetProc("vkCmdWriteAccelerationStructuresPropertiesKHR"))
  vkGetDeviceAccelerationStructureCompatibilityKHR = cast[proc (device: VkDevice, pVersionInfo: ptr VkAccelerationStructureVersionInfoKHR, pCompatibility: ptr VkAccelerationStructureCompatibilityKHR) {.stdcall.}](vkGetProc("vkGetDeviceAccelerationStructureCompatibilityKHR"))
  vkGetAccelerationStructureBuildSizesKHR = cast[proc (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: ptr VkAccelerationStructureBuildGeometryInfoKHR, pMaxPrimitiveCounts: ptr uint32, pSizeInfo: ptr VkAccelerationStructureBuildSizesInfoKHR) {.stdcall.}](vkGetProc("vkGetAccelerationStructureBuildSizesKHR"))

# Load VK_KHR_ray_tracing_pipeline
proc loadVK_KHR_ray_tracing_pipeline*() =
  vkCmdTraceRaysKHR = cast[proc (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, width: uint32, height: uint32, depth: uint32) {.stdcall.}](vkGetProc("vkCmdTraceRaysKHR"))
  vkCreateRayTracingPipelinesKHR = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkRayTracingPipelineCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}](vkGetProc("vkCreateRayTracingPipelinesKHR"))
  vkGetRayTracingShaderGroupHandlesKHR = cast[proc (device: VkDevice, pipeline: VkPipeline, firstGroup: uint32, groupCount: uint32, dataSize: uint, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetRayTracingShaderGroupHandlesKHR"))
  vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = cast[proc (device: VkDevice, pipeline: VkPipeline, firstGroup: uint32, groupCount: uint32, dataSize: uint, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"))
  vkCmdTraceRaysIndirectKHR = cast[proc (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: ptr VkStridedDeviceAddressRegionKHR, indirectDeviceAddress: VkDeviceAddress) {.stdcall.}](vkGetProc("vkCmdTraceRaysIndirectKHR"))
  vkGetRayTracingShaderGroupStackSizeKHR = cast[proc (device: VkDevice, pipeline: VkPipeline, group: uint32, groupShader: VkShaderGroupShaderKHR): VkDeviceSize {.stdcall.}](vkGetProc("vkGetRayTracingShaderGroupStackSizeKHR"))
  vkCmdSetRayTracingPipelineStackSizeKHR = cast[proc (commandBuffer: VkCommandBuffer, pipelineStackSize: uint32) {.stdcall.}](vkGetProc("vkCmdSetRayTracingPipelineStackSizeKHR"))

# Load VK_EXT_image_drm_format_modifier
proc loadVK_EXT_image_drm_format_modifier*() =
  vkGetImageDrmFormatModifierPropertiesEXT = cast[proc (device: VkDevice, image: VkImage, pProperties: ptr VkImageDrmFormatModifierPropertiesEXT): VkResult {.stdcall.}](vkGetProc("vkGetImageDrmFormatModifierPropertiesEXT"))

# Load VK_EXT_validation_cache
proc loadVK_EXT_validation_cache*() =
  vkCreateValidationCacheEXT = cast[proc (device: VkDevice, pCreateInfo: ptr VkValidationCacheCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pValidationCache: ptr VkValidationCacheEXT): VkResult {.stdcall.}](vkGetProc("vkCreateValidationCacheEXT"))
  vkDestroyValidationCacheEXT = cast[proc (device: VkDevice, validationCache: VkValidationCacheEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyValidationCacheEXT"))
  vkMergeValidationCachesEXT = cast[proc (device: VkDevice, dstCache: VkValidationCacheEXT, srcCacheCount: uint32, pSrcCaches: ptr VkValidationCacheEXT): VkResult {.stdcall.}](vkGetProc("vkMergeValidationCachesEXT"))
  vkGetValidationCacheDataEXT = cast[proc (device: VkDevice, validationCache: VkValidationCacheEXT, pDataSize: ptr uint, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetValidationCacheDataEXT"))

# Load VK_NV_shading_rate_image
proc loadVK_NV_shading_rate_image*() =
  vkCmdBindShadingRateImageNV = cast[proc (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) {.stdcall.}](vkGetProc("vkCmdBindShadingRateImageNV"))
  vkCmdSetViewportShadingRatePaletteNV = cast[proc (commandBuffer: VkCommandBuffer, firstViewport: uint32, viewportCount: uint32, pShadingRatePalettes: ptr VkShadingRatePaletteNV) {.stdcall.}](vkGetProc("vkCmdSetViewportShadingRatePaletteNV"))
  vkCmdSetCoarseSampleOrderNV = cast[proc (commandBuffer: VkCommandBuffer, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrderCount: uint32, pCustomSampleOrders: ptr VkCoarseSampleOrderCustomNV) {.stdcall.}](vkGetProc("vkCmdSetCoarseSampleOrderNV"))

# Load VK_NV_ray_tracing
proc loadVK_NV_ray_tracing*() =
  vkCreateAccelerationStructureNV = cast[proc (device: VkDevice, pCreateInfo: ptr VkAccelerationStructureCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pAccelerationStructure: ptr VkAccelerationStructureNV): VkResult {.stdcall.}](vkGetProc("vkCreateAccelerationStructureNV"))
  vkDestroyAccelerationStructureNV = cast[proc (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyAccelerationStructureNV"))
  vkGetAccelerationStructureMemoryRequirementsNV = cast[proc (device: VkDevice, pInfo: ptr VkAccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: ptr VkMemoryRequirements2KHR) {.stdcall.}](vkGetProc("vkGetAccelerationStructureMemoryRequirementsNV"))
  vkBindAccelerationStructureMemoryNV = cast[proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindAccelerationStructureMemoryInfoNV): VkResult {.stdcall.}](vkGetProc("vkBindAccelerationStructureMemoryNV"))
  vkCmdBuildAccelerationStructureNV = cast[proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkAccelerationStructureInfoNV, instanceData: VkBuffer, instanceOffset: VkDeviceSize, update: VkBool32, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, scratch: VkBuffer, scratchOffset: VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdBuildAccelerationStructureNV"))
  vkCmdCopyAccelerationStructureNV = cast[proc (commandBuffer: VkCommandBuffer, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, mode: VkCopyAccelerationStructureModeKHR) {.stdcall.}](vkGetProc("vkCmdCopyAccelerationStructureNV"))
  vkCmdTraceRaysNV = cast[proc (commandBuffer: VkCommandBuffer, raygenShaderBindingTableBuffer: VkBuffer, raygenShaderBindingOffset: VkDeviceSize, missShaderBindingTableBuffer: VkBuffer, missShaderBindingOffset: VkDeviceSize, missShaderBindingStride: VkDeviceSize, hitShaderBindingTableBuffer: VkBuffer, hitShaderBindingOffset: VkDeviceSize, hitShaderBindingStride: VkDeviceSize, callableShaderBindingTableBuffer: VkBuffer, callableShaderBindingOffset: VkDeviceSize, callableShaderBindingStride: VkDeviceSize, width: uint32, height: uint32, depth: uint32) {.stdcall.}](vkGetProc("vkCmdTraceRaysNV"))
  vkCreateRayTracingPipelinesNV = cast[proc (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkRayTracingPipelineCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}](vkGetProc("vkCreateRayTracingPipelinesNV"))
  vkGetAccelerationStructureHandleNV = cast[proc (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, dataSize: uint, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetAccelerationStructureHandleNV"))
  vkCmdWriteAccelerationStructuresPropertiesNV = cast[proc (commandBuffer: VkCommandBuffer, accelerationStructureCount: uint32, pAccelerationStructures: ptr VkAccelerationStructureNV, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: uint32) {.stdcall.}](vkGetProc("vkCmdWriteAccelerationStructuresPropertiesNV"))
  vkCompileDeferredNV = cast[proc (device: VkDevice, pipeline: VkPipeline, shader: uint32): VkResult {.stdcall.}](vkGetProc("vkCompileDeferredNV"))

# Load VK_EXT_external_memory_host
proc loadVK_EXT_external_memory_host*() =
  vkGetMemoryHostPointerPropertiesEXT = cast[proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: pointer, pMemoryHostPointerProperties: ptr VkMemoryHostPointerPropertiesEXT): VkResult {.stdcall.}](vkGetProc("vkGetMemoryHostPointerPropertiesEXT"))

# Load VK_AMD_buffer_marker
proc loadVK_AMD_buffer_marker*() =
  vkCmdWriteBufferMarkerAMD = cast[proc (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: uint32) {.stdcall.}](vkGetProc("vkCmdWriteBufferMarkerAMD"))
  vkCmdWriteBufferMarker2AMD = cast[proc (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: uint32) {.stdcall.}](vkGetProc("vkCmdWriteBufferMarker2AMD"))

# Load VK_NV_mesh_shader
proc loadVK_NV_mesh_shader*() =
  vkCmdDrawMeshTasksNV = cast[proc (commandBuffer: VkCommandBuffer, taskCount: uint32, firstTask: uint32) {.stdcall.}](vkGetProc("vkCmdDrawMeshTasksNV"))
  vkCmdDrawMeshTasksIndirectNV = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawMeshTasksIndirectNV"))
  vkCmdDrawMeshTasksIndirectCountNV = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawMeshTasksIndirectCountNV"))

# Load VK_NV_scissor_exclusive
proc loadVK_NV_scissor_exclusive*() =
  vkCmdSetExclusiveScissorEnableNV = cast[proc (commandBuffer: VkCommandBuffer, firstExclusiveScissor: uint32, exclusiveScissorCount: uint32, pExclusiveScissorEnables: ptr VkBool32) {.stdcall.}](vkGetProc("vkCmdSetExclusiveScissorEnableNV"))
  vkCmdSetExclusiveScissorNV = cast[proc (commandBuffer: VkCommandBuffer, firstExclusiveScissor: uint32, exclusiveScissorCount: uint32, pExclusiveScissors: ptr VkRect2D) {.stdcall.}](vkGetProc("vkCmdSetExclusiveScissorNV"))

# Load VK_NV_device_diagnostic_checkpoints
proc loadVK_NV_device_diagnostic_checkpoints*() =
  vkCmdSetCheckpointNV = cast[proc (commandBuffer: VkCommandBuffer, pCheckpointMarker: pointer) {.stdcall.}](vkGetProc("vkCmdSetCheckpointNV"))
  vkGetQueueCheckpointDataNV = cast[proc (queue: VkQueue, pCheckpointDataCount: ptr uint32, pCheckpointData: ptr VkCheckpointDataNV) {.stdcall.}](vkGetProc("vkGetQueueCheckpointDataNV"))
  vkGetQueueCheckpointData2NV = cast[proc (queue: VkQueue, pCheckpointDataCount: ptr uint32, pCheckpointData: ptr VkCheckpointData2NV) {.stdcall.}](vkGetProc("vkGetQueueCheckpointData2NV"))

# Load VK_EXT_present_timing
proc loadVK_EXT_present_timing*() =
  vkSetSwapchainPresentTimingQueueSizeEXT = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, size: uint32): VkResult {.stdcall.}](vkGetProc("vkSetSwapchainPresentTimingQueueSizeEXT"))
  vkGetSwapchainTimingPropertiesEXT = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainTimingProperties: ptr VkSwapchainTimingPropertiesEXT, pSwapchainTimingPropertiesCounter: ptr uint64): VkResult {.stdcall.}](vkGetProc("vkGetSwapchainTimingPropertiesEXT"))
  vkGetSwapchainTimeDomainPropertiesEXT = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainTimeDomainProperties: ptr VkSwapchainTimeDomainPropertiesEXT, pTimeDomainsCounter: ptr uint64): VkResult {.stdcall.}](vkGetProc("vkGetSwapchainTimeDomainPropertiesEXT"))
  vkGetPastPresentationTimingEXT = cast[proc (device: VkDevice, pPastPresentationTimingInfo: ptr VkPastPresentationTimingInfoEXT, pPastPresentationTimingProperties: ptr VkPastPresentationTimingPropertiesEXT): VkResult {.stdcall.}](vkGetProc("vkGetPastPresentationTimingEXT"))

# Load VK_INTEL_performance_query
proc loadVK_INTEL_performance_query*() =
  vkInitializePerformanceApiINTEL = cast[proc (device: VkDevice, pInitializeInfo: ptr VkInitializePerformanceApiInfoINTEL): VkResult {.stdcall.}](vkGetProc("vkInitializePerformanceApiINTEL"))
  vkUninitializePerformanceApiINTEL = cast[proc (device: VkDevice) {.stdcall.}](vkGetProc("vkUninitializePerformanceApiINTEL"))
  vkCmdSetPerformanceMarkerINTEL = cast[proc (commandBuffer: VkCommandBuffer, pMarkerInfo: ptr VkPerformanceMarkerInfoINTEL): VkResult {.stdcall.}](vkGetProc("vkCmdSetPerformanceMarkerINTEL"))
  vkCmdSetPerformanceStreamMarkerINTEL = cast[proc (commandBuffer: VkCommandBuffer, pMarkerInfo: ptr VkPerformanceStreamMarkerInfoINTEL): VkResult {.stdcall.}](vkGetProc("vkCmdSetPerformanceStreamMarkerINTEL"))
  vkCmdSetPerformanceOverrideINTEL = cast[proc (commandBuffer: VkCommandBuffer, pOverrideInfo: ptr VkPerformanceOverrideInfoINTEL): VkResult {.stdcall.}](vkGetProc("vkCmdSetPerformanceOverrideINTEL"))
  vkAcquirePerformanceConfigurationINTEL = cast[proc (device: VkDevice, pAcquireInfo: ptr VkPerformanceConfigurationAcquireInfoINTEL, pConfiguration: ptr VkPerformanceConfigurationINTEL): VkResult {.stdcall.}](vkGetProc("vkAcquirePerformanceConfigurationINTEL"))
  vkReleasePerformanceConfigurationINTEL = cast[proc (device: VkDevice, configuration: VkPerformanceConfigurationINTEL): VkResult {.stdcall.}](vkGetProc("vkReleasePerformanceConfigurationINTEL"))
  vkQueueSetPerformanceConfigurationINTEL = cast[proc (queue: VkQueue, configuration: VkPerformanceConfigurationINTEL): VkResult {.stdcall.}](vkGetProc("vkQueueSetPerformanceConfigurationINTEL"))
  vkGetPerformanceParameterINTEL = cast[proc (device: VkDevice, parameter: VkPerformanceParameterTypeINTEL, pValue: ptr VkPerformanceValueINTEL): VkResult {.stdcall.}](vkGetProc("vkGetPerformanceParameterINTEL"))

# Load VK_AMD_display_native_hdr
proc loadVK_AMD_display_native_hdr*() =
  vkSetLocalDimmingAMD = cast[proc (device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) {.stdcall.}](vkGetProc("vkSetLocalDimmingAMD"))

# Load VK_FUCHSIA_imagepipe_surface
proc loadVK_FUCHSIA_imagepipe_surface*() =
  vkCreateImagePipeSurfaceFUCHSIA = cast[proc (instance: VkInstance, pCreateInfo: ptr VkImagePipeSurfaceCreateInfoFUCHSIA, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateImagePipeSurfaceFUCHSIA"))

# Load VK_EXT_metal_surface
proc loadVK_EXT_metal_surface*() =
  vkCreateMetalSurfaceEXT = cast[proc (instance: VkInstance, pCreateInfo: ptr VkMetalSurfaceCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateMetalSurfaceEXT"))

# Load VK_KHR_fragment_shading_rate
proc loadVK_KHR_fragment_shading_rate*() =
  vkGetPhysicalDeviceFragmentShadingRatesKHR = cast[proc (physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: ptr uint32, pFragmentShadingRates: ptr VkPhysicalDeviceFragmentShadingRateKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceFragmentShadingRatesKHR"))
  vkCmdSetFragmentShadingRateKHR = cast[proc (commandBuffer: VkCommandBuffer, pFragmentSize: ptr VkExtent2D, combinerOps: array[2, VkFragmentShadingRateCombinerOpKHR]) {.stdcall.}](vkGetProc("vkCmdSetFragmentShadingRateKHR"))

# Load VK_KHR_present_wait
proc loadVK_KHR_present_wait*() =
  vkWaitForPresentKHR = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, presentId: uint64, timeout: uint64): VkResult {.stdcall.}](vkGetProc("vkWaitForPresentKHR"))

# Load VK_NV_cooperative_matrix
proc loadVK_NV_cooperative_matrix*() =
  vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkCooperativeMatrixPropertiesNV): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"))

# Load VK_NV_coverage_reduction_mode
proc loadVK_NV_coverage_reduction_mode*() =
  vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = cast[proc (physicalDevice: VkPhysicalDevice, pCombinationCount: ptr uint32, pCombinations: ptr VkFramebufferMixedSamplesCombinationNV): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"))

# Load VK_EXT_full_screen_exclusive
proc loadVK_EXT_full_screen_exclusive*() =
  vkGetPhysicalDeviceSurfacePresentModes2EXT = cast[proc (physicalDevice: VkPhysicalDevice, pSurfaceInfo: ptr VkPhysicalDeviceSurfaceInfo2KHR, pPresentModeCount: ptr uint32, pPresentModes: ptr VkPresentModeKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSurfacePresentModes2EXT"))
  vkAcquireFullScreenExclusiveModeEXT = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR): VkResult {.stdcall.}](vkGetProc("vkAcquireFullScreenExclusiveModeEXT"))
  vkReleaseFullScreenExclusiveModeEXT = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR): VkResult {.stdcall.}](vkGetProc("vkReleaseFullScreenExclusiveModeEXT"))
  vkGetDeviceGroupSurfacePresentModes2EXT = cast[proc (device: VkDevice, pSurfaceInfo: ptr VkPhysicalDeviceSurfaceInfo2KHR, pModes: ptr VkDeviceGroupPresentModeFlagsKHR): VkResult {.stdcall.}](vkGetProc("vkGetDeviceGroupSurfacePresentModes2EXT"))

# Load VK_EXT_headless_surface
proc loadVK_EXT_headless_surface*() =
  vkCreateHeadlessSurfaceEXT = cast[proc (instance: VkInstance, pCreateInfo: ptr VkHeadlessSurfaceCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateHeadlessSurfaceEXT"))

# Load VK_KHR_deferred_host_operations
proc loadVK_KHR_deferred_host_operations*() =
  vkCreateDeferredOperationKHR = cast[proc (device: VkDevice, pAllocator: ptr VkAllocationCallbacks, pDeferredOperation: ptr VkDeferredOperationKHR): VkResult {.stdcall.}](vkGetProc("vkCreateDeferredOperationKHR"))
  vkDestroyDeferredOperationKHR = cast[proc (device: VkDevice, operation: VkDeferredOperationKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyDeferredOperationKHR"))
  vkGetDeferredOperationMaxConcurrencyKHR = cast[proc (device: VkDevice, operation: VkDeferredOperationKHR): uint32 {.stdcall.}](vkGetProc("vkGetDeferredOperationMaxConcurrencyKHR"))
  vkGetDeferredOperationResultKHR = cast[proc (device: VkDevice, operation: VkDeferredOperationKHR): VkResult {.stdcall.}](vkGetProc("vkGetDeferredOperationResultKHR"))
  vkDeferredOperationJoinKHR = cast[proc (device: VkDevice, operation: VkDeferredOperationKHR): VkResult {.stdcall.}](vkGetProc("vkDeferredOperationJoinKHR"))

# Load VK_KHR_pipeline_executable_properties
proc loadVK_KHR_pipeline_executable_properties*() =
  vkGetPipelineExecutablePropertiesKHR = cast[proc (device: VkDevice, pPipelineInfo: ptr VkPipelineInfoKHR, pExecutableCount: ptr uint32, pProperties: ptr VkPipelineExecutablePropertiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetPipelineExecutablePropertiesKHR"))
  vkGetPipelineExecutableStatisticsKHR = cast[proc (device: VkDevice, pExecutableInfo: ptr VkPipelineExecutableInfoKHR, pStatisticCount: ptr uint32, pStatistics: ptr VkPipelineExecutableStatisticKHR): VkResult {.stdcall.}](vkGetProc("vkGetPipelineExecutableStatisticsKHR"))
  vkGetPipelineExecutableInternalRepresentationsKHR = cast[proc (device: VkDevice, pExecutableInfo: ptr VkPipelineExecutableInfoKHR, pInternalRepresentationCount: ptr uint32, pInternalRepresentations: ptr VkPipelineExecutableInternalRepresentationKHR): VkResult {.stdcall.}](vkGetProc("vkGetPipelineExecutableInternalRepresentationsKHR"))

# Load VK_NV_device_generated_commands
proc loadVK_NV_device_generated_commands*() =
  vkGetGeneratedCommandsMemoryRequirementsNV = cast[proc (device: VkDevice, pInfo: ptr VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetGeneratedCommandsMemoryRequirementsNV"))
  vkCmdPreprocessGeneratedCommandsNV = cast[proc (commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: ptr VkGeneratedCommandsInfoNV) {.stdcall.}](vkGetProc("vkCmdPreprocessGeneratedCommandsNV"))
  vkCmdExecuteGeneratedCommandsNV = cast[proc (commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: ptr VkGeneratedCommandsInfoNV) {.stdcall.}](vkGetProc("vkCmdExecuteGeneratedCommandsNV"))
  vkCmdBindPipelineShaderGroupNV = cast[proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline, groupIndex: uint32) {.stdcall.}](vkGetProc("vkCmdBindPipelineShaderGroupNV"))
  vkCreateIndirectCommandsLayoutNV = cast[proc (device: VkDevice, pCreateInfo: ptr VkIndirectCommandsLayoutCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pIndirectCommandsLayout: ptr VkIndirectCommandsLayoutNV): VkResult {.stdcall.}](vkGetProc("vkCreateIndirectCommandsLayoutNV"))
  vkDestroyIndirectCommandsLayoutNV = cast[proc (device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyIndirectCommandsLayoutNV"))

# Load VK_EXT_depth_bias_control
proc loadVK_EXT_depth_bias_control*() =
  vkCmdSetDepthBias2EXT = cast[proc (commandBuffer: VkCommandBuffer, pDepthBiasInfo: ptr VkDepthBiasInfoEXT) {.stdcall.}](vkGetProc("vkCmdSetDepthBias2EXT"))

# Load VK_EXT_acquire_drm_display
proc loadVK_EXT_acquire_drm_display*() =
  vkAcquireDrmDisplayEXT = cast[proc (physicalDevice: VkPhysicalDevice, drmFd: int32, display: VkDisplayKHR): VkResult {.stdcall.}](vkGetProc("vkAcquireDrmDisplayEXT"))
  vkGetDrmDisplayEXT = cast[proc (physicalDevice: VkPhysicalDevice, drmFd: int32, connectorId: uint32, display: ptr VkDisplayKHR): VkResult {.stdcall.}](vkGetProc("vkGetDrmDisplayEXT"))

# Load VK_KHR_video_encode_queue
proc loadVK_KHR_video_encode_queue*() =
  vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = cast[proc (physicalDevice: VkPhysicalDevice, pQualityLevelInfo: ptr VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, pQualityLevelProperties: ptr VkVideoEncodeQualityLevelPropertiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR"))
  vkGetEncodedVideoSessionParametersKHR = cast[proc (device: VkDevice, pVideoSessionParametersInfo: ptr VkVideoEncodeSessionParametersGetInfoKHR, pFeedbackInfo: ptr VkVideoEncodeSessionParametersFeedbackInfoKHR, pDataSize: ptr uint, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetEncodedVideoSessionParametersKHR"))
  vkCmdEncodeVideoKHR = cast[proc (commandBuffer: VkCommandBuffer, pEncodeInfo: ptr VkVideoEncodeInfoKHR) {.stdcall.}](vkGetProc("vkCmdEncodeVideoKHR"))

# Load VK_NV_cuda_kernel_launch
proc loadVK_NV_cuda_kernel_launch*() =
  vkCreateCudaModuleNV = cast[proc (device: VkDevice, pCreateInfo: ptr VkCudaModuleCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pModule: ptr VkCudaModuleNV): VkResult {.stdcall.}](vkGetProc("vkCreateCudaModuleNV"))
  vkGetCudaModuleCacheNV = cast[proc (device: VkDevice, module: VkCudaModuleNV, pCacheSize: ptr uint, pCacheData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetCudaModuleCacheNV"))
  vkCreateCudaFunctionNV = cast[proc (device: VkDevice, pCreateInfo: ptr VkCudaFunctionCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pFunction: ptr VkCudaFunctionNV): VkResult {.stdcall.}](vkGetProc("vkCreateCudaFunctionNV"))
  vkDestroyCudaModuleNV = cast[proc (device: VkDevice, module: VkCudaModuleNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyCudaModuleNV"))
  vkDestroyCudaFunctionNV = cast[proc (device: VkDevice, function: VkCudaFunctionNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyCudaFunctionNV"))
  vkCmdCudaLaunchKernelNV = cast[proc (commandBuffer: VkCommandBuffer, pLaunchInfo: ptr VkCudaLaunchInfoNV) {.stdcall.}](vkGetProc("vkCmdCudaLaunchKernelNV"))

# Load VK_KHR_object_refresh
proc loadVK_KHR_object_refresh*() =
  vkCmdRefreshObjectsKHR = cast[proc (commandBuffer: VkCommandBuffer, pRefreshObjects: ptr VkRefreshObjectListKHR) {.stdcall.}](vkGetProc("vkCmdRefreshObjectsKHR"))
  vkGetPhysicalDeviceRefreshableObjectTypesKHR = cast[proc (physicalDevice: VkPhysicalDevice, pRefreshableObjectTypeCount: ptr uint32, pRefreshableObjectTypes: ptr VkObjectType): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceRefreshableObjectTypesKHR"))

# Load VK_QCOM_tile_shading
proc loadVK_QCOM_tile_shading*() =
  vkCmdDispatchTileQCOM = cast[proc (commandBuffer: VkCommandBuffer, pDispatchTileInfo: ptr VkDispatchTileInfoQCOM) {.stdcall.}](vkGetProc("vkCmdDispatchTileQCOM"))
  vkCmdBeginPerTileExecutionQCOM = cast[proc (commandBuffer: VkCommandBuffer, pPerTileBeginInfo: ptr VkPerTileBeginInfoQCOM) {.stdcall.}](vkGetProc("vkCmdBeginPerTileExecutionQCOM"))
  vkCmdEndPerTileExecutionQCOM = cast[proc (commandBuffer: VkCommandBuffer, pPerTileEndInfo: ptr VkPerTileEndInfoQCOM) {.stdcall.}](vkGetProc("vkCmdEndPerTileExecutionQCOM"))

# Load VK_EXT_metal_objects
proc loadVK_EXT_metal_objects*() =
  vkExportMetalObjectsEXT = cast[proc (device: VkDevice, pMetalObjectsInfo: ptr VkExportMetalObjectsInfoEXT) {.stdcall.}](vkGetProc("vkExportMetalObjectsEXT"))

# Load VK_EXT_descriptor_buffer
proc loadVK_EXT_descriptor_buffer*() =
  vkGetDescriptorSetLayoutSizeEXT = cast[proc (device: VkDevice, layout: VkDescriptorSetLayout, pLayoutSizeInBytes: ptr VkDeviceSize) {.stdcall.}](vkGetProc("vkGetDescriptorSetLayoutSizeEXT"))
  vkGetDescriptorSetLayoutBindingOffsetEXT = cast[proc (device: VkDevice, layout: VkDescriptorSetLayout, binding: uint32, pOffset: ptr VkDeviceSize) {.stdcall.}](vkGetProc("vkGetDescriptorSetLayoutBindingOffsetEXT"))
  vkGetDescriptorEXT = cast[proc (device: VkDevice, pDescriptorInfo: ptr VkDescriptorGetInfoEXT, dataSize: uint, pDescriptor: pointer) {.stdcall.}](vkGetProc("vkGetDescriptorEXT"))
  vkCmdBindDescriptorBuffersEXT = cast[proc (commandBuffer: VkCommandBuffer, bufferCount: uint32, pBindingInfos: ptr VkDescriptorBufferBindingInfoEXT) {.stdcall.}](vkGetProc("vkCmdBindDescriptorBuffersEXT"))
  vkCmdSetDescriptorBufferOffsetsEXT = cast[proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: uint32, setCount: uint32, pBufferIndices: ptr uint32, pOffsets: ptr VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdSetDescriptorBufferOffsetsEXT"))
  vkCmdBindDescriptorBufferEmbeddedSamplersEXT = cast[proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: uint32) {.stdcall.}](vkGetProc("vkCmdBindDescriptorBufferEmbeddedSamplersEXT"))
  vkGetBufferOpaqueCaptureDescriptorDataEXT = cast[proc (device: VkDevice, pInfo: ptr VkBufferCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetBufferOpaqueCaptureDescriptorDataEXT"))
  vkGetImageOpaqueCaptureDescriptorDataEXT = cast[proc (device: VkDevice, pInfo: ptr VkImageCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetImageOpaqueCaptureDescriptorDataEXT"))
  vkGetImageViewOpaqueCaptureDescriptorDataEXT = cast[proc (device: VkDevice, pInfo: ptr VkImageViewCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetImageViewOpaqueCaptureDescriptorDataEXT"))
  vkGetSamplerOpaqueCaptureDescriptorDataEXT = cast[proc (device: VkDevice, pInfo: ptr VkSamplerCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetSamplerOpaqueCaptureDescriptorDataEXT"))
  vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = cast[proc (device: VkDevice, pInfo: ptr VkAccelerationStructureCaptureDescriptorDataInfoEXT, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT"))

# Load VK_NV_fragment_shading_rate_enums
proc loadVK_NV_fragment_shading_rate_enums*() =
  vkCmdSetFragmentShadingRateEnumNV = cast[proc (commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: array[2, VkFragmentShadingRateCombinerOpKHR]) {.stdcall.}](vkGetProc("vkCmdSetFragmentShadingRateEnumNV"))

# Load VK_EXT_mesh_shader
proc loadVK_EXT_mesh_shader*() =
  vkCmdDrawMeshTasksEXT = cast[proc (commandBuffer: VkCommandBuffer, groupCountX: uint32, groupCountY: uint32, groupCountZ: uint32) {.stdcall.}](vkGetProc("vkCmdDrawMeshTasksEXT"))
  vkCmdDrawMeshTasksIndirectEXT = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawMeshTasksIndirectEXT"))
  vkCmdDrawMeshTasksIndirectCountEXT = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawMeshTasksIndirectCountEXT"))

# Load VK_EXT_device_fault
proc loadVK_EXT_device_fault*() =
  vkGetDeviceFaultInfoEXT = cast[proc (device: VkDevice, pFaultCounts: ptr VkDeviceFaultCountsEXT, pFaultInfo: ptr VkDeviceFaultInfoEXT): VkResult {.stdcall.}](vkGetProc("vkGetDeviceFaultInfoEXT"))

# Load VK_NV_acquire_winrt_display
proc loadVK_NV_acquire_winrt_display*() =
  vkAcquireWinrtDisplayNV = cast[proc (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR): VkResult {.stdcall.}](vkGetProc("vkAcquireWinrtDisplayNV"))
  vkGetWinrtDisplayNV = cast[proc (physicalDevice: VkPhysicalDevice, deviceRelativeId: uint32, pDisplay: ptr VkDisplayKHR): VkResult {.stdcall.}](vkGetProc("vkGetWinrtDisplayNV"))

# Load VK_EXT_directfb_surface
proc loadVK_EXT_directfb_surface*() =
  vkCreateDirectFBSurfaceEXT = cast[proc (instance: VkInstance, pCreateInfo: ptr VkDirectFBSurfaceCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateDirectFBSurfaceEXT"))
  vkGetPhysicalDeviceDirectFBPresentationSupportEXT = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, dfb: ptr IDirectFB): VkBool32 {.stdcall.}](vkGetProc("vkGetPhysicalDeviceDirectFBPresentationSupportEXT"))

# Load VK_EXT_vertex_input_dynamic_state
proc loadVK_EXT_vertex_input_dynamic_state*() =
  vkCmdSetVertexInputEXT = cast[proc (commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: uint32, pVertexBindingDescriptions: ptr VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: uint32, pVertexAttributeDescriptions: ptr VkVertexInputAttributeDescription2EXT) {.stdcall.}](vkGetProc("vkCmdSetVertexInputEXT"))

# Load VK_FUCHSIA_external_memory
proc loadVK_FUCHSIA_external_memory*() =
  vkGetMemoryZirconHandleFUCHSIA = cast[proc (device: VkDevice, pGetZirconHandleInfo: ptr VkMemoryGetZirconHandleInfoFUCHSIA, pZirconHandle: ptr zx_handle_t): VkResult {.stdcall.}](vkGetProc("vkGetMemoryZirconHandleFUCHSIA"))
  vkGetMemoryZirconHandlePropertiesFUCHSIA = cast[proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, zirconHandle: zx_handle_t, pMemoryZirconHandleProperties: ptr VkMemoryZirconHandlePropertiesFUCHSIA): VkResult {.stdcall.}](vkGetProc("vkGetMemoryZirconHandlePropertiesFUCHSIA"))

# Load VK_FUCHSIA_external_semaphore
proc loadVK_FUCHSIA_external_semaphore*() =
  vkImportSemaphoreZirconHandleFUCHSIA = cast[proc (device: VkDevice, pImportSemaphoreZirconHandleInfo: ptr VkImportSemaphoreZirconHandleInfoFUCHSIA): VkResult {.stdcall.}](vkGetProc("vkImportSemaphoreZirconHandleFUCHSIA"))
  vkGetSemaphoreZirconHandleFUCHSIA = cast[proc (device: VkDevice, pGetZirconHandleInfo: ptr VkSemaphoreGetZirconHandleInfoFUCHSIA, pZirconHandle: ptr zx_handle_t): VkResult {.stdcall.}](vkGetProc("vkGetSemaphoreZirconHandleFUCHSIA"))

# Load VK_FUCHSIA_buffer_collection
proc loadVK_FUCHSIA_buffer_collection*() =
  vkCreateBufferCollectionFUCHSIA = cast[proc (device: VkDevice, pCreateInfo: ptr VkBufferCollectionCreateInfoFUCHSIA, pAllocator: ptr VkAllocationCallbacks, pCollection: ptr VkBufferCollectionFUCHSIA): VkResult {.stdcall.}](vkGetProc("vkCreateBufferCollectionFUCHSIA"))
  vkSetBufferCollectionImageConstraintsFUCHSIA = cast[proc (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pImageConstraintsInfo: ptr VkImageConstraintsInfoFUCHSIA): VkResult {.stdcall.}](vkGetProc("vkSetBufferCollectionImageConstraintsFUCHSIA"))
  vkSetBufferCollectionBufferConstraintsFUCHSIA = cast[proc (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pBufferConstraintsInfo: ptr VkBufferConstraintsInfoFUCHSIA): VkResult {.stdcall.}](vkGetProc("vkSetBufferCollectionBufferConstraintsFUCHSIA"))
  vkDestroyBufferCollectionFUCHSIA = cast[proc (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyBufferCollectionFUCHSIA"))
  vkGetBufferCollectionPropertiesFUCHSIA = cast[proc (device: VkDevice, collection: VkBufferCollectionFUCHSIA, pProperties: ptr VkBufferCollectionPropertiesFUCHSIA): VkResult {.stdcall.}](vkGetProc("vkGetBufferCollectionPropertiesFUCHSIA"))

# Load VK_HUAWEI_subpass_shading
proc loadVK_HUAWEI_subpass_shading*() =
  vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = cast[proc (device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: ptr VkExtent2D): VkResult {.stdcall.}](vkGetProc("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"))
  vkCmdSubpassShadingHUAWEI = cast[proc (commandBuffer: VkCommandBuffer) {.stdcall.}](vkGetProc("vkCmdSubpassShadingHUAWEI"))

# Load VK_HUAWEI_invocation_mask
proc loadVK_HUAWEI_invocation_mask*() =
  vkCmdBindInvocationMaskHUAWEI = cast[proc (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) {.stdcall.}](vkGetProc("vkCmdBindInvocationMaskHUAWEI"))

# Load VK_NV_external_memory_rdma
proc loadVK_NV_external_memory_rdma*() =
  vkGetMemoryRemoteAddressNV = cast[proc (device: VkDevice, pMemoryGetRemoteAddressInfo: ptr VkMemoryGetRemoteAddressInfoNV, pAddress: ptr VkRemoteAddressNV): VkResult {.stdcall.}](vkGetProc("vkGetMemoryRemoteAddressNV"))

# Load VK_EXT_pipeline_properties
proc loadVK_EXT_pipeline_properties*() =
  vkGetPipelinePropertiesEXT = cast[proc (device: VkDevice, pPipelineInfo: ptr VkPipelineInfoEXT, pPipelineProperties: ptr VkBaseOutStructure): VkResult {.stdcall.}](vkGetProc("vkGetPipelinePropertiesEXT"))

# Load VK_NV_external_sci_sync
proc loadVK_NV_external_sci_sync*() =
  vkGetFenceSciSyncFenceNV = cast[proc (device: VkDevice, pGetSciSyncHandleInfo: ptr VkFenceGetSciSyncInfoNV, pHandle: pointer): VkResult {.stdcall.}](vkGetProc("vkGetFenceSciSyncFenceNV"))
  vkGetFenceSciSyncObjNV = cast[proc (device: VkDevice, pGetSciSyncHandleInfo: ptr VkFenceGetSciSyncInfoNV, pHandle: pointer): VkResult {.stdcall.}](vkGetProc("vkGetFenceSciSyncObjNV"))
  vkImportFenceSciSyncFenceNV = cast[proc (device: VkDevice, pImportFenceSciSyncInfo: ptr VkImportFenceSciSyncInfoNV): VkResult {.stdcall.}](vkGetProc("vkImportFenceSciSyncFenceNV"))
  vkImportFenceSciSyncObjNV = cast[proc (device: VkDevice, pImportFenceSciSyncInfo: ptr VkImportFenceSciSyncInfoNV): VkResult {.stdcall.}](vkGetProc("vkImportFenceSciSyncObjNV"))
  vkGetPhysicalDeviceSciSyncAttributesNV = cast[proc (physicalDevice: VkPhysicalDevice, pSciSyncAttributesInfo: ptr VkSciSyncAttributesInfoNV, pAttributes: NvSciSyncAttrList): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSciSyncAttributesNV"))
  vkGetSemaphoreSciSyncObjNV = cast[proc (device: VkDevice, pGetSciSyncInfo: ptr VkSemaphoreGetSciSyncInfoNV, pHandle: pointer): VkResult {.stdcall.}](vkGetProc("vkGetSemaphoreSciSyncObjNV"))
  vkImportSemaphoreSciSyncObjNV = cast[proc (device: VkDevice, pImportSemaphoreSciSyncInfo: ptr VkImportSemaphoreSciSyncInfoNV): VkResult {.stdcall.}](vkGetProc("vkImportSemaphoreSciSyncObjNV"))

# Load VK_NV_external_memory_sci_buf
proc loadVK_NV_external_memory_sci_buf*() =
  vkGetMemorySciBufNV = cast[proc (device: VkDevice, pGetSciBufInfo: ptr VkMemoryGetSciBufInfoNV, pHandle: ptr NvSciBufObj): VkResult {.stdcall.}](vkGetProc("vkGetMemorySciBufNV"))
  vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV = cast[proc (physicalDevice: VkPhysicalDevice, handleType: VkExternalMemoryHandleTypeFlagBits, handle: NvSciBufObj, pMemorySciBufProperties: ptr VkMemorySciBufPropertiesNV): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV"))
  vkGetPhysicalDeviceSciBufAttributesNV = cast[proc (physicalDevice: VkPhysicalDevice, pAttributes: NvSciBufAttrList): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSciBufAttributesNV"))

# Load VK_EXT_extended_dynamic_state2
proc loadVK_EXT_extended_dynamic_state2*() =
  vkCmdSetPatchControlPointsEXT = cast[proc (commandBuffer: VkCommandBuffer, patchControlPoints: uint32) {.stdcall.}](vkGetProc("vkCmdSetPatchControlPointsEXT"))
  vkCmdSetLogicOpEXT = cast[proc (commandBuffer: VkCommandBuffer, logicOp: VkLogicOp) {.stdcall.}](vkGetProc("vkCmdSetLogicOpEXT"))

# Load VK_QNX_screen_surface
proc loadVK_QNX_screen_surface*() =
  vkCreateScreenSurfaceQNX = cast[proc (instance: VkInstance, pCreateInfo: ptr VkScreenSurfaceCreateInfoQNX, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateScreenSurfaceQNX"))
  vkGetPhysicalDeviceScreenPresentationSupportQNX = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, window: ptr screen_window): VkBool32 {.stdcall.}](vkGetProc("vkGetPhysicalDeviceScreenPresentationSupportQNX"))

# Load VK_EXT_color_write_enable
proc loadVK_EXT_color_write_enable*() =
  vkCmdSetColorWriteEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, attachmentCount: uint32, pColorWriteEnables: ptr VkBool32) {.stdcall.}](vkGetProc("vkCmdSetColorWriteEnableEXT"))

# Load VK_KHR_ray_tracing_maintenance1
proc loadVK_KHR_ray_tracing_maintenance1*() =
  vkCmdTraceRaysIndirect2KHR = cast[proc (commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) {.stdcall.}](vkGetProc("vkCmdTraceRaysIndirect2KHR"))

# Load VK_EXT_multi_draw
proc loadVK_EXT_multi_draw*() =
  vkCmdDrawMultiEXT = cast[proc (commandBuffer: VkCommandBuffer, drawCount: uint32, pVertexInfo: ptr VkMultiDrawInfoEXT, instanceCount: uint32, firstInstance: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDrawMultiEXT"))
  vkCmdDrawMultiIndexedEXT = cast[proc (commandBuffer: VkCommandBuffer, drawCount: uint32, pIndexInfo: ptr VkMultiDrawIndexedInfoEXT, instanceCount: uint32, firstInstance: uint32, stride: uint32, pVertexOffset: ptr int32) {.stdcall.}](vkGetProc("vkCmdDrawMultiIndexedEXT"))

# Load VK_EXT_opacity_micromap
proc loadVK_EXT_opacity_micromap*() =
  vkCreateMicromapEXT = cast[proc (device: VkDevice, pCreateInfo: ptr VkMicromapCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pMicromap: ptr VkMicromapEXT): VkResult {.stdcall.}](vkGetProc("vkCreateMicromapEXT"))
  vkDestroyMicromapEXT = cast[proc (device: VkDevice, micromap: VkMicromapEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyMicromapEXT"))
  vkCmdBuildMicromapsEXT = cast[proc (commandBuffer: VkCommandBuffer, infoCount: uint32, pInfos: ptr VkMicromapBuildInfoEXT) {.stdcall.}](vkGetProc("vkCmdBuildMicromapsEXT"))
  vkBuildMicromapsEXT = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: uint32, pInfos: ptr VkMicromapBuildInfoEXT): VkResult {.stdcall.}](vkGetProc("vkBuildMicromapsEXT"))
  vkCopyMicromapEXT = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyMicromapInfoEXT): VkResult {.stdcall.}](vkGetProc("vkCopyMicromapEXT"))
  vkCopyMicromapToMemoryEXT = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyMicromapToMemoryInfoEXT): VkResult {.stdcall.}](vkGetProc("vkCopyMicromapToMemoryEXT"))
  vkCopyMemoryToMicromapEXT = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: ptr VkCopyMemoryToMicromapInfoEXT): VkResult {.stdcall.}](vkGetProc("vkCopyMemoryToMicromapEXT"))
  vkWriteMicromapsPropertiesEXT = cast[proc (device: VkDevice, micromapCount: uint32, pMicromaps: ptr VkMicromapEXT, queryType: VkQueryType, dataSize: uint, pData: pointer, stride: uint): VkResult {.stdcall.}](vkGetProc("vkWriteMicromapsPropertiesEXT"))
  vkCmdCopyMicromapEXT = cast[proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyMicromapInfoEXT) {.stdcall.}](vkGetProc("vkCmdCopyMicromapEXT"))
  vkCmdCopyMicromapToMemoryEXT = cast[proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyMicromapToMemoryInfoEXT) {.stdcall.}](vkGetProc("vkCmdCopyMicromapToMemoryEXT"))
  vkCmdCopyMemoryToMicromapEXT = cast[proc (commandBuffer: VkCommandBuffer, pInfo: ptr VkCopyMemoryToMicromapInfoEXT) {.stdcall.}](vkGetProc("vkCmdCopyMemoryToMicromapEXT"))
  vkCmdWriteMicromapsPropertiesEXT = cast[proc (commandBuffer: VkCommandBuffer, micromapCount: uint32, pMicromaps: ptr VkMicromapEXT, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: uint32) {.stdcall.}](vkGetProc("vkCmdWriteMicromapsPropertiesEXT"))
  vkGetDeviceMicromapCompatibilityEXT = cast[proc (device: VkDevice, pVersionInfo: ptr VkMicromapVersionInfoEXT, pCompatibility: ptr VkAccelerationStructureCompatibilityKHR) {.stdcall.}](vkGetProc("vkGetDeviceMicromapCompatibilityEXT"))
  vkGetMicromapBuildSizesEXT = cast[proc (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: ptr VkMicromapBuildInfoEXT, pSizeInfo: ptr VkMicromapBuildSizesInfoEXT) {.stdcall.}](vkGetProc("vkGetMicromapBuildSizesEXT"))

# Load VK_HUAWEI_cluster_culling_shader
proc loadVK_HUAWEI_cluster_culling_shader*() =
  vkCmdDrawClusterHUAWEI = cast[proc (commandBuffer: VkCommandBuffer, groupCountX: uint32, groupCountY: uint32, groupCountZ: uint32) {.stdcall.}](vkGetProc("vkCmdDrawClusterHUAWEI"))
  vkCmdDrawClusterIndirectHUAWEI = cast[proc (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) {.stdcall.}](vkGetProc("vkCmdDrawClusterIndirectHUAWEI"))

# Load VK_EXT_pageable_device_local_memory
proc loadVK_EXT_pageable_device_local_memory*() =
  vkSetDeviceMemoryPriorityEXT = cast[proc (device: VkDevice, memory: VkDeviceMemory, priority: float32) {.stdcall.}](vkGetProc("vkSetDeviceMemoryPriorityEXT"))

# Load VK_VALVE_descriptor_set_host_mapping
proc loadVK_VALVE_descriptor_set_host_mapping*() =
  vkGetDescriptorSetLayoutHostMappingInfoVALVE = cast[proc (device: VkDevice, pBindingReference: ptr VkDescriptorSetBindingReferenceVALVE, pHostMapping: ptr VkDescriptorSetLayoutHostMappingInfoVALVE) {.stdcall.}](vkGetProc("vkGetDescriptorSetLayoutHostMappingInfoVALVE"))
  vkGetDescriptorSetHostMappingVALVE = cast[proc (device: VkDevice, descriptorSet: VkDescriptorSet, ppData: ptr pointer) {.stdcall.}](vkGetProc("vkGetDescriptorSetHostMappingVALVE"))

# Load VK_NV_copy_memory_indirect
proc loadVK_NV_copy_memory_indirect*() =
  vkCmdCopyMemoryIndirectNV = cast[proc (commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdCopyMemoryIndirectNV"))
  vkCmdCopyMemoryToImageIndirectNV = cast[proc (commandBuffer: VkCommandBuffer, copyBufferAddress: VkDeviceAddress, copyCount: uint32, stride: uint32, dstImage: VkImage, dstImageLayout: VkImageLayout, pImageSubresources: ptr VkImageSubresourceLayers) {.stdcall.}](vkGetProc("vkCmdCopyMemoryToImageIndirectNV"))

# Load VK_NV_memory_decompression
proc loadVK_NV_memory_decompression*() =
  vkCmdDecompressMemoryNV = cast[proc (commandBuffer: VkCommandBuffer, decompressRegionCount: uint32, pDecompressMemoryRegions: ptr VkDecompressMemoryRegionNV) {.stdcall.}](vkGetProc("vkCmdDecompressMemoryNV"))
  vkCmdDecompressMemoryIndirectCountNV = cast[proc (commandBuffer: VkCommandBuffer, indirectCommandsAddress: VkDeviceAddress, indirectCommandsCountAddress: VkDeviceAddress, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDecompressMemoryIndirectCountNV"))

# Load VK_NV_device_generated_commands_compute
proc loadVK_NV_device_generated_commands_compute*() =
  vkGetPipelineIndirectMemoryRequirementsNV = cast[proc (device: VkDevice, pCreateInfo: ptr VkComputePipelineCreateInfo, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetPipelineIndirectMemoryRequirementsNV"))
  vkCmdUpdatePipelineIndirectBufferNV = cast[proc (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) {.stdcall.}](vkGetProc("vkCmdUpdatePipelineIndirectBufferNV"))
  vkGetPipelineIndirectDeviceAddressNV = cast[proc (device: VkDevice, pInfo: ptr VkPipelineIndirectDeviceAddressInfoNV): VkDeviceAddress {.stdcall.}](vkGetProc("vkGetPipelineIndirectDeviceAddressNV"))

# Load VK_OHOS_external_memory
proc loadVK_OHOS_external_memory*() =
  vkGetNativeBufferPropertiesOHOS = cast[proc (device: VkDevice, buffer: ptr OH_NativeBuffer, pProperties: ptr VkNativeBufferPropertiesOHOS): VkResult {.stdcall.}](vkGetProc("vkGetNativeBufferPropertiesOHOS"))
  vkGetMemoryNativeBufferOHOS = cast[proc (device: VkDevice, pInfo: ptr VkMemoryGetNativeBufferInfoOHOS, pBuffer: ptr ptr OH_NativeBuffer): VkResult {.stdcall.}](vkGetProc("vkGetMemoryNativeBufferOHOS"))

# Load VK_EXT_extended_dynamic_state3
proc loadVK_EXT_extended_dynamic_state3*() =
  vkCmdSetDepthClampEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthClampEnableEXT"))
  vkCmdSetPolygonModeEXT = cast[proc (commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode) {.stdcall.}](vkGetProc("vkCmdSetPolygonModeEXT"))
  vkCmdSetRasterizationSamplesEXT = cast[proc (commandBuffer: VkCommandBuffer, rasterizationSamples: VkSampleCountFlagBits) {.stdcall.}](vkGetProc("vkCmdSetRasterizationSamplesEXT"))
  vkCmdSetSampleMaskEXT = cast[proc (commandBuffer: VkCommandBuffer, samples: VkSampleCountFlagBits, pSampleMask: ptr VkSampleMask) {.stdcall.}](vkGetProc("vkCmdSetSampleMaskEXT"))
  vkCmdSetAlphaToCoverageEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, alphaToCoverageEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetAlphaToCoverageEnableEXT"))
  vkCmdSetAlphaToOneEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetAlphaToOneEnableEXT"))
  vkCmdSetLogicOpEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetLogicOpEnableEXT"))
  vkCmdSetColorBlendEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorBlendEnables: ptr VkBool32) {.stdcall.}](vkGetProc("vkCmdSetColorBlendEnableEXT"))
  vkCmdSetColorBlendEquationEXT = cast[proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorBlendEquations: ptr VkColorBlendEquationEXT) {.stdcall.}](vkGetProc("vkCmdSetColorBlendEquationEXT"))
  vkCmdSetColorWriteMaskEXT = cast[proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorWriteMasks: ptr VkColorComponentFlags) {.stdcall.}](vkGetProc("vkCmdSetColorWriteMaskEXT"))
  vkCmdSetTessellationDomainOriginEXT = cast[proc (commandBuffer: VkCommandBuffer, domainOrigin: VkTessellationDomainOrigin) {.stdcall.}](vkGetProc("vkCmdSetTessellationDomainOriginEXT"))
  vkCmdSetRasterizationStreamEXT = cast[proc (commandBuffer: VkCommandBuffer, rasterizationStream: uint32) {.stdcall.}](vkGetProc("vkCmdSetRasterizationStreamEXT"))
  vkCmdSetConservativeRasterizationModeEXT = cast[proc (commandBuffer: VkCommandBuffer, conservativeRasterizationMode: VkConservativeRasterizationModeEXT) {.stdcall.}](vkGetProc("vkCmdSetConservativeRasterizationModeEXT"))
  vkCmdSetExtraPrimitiveOverestimationSizeEXT = cast[proc (commandBuffer: VkCommandBuffer, extraPrimitiveOverestimationSize: float32) {.stdcall.}](vkGetProc("vkCmdSetExtraPrimitiveOverestimationSizeEXT"))
  vkCmdSetDepthClipEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthClipEnableEXT"))
  vkCmdSetSampleLocationsEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, sampleLocationsEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetSampleLocationsEnableEXT"))
  vkCmdSetColorBlendAdvancedEXT = cast[proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorBlendAdvanced: ptr VkColorBlendAdvancedEXT) {.stdcall.}](vkGetProc("vkCmdSetColorBlendAdvancedEXT"))
  vkCmdSetProvokingVertexModeEXT = cast[proc (commandBuffer: VkCommandBuffer, provokingVertexMode: VkProvokingVertexModeEXT) {.stdcall.}](vkGetProc("vkCmdSetProvokingVertexModeEXT"))
  vkCmdSetLineRasterizationModeEXT = cast[proc (commandBuffer: VkCommandBuffer, lineRasterizationMode: VkLineRasterizationModeEXT) {.stdcall.}](vkGetProc("vkCmdSetLineRasterizationModeEXT"))
  vkCmdSetLineStippleEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, stippledLineEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetLineStippleEnableEXT"))
  vkCmdSetDepthClipNegativeOneToOneEXT = cast[proc (commandBuffer: VkCommandBuffer, negativeOneToOne: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthClipNegativeOneToOneEXT"))
  vkCmdSetViewportWScalingEnableNV = cast[proc (commandBuffer: VkCommandBuffer, viewportWScalingEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetViewportWScalingEnableNV"))
  vkCmdSetViewportSwizzleNV = cast[proc (commandBuffer: VkCommandBuffer, firstViewport: uint32, viewportCount: uint32, pViewportSwizzles: ptr VkViewportSwizzleNV) {.stdcall.}](vkGetProc("vkCmdSetViewportSwizzleNV"))
  vkCmdSetCoverageToColorEnableNV = cast[proc (commandBuffer: VkCommandBuffer, coverageToColorEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetCoverageToColorEnableNV"))
  vkCmdSetCoverageToColorLocationNV = cast[proc (commandBuffer: VkCommandBuffer, coverageToColorLocation: uint32) {.stdcall.}](vkGetProc("vkCmdSetCoverageToColorLocationNV"))
  vkCmdSetCoverageModulationModeNV = cast[proc (commandBuffer: VkCommandBuffer, coverageModulationMode: VkCoverageModulationModeNV) {.stdcall.}](vkGetProc("vkCmdSetCoverageModulationModeNV"))
  vkCmdSetCoverageModulationTableEnableNV = cast[proc (commandBuffer: VkCommandBuffer, coverageModulationTableEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetCoverageModulationTableEnableNV"))
  vkCmdSetCoverageModulationTableNV = cast[proc (commandBuffer: VkCommandBuffer, coverageModulationTableCount: uint32, pCoverageModulationTable: ptr float32) {.stdcall.}](vkGetProc("vkCmdSetCoverageModulationTableNV"))
  vkCmdSetShadingRateImageEnableNV = cast[proc (commandBuffer: VkCommandBuffer, shadingRateImageEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetShadingRateImageEnableNV"))
  vkCmdSetRepresentativeFragmentTestEnableNV = cast[proc (commandBuffer: VkCommandBuffer, representativeFragmentTestEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetRepresentativeFragmentTestEnableNV"))
  vkCmdSetCoverageReductionModeNV = cast[proc (commandBuffer: VkCommandBuffer, coverageReductionMode: VkCoverageReductionModeNV) {.stdcall.}](vkGetProc("vkCmdSetCoverageReductionModeNV"))

# Load VK_ARM_tensors
proc loadVK_ARM_tensors*() =
  vkCreateTensorARM = cast[proc (device: VkDevice, pCreateInfo: ptr VkTensorCreateInfoARM, pAllocator: ptr VkAllocationCallbacks, pTensor: ptr VkTensorARM): VkResult {.stdcall.}](vkGetProc("vkCreateTensorARM"))
  vkDestroyTensorARM = cast[proc (device: VkDevice, tensor: VkTensorARM, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyTensorARM"))
  vkCreateTensorViewARM = cast[proc (device: VkDevice, pCreateInfo: ptr VkTensorViewCreateInfoARM, pAllocator: ptr VkAllocationCallbacks, pView: ptr VkTensorViewARM): VkResult {.stdcall.}](vkGetProc("vkCreateTensorViewARM"))
  vkDestroyTensorViewARM = cast[proc (device: VkDevice, tensorView: VkTensorViewARM, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyTensorViewARM"))
  vkGetTensorMemoryRequirementsARM = cast[proc (device: VkDevice, pInfo: ptr VkTensorMemoryRequirementsInfoARM, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetTensorMemoryRequirementsARM"))
  vkBindTensorMemoryARM = cast[proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindTensorMemoryInfoARM): VkResult {.stdcall.}](vkGetProc("vkBindTensorMemoryARM"))
  vkGetDeviceTensorMemoryRequirementsARM = cast[proc (device: VkDevice, pInfo: ptr VkDeviceTensorMemoryRequirementsARM, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetDeviceTensorMemoryRequirementsARM"))
  vkCmdCopyTensorARM = cast[proc (commandBuffer: VkCommandBuffer, pCopyTensorInfo: ptr VkCopyTensorInfoARM) {.stdcall.}](vkGetProc("vkCmdCopyTensorARM"))
  vkGetPhysicalDeviceExternalTensorPropertiesARM = cast[proc (physicalDevice: VkPhysicalDevice, pExternalTensorInfo: ptr VkPhysicalDeviceExternalTensorInfoARM, pExternalTensorProperties: ptr VkExternalTensorPropertiesARM) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceExternalTensorPropertiesARM"))
  vkGetTensorOpaqueCaptureDescriptorDataARM = cast[proc (device: VkDevice, pInfo: ptr VkTensorCaptureDescriptorDataInfoARM, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetTensorOpaqueCaptureDescriptorDataARM"))
  vkGetTensorViewOpaqueCaptureDescriptorDataARM = cast[proc (device: VkDevice, pInfo: ptr VkTensorViewCaptureDescriptorDataInfoARM, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetTensorViewOpaqueCaptureDescriptorDataARM"))

# Load VK_EXT_shader_module_identifier
proc loadVK_EXT_shader_module_identifier*() =
  vkGetShaderModuleIdentifierEXT = cast[proc (device: VkDevice, shaderModule: VkShaderModule, pIdentifier: ptr VkShaderModuleIdentifierEXT) {.stdcall.}](vkGetProc("vkGetShaderModuleIdentifierEXT"))
  vkGetShaderModuleCreateInfoIdentifierEXT = cast[proc (device: VkDevice, pCreateInfo: ptr VkShaderModuleCreateInfo, pIdentifier: ptr VkShaderModuleIdentifierEXT) {.stdcall.}](vkGetProc("vkGetShaderModuleCreateInfoIdentifierEXT"))

# Load VK_NV_optical_flow
proc loadVK_NV_optical_flow*() =
  vkGetPhysicalDeviceOpticalFlowImageFormatsNV = cast[proc (physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: ptr VkOpticalFlowImageFormatInfoNV, pFormatCount: ptr uint32, pImageFormatProperties: ptr VkOpticalFlowImageFormatPropertiesNV): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceOpticalFlowImageFormatsNV"))
  vkCreateOpticalFlowSessionNV = cast[proc (device: VkDevice, pCreateInfo: ptr VkOpticalFlowSessionCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pSession: ptr VkOpticalFlowSessionNV): VkResult {.stdcall.}](vkGetProc("vkCreateOpticalFlowSessionNV"))
  vkDestroyOpticalFlowSessionNV = cast[proc (device: VkDevice, session: VkOpticalFlowSessionNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyOpticalFlowSessionNV"))
  vkBindOpticalFlowSessionImageNV = cast[proc (device: VkDevice, session: VkOpticalFlowSessionNV, bindingPoint: VkOpticalFlowSessionBindingPointNV, view: VkImageView, layout: VkImageLayout): VkResult {.stdcall.}](vkGetProc("vkBindOpticalFlowSessionImageNV"))
  vkCmdOpticalFlowExecuteNV = cast[proc (commandBuffer: VkCommandBuffer, session: VkOpticalFlowSessionNV, pExecuteInfo: ptr VkOpticalFlowExecuteInfoNV) {.stdcall.}](vkGetProc("vkCmdOpticalFlowExecuteNV"))

# Load VK_AMD_anti_lag
proc loadVK_AMD_anti_lag*() =
  vkAntiLagUpdateAMD = cast[proc (device: VkDevice, pData: ptr VkAntiLagDataAMD) {.stdcall.}](vkGetProc("vkAntiLagUpdateAMD"))

# Load VK_KHR_present_wait2
proc loadVK_KHR_present_wait2*() =
  vkWaitForPresent2KHR = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pPresentWait2Info: ptr VkPresentWait2InfoKHR): VkResult {.stdcall.}](vkGetProc("vkWaitForPresent2KHR"))

# Load VK_EXT_shader_object
proc loadVK_EXT_shader_object*() =
  vkCreateShadersEXT = cast[proc (device: VkDevice, createInfoCount: uint32, pCreateInfos: ptr VkShaderCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pShaders: ptr VkShaderEXT): VkResult {.stdcall.}](vkGetProc("vkCreateShadersEXT"))
  vkDestroyShaderEXT = cast[proc (device: VkDevice, shader: VkShaderEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyShaderEXT"))
  vkGetShaderBinaryDataEXT = cast[proc (device: VkDevice, shader: VkShaderEXT, pDataSize: ptr uint, pData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetShaderBinaryDataEXT"))
  vkCmdBindShadersEXT = cast[proc (commandBuffer: VkCommandBuffer, stageCount: uint32, pStages: ptr VkShaderStageFlagBits, pShaders: ptr VkShaderEXT) {.stdcall.}](vkGetProc("vkCmdBindShadersEXT"))
  vkCmdSetVertexInputEXT = cast[proc (commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: uint32, pVertexBindingDescriptions: ptr VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: uint32, pVertexAttributeDescriptions: ptr VkVertexInputAttributeDescription2EXT) {.stdcall.}](vkGetProc("vkCmdSetVertexInputEXT"))
  vkCmdSetPatchControlPointsEXT = cast[proc (commandBuffer: VkCommandBuffer, patchControlPoints: uint32) {.stdcall.}](vkGetProc("vkCmdSetPatchControlPointsEXT"))
  vkCmdSetLogicOpEXT = cast[proc (commandBuffer: VkCommandBuffer, logicOp: VkLogicOp) {.stdcall.}](vkGetProc("vkCmdSetLogicOpEXT"))
  vkCmdSetTessellationDomainOriginEXT = cast[proc (commandBuffer: VkCommandBuffer, domainOrigin: VkTessellationDomainOrigin) {.stdcall.}](vkGetProc("vkCmdSetTessellationDomainOriginEXT"))
  vkCmdSetDepthClampEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthClampEnableEXT"))
  vkCmdSetPolygonModeEXT = cast[proc (commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode) {.stdcall.}](vkGetProc("vkCmdSetPolygonModeEXT"))
  vkCmdSetRasterizationSamplesEXT = cast[proc (commandBuffer: VkCommandBuffer, rasterizationSamples: VkSampleCountFlagBits) {.stdcall.}](vkGetProc("vkCmdSetRasterizationSamplesEXT"))
  vkCmdSetSampleMaskEXT = cast[proc (commandBuffer: VkCommandBuffer, samples: VkSampleCountFlagBits, pSampleMask: ptr VkSampleMask) {.stdcall.}](vkGetProc("vkCmdSetSampleMaskEXT"))
  vkCmdSetAlphaToCoverageEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, alphaToCoverageEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetAlphaToCoverageEnableEXT"))
  vkCmdSetAlphaToOneEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetAlphaToOneEnableEXT"))
  vkCmdSetLogicOpEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetLogicOpEnableEXT"))
  vkCmdSetColorBlendEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorBlendEnables: ptr VkBool32) {.stdcall.}](vkGetProc("vkCmdSetColorBlendEnableEXT"))
  vkCmdSetColorBlendEquationEXT = cast[proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorBlendEquations: ptr VkColorBlendEquationEXT) {.stdcall.}](vkGetProc("vkCmdSetColorBlendEquationEXT"))
  vkCmdSetColorWriteMaskEXT = cast[proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorWriteMasks: ptr VkColorComponentFlags) {.stdcall.}](vkGetProc("vkCmdSetColorWriteMaskEXT"))
  vkCmdSetRasterizationStreamEXT = cast[proc (commandBuffer: VkCommandBuffer, rasterizationStream: uint32) {.stdcall.}](vkGetProc("vkCmdSetRasterizationStreamEXT"))
  vkCmdSetConservativeRasterizationModeEXT = cast[proc (commandBuffer: VkCommandBuffer, conservativeRasterizationMode: VkConservativeRasterizationModeEXT) {.stdcall.}](vkGetProc("vkCmdSetConservativeRasterizationModeEXT"))
  vkCmdSetExtraPrimitiveOverestimationSizeEXT = cast[proc (commandBuffer: VkCommandBuffer, extraPrimitiveOverestimationSize: float32) {.stdcall.}](vkGetProc("vkCmdSetExtraPrimitiveOverestimationSizeEXT"))
  vkCmdSetDepthClipEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthClipEnableEXT"))
  vkCmdSetSampleLocationsEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, sampleLocationsEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetSampleLocationsEnableEXT"))
  vkCmdSetColorBlendAdvancedEXT = cast[proc (commandBuffer: VkCommandBuffer, firstAttachment: uint32, attachmentCount: uint32, pColorBlendAdvanced: ptr VkColorBlendAdvancedEXT) {.stdcall.}](vkGetProc("vkCmdSetColorBlendAdvancedEXT"))
  vkCmdSetProvokingVertexModeEXT = cast[proc (commandBuffer: VkCommandBuffer, provokingVertexMode: VkProvokingVertexModeEXT) {.stdcall.}](vkGetProc("vkCmdSetProvokingVertexModeEXT"))
  vkCmdSetLineRasterizationModeEXT = cast[proc (commandBuffer: VkCommandBuffer, lineRasterizationMode: VkLineRasterizationModeEXT) {.stdcall.}](vkGetProc("vkCmdSetLineRasterizationModeEXT"))
  vkCmdSetLineStippleEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, stippledLineEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetLineStippleEnableEXT"))
  vkCmdSetDepthClipNegativeOneToOneEXT = cast[proc (commandBuffer: VkCommandBuffer, negativeOneToOne: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetDepthClipNegativeOneToOneEXT"))
  vkCmdSetViewportWScalingEnableNV = cast[proc (commandBuffer: VkCommandBuffer, viewportWScalingEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetViewportWScalingEnableNV"))
  vkCmdSetViewportSwizzleNV = cast[proc (commandBuffer: VkCommandBuffer, firstViewport: uint32, viewportCount: uint32, pViewportSwizzles: ptr VkViewportSwizzleNV) {.stdcall.}](vkGetProc("vkCmdSetViewportSwizzleNV"))
  vkCmdSetCoverageToColorEnableNV = cast[proc (commandBuffer: VkCommandBuffer, coverageToColorEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetCoverageToColorEnableNV"))
  vkCmdSetCoverageToColorLocationNV = cast[proc (commandBuffer: VkCommandBuffer, coverageToColorLocation: uint32) {.stdcall.}](vkGetProc("vkCmdSetCoverageToColorLocationNV"))
  vkCmdSetCoverageModulationModeNV = cast[proc (commandBuffer: VkCommandBuffer, coverageModulationMode: VkCoverageModulationModeNV) {.stdcall.}](vkGetProc("vkCmdSetCoverageModulationModeNV"))
  vkCmdSetCoverageModulationTableEnableNV = cast[proc (commandBuffer: VkCommandBuffer, coverageModulationTableEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetCoverageModulationTableEnableNV"))
  vkCmdSetCoverageModulationTableNV = cast[proc (commandBuffer: VkCommandBuffer, coverageModulationTableCount: uint32, pCoverageModulationTable: ptr float32) {.stdcall.}](vkGetProc("vkCmdSetCoverageModulationTableNV"))
  vkCmdSetShadingRateImageEnableNV = cast[proc (commandBuffer: VkCommandBuffer, shadingRateImageEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetShadingRateImageEnableNV"))
  vkCmdSetRepresentativeFragmentTestEnableNV = cast[proc (commandBuffer: VkCommandBuffer, representativeFragmentTestEnable: VkBool32) {.stdcall.}](vkGetProc("vkCmdSetRepresentativeFragmentTestEnableNV"))
  vkCmdSetCoverageReductionModeNV = cast[proc (commandBuffer: VkCommandBuffer, coverageReductionMode: VkCoverageReductionModeNV) {.stdcall.}](vkGetProc("vkCmdSetCoverageReductionModeNV"))
  vkCmdSetDepthClampRangeEXT = cast[proc (commandBuffer: VkCommandBuffer, depthClampMode: VkDepthClampModeEXT, pDepthClampRange: ptr VkDepthClampRangeEXT) {.stdcall.}](vkGetProc("vkCmdSetDepthClampRangeEXT"))

# Load VK_KHR_pipeline_binary
proc loadVK_KHR_pipeline_binary*() =
  vkCreatePipelineBinariesKHR = cast[proc (device: VkDevice, pCreateInfo: ptr VkPipelineBinaryCreateInfoKHR, pAllocator: ptr VkAllocationCallbacks, pBinaries: ptr VkPipelineBinaryHandlesInfoKHR): VkResult {.stdcall.}](vkGetProc("vkCreatePipelineBinariesKHR"))
  vkDestroyPipelineBinaryKHR = cast[proc (device: VkDevice, pipelineBinary: VkPipelineBinaryKHR, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyPipelineBinaryKHR"))
  vkGetPipelineKeyKHR = cast[proc (device: VkDevice, pPipelineCreateInfo: ptr VkPipelineCreateInfoKHR, pPipelineKey: ptr VkPipelineBinaryKeyKHR): VkResult {.stdcall.}](vkGetProc("vkGetPipelineKeyKHR"))
  vkGetPipelineBinaryDataKHR = cast[proc (device: VkDevice, pInfo: ptr VkPipelineBinaryDataInfoKHR, pPipelineBinaryKey: ptr VkPipelineBinaryKeyKHR, pPipelineBinaryDataSize: ptr uint, pPipelineBinaryData: pointer): VkResult {.stdcall.}](vkGetProc("vkGetPipelineBinaryDataKHR"))
  vkReleaseCapturedPipelineDataKHR = cast[proc (device: VkDevice, pInfo: ptr VkReleaseCapturedPipelineDataInfoKHR, pAllocator: ptr VkAllocationCallbacks): VkResult {.stdcall.}](vkGetProc("vkReleaseCapturedPipelineDataKHR"))

# Load VK_QCOM_tile_properties
proc loadVK_QCOM_tile_properties*() =
  vkGetFramebufferTilePropertiesQCOM = cast[proc (device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: ptr uint32, pProperties: ptr VkTilePropertiesQCOM): VkResult {.stdcall.}](vkGetProc("vkGetFramebufferTilePropertiesQCOM"))
  vkGetDynamicRenderingTilePropertiesQCOM = cast[proc (device: VkDevice, pRenderingInfo: ptr VkRenderingInfo, pProperties: ptr VkTilePropertiesQCOM): VkResult {.stdcall.}](vkGetProc("vkGetDynamicRenderingTilePropertiesQCOM"))

# Load VK_KHR_swapchain_maintenance1
proc loadVK_KHR_swapchain_maintenance1*() =
  vkReleaseSwapchainImagesKHR = cast[proc (device: VkDevice, pReleaseInfo: ptr VkReleaseSwapchainImagesInfoKHR): VkResult {.stdcall.}](vkGetProc("vkReleaseSwapchainImagesKHR"))

# Load VK_NV_external_sci_sync2
proc loadVK_NV_external_sci_sync2*() =
  vkCreateSemaphoreSciSyncPoolNV = cast[proc (device: VkDevice, pCreateInfo: ptr VkSemaphoreSciSyncPoolCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pSemaphorePool: ptr VkSemaphoreSciSyncPoolNV): VkResult {.stdcall.}](vkGetProc("vkCreateSemaphoreSciSyncPoolNV"))
  vkDestroySemaphoreSciSyncPoolNV = cast[proc (device: VkDevice, semaphorePool: VkSemaphoreSciSyncPoolNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroySemaphoreSciSyncPoolNV"))
  vkGetFenceSciSyncFenceNV = cast[proc (device: VkDevice, pGetSciSyncHandleInfo: ptr VkFenceGetSciSyncInfoNV, pHandle: pointer): VkResult {.stdcall.}](vkGetProc("vkGetFenceSciSyncFenceNV"))
  vkGetFenceSciSyncObjNV = cast[proc (device: VkDevice, pGetSciSyncHandleInfo: ptr VkFenceGetSciSyncInfoNV, pHandle: pointer): VkResult {.stdcall.}](vkGetProc("vkGetFenceSciSyncObjNV"))
  vkImportFenceSciSyncFenceNV = cast[proc (device: VkDevice, pImportFenceSciSyncInfo: ptr VkImportFenceSciSyncInfoNV): VkResult {.stdcall.}](vkGetProc("vkImportFenceSciSyncFenceNV"))
  vkImportFenceSciSyncObjNV = cast[proc (device: VkDevice, pImportFenceSciSyncInfo: ptr VkImportFenceSciSyncInfoNV): VkResult {.stdcall.}](vkGetProc("vkImportFenceSciSyncObjNV"))
  vkGetPhysicalDeviceSciSyncAttributesNV = cast[proc (physicalDevice: VkPhysicalDevice, pSciSyncAttributesInfo: ptr VkSciSyncAttributesInfoNV, pAttributes: NvSciSyncAttrList): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceSciSyncAttributesNV"))

# Load VK_NV_cooperative_vector
proc loadVK_NV_cooperative_vector*() =
  vkGetPhysicalDeviceCooperativeVectorPropertiesNV = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkCooperativeVectorPropertiesNV): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceCooperativeVectorPropertiesNV"))
  vkConvertCooperativeVectorMatrixNV = cast[proc (device: VkDevice, pInfo: ptr VkConvertCooperativeVectorMatrixInfoNV): VkResult {.stdcall.}](vkGetProc("vkConvertCooperativeVectorMatrixNV"))
  vkCmdConvertCooperativeVectorMatrixNV = cast[proc (commandBuffer: VkCommandBuffer, infoCount: uint32, pInfos: ptr VkConvertCooperativeVectorMatrixInfoNV) {.stdcall.}](vkGetProc("vkCmdConvertCooperativeVectorMatrixNV"))

# Load VK_NV_low_latency2
proc loadVK_NV_low_latency2*() =
  vkSetLatencySleepModeNV = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pSleepModeInfo: ptr VkLatencySleepModeInfoNV): VkResult {.stdcall.}](vkGetProc("vkSetLatencySleepModeNV"))
  vkLatencySleepNV = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pSleepInfo: ptr VkLatencySleepInfoNV): VkResult {.stdcall.}](vkGetProc("vkLatencySleepNV"))
  vkSetLatencyMarkerNV = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: ptr VkSetLatencyMarkerInfoNV) {.stdcall.}](vkGetProc("vkSetLatencyMarkerNV"))
  vkGetLatencyTimingsNV = cast[proc (device: VkDevice, swapchain: VkSwapchainKHR, pLatencyMarkerInfo: ptr VkGetLatencyMarkerInfoNV) {.stdcall.}](vkGetProc("vkGetLatencyTimingsNV"))
  vkQueueNotifyOutOfBandNV = cast[proc (queue: VkQueue, pQueueTypeInfo: ptr VkOutOfBandQueueTypeInfoNV) {.stdcall.}](vkGetProc("vkQueueNotifyOutOfBandNV"))

# Load VK_KHR_cooperative_matrix
proc loadVK_KHR_cooperative_matrix*() =
  vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkCooperativeMatrixPropertiesKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR"))

# Load VK_ARM_data_graph
proc loadVK_ARM_data_graph*() =
  vkCreateDataGraphPipelinesARM = cast[proc (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: uint32, pCreateInfos: ptr VkDataGraphPipelineCreateInfoARM, pAllocator: ptr VkAllocationCallbacks, pPipelines: ptr VkPipeline): VkResult {.stdcall.}](vkGetProc("vkCreateDataGraphPipelinesARM"))
  vkCreateDataGraphPipelineSessionARM = cast[proc (device: VkDevice, pCreateInfo: ptr VkDataGraphPipelineSessionCreateInfoARM, pAllocator: ptr VkAllocationCallbacks, pSession: ptr VkDataGraphPipelineSessionARM): VkResult {.stdcall.}](vkGetProc("vkCreateDataGraphPipelineSessionARM"))
  vkGetDataGraphPipelineSessionBindPointRequirementsARM = cast[proc (device: VkDevice, pInfo: ptr VkDataGraphPipelineSessionBindPointRequirementsInfoARM, pBindPointRequirementCount: ptr uint32, pBindPointRequirements: ptr VkDataGraphPipelineSessionBindPointRequirementARM): VkResult {.stdcall.}](vkGetProc("vkGetDataGraphPipelineSessionBindPointRequirementsARM"))
  vkGetDataGraphPipelineSessionMemoryRequirementsARM = cast[proc (device: VkDevice, pInfo: ptr VkDataGraphPipelineSessionMemoryRequirementsInfoARM, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetDataGraphPipelineSessionMemoryRequirementsARM"))
  vkBindDataGraphPipelineSessionMemoryARM = cast[proc (device: VkDevice, bindInfoCount: uint32, pBindInfos: ptr VkBindDataGraphPipelineSessionMemoryInfoARM): VkResult {.stdcall.}](vkGetProc("vkBindDataGraphPipelineSessionMemoryARM"))
  vkDestroyDataGraphPipelineSessionARM = cast[proc (device: VkDevice, session: VkDataGraphPipelineSessionARM, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyDataGraphPipelineSessionARM"))
  vkCmdDispatchDataGraphARM = cast[proc (commandBuffer: VkCommandBuffer, session: VkDataGraphPipelineSessionARM, pInfo: ptr VkDataGraphPipelineDispatchInfoARM) {.stdcall.}](vkGetProc("vkCmdDispatchDataGraphARM"))
  vkGetDataGraphPipelineAvailablePropertiesARM = cast[proc (device: VkDevice, pPipelineInfo: ptr VkDataGraphPipelineInfoARM, pPropertiesCount: ptr uint32, pProperties: ptr VkDataGraphPipelinePropertyARM): VkResult {.stdcall.}](vkGetProc("vkGetDataGraphPipelineAvailablePropertiesARM"))
  vkGetDataGraphPipelinePropertiesARM = cast[proc (device: VkDevice, pPipelineInfo: ptr VkDataGraphPipelineInfoARM, propertiesCount: uint32, pProperties: ptr VkDataGraphPipelinePropertyQueryResultARM): VkResult {.stdcall.}](vkGetProc("vkGetDataGraphPipelinePropertiesARM"))
  vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, pQueueFamilyDataGraphPropertyCount: ptr uint32, pQueueFamilyDataGraphProperties: ptr VkQueueFamilyDataGraphPropertiesARM): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM"))
  vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = cast[proc (physicalDevice: VkPhysicalDevice, pQueueFamilyDataGraphProcessingEngineInfo: ptr VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, pQueueFamilyDataGraphProcessingEngineProperties: ptr VkQueueFamilyDataGraphProcessingEnginePropertiesARM) {.stdcall.}](vkGetProc("vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM"))

# Load VK_EXT_attachment_feedback_loop_dynamic_state
proc loadVK_EXT_attachment_feedback_loop_dynamic_state*() =
  vkCmdSetAttachmentFeedbackLoopEnableEXT = cast[proc (commandBuffer: VkCommandBuffer, aspectMask: VkImageAspectFlags) {.stdcall.}](vkGetProc("vkCmdSetAttachmentFeedbackLoopEnableEXT"))

# Load VK_QNX_external_memory_screen_buffer
proc loadVK_QNX_external_memory_screen_buffer*() =
  vkGetScreenBufferPropertiesQNX = cast[proc (device: VkDevice, buffer: ptr screen_buffer, pProperties: ptr VkScreenBufferPropertiesQNX): VkResult {.stdcall.}](vkGetProc("vkGetScreenBufferPropertiesQNX"))

# Load VK_KHR_calibrated_timestamps
proc loadVK_KHR_calibrated_timestamps*() =
  vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = cast[proc (physicalDevice: VkPhysicalDevice, pTimeDomainCount: ptr uint32, pTimeDomains: ptr VkTimeDomainKHR): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR"))
  vkGetCalibratedTimestampsKHR = cast[proc (device: VkDevice, timestampCount: uint32, pTimestampInfos: ptr VkCalibratedTimestampInfoKHR, pTimestamps: ptr uint64, pMaxDeviation: ptr uint64): VkResult {.stdcall.}](vkGetProc("vkGetCalibratedTimestampsKHR"))

# Load VK_KHR_maintenance6
proc loadVK_KHR_maintenance6*() =
  vkCmdSetDescriptorBufferOffsets2EXT = cast[proc (commandBuffer: VkCommandBuffer, pSetDescriptorBufferOffsetsInfo: ptr VkSetDescriptorBufferOffsetsInfoEXT) {.stdcall.}](vkGetProc("vkCmdSetDescriptorBufferOffsets2EXT"))
  vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = cast[proc (commandBuffer: VkCommandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo: ptr VkBindDescriptorBufferEmbeddedSamplersInfoEXT) {.stdcall.}](vkGetProc("vkCmdBindDescriptorBufferEmbeddedSamplers2EXT"))

# Load VK_QCOM_tile_memory_heap
proc loadVK_QCOM_tile_memory_heap*() =
  vkCmdBindTileMemoryQCOM = cast[proc (commandBuffer: VkCommandBuffer, pTileMemoryBindInfo: ptr VkTileMemoryBindInfoQCOM) {.stdcall.}](vkGetProc("vkCmdBindTileMemoryQCOM"))

# Load VK_KHR_copy_memory_indirect
proc loadVK_KHR_copy_memory_indirect*() =
  vkCmdCopyMemoryIndirectKHR = cast[proc (commandBuffer: VkCommandBuffer, pCopyMemoryIndirectInfo: ptr VkCopyMemoryIndirectInfoKHR) {.stdcall.}](vkGetProc("vkCmdCopyMemoryIndirectKHR"))
  vkCmdCopyMemoryToImageIndirectKHR = cast[proc (commandBuffer: VkCommandBuffer, pCopyMemoryToImageIndirectInfo: ptr VkCopyMemoryToImageIndirectInfoKHR) {.stdcall.}](vkGetProc("vkCmdCopyMemoryToImageIndirectKHR"))

# Load VK_EXT_memory_decompression
proc loadVK_EXT_memory_decompression*() =
  vkCmdDecompressMemoryEXT = cast[proc (commandBuffer: VkCommandBuffer, pDecompressMemoryInfoEXT: ptr VkDecompressMemoryInfoEXT) {.stdcall.}](vkGetProc("vkCmdDecompressMemoryEXT"))
  vkCmdDecompressMemoryIndirectCountEXT = cast[proc (commandBuffer: VkCommandBuffer, decompressionMethod: VkMemoryDecompressionMethodFlagsEXT, indirectCommandsAddress: VkDeviceAddress, indirectCommandsCountAddress: VkDeviceAddress, maxDecompressionCount: uint32, stride: uint32) {.stdcall.}](vkGetProc("vkCmdDecompressMemoryIndirectCountEXT"))

# Load VK_NV_external_compute_queue
proc loadVK_NV_external_compute_queue*() =
  vkCreateExternalComputeQueueNV = cast[proc (device: VkDevice, pCreateInfo: ptr VkExternalComputeQueueCreateInfoNV, pAllocator: ptr VkAllocationCallbacks, pExternalQueue: ptr VkExternalComputeQueueNV): VkResult {.stdcall.}](vkGetProc("vkCreateExternalComputeQueueNV"))
  vkDestroyExternalComputeQueueNV = cast[proc (device: VkDevice, externalQueue: VkExternalComputeQueueNV, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyExternalComputeQueueNV"))
  vkGetExternalComputeQueueDataNV = cast[proc (externalQueue: VkExternalComputeQueueNV, params: ptr VkExternalComputeQueueDataParamsNV, pData: pointer) {.stdcall.}](vkGetProc("vkGetExternalComputeQueueDataNV"))

# Load VK_NV_cluster_acceleration_structure
proc loadVK_NV_cluster_acceleration_structure*() =
  vkGetClusterAccelerationStructureBuildSizesNV = cast[proc (device: VkDevice, pInfo: ptr VkClusterAccelerationStructureInputInfoNV, pSizeInfo: ptr VkAccelerationStructureBuildSizesInfoKHR) {.stdcall.}](vkGetProc("vkGetClusterAccelerationStructureBuildSizesNV"))
  vkCmdBuildClusterAccelerationStructureIndirectNV = cast[proc (commandBuffer: VkCommandBuffer, pCommandInfos: ptr VkClusterAccelerationStructureCommandsInfoNV) {.stdcall.}](vkGetProc("vkCmdBuildClusterAccelerationStructureIndirectNV"))

# Load VK_NV_partitioned_acceleration_structure
proc loadVK_NV_partitioned_acceleration_structure*() =
  vkGetPartitionedAccelerationStructuresBuildSizesNV = cast[proc (device: VkDevice, pInfo: ptr VkPartitionedAccelerationStructureInstancesInputNV, pSizeInfo: ptr VkAccelerationStructureBuildSizesInfoKHR) {.stdcall.}](vkGetProc("vkGetPartitionedAccelerationStructuresBuildSizesNV"))
  vkCmdBuildPartitionedAccelerationStructuresNV = cast[proc (commandBuffer: VkCommandBuffer, pBuildInfo: ptr VkBuildPartitionedAccelerationStructureInfoNV) {.stdcall.}](vkGetProc("vkCmdBuildPartitionedAccelerationStructuresNV"))

# Load VK_EXT_device_generated_commands
proc loadVK_EXT_device_generated_commands*() =
  vkGetGeneratedCommandsMemoryRequirementsEXT = cast[proc (device: VkDevice, pInfo: ptr VkGeneratedCommandsMemoryRequirementsInfoEXT, pMemoryRequirements: ptr VkMemoryRequirements2) {.stdcall.}](vkGetProc("vkGetGeneratedCommandsMemoryRequirementsEXT"))
  vkCmdPreprocessGeneratedCommandsEXT = cast[proc (commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: ptr VkGeneratedCommandsInfoEXT, stateCommandBuffer: VkCommandBuffer) {.stdcall.}](vkGetProc("vkCmdPreprocessGeneratedCommandsEXT"))
  vkCmdExecuteGeneratedCommandsEXT = cast[proc (commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: ptr VkGeneratedCommandsInfoEXT) {.stdcall.}](vkGetProc("vkCmdExecuteGeneratedCommandsEXT"))
  vkCreateIndirectCommandsLayoutEXT = cast[proc (device: VkDevice, pCreateInfo: ptr VkIndirectCommandsLayoutCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pIndirectCommandsLayout: ptr VkIndirectCommandsLayoutEXT): VkResult {.stdcall.}](vkGetProc("vkCreateIndirectCommandsLayoutEXT"))
  vkDestroyIndirectCommandsLayoutEXT = cast[proc (device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyIndirectCommandsLayoutEXT"))
  vkCreateIndirectExecutionSetEXT = cast[proc (device: VkDevice, pCreateInfo: ptr VkIndirectExecutionSetCreateInfoEXT, pAllocator: ptr VkAllocationCallbacks, pIndirectExecutionSet: ptr VkIndirectExecutionSetEXT): VkResult {.stdcall.}](vkGetProc("vkCreateIndirectExecutionSetEXT"))
  vkDestroyIndirectExecutionSetEXT = cast[proc (device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, pAllocator: ptr VkAllocationCallbacks) {.stdcall.}](vkGetProc("vkDestroyIndirectExecutionSetEXT"))
  vkUpdateIndirectExecutionSetPipelineEXT = cast[proc (device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: uint32, pExecutionSetWrites: ptr VkWriteIndirectExecutionSetPipelineEXT) {.stdcall.}](vkGetProc("vkUpdateIndirectExecutionSetPipelineEXT"))
  vkUpdateIndirectExecutionSetShaderEXT = cast[proc (device: VkDevice, indirectExecutionSet: VkIndirectExecutionSetEXT, executionSetWriteCount: uint32, pExecutionSetWrites: ptr VkWriteIndirectExecutionSetShaderEXT) {.stdcall.}](vkGetProc("vkUpdateIndirectExecutionSetShaderEXT"))

# Load VK_EXT_depth_clamp_control
proc loadVK_EXT_depth_clamp_control*() =
  vkCmdSetDepthClampRangeEXT = cast[proc (commandBuffer: VkCommandBuffer, depthClampMode: VkDepthClampModeEXT, pDepthClampRange: ptr VkDepthClampRangeEXT) {.stdcall.}](vkGetProc("vkCmdSetDepthClampRangeEXT"))

# Load VK_OHOS_surface
proc loadVK_OHOS_surface*() =
  vkCreateSurfaceOHOS = cast[proc (instance: VkInstance, pCreateInfo: ptr VkSurfaceCreateInfoOHOS, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateSurfaceOHOS"))

# Load VK_OHOS_native_buffer
proc loadVK_OHOS_native_buffer*() =
  vkGetSwapchainGrallocUsageOHOS = cast[proc (device: VkDevice, format: VkFormat, imageUsage: VkImageUsageFlags, grallocUsage: ptr uint64): VkResult {.stdcall.}](vkGetProc("vkGetSwapchainGrallocUsageOHOS"))
  vkAcquireImageOHOS = cast[proc (device: VkDevice, image: VkImage, nativeFenceFd: int32, semaphore: VkSemaphore, fence: VkFence): VkResult {.stdcall.}](vkGetProc("vkAcquireImageOHOS"))
  vkQueueSignalReleaseImageOHOS = cast[proc (queue: VkQueue, waitSemaphoreCount: uint32, pWaitSemaphores: ptr VkSemaphore, image: VkImage, pNativeFenceFd: ptr int32): VkResult {.stdcall.}](vkGetProc("vkQueueSignalReleaseImageOHOS"))

# Load VK_NV_cooperative_matrix2
proc loadVK_NV_cooperative_matrix2*() =
  vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = cast[proc (physicalDevice: VkPhysicalDevice, pPropertyCount: ptr uint32, pProperties: ptr VkCooperativeMatrixFlexibleDimensionsPropertiesNV): VkResult {.stdcall.}](vkGetProc("vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV"))

# Load VK_EXT_external_memory_metal
proc loadVK_EXT_external_memory_metal*() =
  vkGetMemoryMetalHandleEXT = cast[proc (device: VkDevice, pGetMetalHandleInfo: ptr VkMemoryGetMetalHandleInfoEXT, pHandle: ptr pointer): VkResult {.stdcall.}](vkGetProc("vkGetMemoryMetalHandleEXT"))
  vkGetMemoryMetalHandlePropertiesEXT = cast[proc (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHandle: pointer, pMemoryMetalHandleProperties: ptr VkMemoryMetalHandlePropertiesEXT): VkResult {.stdcall.}](vkGetProc("vkGetMemoryMetalHandlePropertiesEXT"))

# Load VK_ARM_performance_counters_by_region
proc loadVK_ARM_performance_counters_by_region*() =
  vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, pCounterCount: ptr uint32, pCounters: ptr VkPerformanceCounterARM, pCounterDescriptions: ptr VkPerformanceCounterDescriptionARM): VkResult {.stdcall.}](vkGetProc("vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM"))

# Load VK_EXT_custom_resolve
proc loadVK_EXT_custom_resolve*() =
  vkCmdBeginCustomResolveEXT = cast[proc (commandBuffer: VkCommandBuffer, pBeginCustomResolveInfo: ptr VkBeginCustomResolveInfoEXT) {.stdcall.}](vkGetProc("vkCmdBeginCustomResolveEXT"))

# Load VK_KHR_maintenance10
proc loadVK_KHR_maintenance10*() =
  vkCmdEndRendering2KHR = cast[proc (commandBuffer: VkCommandBuffer, pRenderingEndInfo: ptr VkRenderingEndInfoKHR) {.stdcall.}](vkGetProc("vkCmdEndRendering2KHR"))

# Load VK_NV_compute_occupancy_priority
proc loadVK_NV_compute_occupancy_priority*() =
  vkCmdSetComputeOccupancyPriorityNV = cast[proc (commandBuffer: VkCommandBuffer, pParameters: ptr VkComputeOccupancyPriorityParametersNV) {.stdcall.}](vkGetProc("vkCmdSetComputeOccupancyPriorityNV"))

# Load VK_SEC_ubm_surface
proc loadVK_SEC_ubm_surface*() =
  vkCreateUbmSurfaceSEC = cast[proc (instance: VkInstance, pCreateInfo: ptr VkUbmSurfaceCreateInfoSEC, pAllocator: ptr VkAllocationCallbacks, pSurface: ptr VkSurfaceKHR): VkResult {.stdcall.}](vkGetProc("vkCreateUbmSurfaceSEC"))
  vkGetPhysicalDeviceUbmPresentationSupportSEC = cast[proc (physicalDevice: VkPhysicalDevice, queueFamilyIndex: uint32, device: ptr ubm_device): VkBool32 {.stdcall.}](vkGetProc("vkGetPhysicalDeviceUbmPresentationSupportSEC"))

# VkDeviceSize helpers
proc `==`*(x, y: VkDeviceSize): bool {.borrow.}
proc `<=`*(x, y: VkDeviceSize): bool {.borrow.}
proc `< `*(x, y: VkDeviceSize): bool {.borrow.}
proc `+`*(x, y: VkDeviceSize): VkDeviceSize {.borrow.}
proc `-`*(x, y: VkDeviceSize): VkDeviceSize {.borrow.}
proc `*`*(x, y: VkDeviceSize): VkDeviceSize {.borrow.}
proc `not`*(x: VkDeviceSize): VkDeviceSize {.borrow.}
proc `div`*(x, y: VkDeviceSize): VkDeviceSize {.borrow.}
proc `and`*(x, y: VkDeviceSize): VkDeviceSize {.borrow.}
proc `shl`*(x: VkDeviceSize; y: uint64): VkDeviceSize {.borrow.}
proc `shr`*(x: VkDeviceSize; y: uint64): VkDeviceSize {.borrow.}


# Handle helpers
proc `==`*(x, y: VkInstance): bool {.borrow.}
proc `==`*(x, y: VkPhysicalDevice): bool {.borrow.}
proc `==`*(x, y: VkDevice): bool {.borrow.}
proc `==`*(x, y: VkQueue): bool {.borrow.}
proc `==`*(x, y: VkCommandBuffer): bool {.borrow.}
proc `==`*(x, y: VkDeviceMemory): bool {.borrow.}
proc `==`*(x, y: VkCommandPool): bool {.borrow.}
proc `==`*(x, y: VkBuffer): bool {.borrow.}
proc `==`*(x, y: VkBufferView): bool {.borrow.}
proc `==`*(x, y: VkImage): bool {.borrow.}
proc `==`*(x, y: VkImageView): bool {.borrow.}
proc `==`*(x, y: VkShaderModule): bool {.borrow.}
proc `==`*(x, y: VkPipeline): bool {.borrow.}
proc `==`*(x, y: VkPipelineLayout): bool {.borrow.}
proc `==`*(x, y: VkSampler): bool {.borrow.}
proc `==`*(x, y: VkDescriptorSet): bool {.borrow.}
proc `==`*(x, y: VkDescriptorSetLayout): bool {.borrow.}
proc `==`*(x, y: VkDescriptorPool): bool {.borrow.}
proc `==`*(x, y: VkFence): bool {.borrow.}
proc `==`*(x, y: VkSemaphore): bool {.borrow.}
proc `==`*(x, y: VkEvent): bool {.borrow.}
proc `==`*(x, y: VkQueryPool): bool {.borrow.}
proc `==`*(x, y: VkFramebuffer): bool {.borrow.}
proc `==`*(x, y: VkRenderPass): bool {.borrow.}
proc `==`*(x, y: VkPipelineCache): bool {.borrow.}
proc `==`*(x, y: VkPipelineBinaryKHR): bool {.borrow.}
proc `==`*(x, y: VkIndirectCommandsLayoutNV): bool {.borrow.}
proc `==`*(x, y: VkIndirectCommandsLayoutEXT): bool {.borrow.}
proc `==`*(x, y: VkIndirectExecutionSetEXT): bool {.borrow.}
proc `==`*(x, y: VkDescriptorUpdateTemplate): bool {.borrow.}
proc `==`*(x, y: VkSamplerYcbcrConversion): bool {.borrow.}
proc `==`*(x, y: VkValidationCacheEXT): bool {.borrow.}
proc `==`*(x, y: VkAccelerationStructureKHR): bool {.borrow.}
proc `==`*(x, y: VkAccelerationStructureNV): bool {.borrow.}
proc `==`*(x, y: VkPerformanceConfigurationINTEL): bool {.borrow.}
proc `==`*(x, y: VkBufferCollectionFUCHSIA): bool {.borrow.}
proc `==`*(x, y: VkDeferredOperationKHR): bool {.borrow.}
proc `==`*(x, y: VkPrivateDataSlot): bool {.borrow.}
proc `==`*(x, y: VkCuModuleNVX): bool {.borrow.}
proc `==`*(x, y: VkCuFunctionNVX): bool {.borrow.}
proc `==`*(x, y: VkOpticalFlowSessionNV): bool {.borrow.}
proc `==`*(x, y: VkMicromapEXT): bool {.borrow.}
proc `==`*(x, y: VkShaderEXT): bool {.borrow.}
proc `==`*(x, y: VkTensorARM): bool {.borrow.}
proc `==`*(x, y: VkTensorViewARM): bool {.borrow.}
proc `==`*(x, y: VkDataGraphPipelineSessionARM): bool {.borrow.}
proc `==`*(x, y: VkDisplayKHR): bool {.borrow.}
proc `==`*(x, y: VkDisplayModeKHR): bool {.borrow.}
proc `==`*(x, y: VkSurfaceKHR): bool {.borrow.}
proc `==`*(x, y: VkSwapchainKHR): bool {.borrow.}
proc `==`*(x, y: VkDebugReportCallbackEXT): bool {.borrow.}
proc `==`*(x, y: VkDebugUtilsMessengerEXT): bool {.borrow.}
proc `==`*(x, y: VkVideoSessionKHR): bool {.borrow.}
proc `==`*(x, y: VkVideoSessionParametersKHR): bool {.borrow.}
proc `==`*(x, y: VkSemaphoreSciSyncPoolNV): bool {.borrow.}
proc `==`*(x, y: VkCudaModuleNV): bool {.borrow.}
proc `==`*(x, y: VkCudaFunctionNV): bool {.borrow.}
proc `==`*(x, y: VkExternalComputeQueueNV): bool {.borrow.}

# Flags helpers
import std/macros

macro flagsImpl(base, bits: typed, args: varargs[untyped]): untyped =
  let arr = newNimNode(nnkBracketExpr)
  for n in args: arr.add newCall(base, if n.kind == nnkDotExpr: n else: newDotExpr(bits, n))
  result = nestList(bindSym"or", arr)

template `{}`*(t: typedesc[VkFramebufferCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkFramebufferCreateFlagBits, args))

proc `==`*(x, y: VkFramebufferCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkFramebufferCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkFramebufferCreateFlags; y: VkFramebufferCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkQueryPoolCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkQueryPoolCreateFlagBits, args))

proc `==`*(x, y: VkQueryPoolCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkQueryPoolCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkQueryPoolCreateFlags; y: VkQueryPoolCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkRenderPassCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkRenderPassCreateFlagBits, args))

proc `==`*(x, y: VkRenderPassCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkRenderPassCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkRenderPassCreateFlags; y: VkRenderPassCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSamplerCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSamplerCreateFlagBits, args))

proc `==`*(x, y: VkSamplerCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSamplerCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSamplerCreateFlags; y: VkSamplerCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineLayoutCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineLayoutCreateFlagBits, args))

proc `==`*(x, y: VkPipelineLayoutCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineLayoutCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineLayoutCreateFlags; y: VkPipelineLayoutCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineCacheCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineCacheCreateFlagBits, args))

proc `==`*(x, y: VkPipelineCacheCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineCacheCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineCacheCreateFlags; y: VkPipelineCacheCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineDepthStencilStateCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineDepthStencilStateCreateFlagBits, args))

proc `==`*(x, y: VkPipelineDepthStencilStateCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineDepthStencilStateCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineDepthStencilStateCreateFlags; y: VkPipelineDepthStencilStateCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineColorBlendStateCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineColorBlendStateCreateFlagBits, args))

proc `==`*(x, y: VkPipelineColorBlendStateCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineColorBlendStateCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineColorBlendStateCreateFlags; y: VkPipelineColorBlendStateCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineShaderStageCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineShaderStageCreateFlagBits, args))

proc `==`*(x, y: VkPipelineShaderStageCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineShaderStageCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineShaderStageCreateFlags; y: VkPipelineShaderStageCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDescriptorSetLayoutCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDescriptorSetLayoutCreateFlagBits, args))

proc `==`*(x, y: VkDescriptorSetLayoutCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDescriptorSetLayoutCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDescriptorSetLayoutCreateFlags; y: VkDescriptorSetLayoutCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkInstanceCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkInstanceCreateFlagBits, args))

proc `==`*(x, y: VkInstanceCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkInstanceCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkInstanceCreateFlags; y: VkInstanceCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDeviceQueueCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDeviceQueueCreateFlagBits, args))

proc `==`*(x, y: VkDeviceQueueCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDeviceQueueCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDeviceQueueCreateFlags; y: VkDeviceQueueCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkQueueFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkQueueFlagBits, args))

proc `==`*(x, y: VkQueueFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkQueueFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkQueueFlags; y: VkQueueFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkMemoryPropertyFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkMemoryPropertyFlagBits, args))

proc `==`*(x, y: VkMemoryPropertyFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkMemoryPropertyFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkMemoryPropertyFlags; y: VkMemoryPropertyFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkMemoryHeapFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkMemoryHeapFlagBits, args))

proc `==`*(x, y: VkMemoryHeapFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkMemoryHeapFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkMemoryHeapFlags; y: VkMemoryHeapFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkAccessFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkAccessFlagBits, args))

proc `==`*(x, y: VkAccessFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkAccessFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkAccessFlags; y: VkAccessFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkBufferUsageFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkBufferUsageFlagBits, args))

proc `==`*(x, y: VkBufferUsageFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkBufferUsageFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkBufferUsageFlags; y: VkBufferUsageFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkBufferCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkBufferCreateFlagBits, args))

proc `==`*(x, y: VkBufferCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkBufferCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkBufferCreateFlags; y: VkBufferCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkShaderStageFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkShaderStageFlagBits, args))

proc `==`*(x, y: VkShaderStageFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkShaderStageFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkShaderStageFlags; y: VkShaderStageFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkImageUsageFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkImageUsageFlagBits, args))

proc `==`*(x, y: VkImageUsageFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkImageUsageFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkImageUsageFlags; y: VkImageUsageFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkImageCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkImageCreateFlagBits, args))

proc `==`*(x, y: VkImageCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkImageCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkImageCreateFlags; y: VkImageCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkImageViewCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkImageViewCreateFlagBits, args))

proc `==`*(x, y: VkImageViewCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkImageViewCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkImageViewCreateFlags; y: VkImageViewCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineCreateFlagBits, args))

proc `==`*(x, y: VkPipelineCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineCreateFlags; y: VkPipelineCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkColorComponentFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkColorComponentFlagBits, args))

proc `==`*(x, y: VkColorComponentFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkColorComponentFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkColorComponentFlags; y: VkColorComponentFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkFenceCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkFenceCreateFlagBits, args))

proc `==`*(x, y: VkFenceCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkFenceCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkFenceCreateFlags; y: VkFenceCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkFormatFeatureFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkFormatFeatureFlagBits, args))

proc `==`*(x, y: VkFormatFeatureFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkFormatFeatureFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkFormatFeatureFlags; y: VkFormatFeatureFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkQueryControlFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkQueryControlFlagBits, args))

proc `==`*(x, y: VkQueryControlFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkQueryControlFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkQueryControlFlags; y: VkQueryControlFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkQueryResultFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkQueryResultFlagBits, args))

proc `==`*(x, y: VkQueryResultFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkQueryResultFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkQueryResultFlags; y: VkQueryResultFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkEventCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkEventCreateFlagBits, args))

proc `==`*(x, y: VkEventCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkEventCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkEventCreateFlags; y: VkEventCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkCommandPoolCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkCommandPoolCreateFlagBits, args))

proc `==`*(x, y: VkCommandPoolCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkCommandPoolCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkCommandPoolCreateFlags; y: VkCommandPoolCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkCommandPoolResetFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkCommandPoolResetFlagBits, args))

proc `==`*(x, y: VkCommandPoolResetFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkCommandPoolResetFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkCommandPoolResetFlags; y: VkCommandPoolResetFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkCommandBufferResetFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkCommandBufferResetFlagBits, args))

proc `==`*(x, y: VkCommandBufferResetFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkCommandBufferResetFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkCommandBufferResetFlags; y: VkCommandBufferResetFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkCommandBufferUsageFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkCommandBufferUsageFlagBits, args))

proc `==`*(x, y: VkCommandBufferUsageFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkCommandBufferUsageFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkCommandBufferUsageFlags; y: VkCommandBufferUsageFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkQueryPipelineStatisticFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkQueryPipelineStatisticFlagBits, args))

proc `==`*(x, y: VkQueryPipelineStatisticFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkQueryPipelineStatisticFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkQueryPipelineStatisticFlags; y: VkQueryPipelineStatisticFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkMemoryMapFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkMemoryMapFlagBits, args))

proc `==`*(x, y: VkMemoryMapFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkMemoryMapFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkMemoryMapFlags; y: VkMemoryMapFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkMemoryUnmapFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkMemoryUnmapFlagBits, args))

proc `==`*(x, y: VkMemoryUnmapFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkMemoryUnmapFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkMemoryUnmapFlags; y: VkMemoryUnmapFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkImageAspectFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkImageAspectFlagBits, args))

proc `==`*(x, y: VkImageAspectFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkImageAspectFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkImageAspectFlags; y: VkImageAspectFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSparseMemoryBindFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSparseMemoryBindFlagBits, args))

proc `==`*(x, y: VkSparseMemoryBindFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSparseMemoryBindFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSparseMemoryBindFlags; y: VkSparseMemoryBindFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSparseImageFormatFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSparseImageFormatFlagBits, args))

proc `==`*(x, y: VkSparseImageFormatFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSparseImageFormatFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSparseImageFormatFlags; y: VkSparseImageFormatFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSubpassDescriptionFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSubpassDescriptionFlagBits, args))

proc `==`*(x, y: VkSubpassDescriptionFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSubpassDescriptionFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSubpassDescriptionFlags; y: VkSubpassDescriptionFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineStageFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineStageFlagBits, args))

proc `==`*(x, y: VkPipelineStageFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineStageFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineStageFlags; y: VkPipelineStageFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSampleCountFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSampleCountFlagBits, args))

proc `==`*(x, y: VkSampleCountFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSampleCountFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSampleCountFlags; y: VkSampleCountFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkAttachmentDescriptionFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkAttachmentDescriptionFlagBits, args))

proc `==`*(x, y: VkAttachmentDescriptionFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkAttachmentDescriptionFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkAttachmentDescriptionFlags; y: VkAttachmentDescriptionFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkStencilFaceFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkStencilFaceFlagBits, args))

proc `==`*(x, y: VkStencilFaceFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkStencilFaceFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkStencilFaceFlags; y: VkStencilFaceFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkCullModeFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkCullModeFlagBits, args))

proc `==`*(x, y: VkCullModeFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkCullModeFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkCullModeFlags; y: VkCullModeFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDescriptorPoolCreateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDescriptorPoolCreateFlagBits, args))

proc `==`*(x, y: VkDescriptorPoolCreateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDescriptorPoolCreateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDescriptorPoolCreateFlags; y: VkDescriptorPoolCreateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDependencyFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDependencyFlagBits, args))

proc `==`*(x, y: VkDependencyFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDependencyFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDependencyFlags; y: VkDependencyFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSubgroupFeatureFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSubgroupFeatureFlagBits, args))

proc `==`*(x, y: VkSubgroupFeatureFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSubgroupFeatureFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSubgroupFeatureFlags; y: VkSubgroupFeatureFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkIndirectCommandsLayoutUsageFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkIndirectCommandsLayoutUsageFlagBitsNV, args))

proc `==`*(x, y: VkIndirectCommandsLayoutUsageFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkIndirectCommandsLayoutUsageFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkIndirectCommandsLayoutUsageFlagsNV; y: VkIndirectCommandsLayoutUsageFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkIndirectStateFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkIndirectStateFlagBitsNV, args))

proc `==`*(x, y: VkIndirectStateFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkIndirectStateFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkIndirectStateFlagsNV; y: VkIndirectStateFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkGeometryFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkGeometryFlagBitsKHR, args))

proc `==`*(x, y: VkGeometryFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkGeometryFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkGeometryFlagsKHR; y: VkGeometryFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkGeometryInstanceFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkGeometryInstanceFlagBitsKHR, args))

proc `==`*(x, y: VkGeometryInstanceFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkGeometryInstanceFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkGeometryInstanceFlagsKHR; y: VkGeometryInstanceFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkClusterAccelerationStructureGeometryFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkClusterAccelerationStructureGeometryFlagBitsNV, args))

proc `==`*(x, y: VkClusterAccelerationStructureGeometryFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkClusterAccelerationStructureGeometryFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkClusterAccelerationStructureGeometryFlagsNV; y: VkClusterAccelerationStructureGeometryFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkClusterAccelerationStructureClusterFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkClusterAccelerationStructureClusterFlagBitsNV, args))

proc `==`*(x, y: VkClusterAccelerationStructureClusterFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkClusterAccelerationStructureClusterFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkClusterAccelerationStructureClusterFlagsNV; y: VkClusterAccelerationStructureClusterFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkClusterAccelerationStructureAddressResolutionFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkClusterAccelerationStructureAddressResolutionFlagBitsNV, args))

proc `==`*(x, y: VkClusterAccelerationStructureAddressResolutionFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkClusterAccelerationStructureAddressResolutionFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkClusterAccelerationStructureAddressResolutionFlagsNV; y: VkClusterAccelerationStructureAddressResolutionFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkBuildAccelerationStructureFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkBuildAccelerationStructureFlagBitsKHR, args))

proc `==`*(x, y: VkBuildAccelerationStructureFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkBuildAccelerationStructureFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkBuildAccelerationStructureFlagsKHR; y: VkBuildAccelerationStructureFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkAccelerationStructureCreateFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkAccelerationStructureCreateFlagBitsKHR, args))

proc `==`*(x, y: VkAccelerationStructureCreateFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkAccelerationStructureCreateFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkAccelerationStructureCreateFlagsKHR; y: VkAccelerationStructureCreateFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineCreationFeedbackFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineCreationFeedbackFlagBits, args))

proc `==`*(x, y: VkPipelineCreationFeedbackFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineCreationFeedbackFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineCreationFeedbackFlags; y: VkPipelineCreationFeedbackFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPerformanceCounterDescriptionFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPerformanceCounterDescriptionFlagBitsKHR, args))

proc `==`*(x, y: VkPerformanceCounterDescriptionFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPerformanceCounterDescriptionFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPerformanceCounterDescriptionFlagsKHR; y: VkPerformanceCounterDescriptionFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSemaphoreWaitFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSemaphoreWaitFlagBits, args))

proc `==`*(x, y: VkSemaphoreWaitFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSemaphoreWaitFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSemaphoreWaitFlags; y: VkSemaphoreWaitFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDeviceDiagnosticsConfigFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDeviceDiagnosticsConfigFlagBitsNV, args))

proc `==`*(x, y: VkDeviceDiagnosticsConfigFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDeviceDiagnosticsConfigFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDeviceDiagnosticsConfigFlagsNV; y: VkDeviceDiagnosticsConfigFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkAccessFlags2]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkAccessFlagBits2, args))

proc `==`*(x, y: VkAccessFlags2): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkAccessFlags2): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkAccessFlags2; y: VkAccessFlagBits2): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineStageFlags2]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineStageFlagBits2, args))

proc `==`*(x, y: VkPipelineStageFlags2): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineStageFlags2): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineStageFlags2; y: VkPipelineStageFlagBits2): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkFormatFeatureFlags2]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkFormatFeatureFlagBits2, args))

proc `==`*(x, y: VkFormatFeatureFlags2): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkFormatFeatureFlags2): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkFormatFeatureFlags2; y: VkFormatFeatureFlagBits2): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkRenderingFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkRenderingFlagBits, args))

proc `==`*(x, y: VkRenderingFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkRenderingFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkRenderingFlags; y: VkRenderingFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkMemoryDecompressionMethodFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkMemoryDecompressionMethodFlagBitsEXT, args))

proc `==`*(x, y: VkMemoryDecompressionMethodFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkMemoryDecompressionMethodFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkMemoryDecompressionMethodFlagsEXT; y: VkMemoryDecompressionMethodFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkBuildMicromapFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkBuildMicromapFlagBitsEXT, args))

proc `==`*(x, y: VkBuildMicromapFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkBuildMicromapFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkBuildMicromapFlagsEXT; y: VkBuildMicromapFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkMicromapCreateFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkMicromapCreateFlagBitsEXT, args))

proc `==`*(x, y: VkMicromapCreateFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkMicromapCreateFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkMicromapCreateFlagsEXT; y: VkMicromapCreateFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkIndirectCommandsLayoutUsageFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkIndirectCommandsLayoutUsageFlagBitsEXT, args))

proc `==`*(x, y: VkIndirectCommandsLayoutUsageFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkIndirectCommandsLayoutUsageFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkIndirectCommandsLayoutUsageFlagsEXT; y: VkIndirectCommandsLayoutUsageFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkIndirectCommandsInputModeFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkIndirectCommandsInputModeFlagBitsEXT, args))

proc `==`*(x, y: VkIndirectCommandsInputModeFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkIndirectCommandsInputModeFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkIndirectCommandsInputModeFlagsEXT; y: VkIndirectCommandsInputModeFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPipelineCreateFlags2]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPipelineCreateFlagBits2, args))

proc `==`*(x, y: VkPipelineCreateFlags2): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPipelineCreateFlags2): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPipelineCreateFlags2; y: VkPipelineCreateFlagBits2): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkBufferUsageFlags2]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkBufferUsageFlagBits2, args))

proc `==`*(x, y: VkBufferUsageFlags2): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkBufferUsageFlags2): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkBufferUsageFlags2; y: VkBufferUsageFlagBits2): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkAddressCopyFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkAddressCopyFlagBitsKHR, args))

proc `==`*(x, y: VkAddressCopyFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkAddressCopyFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkAddressCopyFlagsKHR; y: VkAddressCopyFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkTensorCreateFlagsARM]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkTensorCreateFlagBitsARM, args))

proc `==`*(x, y: VkTensorCreateFlagsARM): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkTensorCreateFlagsARM): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkTensorCreateFlagsARM; y: VkTensorCreateFlagBitsARM): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkTensorUsageFlagsARM]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkTensorUsageFlagBitsARM, args))

proc `==`*(x, y: VkTensorUsageFlagsARM): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkTensorUsageFlagsARM): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkTensorUsageFlagsARM; y: VkTensorUsageFlagBitsARM): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkTensorViewCreateFlagsARM]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkTensorViewCreateFlagBitsARM, args))

proc `==`*(x, y: VkTensorViewCreateFlagsARM): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkTensorViewCreateFlagsARM): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkTensorViewCreateFlagsARM; y: VkTensorViewCreateFlagBitsARM): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDataGraphPipelineSessionCreateFlagsARM]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDataGraphPipelineSessionCreateFlagBitsARM, args))

proc `==`*(x, y: VkDataGraphPipelineSessionCreateFlagsARM): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDataGraphPipelineSessionCreateFlagsARM): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDataGraphPipelineSessionCreateFlagsARM; y: VkDataGraphPipelineSessionCreateFlagBitsARM): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeRgbModelConversionFlagsVALVE]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeRgbModelConversionFlagBitsVALVE, args))

proc `==`*(x, y: VkVideoEncodeRgbModelConversionFlagsVALVE): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeRgbModelConversionFlagsVALVE): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeRgbModelConversionFlagsVALVE; y: VkVideoEncodeRgbModelConversionFlagBitsVALVE): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeRgbRangeCompressionFlagsVALVE]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeRgbRangeCompressionFlagBitsVALVE, args))

proc `==`*(x, y: VkVideoEncodeRgbRangeCompressionFlagsVALVE): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeRgbRangeCompressionFlagsVALVE): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeRgbRangeCompressionFlagsVALVE; y: VkVideoEncodeRgbRangeCompressionFlagBitsVALVE): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeRgbChromaOffsetFlagsVALVE]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeRgbChromaOffsetFlagBitsVALVE, args))

proc `==`*(x, y: VkVideoEncodeRgbChromaOffsetFlagsVALVE): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeRgbChromaOffsetFlagsVALVE): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeRgbChromaOffsetFlagsVALVE; y: VkVideoEncodeRgbChromaOffsetFlagBitsVALVE): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSpirvResourceTypeFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSpirvResourceTypeFlagBitsEXT, args))

proc `==`*(x, y: VkSpirvResourceTypeFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSpirvResourceTypeFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSpirvResourceTypeFlagsEXT; y: VkSpirvResourceTypeFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkCompositeAlphaFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkCompositeAlphaFlagBitsKHR, args))

proc `==`*(x, y: VkCompositeAlphaFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkCompositeAlphaFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkCompositeAlphaFlagsKHR; y: VkCompositeAlphaFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDisplayPlaneAlphaFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDisplayPlaneAlphaFlagBitsKHR, args))

proc `==`*(x, y: VkDisplayPlaneAlphaFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDisplayPlaneAlphaFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDisplayPlaneAlphaFlagsKHR; y: VkDisplayPlaneAlphaFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSurfaceTransformFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSurfaceTransformFlagBitsKHR, args))

proc `==`*(x, y: VkSurfaceTransformFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSurfaceTransformFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSurfaceTransformFlagsKHR; y: VkSurfaceTransformFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSwapchainCreateFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSwapchainCreateFlagBitsKHR, args))

proc `==`*(x, y: VkSwapchainCreateFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSwapchainCreateFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSwapchainCreateFlagsKHR; y: VkSwapchainCreateFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPeerMemoryFeatureFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPeerMemoryFeatureFlagBits, args))

proc `==`*(x, y: VkPeerMemoryFeatureFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPeerMemoryFeatureFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPeerMemoryFeatureFlags; y: VkPeerMemoryFeatureFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkMemoryAllocateFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkMemoryAllocateFlagBits, args))

proc `==`*(x, y: VkMemoryAllocateFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkMemoryAllocateFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkMemoryAllocateFlags; y: VkMemoryAllocateFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDeviceGroupPresentModeFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDeviceGroupPresentModeFlagBitsKHR, args))

proc `==`*(x, y: VkDeviceGroupPresentModeFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDeviceGroupPresentModeFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDeviceGroupPresentModeFlagsKHR; y: VkDeviceGroupPresentModeFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDebugReportFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDebugReportFlagBitsEXT, args))

proc `==`*(x, y: VkDebugReportFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDebugReportFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDebugReportFlagsEXT; y: VkDebugReportFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkExternalMemoryHandleTypeFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkExternalMemoryHandleTypeFlagBitsNV, args))

proc `==`*(x, y: VkExternalMemoryHandleTypeFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkExternalMemoryHandleTypeFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkExternalMemoryHandleTypeFlagsNV; y: VkExternalMemoryHandleTypeFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkClusterAccelerationStructureIndexFormatFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkClusterAccelerationStructureIndexFormatFlagBitsNV, args))

proc `==`*(x, y: VkClusterAccelerationStructureIndexFormatFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkClusterAccelerationStructureIndexFormatFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkClusterAccelerationStructureIndexFormatFlagsNV; y: VkClusterAccelerationStructureIndexFormatFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkExternalMemoryFeatureFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkExternalMemoryFeatureFlagBitsNV, args))

proc `==`*(x, y: VkExternalMemoryFeatureFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkExternalMemoryFeatureFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkExternalMemoryFeatureFlagsNV; y: VkExternalMemoryFeatureFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkExternalMemoryHandleTypeFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkExternalMemoryHandleTypeFlagBits, args))

proc `==`*(x, y: VkExternalMemoryHandleTypeFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkExternalMemoryHandleTypeFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkExternalMemoryHandleTypeFlags; y: VkExternalMemoryHandleTypeFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkExternalMemoryFeatureFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkExternalMemoryFeatureFlagBits, args))

proc `==`*(x, y: VkExternalMemoryFeatureFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkExternalMemoryFeatureFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkExternalMemoryFeatureFlags; y: VkExternalMemoryFeatureFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkExternalSemaphoreHandleTypeFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkExternalSemaphoreHandleTypeFlagBits, args))

proc `==`*(x, y: VkExternalSemaphoreHandleTypeFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkExternalSemaphoreHandleTypeFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkExternalSemaphoreHandleTypeFlags; y: VkExternalSemaphoreHandleTypeFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkExternalSemaphoreFeatureFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkExternalSemaphoreFeatureFlagBits, args))

proc `==`*(x, y: VkExternalSemaphoreFeatureFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkExternalSemaphoreFeatureFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkExternalSemaphoreFeatureFlags; y: VkExternalSemaphoreFeatureFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSemaphoreImportFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSemaphoreImportFlagBits, args))

proc `==`*(x, y: VkSemaphoreImportFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSemaphoreImportFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSemaphoreImportFlags; y: VkSemaphoreImportFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkExternalFenceHandleTypeFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkExternalFenceHandleTypeFlagBits, args))

proc `==`*(x, y: VkExternalFenceHandleTypeFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkExternalFenceHandleTypeFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkExternalFenceHandleTypeFlags; y: VkExternalFenceHandleTypeFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkExternalFenceFeatureFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkExternalFenceFeatureFlagBits, args))

proc `==`*(x, y: VkExternalFenceFeatureFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkExternalFenceFeatureFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkExternalFenceFeatureFlags; y: VkExternalFenceFeatureFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkFenceImportFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkFenceImportFlagBits, args))

proc `==`*(x, y: VkFenceImportFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkFenceImportFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkFenceImportFlags; y: VkFenceImportFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSurfaceCounterFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSurfaceCounterFlagBitsEXT, args))

proc `==`*(x, y: VkSurfaceCounterFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSurfaceCounterFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSurfaceCounterFlagsEXT; y: VkSurfaceCounterFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDebugUtilsMessageSeverityFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDebugUtilsMessageSeverityFlagBitsEXT, args))

proc `==`*(x, y: VkDebugUtilsMessageSeverityFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDebugUtilsMessageSeverityFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDebugUtilsMessageSeverityFlagsEXT; y: VkDebugUtilsMessageSeverityFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDebugUtilsMessageTypeFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDebugUtilsMessageTypeFlagBitsEXT, args))

proc `==`*(x, y: VkDebugUtilsMessageTypeFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDebugUtilsMessageTypeFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDebugUtilsMessageTypeFlagsEXT; y: VkDebugUtilsMessageTypeFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDescriptorBindingFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDescriptorBindingFlagBits, args))

proc `==`*(x, y: VkDescriptorBindingFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDescriptorBindingFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDescriptorBindingFlags; y: VkDescriptorBindingFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkConditionalRenderingFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkConditionalRenderingFlagBitsEXT, args))

proc `==`*(x, y: VkConditionalRenderingFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkConditionalRenderingFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkConditionalRenderingFlagsEXT; y: VkConditionalRenderingFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkResolveModeFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkResolveModeFlagBits, args))

proc `==`*(x, y: VkResolveModeFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkResolveModeFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkResolveModeFlags; y: VkResolveModeFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSwapchainImageUsageFlagsANDROID]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSwapchainImageUsageFlagBitsANDROID, args))

proc `==`*(x, y: VkSwapchainImageUsageFlagsANDROID): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSwapchainImageUsageFlagsANDROID): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSwapchainImageUsageFlagsANDROID; y: VkSwapchainImageUsageFlagBitsANDROID): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkToolPurposeFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkToolPurposeFlagBits, args))

proc `==`*(x, y: VkToolPurposeFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkToolPurposeFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkToolPurposeFlags; y: VkToolPurposeFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSubmitFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSubmitFlagBits, args))

proc `==`*(x, y: VkSubmitFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSubmitFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSubmitFlags; y: VkSubmitFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkHostImageCopyFlags]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkHostImageCopyFlagBits, args))

proc `==`*(x, y: VkHostImageCopyFlags): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkHostImageCopyFlags): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkHostImageCopyFlags; y: VkHostImageCopyFlagBits): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPartitionedAccelerationStructureInstanceFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPartitionedAccelerationStructureInstanceFlagBitsNV, args))

proc `==`*(x, y: VkPartitionedAccelerationStructureInstanceFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPartitionedAccelerationStructureInstanceFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPartitionedAccelerationStructureInstanceFlagsNV; y: VkPartitionedAccelerationStructureInstanceFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkImageConstraintsInfoFlagsFUCHSIA]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkImageConstraintsInfoFlagBitsFUCHSIA, args))

proc `==`*(x, y: VkImageConstraintsInfoFlagsFUCHSIA): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkImageConstraintsInfoFlagsFUCHSIA): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkImageConstraintsInfoFlagsFUCHSIA; y: VkImageConstraintsInfoFlagBitsFUCHSIA): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkGraphicsPipelineLibraryFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkGraphicsPipelineLibraryFlagBitsEXT, args))

proc `==`*(x, y: VkGraphicsPipelineLibraryFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkGraphicsPipelineLibraryFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkGraphicsPipelineLibraryFlagsEXT; y: VkGraphicsPipelineLibraryFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkImageCompressionFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkImageCompressionFlagBitsEXT, args))

proc `==`*(x, y: VkImageCompressionFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkImageCompressionFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkImageCompressionFlagsEXT; y: VkImageCompressionFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkImageCompressionFixedRateFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkImageCompressionFixedRateFlagBitsEXT, args))

proc `==`*(x, y: VkImageCompressionFixedRateFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkImageCompressionFixedRateFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkImageCompressionFixedRateFlagsEXT; y: VkImageCompressionFixedRateFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkExportMetalObjectTypeFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkExportMetalObjectTypeFlagBitsEXT, args))

proc `==`*(x, y: VkExportMetalObjectTypeFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkExportMetalObjectTypeFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkExportMetalObjectTypeFlagsEXT; y: VkExportMetalObjectTypeFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkRenderingAttachmentFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkRenderingAttachmentFlagBitsKHR, args))

proc `==`*(x, y: VkRenderingAttachmentFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkRenderingAttachmentFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkRenderingAttachmentFlagsKHR; y: VkRenderingAttachmentFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkResolveImageFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkResolveImageFlagBitsKHR, args))

proc `==`*(x, y: VkResolveImageFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkResolveImageFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkResolveImageFlagsKHR; y: VkResolveImageFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkDeviceAddressBindingFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkDeviceAddressBindingFlagBitsEXT, args))

proc `==`*(x, y: VkDeviceAddressBindingFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkDeviceAddressBindingFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkDeviceAddressBindingFlagsEXT; y: VkDeviceAddressBindingFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkOpticalFlowGridSizeFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkOpticalFlowGridSizeFlagBitsNV, args))

proc `==`*(x, y: VkOpticalFlowGridSizeFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkOpticalFlowGridSizeFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkOpticalFlowGridSizeFlagsNV; y: VkOpticalFlowGridSizeFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkOpticalFlowUsageFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkOpticalFlowUsageFlagBitsNV, args))

proc `==`*(x, y: VkOpticalFlowUsageFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkOpticalFlowUsageFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkOpticalFlowUsageFlagsNV; y: VkOpticalFlowUsageFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkOpticalFlowSessionCreateFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkOpticalFlowSessionCreateFlagBitsNV, args))

proc `==`*(x, y: VkOpticalFlowSessionCreateFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkOpticalFlowSessionCreateFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkOpticalFlowSessionCreateFlagsNV; y: VkOpticalFlowSessionCreateFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkOpticalFlowExecuteFlagsNV]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkOpticalFlowExecuteFlagBitsNV, args))

proc `==`*(x, y: VkOpticalFlowExecuteFlagsNV): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkOpticalFlowExecuteFlagsNV): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkOpticalFlowExecuteFlagsNV; y: VkOpticalFlowExecuteFlagBitsNV): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkFrameBoundaryFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkFrameBoundaryFlagBitsEXT, args))

proc `==`*(x, y: VkFrameBoundaryFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkFrameBoundaryFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkFrameBoundaryFlagsEXT; y: VkFrameBoundaryFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPresentScalingFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPresentScalingFlagBitsKHR, args))

proc `==`*(x, y: VkPresentScalingFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPresentScalingFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPresentScalingFlagsKHR; y: VkPresentScalingFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPresentGravityFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPresentGravityFlagBitsKHR, args))

proc `==`*(x, y: VkPresentGravityFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPresentGravityFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPresentGravityFlagsKHR; y: VkPresentGravityFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkShaderCreateFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkShaderCreateFlagBitsEXT, args))

proc `==`*(x, y: VkShaderCreateFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkShaderCreateFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkShaderCreateFlagsEXT; y: VkShaderCreateFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkTileShadingRenderPassFlagsQCOM]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkTileShadingRenderPassFlagBitsQCOM, args))

proc `==`*(x, y: VkTileShadingRenderPassFlagsQCOM): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkTileShadingRenderPassFlagsQCOM): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkTileShadingRenderPassFlagsQCOM; y: VkTileShadingRenderPassFlagBitsQCOM): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPhysicalDeviceSchedulingControlsFlagsARM]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPhysicalDeviceSchedulingControlsFlagBitsARM, args))

proc `==`*(x, y: VkPhysicalDeviceSchedulingControlsFlagsARM): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPhysicalDeviceSchedulingControlsFlagsARM): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPhysicalDeviceSchedulingControlsFlagsARM; y: VkPhysicalDeviceSchedulingControlsFlagBitsARM): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPresentStageFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPresentStageFlagBitsEXT, args))

proc `==`*(x, y: VkPresentStageFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPresentStageFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPresentStageFlagsEXT; y: VkPresentStageFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPastPresentationTimingFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPastPresentationTimingFlagBitsEXT, args))

proc `==`*(x, y: VkPastPresentationTimingFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPastPresentationTimingFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPastPresentationTimingFlagsEXT; y: VkPastPresentationTimingFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkPresentTimingInfoFlagsEXT]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkPresentTimingInfoFlagBitsEXT, args))

proc `==`*(x, y: VkPresentTimingInfoFlagsEXT): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkPresentTimingInfoFlagsEXT): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkPresentTimingInfoFlagsEXT; y: VkPresentTimingInfoFlagBitsEXT): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkSwapchainImageUsageFlagsOHOS]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkSwapchainImageUsageFlagBitsOHOS, args))

proc `==`*(x, y: VkSwapchainImageUsageFlagsOHOS): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkSwapchainImageUsageFlagsOHOS): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkSwapchainImageUsageFlagsOHOS; y: VkSwapchainImageUsageFlagBitsOHOS): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoCodecOperationFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoCodecOperationFlagBitsKHR, args))

proc `==`*(x, y: VkVideoCodecOperationFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoCodecOperationFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoCodecOperationFlagsKHR; y: VkVideoCodecOperationFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoCapabilityFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoCapabilityFlagBitsKHR, args))

proc `==`*(x, y: VkVideoCapabilityFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoCapabilityFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoCapabilityFlagsKHR; y: VkVideoCapabilityFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoSessionCreateFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoSessionCreateFlagBitsKHR, args))

proc `==`*(x, y: VkVideoSessionCreateFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoSessionCreateFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoSessionCreateFlagsKHR; y: VkVideoSessionCreateFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoSessionParametersCreateFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoSessionParametersCreateFlagBitsKHR, args))

proc `==`*(x, y: VkVideoSessionParametersCreateFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoSessionParametersCreateFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoSessionParametersCreateFlagsKHR; y: VkVideoSessionParametersCreateFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoCodingControlFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoCodingControlFlagBitsKHR, args))

proc `==`*(x, y: VkVideoCodingControlFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoCodingControlFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoCodingControlFlagsKHR; y: VkVideoCodingControlFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoDecodeUsageFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoDecodeUsageFlagBitsKHR, args))

proc `==`*(x, y: VkVideoDecodeUsageFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoDecodeUsageFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoDecodeUsageFlagsKHR; y: VkVideoDecodeUsageFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoDecodeCapabilityFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoDecodeCapabilityFlagBitsKHR, args))

proc `==`*(x, y: VkVideoDecodeCapabilityFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoDecodeCapabilityFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoDecodeCapabilityFlagsKHR; y: VkVideoDecodeCapabilityFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoDecodeH264PictureLayoutFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoDecodeH264PictureLayoutFlagBitsKHR, args))

proc `==`*(x, y: VkVideoDecodeH264PictureLayoutFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoDecodeH264PictureLayoutFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoDecodeH264PictureLayoutFlagsKHR; y: VkVideoDecodeH264PictureLayoutFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeFlagsKHR; y: VkVideoEncodeFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeUsageFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeUsageFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeUsageFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeUsageFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeUsageFlagsKHR; y: VkVideoEncodeUsageFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeContentFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeContentFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeContentFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeContentFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeContentFlagsKHR; y: VkVideoEncodeContentFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeCapabilityFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeCapabilityFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeCapabilityFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeCapabilityFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeCapabilityFlagsKHR; y: VkVideoEncodeCapabilityFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeFeedbackFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeFeedbackFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeFeedbackFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeFeedbackFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeFeedbackFlagsKHR; y: VkVideoEncodeFeedbackFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeRateControlModeFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeRateControlModeFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeRateControlModeFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeRateControlModeFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeRateControlModeFlagsKHR; y: VkVideoEncodeRateControlModeFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeIntraRefreshModeFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeIntraRefreshModeFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeIntraRefreshModeFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeIntraRefreshModeFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeIntraRefreshModeFlagsKHR; y: VkVideoEncodeIntraRefreshModeFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoChromaSubsamplingFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoChromaSubsamplingFlagBitsKHR, args))

proc `==`*(x, y: VkVideoChromaSubsamplingFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoChromaSubsamplingFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoChromaSubsamplingFlagsKHR; y: VkVideoChromaSubsamplingFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoComponentBitDepthFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoComponentBitDepthFlagBitsKHR, args))

proc `==`*(x, y: VkVideoComponentBitDepthFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoComponentBitDepthFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoComponentBitDepthFlagsKHR; y: VkVideoComponentBitDepthFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeH264CapabilityFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeH264CapabilityFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeH264CapabilityFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeH264CapabilityFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeH264CapabilityFlagsKHR; y: VkVideoEncodeH264CapabilityFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeH264StdFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeH264StdFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeH264StdFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeH264StdFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeH264StdFlagsKHR; y: VkVideoEncodeH264StdFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeH264RateControlFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeH264RateControlFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeH264RateControlFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeH264RateControlFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeH264RateControlFlagsKHR; y: VkVideoEncodeH264RateControlFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeH265CapabilityFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeH265CapabilityFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeH265CapabilityFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeH265CapabilityFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeH265CapabilityFlagsKHR; y: VkVideoEncodeH265CapabilityFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeH265StdFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeH265StdFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeH265StdFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeH265StdFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeH265StdFlagsKHR; y: VkVideoEncodeH265StdFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeH265RateControlFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeH265RateControlFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeH265RateControlFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeH265RateControlFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeH265RateControlFlagsKHR; y: VkVideoEncodeH265RateControlFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeH265CtbSizeFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeH265CtbSizeFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeH265CtbSizeFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeH265CtbSizeFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeH265CtbSizeFlagsKHR; y: VkVideoEncodeH265CtbSizeFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeH265TransformBlockSizeFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeH265TransformBlockSizeFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeH265TransformBlockSizeFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeH265TransformBlockSizeFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeH265TransformBlockSizeFlagsKHR; y: VkVideoEncodeH265TransformBlockSizeFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeAV1CapabilityFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeAV1CapabilityFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeAV1CapabilityFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeAV1CapabilityFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeAV1CapabilityFlagsKHR; y: VkVideoEncodeAV1CapabilityFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeAV1StdFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeAV1StdFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeAV1StdFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeAV1StdFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeAV1StdFlagsKHR; y: VkVideoEncodeAV1StdFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeAV1RateControlFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeAV1RateControlFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeAV1RateControlFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeAV1RateControlFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeAV1RateControlFlagsKHR; y: VkVideoEncodeAV1RateControlFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkVideoEncodeAV1SuperblockSizeFlagsKHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkVideoEncodeAV1SuperblockSizeFlagBitsKHR, args))

proc `==`*(x, y: VkVideoEncodeAV1SuperblockSizeFlagsKHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkVideoEncodeAV1SuperblockSizeFlagsKHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkVideoEncodeAV1SuperblockSizeFlagsKHR; y: VkVideoEncodeAV1SuperblockSizeFlagBitsKHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0

template `{}`*(t: typedesc[VkAccessFlags3KHR]; args: varargs[untyped]): untyped =
  t(flagsImpl(uint32, VkAccessFlagBits3KHR, args))

proc `==`*(x, y: VkAccessFlags3KHR): bool {.inline.} =
  x.uint32 == y.uint32
proc `<=`*(x, y: VkAccessFlags3KHR): bool {.inline.} =
  (x.uint32 and not y.uint32) == 0
proc contains*(x: VkAccessFlags3KHR; y: VkAccessFlagBits3KHR): bool {.inline.} =
  (x.uint32 and y.uint32) != 0


var
  vkCreateInstance*: proc (pCreateInfo: ptr VkInstanceCreateInfo, pAllocator: ptr VkAllocationCallbacks, pInstance: ptr VkInstance): VkResult {.stdcall.}
  vkEnumerateInstanceExtensionProperties*: proc (pLayerName: cstring, pPropertyCount: ptr uint32, pProperties: ptr VkExtensionProperties): VkResult {.stdcall.}
  vkEnumerateInstanceLayerProperties*: proc (pPropertyCount: ptr uint32, pProperties: ptr VkLayerProperties): VkResult {.stdcall.}
  vkEnumerateInstanceVersion*: proc (pApiVersion: ptr uint32): VkResult {.stdcall.}

proc vkPreload*(load1_1: bool = true) =
  vkGetInstanceProcAddr = cast[proc (instance: VkInstance, pName: cstring): PFN_vkVoidFunction {.stdcall.}](symAddr(vkHandleDLL, "vkGetInstanceProcAddr"))

  vkCreateInstance = cast[proc (pCreateInfo: ptr VkInstanceCreateInfo, pAllocator: ptr VkAllocationCallbacks, pInstance: ptr VkInstance): VkResult {.stdcall.}](vkGetProc("vkCreateInstance"))
  vkEnumerateInstanceExtensionProperties = cast[proc (pLayerName: cstring, pPropertyCount: ptr uint32, pProperties: ptr VkExtensionProperties): VkResult {.stdcall.}](vkGetProc("vkEnumerateInstanceExtensionProperties"))
  vkEnumerateInstanceLayerProperties = cast[proc (pPropertyCount: ptr uint32, pProperties: ptr VkLayerProperties): VkResult {.stdcall.}](vkGetProc("vkEnumerateInstanceLayerProperties"))

  if load1_1:
    vkEnumerateInstanceVersion = cast[proc (pApiVersion: ptr uint32): VkResult {.stdcall.}](vkGetProc("vkEnumerateInstanceVersion"))

proc vkInit*(instance: VkInstance, load1_0 = true, load1_1: bool = true, load1_2 = true, load1_3: bool = true, load1_4: bool = true) =
  currInst = cast[pointer](instance)
  if currInst == nil:
    raise newException(NilAccessDefect, "Instance is nil")
  if load1_0:
    vkLoad1_0()
  if load1_1:
    vkLoad1_1()
  if load1_2:
    vkLoad1_2()
  when not defined(macosx):
    if load1_3:
      vkLoad1_3()
    if load1_4:
      vkLoad1_4()

include vulkan/headers
